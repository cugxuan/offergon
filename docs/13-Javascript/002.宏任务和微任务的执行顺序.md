---
title: 宏任务和微任务的执行顺序
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: macro-task-micro-task-execution-order
ref:
---

## 核心要点

- **优先级规则**：微任务 > 宏任务，每个宏任务执行后立即清空所有微任务
- **执行时机**：同步代码 → 微任务队列 → 宏任务队列 → 微任务队列（循环）
- **常见陷阱**：Promise构造函数同步执行，await后的代码是微任务
- **Node.js特殊**：process.nextTick优先级最高，setImmediate属于check阶段

## 详细回答

### 1. 任务队列分类

#### 宏任务（MacroTask / Task）
```javascript
// 宏任务类型（按优先级排序）
setTimeout(() => {}, 0)           // Timer任务
setInterval(() => {}, 100)        // Timer任务
setImmediate(() => {})            // Node.js - Check阶段
MessageChannel                    // 浏览器 - 消息通道
postMessage                       // 浏览器 - 跨文档通信
I/O操作回调                        // 文件读写、网络请求
UI渲染事件                         // 浏览器渲染
```

#### 微任务（MicroTask / Job）
```javascript
// 微任务类型（按优先级排序）
process.nextTick(() => {})        // Node.js - 最高优先级
Promise.resolve().then(() => {})  // Promise回调
async/await                       // 语法糖，本质是Promise
queueMicrotask(() => {})          // 原生微任务API
MutationObserver                  // 浏览器 - DOM变化监听
Object.observe                    // 已废弃
```

### 2. 执行顺序详解

#### 基本执行规则
```
1. 执行所有同步代码
2. 执行所有微任务（直到微任务队列为空）
3. 执行一个宏任务
4. 重复步骤2-3
```

#### 可视化流程
```
┌─ 主线程 ─┐    ┌── 微任务队列 ──┐    ┌── 宏任务队列 ──┐
│ 同步代码  │ → │ Promise.then  │ → │ setTimeout    │
│ 函数调用  │   │ async/await   │   │ setInterval   │
│ 变量声明  │   │ nextTick      │   │ setImmediate  │
└─────────┘    └──────────────┘    └──────────────┘
      ↓              ↓                      ↓
   立即执行      优先执行               最后执行
```

### 3. 经典面试例题

#### 例题1：基础执行顺序
```javascript
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');

// 输出：1 → 4 → 3 → 2
// 分析：同步代码(1,4) → 微任务(3) → 宏任务(2)
```

#### 例题2：嵌套任务
```javascript
console.log('start');

setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(() => console.log('promise1'));
}, 0);

Promise.resolve().then(() => {
    console.log('promise2');
    setTimeout(() => console.log('timeout2'), 0);
});

console.log('end');

// 输出：start → end → promise2 → timeout1 → promise1 → timeout2
```

**详细分析过程：**
```
第1轮事件循环：
- 同步：start, end
- 微任务：promise2（同时注册timeout2）
- 宏任务：执行timeout1（同时注册promise1）

第2轮事件循环：
- 微任务：promise1
- 宏任务：timeout2
```

#### 例题3：async/await混合
```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end'); // 微任务
}

async function async2() {
    console.log('async2');
}

console.log('script start');

setTimeout(() => console.log('setTimeout'), 0);

async1();

new Promise(resolve => {
    console.log('promise1'); // 同步执行
    resolve();
}).then(() => {
    console.log('promise2'); // 微任务
});

console.log('script end');

// 输出：script start → async1 start → async2 → promise1 → script end → async1 end → promise2 → setTimeout
```

### 4. Node.js环境差异

#### process.nextTick的特殊性
```javascript
console.log('start');

setTimeout(() => console.log('timeout'), 0);
setImmediate(() => console.log('immediate'));

Promise.resolve().then(() => console.log('promise'));
process.nextTick(() => console.log('nextTick'));

console.log('end');

// Node.js输出：start → end → nextTick → promise → timeout → immediate
// 注意：nextTick优先级最高，immediate在check阶段执行
```

#### Node.js事件循环阶段
```javascript
// 不同版本Node.js可能有差异
┌───────────────────────────┐
┌─>│           timers          │ ← setTimeout, setInterval
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │ ← I/O回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │ ← 内部使用
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   nextTick    │
│  │           poll            │ ← I/O │   Promise     │
│  └─────────────┬─────────────┘      └───────────────┘
│  ┌─────────────┴─────────────┐             ↑
│  │           check           │ ← setImmediate │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │  每个阶段后    │
└──┤      close callbacks      │      │  执行微任务    │
   └───────────────────────────┘      └───────────────┘
```

### 5. 复杂综合示例

```javascript
console.log('1');

setTimeout(() => {
    console.log('2');
    process.nextTick(() => {
        console.log('3');
    });
    new Promise(resolve => {
        console.log('4');
        resolve();
    }).then(() => {
        console.log('5');
    });
});

process.nextTick(() => {
    console.log('6');
});

new Promise(resolve => {
    console.log('7');
    resolve();
}).then(() => {
    console.log('8');
});

setTimeout(() => {
    console.log('9');
    process.nextTick(() => {
        console.log('10');
    });
    new Promise(resolve => {
        console.log('11');
        resolve();
    }).then(() => {
        console.log('12');
    });
});

// Node.js输出：1 → 7 → 6 → 8 → 2 → 4 → 3 → 5 → 9 → 11 → 10 → 12
```

### 6. 实际应用场景

#### 性能优化：任务分片
```javascript
function processLargeData(data) {
    const chunkSize = 1000;
    let index = 0;

    function processChunk() {
        let count = 0;
        while (count < chunkSize && index < data.length) {
            // 处理数据
            processItem(data[index]);
            index++;
            count++;
        }

        if (index < data.length) {
            // 使用宏任务避免阻塞渲染
            setTimeout(processChunk, 0);
        }
    }

    processChunk();
}
```

#### 状态同步：确保DOM更新
```javascript
function updateUI() {
    // 更新DOM
    element.textContent = 'Loading...';

    // 确保DOM更新后执行
    Promise.resolve().then(() => {
        // 此时DOM已更新，可以读取最新状态
        const height = element.offsetHeight;
        console.log('Element height:', height);
    });

    // 或使用queueMicrotask
    queueMicrotask(() => {
        // 微任务，在下次渲染前执行
        performCalculations();
    });
}
```

### 7. 调试技巧

#### 任务执行顺序验证
```javascript
function createTaskLogger(name, type) {
    return () => console.log(`${type}: ${name}`);
}

// 注册不同类型的任务
console.log('=== 开始测试 ===');

setTimeout(createTaskLogger('timeout1', 'macro'), 0);
Promise.resolve().then(createTaskLogger('promise1', 'micro'));
queueMicrotask(createTaskLogger('queueMicrotask1', 'micro'));

setTimeout(createTaskLogger('timeout2', 'macro'), 0);
Promise.resolve().then(createTaskLogger('promise2', 'micro'));

console.log('=== 同步代码结束 ===');
```

#### 性能监控
```javascript
function measureTaskExecution() {
    const start = performance.now();

    // 微任务测量
    Promise.resolve().then(() => {
        console.log('微任务延迟:', performance.now() - start);
    });

    // 宏任务测量
    setTimeout(() => {
        console.log('宏任务延迟:', performance.now() - start);
    }, 0);
}
```

### 8. 常见错误与解决

#### 错误1：假设setTimeout(0)立即执行
```javascript
// 错误认知
console.log('1');
setTimeout(() => console.log('2'), 0); // 以为立即执行
console.log('3');
// 实际输出：1 → 3 → 2

// 正确理解：setTimeout最小延迟4ms，且是宏任务
```

#### 错误2：混淆async函数执行时机
```javascript
// 容易混淆的情况
async function test() {
    console.log('async start'); // 同步执行
    await Promise.resolve();
    console.log('async end');   // 微任务
}

console.log('1');
test();
console.log('2');
// 输出：1 → async start → 2 → async end
```

### 9. 总结

宏任务和微任务的执行顺序是JavaScript异步编程的基础：

**记忆口诀：**
- 同步先行，微任务优先，宏任务殿后
- 每个宏任务后，微任务清空
- Node.js中nextTick最优先

**实际应用：**
- 使用微任务确保DOM操作的时序性
- 使用宏任务进行任务分片，避免阻塞渲染
- 合理安排任务优先级，优化用户体验

掌握这些概念对于编写高质量的异步JavaScript代码至关重要。
