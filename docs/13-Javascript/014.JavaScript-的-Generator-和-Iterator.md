---
title: JavaScript 的 Generator 和 Iterator
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: generator-and-iterator-in-javascript
ref:
---

## 核心要点总结

**Iterator迭代器**：统一的遍历接口，实现next()方法返回{value, done}，支持for...of循环
**Generator生成器**：function*语法创建的特殊函数，yield暂停执行，支持惰性求值和状态管理
**应用场景**：异步流程控制、无限序列生成、状态机实现、自定义迭代行为

## 详细回答

### 1. Iterator迭代器基础

Iterator是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。

**Iterator接口定义**：
```javascript
// Iterator接口的基本结构
interface Iterator {
  next(): IteratorResult;
}

interface IteratorResult {
  value: any;      // 当前值
  done: boolean;   // 是否完成迭代
}
```

**手动实现Iterator**：
```javascript
// 简单的数组迭代器
function createArrayIterator(array) {
  let index = 0;

  return {
    next() {
      if (index < array.length) {
        return { value: array[index++], done: false };
      } else {
        return { value: undefined, done: true };
      }
    },

    // 使对象本身可迭代
    [Symbol.iterator]() {
      return this;
    }
  };
}

// 使用示例
const iterator = createArrayIterator([1, 2, 3]);

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }

// 可以用于for...of循环
for (const value of createArrayIterator([1, 2, 3])) {
  console.log(value); // 1, 2, 3
}
```

**内置的可迭代对象**：
```javascript
// 原生支持Iterator的数据结构
const arr = [1, 2, 3];
const str = 'hello';
const set = new Set([1, 2, 3]);
const map = new Map([['a', 1], ['b', 2]]);

// 获取迭代器
const arrIterator = arr[Symbol.iterator]();
const strIterator = str[Symbol.iterator]();
const setIterator = set[Symbol.iterator]();
const mapIterator = map[Symbol.iterator]();

// 手动迭代
console.log(arrIterator.next()); // { value: 1, done: false }
console.log(strIterator.next()); // { value: 'h', done: false }
console.log(setIterator.next()); // { value: 1, done: false }
console.log(mapIterator.next()); // { value: ['a', 1], done: false }

// 不同的迭代方法
console.log([...arr]);           // [1, 2, 3]
console.log(Array.from(str));    // ['h', 'e', 'l', 'l', 'o']
console.log([...set]);           // [1, 2, 3]
console.log([...map]);           // [['a', 1], ['b', 2]]
```

**自定义可迭代对象**：
```javascript
// 创建一个范围迭代器
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }

  // 实现Symbol.iterator方法
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;

    return {
      next() {
        if ((step > 0 && current < end) || (step < 0 && current > end)) {
          const value = current;
          current += step;
          return { value, done: false };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
}

// 使用自定义迭代器
const range = new Range(1, 5);
console.log([...range]); // [1, 2, 3, 4]

for (const num of new Range(0, 10, 2)) {
  console.log(num); // 0, 2, 4, 6, 8
}

// 倒序迭代
for (const num of new Range(5, 0, -1)) {
  console.log(num); // 5, 4, 3, 2, 1
}
```

### 2. Generator生成器详解

Generator是ES6引入的一种异步编程解决方案，语法上是一个状态机，封装了多个内部状态。

**基本语法和特性**：
```javascript
// Generator函数声明
function* simpleGenerator() {
  console.log('开始执行');
  yield 1;
  console.log('第一次恢复');
  yield 2;
  console.log('第二次恢复');
  yield 3;
  console.log('执行结束');
  return 'done';
}

// Generator函数调用返回Generator对象
const generator = simpleGenerator();

console.log(generator.next()); // 开始执行 -> { value: 1, done: false }
console.log(generator.next()); // 第一次恢复 -> { value: 2, done: false }
console.log(generator.next()); // 第二次恢复 -> { value: 3, done: false }
console.log(generator.next()); // 执行结束 -> { value: 'done', done: true }
console.log(generator.next()); // { value: undefined, done: true }
```

**yield表达式的双向通信**：
```javascript
function* communicationGenerator() {
  console.log('Generator开始');

  const a = yield 'First yield';
  console.log('收到:', a);

  const b = yield 'Second yield';
  console.log('收到:', b);

  return 'Generator结束';
}

const gen = communicationGenerator();

console.log(gen.next());        // Generator开始 -> { value: 'First yield', done: false }
console.log(gen.next('Hello')); // 收到: Hello -> { value: 'Second yield', done: false }
console.log(gen.next('World')); // 收到: World -> { value: 'Generator结束', done: true }
```

**Generator的方法**：
```javascript
function* generatorMethods() {
  try {
    const a = yield 1;
    const b = yield 2;
    const c = yield 3;
  } catch (error) {
    console.log('捕获错误:', error.message);
    yield 'error handled';
  } finally {
    console.log('清理工作');
    yield 'cleanup';
  }
}

const gen = generatorMethods();

console.log(gen.next());                    // { value: 1, done: false }
console.log(gen.next('value1'));            // { value: 2, done: false }

// throw方法：向Generator内部抛出错误
console.log(gen.throw(new Error('测试错误'))); // 捕获错误: 测试错误 -> { value: 'error handled', done: false }

// return方法：强制返回给定值
console.log(gen.return('强制结束'));          // 清理工作 -> { value: '强制结束', done: true }
```

**Generator实现Iterator**：
```javascript
// 使用Generator实现斐波那契数列
function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

// 生成前10个斐波那契数
const fib = fibonacci();
const first10 = [];
for (let i = 0; i < 10; i++) {
  first10.push(fib.next().value);
}
console.log(first10); // [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

// 使用take函数限制数量
function* take(iterable, count) {
  let i = 0;
  for (const value of iterable) {
    if (i++ >= count) break;
    yield value;
  }
}

console.log([...take(fibonacci(), 5)]); // [1, 1, 2, 3, 5]
```

### 3. 高级应用场景

**1. 异步流程控制**：
```javascript
// 使用Generator实现async/await的基础原理
function* asyncGenerator() {
  try {
    const user = yield fetch('/api/user/1');
    const userData = yield user.json();

    const posts = yield fetch(`/api/user/${userData.id}/posts`);
    const postsData = yield posts.json();

    return { user: userData, posts: postsData };
  } catch (error) {
    console.error('请求失败:', error);
  }
}

// 自动执行Generator的函数
function runAsync(generatorFunction) {
  const generator = generatorFunction();

  function handle(result) {
    if (!result.done) {
      return Promise.resolve(result.value)
        .then(res => handle(generator.next(res)))
        .catch(err => handle(generator.throw(err)));
    }
    return result.value;
  }

  return handle(generator.next());
}

// 使用
runAsync(asyncGenerator).then(result => {
  console.log('最终结果:', result);
});
```

**2. 无限序列和惰性求值**：
```javascript
// 无限的自然数序列
function* naturalNumbers() {
  let n = 1;
  while (true) {
    yield n++;
  }
}

// 素数生成器
function* primes() {
  const isPrime = (n) => {
    if (n < 2) return false;
    for (let i = 2; i * i <= n; i++) {
      if (n % i === 0) return false;
    }
    return true;
  };

  for (const num of naturalNumbers()) {
    if (isPrime(num)) {
      yield num;
    }
  }
}

// 只计算需要的素数
const first5Primes = [...take(primes(), 5)];
console.log(first5Primes); // [2, 3, 5, 7, 11]

// 组合生成器
function* map(iterable, fn) {
  for (const value of iterable) {
    yield fn(value);
  }
}

function* filter(iterable, predicate) {
  for (const value of iterable) {
    if (predicate(value)) {
      yield value;
    }
  }
}

// 链式调用
const evenSquares = take(
  map(
    filter(naturalNumbers(), n => n % 2 === 0),
    n => n * n
  ),
  5
);

console.log([...evenSquares]); // [4, 16, 36, 64, 100]
```

**3. 状态机实现**：
```javascript
// 使用Generator实现状态机
function* trafficLight() {
  while (true) {
    console.log('红灯 - 停止');
    yield 'red';

    console.log('绿灯 - 通行');
    yield 'green';

    console.log('黄灯 - 准备');
    yield 'yellow';
  }
}

const light = trafficLight();

// 模拟信号灯变化
setInterval(() => {
  const { value } = light.next();
  console.log(`当前状态: ${value}`);
}, 2000);

// 更复杂的状态机：任务处理器
function* taskProcessor() {
  let tasks = [];

  while (true) {
    const action = yield;

    switch (action.type) {
      case 'ADD_TASK':
        tasks.push(action.task);
        console.log(`添加任务: ${action.task.name}`);
        break;

      case 'PROCESS_TASK':
        if (tasks.length > 0) {
          const task = tasks.shift();
          console.log(`处理任务: ${task.name}`);
          yield `任务 ${task.name} 完成`;
        } else {
          yield '没有待处理任务';
        }
        break;

      case 'GET_STATUS':
        yield `剩余任务: ${tasks.length}`;
        break;

      default:
        yield '未知操作';
    }
  }
}

const processor = taskProcessor();
processor.next(); // 启动生成器

console.log(processor.next({ type: 'ADD_TASK', task: { name: '任务1' } }));
console.log(processor.next({ type: 'ADD_TASK', task: { name: '任务2' } }));
console.log(processor.next({ type: 'GET_STATUS' }));
console.log(processor.next({ type: 'PROCESS_TASK' }));
```

**4. 树的遍历**：
```javascript
// 二叉树节点
class TreeNode {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }

  // 中序遍历生成器
  * inorderTraversal() {
    if (this.left) {
      yield* this.left.inorderTraversal();
    }
    yield this.value;
    if (this.right) {
      yield* this.right.inorderTraversal();
    }
  }

  // 先序遍历生成器
  * preorderTraversal() {
    yield this.value;
    if (this.left) {
      yield* this.left.preorderTraversal();
    }
    if (this.right) {
      yield* this.right.preorderTraversal();
    }
  }

  // 层序遍历生成器
  * levelOrderTraversal() {
    const queue = [this];

    while (queue.length > 0) {
      const node = queue.shift();
      yield node.value;

      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }
}

// 构建测试树
const tree = new TreeNode(1,
  new TreeNode(2,
    new TreeNode(4),
    new TreeNode(5)
  ),
  new TreeNode(3,
    new TreeNode(6),
    new TreeNode(7)
  )
);

console.log('中序遍历:', [...tree.inorderTraversal()]); // [4, 2, 5, 1, 6, 3, 7]
console.log('先序遍历:', [...tree.preorderTraversal()]); // [1, 2, 4, 5, 3, 6, 7]
console.log('层序遍历:', [...tree.levelOrderTraversal()]); // [1, 2, 3, 4, 5, 6, 7]
```

### 4. 实际开发中的应用

**1. 分页数据处理**：
```javascript
async function* fetchAllPages(apiUrl, pageSize = 20) {
  let page = 1;
  let hasMore = true;

  while (hasMore) {
    try {
      const response = await fetch(`${apiUrl}?page=${page}&size=${pageSize}`);
      const data = await response.json();

      for (const item of data.items) {
        yield item;
      }

      hasMore = data.hasNext;
      page++;
    } catch (error) {
      console.error(`获取第${page}页数据失败:`, error);
      break;
    }
  }
}

// 使用异步生成器处理大量数据
async function processAllData() {
  let count = 0;
  for await (const item of fetchAllPages('/api/items')) {
    console.log(`处理项目: ${item.id}`);
    count++;

    // 可以随时中断处理
    if (count >= 100) break;
  }
}
```

**2. 事件流处理**：
```javascript
function* eventStream() {
  const events = [];
  let resolver;

  // 事件监听器
  const addEvent = (event) => {
    events.push(event);
    if (resolver) {
      resolver();
      resolver = null;
    }
  };

  // 模拟事件源
  setTimeout(() => addEvent({ type: 'click', x: 100, y: 200 }), 1000);
  setTimeout(() => addEvent({ type: 'keydown', key: 'Enter' }), 2000);
  setTimeout(() => addEvent({ type: 'scroll', y: 500 }), 3000);

  while (true) {
    if (events.length > 0) {
      yield events.shift();
    } else {
      // 等待新事件
      yield new Promise(resolve => {
        resolver = resolve;
      });
    }
  }
}

// 处理事件流
async function handleEvents() {
  for (const eventPromise of eventStream()) {
    const event = await eventPromise;
    if (event) {
      console.log('处理事件:', event);
    }
  }
}
```

**3. 数据管道**：
```javascript
// 创建数据处理管道
function* pipeline(...generators) {
  let input = null;

  for (const generator of generators) {
    if (input === null) {
      input = generator;
    } else {
      input = compose(input, generator);
    }
  }

  yield* input;
}

function* compose(source, transform) {
  for (const item of source) {
    yield* transform(item);
  }
}

// 数据源
function* dataSource() {
  const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  for (const item of data) {
    yield item;
  }
}

// 转换器
function* multiplyBy(factor) {
  return function*(source) {
    for (const item of source) {
      yield item * factor;
    }
  };
}

function* filterEven(source) {
  for (const item of source) {
    if (item % 2 === 0) {
      yield item;
    }
  }
}

// 使用管道
const result = pipeline(
  dataSource(),
  multiplyBy(2),
  filterEven
);

console.log([...result]); // [4, 8, 12, 16, 20]
```

### 5. 性能优化和最佳实践

**1. 内存效率**：
```javascript
// 传统方式：一次性加载所有数据
function generateLargeDataset() {
  const data = [];
  for (let i = 0; i < 1000000; i++) {
    data.push(i * i);
  }
  return data;
}

// Generator方式：按需生成
function* generateLargeDatasetLazy() {
  for (let i = 0; i < 1000000; i++) {
    yield i * i;
  }
}

// 内存使用对比
console.time('传统方式');
const traditionalData = generateLargeDataset();
console.log('传统方式内存峰值:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');
console.timeEnd('传统方式');

console.time('Generator方式');
const generatorData = generateLargeDatasetLazy();
console.log('Generator方式内存峰值:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');

// 只处理前100个元素
let count = 0;
for (const value of generatorData) {
  if (count++ >= 100) break;
}
console.timeEnd('Generator方式');
```

**2. 错误处理最佳实践**：
```javascript
function* robustGenerator() {
  let retryCount = 0;
  const maxRetries = 3;

  while (retryCount < maxRetries) {
    try {
      // 模拟可能失败的操作
      const result = yield simulateAsyncOperation();
      yield result;
      break; // 成功时退出重试循环
    } catch (error) {
      retryCount++;
      console.log(`重试 ${retryCount}/${maxRetries}:`, error.message);

      if (retryCount >= maxRetries) {
        throw new Error(`操作失败，已重试${maxRetries}次`);
      }

      // 指数退避
      yield new Promise(resolve =>
        setTimeout(resolve, Math.pow(2, retryCount) * 1000)
      );
    }
  }
}

function simulateAsyncOperation() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      Math.random() > 0.7 ? resolve('success') : reject(new Error('随机失败'));
    }, 1000);
  });
}
```

Generator和Iterator为JavaScript提供了强大的迭代和状态管理能力。它们不仅可以简化异步编程，还能实现高效的数据处理管道，是现代JavaScript开发中不可或缺的工具。正确使用它们可以写出更优雅、更高效的代码。
