---
title: JavaScript 的防抖和节流实现
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: debounce-and-throttle-implementation
ref:
---

## 核心要点

1. **防抖(Debounce)**:事件触发 n 秒后执行,若在 n 秒内再次触发则重新计时
2. **节流(Throttle)**:固定时间间隔内只执行一次,降低事件触发频率
3. **应用场景**:防抖用于搜索框输入、窗口 resize;节流用于滚动事件、鼠标移动
4. **关键技术**:定时器、闭包、立即执行控制、取消功能

---

## 详细解答

### 一、防抖(Debounce)

#### 1. 概念理解

防抖的核心思想:**在事件被触发 n 秒后再执行回调,如果在这 n 秒内又被触发,则重新计时**。

**生活场景类比**:想象你在电梯里,每当有人进来,电梯就会延迟 10 秒关门。如果 10 秒内又有人进来,就重新计时 10 秒。只有当 10 秒内没有人进来,电梯才会关门。

```javascript
// 防抖示意图
用户连续输入:  a___b__c_____d___________→ (等待中...)
                ↓   ↓  ↓     ↓
定时器:        取消 取消取消  取消  [执行]
                              ↑
                         (500ms 后无操作才执行)
```

#### 2. 基础实现

**简单版防抖**:

```javascript
function debounce(func, delay) {
  let timer = null;

  return function(...args) {
    // 清除之前的定时器
    if (timer) {
      clearTimeout(timer);
    }

    // 设置新的定时器
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用示例
const handleInput = debounce((e) => {
  console.log('搜索:', e.target.value);
}, 500);

// HTML: <input oninput="handleInput(event)" />
// 用户输入 "hello" 时:
// 输入 h -> 等待 500ms
// 输入 e -> 重新等待 500ms
// 输入 l -> 重新等待 500ms
// 输入 l -> 重新等待 500ms
// 输入 o -> 重新等待 500ms
// 停止输入 500ms 后 -> 执行 console.log('搜索: hello')
```

**完整版防抖(支持立即执行)**:

```javascript
/**
 * 防抖函数
 * @param {Function} func - 要防抖的函数
 * @param {number} delay - 延迟时间(毫秒)
 * @param {boolean} immediate - 是否立即执行(第一次触发时立即执行)
 * @returns {Function} 防抖后的函数
 */
function debounce(func, delay, immediate = false) {
  let timer = null;

  return function(...args) {
    const context = this;

    // 清除之前的定时器
    if (timer) {
      clearTimeout(timer);
    }

    // 立即执行模式
    if (immediate) {
      // 如果 timer 为 null,说明是第一次触发或者已经执行过了
      const callNow = !timer;

      // 设置定时器,delay 时间后将 timer 置为 null
      timer = setTimeout(() => {
        timer = null;
      }, delay);

      // 立即执行
      if (callNow) {
        func.apply(context, args);
      }
    } else {
      // 延迟执行模式
      timer = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }
  };
}

// 使用示例
// 1. 延迟执行(默认)
const search = debounce((keyword) => {
  console.log('搜索:', keyword);
}, 500);

// 2. 立即执行
const submit = debounce((data) => {
  console.log('提交:', data);
}, 1000, true);

// 立即执行的效果:
// 第一次点击 -> 立即执行
// 1000ms 内再次点击 -> 忽略
// 1000ms 后点击 -> 立即执行
```

**增强版防抖(支持取消和获取返回值)**:

```javascript
function debounce(func, delay, immediate = false) {
  let timer = null;
  let result = null;

  // 防抖函数
  const debounced = function(...args) {
    const context = this;

    // 清除之前的定时器
    if (timer) {
      clearTimeout(timer);
    }

    if (immediate) {
      const callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);

      if (callNow) {
        result = func.apply(context, args);
      }
    } else {
      timer = setTimeout(() => {
        result = func.apply(context, args);
      }, delay);
    }

    return result;
  };

  // 取消防抖
  debounced.cancel = function() {
    clearTimeout(timer);
    timer = null;
  };

  // 立即执行
  debounced.flush = function() {
    if (timer) {
      clearTimeout(timer);
      result = func.apply(this, arguments);
      timer = null;
    }
    return result;
  };

  return debounced;
}

// 使用示例
const handler = debounce(() => {
  console.log('执行');
}, 1000);

handler(); // 触发
handler(); // 重新计时
handler.cancel(); // 取消执行
handler.flush(); // 立即执行
```

#### 3. 防抖的应用场景

**场景1:搜索框输入联想**

```javascript
// 搜索框输入防抖
class SearchBox {
  constructor() {
    this.input = document.querySelector('#search-input');
    this.resultList = document.querySelector('#search-results');

    // 防抖处理搜索请求
    this.handleSearch = debounce(this.search.bind(this), 500);

    this.input.addEventListener('input', (e) => {
      this.handleSearch(e.target.value);
    });
  }

  async search(keyword) {
    if (!keyword.trim()) {
      this.resultList.innerHTML = '';
      return;
    }

    console.log('发起搜索请求:', keyword);

    try {
      const response = await fetch(`/api/search?q=${keyword}`);
      const results = await response.json();
      this.renderResults(results);
    } catch (error) {
      console.error('搜索失败:', error);
    }
  }

  renderResults(results) {
    this.resultList.innerHTML = results
      .map(item => `<li>${item.title}</li>`)
      .join('');
  }
}

// 优势:用户输入 "JavaScript" 时,
// 不会发送 11 次请求(J, a, v, a, S, c, r, i, p, t),
// 而是等待 500ms 停止输入后只发送 1 次请求
```

**场景2:窗口 resize 事件**

```javascript
// 窗口大小调整防抖
class ResponsiveLayout {
  constructor() {
    this.handleResize = debounce(this.onResize.bind(this), 300);
    window.addEventListener('resize', this.handleResize);
  }

  onResize() {
    const width = window.innerWidth;
    console.log('窗口宽度:', width);

    // 根据宽度调整布局
    if (width < 768) {
      this.switchToMobileLayout();
    } else if (width < 1024) {
      this.switchToTabletLayout();
    } else {
      this.switchToDesktopLayout();
    }
  }

  switchToMobileLayout() {
    console.log('切换到移动端布局');
  }

  switchToTabletLayout() {
    console.log('切换到平板布局');
  }

  switchToDesktopLayout() {
    console.log('切换到桌面端布局');
  }

  destroy() {
    window.removeEventListener('resize', this.handleResize);
    this.handleResize.cancel(); // 取消待执行的防抖
  }
}
```

**场景3:表单验证**

```javascript
// 表单输入验证防抖
class FormValidator {
  constructor() {
    this.emailInput = document.querySelector('#email');
    this.usernameInput = document.querySelector('#username');

    // 防抖验证
    this.validateEmail = debounce(this.checkEmail.bind(this), 500);
    this.validateUsername = debounce(this.checkUsername.bind(this), 500);

    this.emailInput.addEventListener('input', (e) => {
      this.validateEmail(e.target.value);
    });

    this.usernameInput.addEventListener('input', (e) => {
      this.validateUsername(e.target.value);
    });
  }

  async checkEmail(email) {
    if (!email) return;

    console.log('验证邮箱:', email);

    const response = await fetch('/api/validate-email', {
      method: 'POST',
      body: JSON.stringify({ email })
    });

    const { isValid, message } = await response.json();
    this.showEmailFeedback(isValid, message);
  }

  async checkUsername(username) {
    if (!username) return;

    console.log('验证用户名:', username);

    const response = await fetch('/api/validate-username', {
      method: 'POST',
      body: JSON.stringify({ username })
    });

    const { isAvailable, message } = await response.json();
    this.showUsernameFeedback(isAvailable, message);
  }

  showEmailFeedback(isValid, message) {
    const feedback = document.querySelector('#email-feedback');
    feedback.textContent = message;
    feedback.className = isValid ? 'valid' : 'invalid';
  }

  showUsernameFeedback(isAvailable, message) {
    const feedback = document.querySelector('#username-feedback');
    feedback.textContent = message;
    feedback.className = isAvailable ? 'valid' : 'invalid';
  }
}
```

**场景4:按钮防重复点击**

```javascript
// 提交按钮防抖(使用立即执行模式)
class SubmitButton {
  constructor() {
    this.button = document.querySelector('#submit-btn');

    // 立即执行防抖,防止重复提交
    this.handleSubmit = debounce(this.submit.bind(this), 2000, true);

    this.button.addEventListener('click', this.handleSubmit);
  }

  async submit() {
    console.log('提交表单...');

    this.button.disabled = true;
    this.button.textContent = '提交中...';

    try {
      const formData = this.getFormData();
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: JSON.stringify(formData)
      });

      const result = await response.json();
      console.log('提交成功:', result);
    } catch (error) {
      console.error('提交失败:', error);
    } finally {
      this.button.disabled = false;
      this.button.textContent = '提交';
    }
  }

  getFormData() {
    // 获取表单数据
    return {
      name: document.querySelector('#name').value,
      email: document.querySelector('#email').value
    };
  }
}
```

### 二、节流(Throttle)

#### 1. 概念理解

节流的核心思想:**在固定的时间间隔内,只执行一次函数。无论触发多少次,都按固定频率执行**。

**生活场景类比**:想象一个水龙头,无论你怎么拧,水流量都有上限。节流就像是控制水龙头的流量,让水按固定速率流出。

```javascript
// 节流示意图
用户连续触发: ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓→
              0ms          1000ms        2000ms
执行时机:     [执行]         [执行]        [执行]
              ↑            ↑            ↑
        (每隔1000ms执行一次,匀速执行)
```

#### 2. 基础实现

**时间戳版本(立即执行)**:

```javascript
/**
 * 节流函数 - 时间戳版本
 * 特点:第一次触发立即执行,最后一次触发可能不执行
 */
function throttle(func, delay) {
  let lastTime = 0;

  return function(...args) {
    const now = Date.now();

    // 如果距离上次执行超过 delay 时间,则执行
    if (now - lastTime >= delay) {
      lastTime = now;
      func.apply(this, args);
    }
  };
}

// 使用示例
const handleScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 1000);

window.addEventListener('scroll', handleScroll);

// 效果:
// 0ms:滚动 -> 立即执行
// 500ms:滚动 -> 忽略(距上次不足1000ms)
// 1000ms:滚动 -> 执行
// 1500ms:滚动 -> 忽略
// 2000ms:滚动 -> 执行
```

**定时器版本(延迟执行)**:

```javascript
/**
 * 节流函数 - 定时器版本
 * 特点:第一次触发延迟执行,最后一次触发一定会执行
 */
function throttle(func, delay) {
  let timer = null;

  return function(...args) {
    // 如果定时器存在,说明还在冷却期,直接返回
    if (timer) {
      return;
    }

    // 设置定时器
    timer = setTimeout(() => {
      func.apply(this, args);
      timer = null; // 执行后清空定时器
    }, delay);
  };
}

// 效果:
// 0ms:滚动 -> 设置定时器(1000ms后执行)
// 500ms:滚动 -> 忽略(定时器存在)
// 1000ms:执行回调,清空定时器
// 1100ms:滚动 -> 设置新定时器
```

**完整版节流(支持首尾执行控制)**:

```javascript
/**
 * 节流函数 - 完整版
 * @param {Function} func - 要节流的函数
 * @param {number} delay - 时间间隔(毫秒)
 * @param {Object} options - 配置选项
 * @param {boolean} options.leading - 是否在开始时执行(默认 true)
 * @param {boolean} options.trailing - 是否在结束时执行(默认 true)
 */
function throttle(func, delay, options = {}) {
  let timer = null;
  let lastTime = 0;

  const { leading = true, trailing = true } = options;

  return function(...args) {
    const now = Date.now();
    const context = this;

    // 首次触发且 leading 为 false,记录时间但不执行
    if (!lastTime && !leading) {
      lastTime = now;
    }

    // 计算剩余时间
    const remaining = delay - (now - lastTime);

    // 时间到了,执行函数
    if (remaining <= 0 || remaining > delay) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      lastTime = now;
      func.apply(context, args);
    }
    // 时间未到,且 trailing 为 true,设置定时器
    else if (!timer && trailing) {
      timer = setTimeout(() => {
        lastTime = leading ? Date.now() : 0;
        timer = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}

// 使用示例
// 1. 默认配置(首尾都执行)
const handler1 = throttle(() => console.log('执行'), 1000);

// 2. 只在开始时执行
const handler2 = throttle(() => console.log('执行'), 1000, {
  leading: true,
  trailing: false
});

// 3. 只在结束时执行
const handler3 = throttle(() => console.log('执行'), 1000, {
  leading: false,
  trailing: true
});
```

**增强版节流(支持取消)**:

```javascript
function throttle(func, delay, options = {}) {
  let timer = null;
  let lastTime = 0;
  const { leading = true, trailing = true } = options;

  const throttled = function(...args) {
    const now = Date.now();
    const context = this;

    if (!lastTime && !leading) {
      lastTime = now;
    }

    const remaining = delay - (now - lastTime);

    if (remaining <= 0 || remaining > delay) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      lastTime = now;
      func.apply(context, args);
    } else if (!timer && trailing) {
      timer = setTimeout(() => {
        lastTime = leading ? Date.now() : 0;
        timer = null;
        func.apply(context, args);
      }, remaining);
    }
  };

  // 取消节流
  throttled.cancel = function() {
    clearTimeout(timer);
    timer = null;
    lastTime = 0;
  };

  return throttled;
}

// 使用示例
const handler = throttle(() => console.log('执行'), 1000);

window.addEventListener('scroll', handler);

// 在组件销毁时取消
window.removeEventListener('scroll', handler);
handler.cancel();
```

#### 3. 节流的应用场景

**场景1:滚动事件监听**

```javascript
// 滚动加载更多
class InfiniteScroll {
  constructor() {
    this.loading = false;
    this.hasMore = true;

    // 节流处理滚动事件
    this.handleScroll = throttle(this.checkScrollPosition.bind(this), 200);

    window.addEventListener('scroll', this.handleScroll);
  }

  checkScrollPosition() {
    // 如果正在加载或没有更多数据,直接返回
    if (this.loading || !this.hasMore) return;

    const scrollTop = window.scrollY;
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;

    // 距离底部 100px 时加载
    if (scrollTop + windowHeight >= documentHeight - 100) {
      this.loadMore();
    }
  }

  async loadMore() {
    this.loading = true;
    console.log('加载更多数据...');

    try {
      const response = await fetch('/api/items?page=' + this.currentPage);
      const data = await response.json();

      this.renderItems(data.items);
      this.currentPage++;
      this.hasMore = data.hasMore;
    } catch (error) {
      console.error('加载失败:', error);
    } finally {
      this.loading = false;
    }
  }

  renderItems(items) {
    const container = document.querySelector('#items-container');
    items.forEach(item => {
      const div = document.createElement('div');
      div.textContent = item.title;
      container.appendChild(div);
    });
  }

  destroy() {
    window.removeEventListener('scroll', this.handleScroll);
    this.handleScroll.cancel();
  }
}
```

**场景2:鼠标移动事件**

```javascript
// 鼠标移动绘图
class DrawingCanvas {
  constructor() {
    this.canvas = document.querySelector('#canvas');
    this.ctx = this.canvas.getContext('2d');
    this.isDrawing = false;

    // 节流处理鼠标移动
    this.handleMouseMove = throttle(this.draw.bind(this), 16); // ~60fps

    this.canvas.addEventListener('mousedown', (e) => {
      this.isDrawing = true;
      this.lastX = e.offsetX;
      this.lastY = e.offsetY;
    });

    this.canvas.addEventListener('mousemove', (e) => {
      if (this.isDrawing) {
        this.handleMouseMove(e.offsetX, e.offsetY);
      }
    });

    this.canvas.addEventListener('mouseup', () => {
      this.isDrawing = false;
    });
  }

  draw(x, y) {
    this.ctx.beginPath();
    this.ctx.moveTo(this.lastX, this.lastY);
    this.ctx.lineTo(x, y);
    this.ctx.stroke();

    this.lastX = x;
    this.lastY = y;
  }
}
```

**场景3:实时搜索(高频输入)**

```javascript
// 结合防抖和节流的实时搜索
class RealtimeSearch {
  constructor() {
    this.input = document.querySelector('#search-input');

    // 节流:实时显示输入字数
    this.updateCounter = throttle(this.showCounter.bind(this), 100);

    // 防抖:发送搜索请求
    this.performSearch = debounce(this.search.bind(this), 500);

    this.input.addEventListener('input', (e) => {
      const value = e.target.value;
      this.updateCounter(value);  // 实时更新(节流)
      this.performSearch(value);  // 延迟搜索(防抖)
    });
  }

  showCounter(value) {
    const counter = document.querySelector('#char-counter');
    counter.textContent = `已输入 ${value.length} 个字符`;
  }

  async search(keyword) {
    if (!keyword) return;

    console.log('搜索:', keyword);
    const response = await fetch(`/api/search?q=${keyword}`);
    const results = await response.json();
    this.renderResults(results);
  }

  renderResults(results) {
    // 渲染搜索结果
  }
}
```

**场景4:按钮点击(防暴力点击)**

```javascript
// 点赞按钮节流
class LikeButton {
  constructor() {
    this.button = document.querySelector('#like-btn');
    this.count = 0;

    // 节流处理点赞
    this.handleLike = throttle(this.like.bind(this), 1000, {
      leading: true,   // 第一次立即执行
      trailing: false  // 最后一次不执行
    });

    this.button.addEventListener('click', this.handleLike);
  }

  async like() {
    this.count++;
    console.log('点赞次数:', this.count);

    // 更新 UI
    this.button.classList.add('liked');
    this.button.textContent = `❤ ${this.count}`;

    // 发送请求
    try {
      await fetch('/api/like', {
        method: 'POST',
        body: JSON.stringify({ postId: this.postId })
      });
    } catch (error) {
      console.error('点赞失败:', error);
      this.count--;
    }
  }
}
```

**场景5:拖拽元素**

```javascript
// 元素拖拽节流
class DraggableElement {
  constructor(element) {
    this.element = element;
    this.isDragging = false;

    // 节流处理拖拽移动
    this.handleDrag = throttle(this.onDrag.bind(this), 16); // ~60fps

    this.element.addEventListener('mousedown', (e) => {
      this.isDragging = true;
      this.offsetX = e.offsetX;
      this.offsetY = e.offsetY;
    });

    document.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        this.handleDrag(e.clientX, e.clientY);
      }
    });

    document.addEventListener('mouseup', () => {
      this.isDragging = false;
    });
  }

  onDrag(clientX, clientY) {
    const x = clientX - this.offsetX;
    const y = clientY - this.offsetY;

    this.element.style.left = `${x}px`;
    this.element.style.top = `${y}px`;

    console.log(`位置: (${x}, ${y})`);
  }
}
```

### 三、防抖 vs 节流对比

#### 1. 核心区别

| 特性 | 防抖(Debounce) | 节流(Throttle) |
|------|---------------|---------------|
| **执行时机** | n 秒后执行一次 | 每隔 n 秒执行一次 |
| **执行频率** | 可能一次都不执行 | 固定频率执行 |
| **重新计时** | 每次触发重新计时 | 不重新计时 |
| **应用场景** | 低频场景(搜索、验证) | 高频场景(滚动、移动) |
| **用户体验** | 等待停止操作后响应 | 持续响应,匀速执行 |

#### 2. 可视化对比

```javascript
// 模拟连续触发 20 次事件,间隔 50ms

// 原始函数(无优化)
// 执行 20 次
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

// 防抖(500ms)
// 只执行 1 次(最后一次触发后 500ms)
↓-------------------[执行]

// 节流(200ms)
// 执行 5 次(每 200ms 执行一次)
↓--------↓--------↓--------↓--------↓
[执行]   [执行]   [执行]   [执行]   [执行]
```

#### 3. 实际效果对比

```javascript
// 对比测试
let normalCount = 0;
let debounceCount = 0;
let throttleCount = 0;

// 原始函数
const normalFunc = () => {
  normalCount++;
  console.log('原始函数执行次数:', normalCount);
};

// 防抖函数
const debounceFunc = debounce(() => {
  debounceCount++;
  console.log('防抖函数执行次数:', debounceCount);
}, 500);

// 节流函数
const throttleFunc = throttle(() => {
  throttleCount++;
  console.log('节流函数执行次数:', throttleCount);
}, 500);

// 模拟连续触发
const testDuration = 3000; // 3秒
const triggerInterval = 50; // 每 50ms 触发一次

const intervalId = setInterval(() => {
  normalFunc();
  debounceFunc();
  throttleFunc();
}, triggerInterval);

// 3 秒后停止
setTimeout(() => {
  clearInterval(intervalId);

  console.log('\n最终结果:');
  console.log('原始函数:', normalCount);    // ~60 次
  console.log('防抖函数:', debounceCount);  // 1 次
  console.log('节流函数:', throttleCount);  // ~6 次
}, testDuration);
```

### 四、实际开发中的最佳实践

#### 1. React Hooks 中使用防抖节流

```javascript
import { useCallback, useRef, useEffect } from 'react';

// 自定义防抖 Hook
function useDebounce(callback, delay) {
  const callbackRef = useRef(callback);
  const timerRef = useRef(null);

  // 保持 callback 最新
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const debouncedCallback = useCallback((...args) => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }

    timerRef.current = setTimeout(() => {
      callbackRef.current(...args);
    }, delay);
  }, [delay]);

  // 组件卸载时清理
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);

  return debouncedCallback;
}

// 自定义节流 Hook
function useThrottle(callback, delay) {
  const callbackRef = useRef(callback);
  const lastTimeRef = useRef(0);

  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const throttledCallback = useCallback((...args) => {
    const now = Date.now();

    if (now - lastTimeRef.current >= delay) {
      lastTimeRef.current = now;
      callbackRef.current(...args);
    }
  }, [delay]);

  return throttledCallback;
}

// 使用示例
function SearchComponent() {
  const [keyword, setKeyword] = useState('');

  const handleSearch = useDebounce((value) => {
    console.log('搜索:', value);
    // 发起搜索请求
  }, 500);

  return (
    <input
      value={keyword}
      onChange={(e) => {
        setKeyword(e.target.value);
        handleSearch(e.target.value);
      }}
    />
  );
}
```

#### 2. Vue3 中使用防抖节流

```javascript
import { ref, watch } from 'vue';

// 组合式 API
export default {
  setup() {
    const keyword = ref('');

    // 防抖搜索
    const debouncedSearch = debounce((value) => {
      console.log('搜索:', value);
      // 发起搜索请求
    }, 500);

    watch(keyword, (newValue) => {
      debouncedSearch(newValue);
    });

    return {
      keyword
    };
  }
};
```

#### 3. lodash 实现(生产环境推荐)

```javascript
import { debounce, throttle } from 'lodash';

// 防抖
const debouncedSearch = debounce((keyword) => {
  console.log('搜索:', keyword);
}, 500, {
  leading: false,  // 开始时不执行
  trailing: true,  // 结束时执行
  maxWait: 2000    // 最大等待时间
});

// 节流
const throttledScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 200, {
  leading: true,   // 开始时执行
  trailing: true   // 结束时执行
});

// 取消
debouncedSearch.cancel();
throttledScroll.cancel();

// 立即执行
debouncedSearch.flush();
```

### 五、面试回答模板

**简洁版**:

**防抖(Debounce)**:事件触发 n 秒后执行,如果 n 秒内再次触发则重新计时。适用于搜索框输入、表单验证等低频场景。

**节流(Throttle)**:每隔固定时间执行一次,无论触发多少次都按固定频率执行。适用于滚动事件、鼠标移动等高频场景。

**核心区别**:防抖是"等你停下来",节流是"匀速执行"。防抖可能一次都不执行,节流保证固定频率执行。

**实现要点**:
- 防抖用 `setTimeout` + 清除定时器实现
- 节流用时间戳或定时器实现
- 都需要用闭包保存状态
- 生产环境推荐使用 lodash

**详细版**:

防抖和节流都是用来优化高频事件触发的技术,但处理方式不同:

**防抖**的原理是:在事件触发 n 秒后才执行回调,如果在这 n 秒内事件再次被触发,则重新开始计时。实现时使用 `setTimeout` 创建定时器,每次触发时先清除之前的定时器,再创建新的定时器。可以支持立即执行模式,即第一次触发立即执行,后续触发重新计时。典型应用包括搜索框联想(等用户停止输入)、窗口 resize 事件、表单验证等低频场景。

**节流**的原理是:固定时间间隔内只执行一次,无论触发多少次。有两种实现方式:时间戳版本记录上次执行时间,每次触发时对比时间差;定时器版本在冷却期内直接忽略后续触发。可以通过配置控制首尾是否执行。典型应用包括滚动加载、鼠标移动绘图、拖拽元素等高频场景。

**核心区别**:防抖关注"最后一次",只在停止触发后执行,可能一次都不执行;节流关注"执行频率",保证固定时间间隔执行一次,匀速响应用户操作。

**实现技巧**包括:用闭包保存定时器和时间戳状态;用 `apply` 保持正确的 `this` 指向;支持取消和立即执行功能;使用 `WeakMap` 避免内存泄漏。在 React/Vue 中需要特别注意生命周期,组件卸载时要清理定时器。生产环境推荐使用 lodash 的 `debounce` 和 `throttle`,功能更完善且经过充分测试。
