---
title: JavaScript 的原型链和继承机制
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: javascript-prototype-chain-and-inheritance
ref:
---

## 核心要点
- **prototype vs __proto__**：构造函数的原型对象 vs 实例的原型链指针
- **原型链查找**：属性/方法查找的向上委托机制
- **继承实现**：ES5构造函数继承 vs ES6类继承的区别和原理

## 详细解答

### 1. 原型链基础概念

JavaScript采用原型继承机制，每个对象都有一个隐式原型链指针。

```javascript
// 构造函数
function Person(name) {
    this.name = name;
}

// 在原型上添加方法
Person.prototype.sayHello = function() {
    console.log(`Hello, I'm ${this.name}`);
};

const person1 = new Person('Alice');

// 原型链关系
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

**原型链查找过程：**
1. 在对象自身查找属性
2. 沿着 `__proto__` 向上查找
3. 直到找到属性或到达 `null`

### 2. prototype vs __proto__

```javascript
function Animal() {}

// prototype：构造函数的原型对象（只有函数有）
console.log(typeof Animal.prototype); // "object"

const dog = new Animal();

// __proto__：实例的原型链指针（所有对象都有）
console.log(dog.__proto__ === Animal.prototype); // true

// 等价的标准方法
console.log(Object.getPrototypeOf(dog) === Animal.prototype); // true
```

### 3. ES5 继承实现

#### 组合继承（最常用）

```javascript
// 父类
function Animal(name) {
    this.name = name;
    this.colors = ['red', 'blue'];
}

Animal.prototype.say = function() {
    console.log(`${this.name} makes a sound`);
};

// 子类
function Dog(name, breed) {
    // 继承实例属性
    Animal.call(this, name);
    this.breed = breed;
}

// 继承原型方法
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log(`${this.name} barks`);
};

const dog1 = new Dog('Buddy', 'Golden');
dog1.say();  // "Buddy makes a sound"
dog1.bark(); // "Buddy barks"

// 验证继承链
console.log(dog1 instanceof Dog);    // true
console.log(dog1 instanceof Animal); // true
```

#### 寄生组合继承（最佳方案）

```javascript
function inherit(Child, Parent) {
    // 创建父类原型的副本
    const prototype = Object.create(Parent.prototype);
    // 修正构造函数指向
    prototype.constructor = Child;
    // 设置子类原型
    Child.prototype = prototype;
}

function Animal(name) {
    this.name = name;
}

Animal.prototype.move = function() {
    console.log(`${this.name} moves`);
};

function Bird(name, canFly) {
    Animal.call(this, name);
    this.canFly = canFly;
}

// 使用寄生组合继承
inherit(Bird, Animal);

Bird.prototype.fly = function() {
    if (this.canFly) {
        console.log(`${this.name} flies`);
    }
};
```

### 4. ES6 类继承

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    move() {
        console.log(`${this.name} moves`);
    }

    // 静态方法
    static getSpecies() {
        return 'Unknown';
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 必须调用父类构造函数
        this.breed = breed;
    }

    bark() {
        console.log(`${this.name} barks`);
    }

    // 重写父类方法
    move() {
        super.move(); // 调用父类方法
        console.log('Dog runs fast');
    }

    static getSpecies() {
        return 'Canis lupus';
    }
}

const myDog = new Dog('Max', 'Labrador');
myDog.move(); // "Max moves" + "Dog runs fast"
```

### 5. ES5 vs ES6 继承差异

| 特性 | ES5 | ES6 |
|------|-----|-----|
| **继承顺序** | 先创建子类实例，再调用父类构造函数 | 先创建父类实例，再初始化子类 |
| **super关键字** | 无，需要 call/apply | 有，必须在constructor中调用 |
| **静态方法继承** | 需要手动设置 | 自动继承 |
| **语法复杂度** | 复杂，容易出错 | 简洁，语义清晰 |

```javascript
// ES5：子类实例 -> 父类构造函数
function Child() {
    Parent.call(this); // this 先存在
}

// ES6：父类实例 -> 子类初始化
class Child extends Parent {
    constructor() {
        super(); // 必须先调用，创建 this
        // 然后才能使用 this
    }
}
```

### 6. 原型链操作方法

```javascript
const obj = { name: 'test' };

// 检查原型链
console.log(obj.hasOwnProperty('name')); // true
console.log('toString' in obj); // true (继承的)
console.log(obj.hasOwnProperty('toString')); // false

// 设置原型
const proto = { sayHi() { console.log('Hi'); } };
Object.setPrototypeOf(obj, proto);
obj.sayHi(); // "Hi"

// 创建无原型对象
const pureObj = Object.create(null);
console.log(pureObj.__proto__); // undefined
```

### 7. 实际应用场景

#### 插件系统

```javascript
class Plugin {
    constructor(name) {
        this.name = name;
    }

    init() {
        console.log(`${this.name} plugin initialized`);
    }
}

class AuthPlugin extends Plugin {
    constructor() {
        super('Auth');
        this.token = null;
    }

    init() {
        super.init();
        this.setupAuth();
    }

    setupAuth() {
        // 认证逻辑
    }
}
```

#### Mixin 模式

```javascript
const Flyable = {
    fly() {
        console.log(`${this.name} is flying`);
    }
};

const Swimmable = {
    swim() {
        console.log(`${this.name} is swimming`);
    }
};

class Duck extends Animal {
    constructor(name) {
        super(name);
    }
}

// 混入多个能力
Object.assign(Duck.prototype, Flyable, Swimmable);

const duck = new Duck('Donald');
duck.fly();  // "Donald is flying"
duck.swim(); // "Donald is swimming"
```

### 8. 性能考虑

```javascript
// 避免深层原型链
function deepChain() {
    const a = {};
    const b = Object.create(a);
    const c = Object.create(b);
    const d = Object.create(c);
    // 过深的原型链影响属性查找性能
}

// 优化：缓存原型方法
class OptimizedClass {
    constructor() {
        // 将常用方法绑定到实例
        this.boundMethod = this.expensiveMethod.bind(this);
    }

    expensiveMethod() {
        // 复杂逻辑
    }
}
```

### 9. 常见面试问题

```javascript
// Q: 为什么需要修正 constructor？
function Parent() {}
function Child() {}

Child.prototype = Object.create(Parent.prototype);
// 不修正的话
console.log(new Child().constructor === Parent); // true

Child.prototype.constructor = Child;
console.log(new Child().constructor === Child); // true

// Q: instanceof 原理
function myInstanceof(obj, Constructor) {
    let proto = Object.getPrototypeOf(obj);

    while (proto) {
        if (proto === Constructor.prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }

    return false;
}
```

### 总结

原型链是JavaScript面向对象编程的核心机制，理解其工作原理对于：
- 掌握继承模式
- 优化代码性能
- 避免原型污染
- 设计可扩展架构

都至关重要。现代开发中虽然多使用ES6类语法，但了解底层原型链机制仍然必不可少。
