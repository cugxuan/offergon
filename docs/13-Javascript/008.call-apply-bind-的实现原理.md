---
title: call、apply、bind 的实现原理
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: call-apply-bind-implementation
ref:
---

## 核心要点
- **call/apply立即执行**：改变this指向并立即调用函数，区别在于参数传递方式
- **bind延迟执行**：返回新函数，预设this指向和部分参数（柯里化）
- **手写实现原理**：利用对象方法调用时this指向该对象的特性

## 详细解答

### 1. 基本用法和区别

```javascript
function greet(greeting, punctuation) {
    return `${greeting}, I'm ${this.name}${punctuation}`;
}

const person = { name: 'Alice' };

// call：参数逐个传递
const result1 = greet.call(person, 'Hello', '!');
console.log(result1); // "Hello, I'm Alice!"

// apply：参数数组传递
const result2 = greet.apply(person, ['Hi', '?']);
console.log(result2); // "Hi, I'm Alice?"

// bind：返回新函数
const boundGreet = greet.bind(person, 'Hey');
const result3 = boundGreet('.');
console.log(result3); // "Hey, I'm Alice."
```

### 2. call的实现原理

```javascript
// 基础版本
Function.prototype.myCall = function(context, ...args) {
    // 1. 处理context为null/undefined的情况
    context = context || globalThis; // 浏览器中是window，Node.js中是global

    // 2. 将函数设置为context的属性
    const fnSymbol = Symbol('fn'); // 使用Symbol避免属性名冲突
    context[fnSymbol] = this;

    // 3. 调用函数
    const result = context[fnSymbol](...args);

    // 4. 删除临时属性
    delete context[fnSymbol];

    // 5. 返回结果
    return result;
};

// 完整版本（处理边界情况）
Function.prototype.myCallComplete = function(context, ...args) {
    // 类型检查
    if (typeof this !== 'function') {
        throw new TypeError('myCall must be called on a function');
    }

    // 处理context
    if (context == null) {
        context = globalThis;
    } else if (typeof context !== 'object') {
        // 原始值转换为对象
        context = Object(context);
    }

    // 创建唯一属性名
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;

    try {
        // 调用函数并返回结果
        return context[fnSymbol](...args);
    } finally {
        // 确保清理临时属性
        delete context[fnSymbol];
    }
};

// 测试
function test() {
    return `this is ${this.name}`;
}

const obj = { name: 'test object' };
console.log(test.myCall(obj)); // "this is test object"
```

### 3. apply的实现原理

```javascript
Function.prototype.myApply = function(context, argsArray) {
    // 类型检查
    if (typeof this !== 'function') {
        throw new TypeError('myApply must be called on a function');
    }

    // 处理context
    context = context || globalThis;
    if (typeof context !== 'object') {
        context = Object(context);
    }

    // 处理参数数组
    const args = Array.isArray(argsArray) ? argsArray : [];

    // 创建唯一属性名
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;

    try {
        // 调用函数
        return context[fnSymbol](...args);
    } finally {
        delete context[fnSymbol];
    }
};

// 测试
function sum(a, b, c) {
    console.log(`this.name: ${this.name}`);
    return a + b + c;
}

const calculator = { name: 'Calculator' };
const result = sum.myApply(calculator, [1, 2, 3]);
console.log(result); // 6
```

### 4. bind的实现原理

```javascript
// 基础版本
Function.prototype.myBind = function(context, ...bindArgs) {
    if (typeof this !== 'function') {
        throw new TypeError('myBind must be called on a function');
    }

    const fn = this;

    return function boundFunction(...callArgs) {
        // 合并预设参数和调用参数
        const allArgs = [...bindArgs, ...callArgs];

        // 使用call改变this指向
        return fn.call(context, ...allArgs);
    };
};

// 完整版本（支持new操作）
Function.prototype.myBindComplete = function(context, ...bindArgs) {
    if (typeof this !== 'function') {
        throw new TypeError('myBind must be called on a function');
    }

    const fn = this;

    function boundFunction(...callArgs) {
        const allArgs = [...bindArgs, ...callArgs];

        // 检查是否使用new调用
        if (new.target) {
            // new调用：忽略context，this指向新创建的实例
            return fn.call(this, ...allArgs);
        } else {
            // 普通调用：使用绑定的context
            return fn.call(context, ...allArgs);
        }
    }

    // 维护原型链
    if (fn.prototype) {
        boundFunction.prototype = Object.create(fn.prototype);
    }

    return boundFunction;
};

// 测试
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHello = function() {
    return `Hello, I'm ${this.name}`;
};

const obj = { x: 1 };
const BoundPerson = Person.myBindComplete(obj, 'Alice');

// 作为构造函数使用
const person = new BoundPerson(25);
console.log(person.name); // "Alice"
console.log(person.sayHello()); // "Hello, I'm Alice"

// 作为普通函数使用
BoundPerson(30); // obj.name = "Alice"
```

### 5. 高级实现考虑

#### 5.1 处理特殊情况

```javascript
Function.prototype.myBindAdvanced = function(context, ...bindArgs) {
    if (typeof this !== 'function') {
        throw new TypeError('Bind must be called on a function');
    }

    const fn = this;
    const fNOP = function() {}; // 空函数作为中介

    function boundFunction(...callArgs) {
        const allArgs = [...bindArgs, ...callArgs];

        // 判断是否为构造函数调用
        const isNew = this instanceof boundFunction;

        return fn.apply(
            isNew ? this : context,
            allArgs
        );
    }

    // 维护原型链关系
    if (fn.prototype) {
        fNOP.prototype = fn.prototype;
        boundFunction.prototype = new fNOP();
    }

    // 保存原函数信息
    boundFunction.displayName = `bound ${fn.name || 'anonymous'}`;
    boundFunction.length = Math.max(0, fn.length - bindArgs.length);

    return boundFunction;
};
```

#### 5.2 性能优化版本

```javascript
Function.prototype.myBindOptimized = function(context, ...bindArgs) {
    if (typeof this !== 'function') {
        throw new TypeError('Bind must be called on a function');
    }

    const fn = this;

    // 根据参数数量优化
    if (bindArgs.length === 0) {
        return function(...callArgs) {
            return new.target ?
                fn.call(this, ...callArgs) :
                fn.call(context, ...callArgs);
        };
    }

    return function(...callArgs) {
        const allArgs = bindArgs.concat(callArgs);
        return new.target ?
            fn.apply(this, allArgs) :
            fn.apply(context, allArgs);
    };
};
```

### 6. 实际应用场景

#### 6.1 数组方法借用

```javascript
// 类数组对象借用数组方法
const arrayLike = {
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3
};

// 使用call/apply借用数组方法
const slice = Array.prototype.slice;
const result1 = slice.call(arrayLike, 1, 3);
console.log(result1); // ['b', 'c']

// 或者直接调用
const result2 = Array.prototype.map.call(arrayLike, item => item.toUpperCase());
console.log(result2); // ['A', 'B', 'C']

// 现代替代方法
const result3 = Array.from(arrayLike, item => item.toUpperCase());
```

#### 6.2 函数参数处理

```javascript
function processArguments() {
    // 将arguments转换为真正的数组
    const args = Array.prototype.slice.call(arguments);

    return args.map(arg => arg * 2);
}

console.log(processArguments(1, 2, 3)); // [2, 4, 6]

// ES6替代方法
function processArgumentsES6(...args) {
    return args.map(arg => arg * 2);
}
```

#### 6.3 事件处理器绑定

```javascript
class EventHandler {
    constructor() {
        this.count = 0;
        this.element = document.getElementById('button');

        // 绑定this
        this.handleClick = this.handleClick.bind(this);
        this.element.addEventListener('click', this.handleClick);

        // 或使用箭头函数
        this.element.addEventListener('click', (e) => this.handleClick(e));
    }

    handleClick(event) {
        this.count++;
        console.log(`Clicked ${this.count} times`);
    }

    destroy() {
        this.element.removeEventListener('click', this.handleClick);
    }
}
```

#### 6.4 函数柯里化

```javascript
// 使用bind实现柯里化
function multiply(a, b, c) {
    return a * b * c;
}

const multiplyByTwo = multiply.bind(null, 2);
const multiplyByTwoAndThree = multiplyByTwo.bind(null, 3);

console.log(multiplyByTwoAndThree(4)); // 24

// 通用柯里化函数
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, [...args, ...nextArgs]);
            };
        }
    };
}

const curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4)); // 24
```

### 7. 性能对比和选择

```javascript
// 性能测试
function testFunction(a, b) {
    return this.value + a + b;
}

const obj = { value: 10 };

// 测试不同调用方式的性能
const iterations = 1000000;

// 直接调用（最快）
console.time('direct call');
for (let i = 0; i < iterations; i++) {
    obj.method = testFunction;
    obj.method(1, 2);
    delete obj.method;
}
console.timeEnd('direct call');

// call调用
console.time('call');
for (let i = 0; i < iterations; i++) {
    testFunction.call(obj, 1, 2);
}
console.timeEnd('call');

// apply调用
console.time('apply');
for (let i = 0; i < iterations; i++) {
    testFunction.apply(obj, [1, 2]);
}
console.timeEnd('apply');

// bind调用
const boundFunction = testFunction.bind(obj);
console.time('bind');
for (let i = 0; i < iterations; i++) {
    boundFunction(1, 2);
}
console.timeEnd('bind');
```

### 8. 常见面试题

#### 8.1 this指向问题

```javascript
const obj = {
    name: 'Object',
    getName: function() {
        return this.name;
    }
};

// Q: 以下输出什么？
setTimeout(obj.getName, 100); // undefined (this丢失)
setTimeout(obj.getName.bind(obj), 100); // "Object"
setTimeout(() => obj.getName(), 100); // "Object"
```

#### 8.2 bind连续调用

```javascript
function test() {
    return this.value;
}

const obj1 = { value: 1 };
const obj2 = { value: 2 };

// Q: 输出什么？
const fn = test.bind(obj1).bind(obj2);
console.log(fn()); // 1 (bind只生效一次)
```

#### 8.3 构造函数bind

```javascript
function Person(name) {
    this.name = name;
}

const BoundPerson = Person.bind(null, 'Alice');

// Q: 以下输出什么？
const person = new BoundPerson();
console.log(person.name); // "Alice" (new调用忽略bind的context)
```

### 9. 最佳实践

#### 9.1 何时使用哪个方法

```javascript
// call: 明确知道参数个数，立即执行
obj.method.call(context, arg1, arg2);

// apply: 参数为数组，立即执行
obj.method.apply(context, argsArray);

// bind: 需要复用，延迟执行，事件处理
const boundMethod = obj.method.bind(context);

// 现代ES6+替代
// 扩展运算符替代apply
Math.max(...numbers);

// 箭头函数替代bind（在某些场景）
element.addEventListener('click', () => this.handleClick());
```

#### 9.2 避免常见陷阱

```javascript
// 陷阱1：对象方法解构
const { method } = obj;
method(); // this丢失

// 解决方案
const boundMethod = obj.method.bind(obj);
const arrowMethod = () => obj.method();

// 陷阱2：异步回调
setTimeout(obj.method, 100); // this丢失

// 解决方案
setTimeout(obj.method.bind(obj), 100);
setTimeout(() => obj.method(), 100);

// 陷阱3：数组遍历
array.forEach(obj.method); // this丢失

// 解决方案
array.forEach(obj.method, obj); // 传递thisArg
array.forEach(obj.method.bind(obj));
```

### 10. 与ES6+特性结合

```javascript
// 与箭头函数结合
class MyClass {
    constructor() {
        this.value = 42;

        // 箭头函数自动绑定this
        this.arrowMethod = () => {
            return this.value;
        };
    }

    normalMethod() {
        return this.value;
    }
}

const obj = new MyClass();
const { arrowMethod, normalMethod } = obj;

console.log(arrowMethod()); // 42
console.log(normalMethod()); // undefined

// 与Proxy结合
const autoBindProxy = (target) => {
    return new Proxy(target, {
        get(target, prop) {
            const value = target[prop];
            if (typeof value === 'function') {
                return value.bind(target);
            }
            return value;
        }
    });
};

const proxiedObj = autoBindProxy(obj);
const { normalMethod: boundNormal } = proxiedObj;
console.log(boundNormal()); // 42
```

### 总结

call、apply、bind是JavaScript函数式编程的核心工具，理解其实现原理有助于：

- **深度理解this机制**：掌握函数调用时this的绑定规则
- **解决常见问题**：正确处理回调函数、事件处理器中的this指向
- **提升代码质量**：写出更健壮、可维护的代码
- **面试准备**：这是前端面试的高频考点

在现代开发中，虽然箭头函数和其他ES6+特性提供了替代方案，但理解这些基础机制仍然至关重要，特别是在处理复杂的this绑定场景时。
