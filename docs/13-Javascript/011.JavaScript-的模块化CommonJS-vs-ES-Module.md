---
title: JavaScript 的模块化（CommonJS vs ES Module）
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: commonjs-vs-es-module
ref:
---

## 核心要点总结

**模块化系统对比**：CommonJS（同步加载、运行时解析）vs ES Module（异步加载、编译时静态分析）
**加载机制差异**：require()动态加载 vs import声明式导入的性能和Tree Shaking优势
**兼容性处理**：Node.js中两种模块系统的互操作和现代构建工具的转换策略

## 详细回答

### 1. 模块化发展历程

JavaScript模块化经历了从无到有的发展过程：

```javascript
// 早期：全局变量污染
var userModule = {
  name: 'John',
  getName: function() { return this.name; }
};

// IIFE模式：避免全局污染
var userModule = (function() {
  var name = 'John';
  return {
    getName: function() { return name; }
  };
})();

// AMD/CMD：异步模块定义
define(['dependency'], function(dep) {
  return { /* module */ };
});
```

### 2. CommonJS详解

**核心特征**：
- 同步加载，运行时解析
- 值拷贝（基本类型）或引用拷贝（对象类型）
- 动态加载，支持条件导入

```javascript
// math.js - CommonJS导出
const PI = 3.14159;
function add(a, b) {
  return a + b;
}

// 四种导出方式
module.exports = { PI, add };                    // 整体导出
module.exports.PI = PI;                          // 单个导出
exports.add = add;                               // exports简写
module.exports = add;                            // 默认导出

// main.js - CommonJS导入
const math = require('./math');                  // 整体导入
const { PI, add } = require('./math');          // 解构导入
const add = require('./math');                  // 默认导入

// 动态导入示例
if (condition) {
  const dynamicModule = require('./dynamic');    // 条件加载
}

// 运行时特性
console.log(require.cache);                     // 查看模块缓存
delete require.cache[require.resolve('./math')]; // 清除缓存
```

**执行机制**：
```javascript
// 模块包装函数（Node.js内部实现）
function(exports, require, module, __filename, __dirname) {
  // 你的模块代码在这里
  const add = (a, b) => a + b;
  module.exports = { add };
}
```

### 3. ES Module详解

**核心特征**：
- 异步加载，编译时静态分析
- 值引用绑定（live binding）
- 声明式导入，支持Tree Shaking

```javascript
// math.mjs - ES Module导出
export const PI = 3.14159;                      // 命名导出
export function add(a, b) { return a + b; }     // 函数导出
export default function multiply(a, b) {        // 默认导出
  return a * b;
}

// 批量导出
const subtract = (a, b) => a - b;
const divide = (a, b) => a / b;
export { subtract, divide };

// 重命名导出
export { add as sum, PI as pi };

// main.mjs - ES Module导入
import multiply from './math.mjs';               // 默认导入
import { PI, add } from './math.mjs';           // 命名导入
import * as math from './math.mjs';             // 命名空间导入
import { add as sum } from './math.mjs';        // 重命名导入

// 动态导入（ES2020）
if (condition) {
  const module = await import('./dynamic.mjs');  // 动态导入返回Promise
}

// 混合导入
import multiply, { PI, add } from './math.mjs';
```

### 4. 核心差异对比

| 特性 | CommonJS | ES Module |
|------|----------|-----------|
| **加载时机** | 运行时同步加载 | 编译时静态分析 |
| **导入方式** | require()函数调用 | import声明语句 |
| **导出方式** | module.exports赋值 | export声明 |
| **值绑定** | 值拷贝/引用拷贝 | 实时绑定(live binding) |
| **Tree Shaking** | 不支持 | 支持 |
| **循环依赖** | 可能出现不完整对象 | 更好的处理机制 |
| **顶层await** | 不支持 | 支持 |

**值绑定差异示例**：
```javascript
// CommonJS - 值拷贝
// counter.js
let count = 0;
module.exports = {
  count,
  increment() { count++; }
};

// main.js
const { count, increment } = require('./counter');
console.log(count); // 0
increment();
console.log(count); // 仍然是0（值拷贝）

// ES Module - 实时绑定
// counter.mjs
export let count = 0;
export function increment() { count++; }

// main.mjs
import { count, increment } from './counter.mjs';
console.log(count); // 0
increment();
console.log(count); // 1（实时绑定）
```

### 5. 循环依赖处理

```javascript
// CommonJS循环依赖
// a.js
const b = require('./b');
module.exports = { name: 'A', b };

// b.js
const a = require('./a');  // 此时a可能是{}空对象
module.exports = { name: 'B', a };

// ES Module循环依赖
// a.mjs
import { b } from './b.mjs';
export const a = { name: 'A', b };

// b.mjs
import { a } from './a.mjs';  // 更好的处理机制
export const b = { name: 'B', a };
```

### 6. 现代开发中的应用

**Node.js中的互操作**：
```javascript
// package.json配置
{
  "type": "module",              // 设置为ES Module
  "exports": {
    "import": "./esm/index.mjs", // ES Module入口
    "require": "./cjs/index.js"  // CommonJS入口
  }
}

// ESM中使用CommonJS
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const commonjsModule = require('./commonjs-module');

// 使用import()动态导入CommonJS
const commonjsModule = await import('./commonjs-module');
```

**构建工具处理**：
```javascript
// webpack配置
module.exports = {
  resolve: {
    extensions: ['.mjs', '.js'],
  },
  module: {
    rules: [
      {
        test: /\.mjs$/,
        type: 'javascript/esm',
      }
    ]
  }
};

// Babel转换
// .babelrc
{
  "presets": [
    ["@babel/preset-env", {
      "modules": "auto"  // 自动检测模块系统
    }]
  ]
}
```

### 7. 性能和优化考虑

**Tree Shaking优势**：
```javascript
// utils.mjs
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export const multiply = (a, b) => a * b;  // 未使用，会被Tree Shaking移除

// main.mjs
import { add } from './utils.mjs';  // 只导入需要的函数
console.log(add(1, 2));
```

**代码分割**：
```javascript
// 动态导入实现代码分割
async function loadModule() {
  const { heavyFunction } = await import('./heavy-module.mjs');
  return heavyFunction;
}

// 条件加载
if (userPreference === 'advanced') {
  const advancedFeatures = await import('./advanced.mjs');
  advancedFeatures.init();
}
```

### 8. 最佳实践

1. **新项目优先使用ES Module**：更好的静态分析和优化
2. **混合项目渐进迁移**：逐步替换CommonJS为ES Module
3. **构建工具配置**：正确配置模块解析规则
4. **类型定义**：使用TypeScript提供更好的模块类型支持

```javascript
// TypeScript模块声明
declare module '*.mjs' {
  const content: any;
  export default content;
}

// 模块类型导出
export type { UserConfig } from './types.mjs';
export { createUser } from './user.mjs';
```

通过理解这两种模块系统的差异，开发者可以根据项目需求选择合适的模块化方案，并在必要时进行平滑迁移。
