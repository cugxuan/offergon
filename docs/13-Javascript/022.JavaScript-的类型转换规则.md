---
title: JavaScript 的类型转换规则
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-type-conversion-rules
ref:
---

## 核心要点

JavaScript 类型转换分为**显式转换**（主动调用转换函数）和**隐式转换**（运算符触发）。转换规则包括：**转字符串**（+运算符/String()）、**转数字**（Number()/parseInt()）、**转布尔**（Boolean()/!!）。核心陷阱：对象转换优先调用 `valueOf()` 再调用 `toString()`，`[] == false` 为 true 但 `[] === false` 为 false，`{} + []` 在不同场景结果不同。

---

## 详细解答

JavaScript 是弱类型语言，在运算和比较时会自动进行类型转换，这是面试高频考点。理解转换规则能避免 90% 的类型相关 bug。

### 一、转换的三种基本类型

JavaScript 类型转换主要针对三种目标类型：String、Number、Boolean。

#### 1. 转换为字符串（ToPrimitive → String）

**显式转换：**
```javascript
String(123)           // "123"
String(true)          // "true"
String(null)          // "null"
String(undefined)     // "undefined"
String([1, 2, 3])     // "1,2,3"
String({a: 1})        // "[object Object]"

// 或使用 toString()
(123).toString()      // "123"
[1, 2, 3].toString()  // "1,2,3"
```

**隐式转换（触发场景）：**
```javascript
// 1. 字符串拼接（+ 运算符）
"hello" + 123         // "hello123"
"5" + 3               // "53"

// 2. 模板字符串
`The number is ${123}` // "The number is 123"

// 3. alert/console.log 等（自动调用 toString）
alert([1, 2, 3])      // 显示 "1,2,3"
```

**转换规则：**
| 原始类型 | 转换结果 |
|---------|---------|
| 数字 | 对应字符串（如 `123` → `"123"`） |
| 布尔值 | `"true"` 或 `"false"` |
| null | `"null"` |
| undefined | `"undefined"` |
| Symbol | 报错（不能隐式转换）|
| 对象 | 先调用 `toString()`，如果返回原始值则结束，否则调用 `valueOf()`，再返回原始值 |

#### 2. 转换为数字（ToPrimitive → Number）

**显式转换：**
```javascript
Number("123")         // 123
Number("12.5")        // 12.5
Number("123abc")      // NaN ⚠️
Number("")            // 0 ⚠️ 空字符串转为0
Number(" ")           // 0 ⚠️ 空白字符串转为0
Number(true)          // 1
Number(false)         // 0
Number(null)          // 0 ⚠️
Number(undefined)     // NaN ⚠️
Number([])            // 0 ⚠️ 空数组转为0
Number([5])           // 5 ⚠️ 单元素数组转为该元素的数字值
Number([1, 2])        // NaN
Number({})            // NaN

// parseInt/parseFloat（解析到非数字为止）
parseInt("123abc")    // 123 ⚠️ 与 Number() 不同
parseInt("12.5")      // 12
parseFloat("12.5")    // 12.5
```

**隐式转换（触发场景）：**
```javascript
// 1. 算术运算符（除了 + 可能触发字符串拼接）
"5" - 3               // 2
"5" * 2               // 10
"10" / 2              // 5
"6" % 4               // 2

// 2. 比较运算符
"5" > 3               // true
"10" == 10            // true

// 3. 一元 + 操作符
+"123"                // 123
+[]                   // 0
+[1]                  // 1

// 4. 位运算符
"5" | 0               // 5（常用于取整）
```

**转换规则：**
| 原始类型 | 转换结果 |
|---------|---------|
| 字符串 | 解析为数字，无法解析返回 NaN（空字符串为 0）|
| 布尔值 | `true` → 1，`false` → 0 |
| null | 0 |
| undefined | NaN |
| Symbol | 报错 |
| 对象 | 先调用 `valueOf()`，如果返回原始值则转数字，否则调用 `toString()` 再转数字 |

#### 3. 转换为布尔值（ToBoolean）

**显式转换：**
```javascript
Boolean(0)            // false
Boolean(1)            // true
Boolean("")           // false
Boolean("hello")      // true
Boolean(null)         // false
Boolean(undefined)    // false
Boolean(NaN)          // false
Boolean([])           // true ⚠️ 空数组是 truthy
Boolean({})           // true ⚠️ 空对象是 truthy

// 双重取反（常用）
!!0                   // false
!!""                  // false
!![]                  // true
```

**隐式转换（触发场景）：**
```javascript
// 1. if/while/for 条件判断
if ("hello") { /* 执行 */ }
while (obj) { /* 执行 */ }

// 2. 三元运算符
value ? "yes" : "no"

// 3. 逻辑运算符（&& || !）
"hello" && 123        // 123（返回最后一个 truthy 值）
0 || "default"        // "default"
!"hello"              // false
```

**转换规则（只有 8 个 falsy 值）：**
| 值 | 转换结果 |
|---------|---------|
| `false` | false |
| `0` / `-0` / `0n` | false |
| `""` / `''` / ``` `` ``` | false |
| `null` | false |
| `undefined` | false |
| `NaN` | false |
| **其他所有值（包括 `[]`、`{}`）** | **true** |

---

### 二、对象类型转换（ToPrimitive）

对象转换为原始类型时，遵循 **ToPrimitive** 算法：

**转换流程：**
```javascript
// 转换为数字时（hint = "number"）
obj.valueOf() → 如果返回原始值，结束
obj.toString() → 如果返回原始值，结束
报错 TypeError

// 转换为字符串时（hint = "string"）
obj.toString() → 如果返回原始值，结束
obj.valueOf() → 如果返回原始值，结束
报错 TypeError
```

**实例演示：**
```javascript
const obj = {
  valueOf() {
    console.log("valueOf called")
    return 42
  },
  toString() {
    console.log("toString called")
    return "hello"
  }
}

// 转数字（优先 valueOf）
Number(obj)
// 输出: valueOf called
// 返回: 42

// 转字符串（优先 toString）
String(obj)
// 输出: toString called
// 返回: "hello"

// + 运算符（优先 valueOf）
obj + 1
// 输出: valueOf called
// 返回: 43
```

**常见对象转换结果：**
```javascript
// 数组
[1, 2, 3].toString()  // "1,2,3"
[1, 2, 3].valueOf()   // [1, 2, 3]（返回自身）
Number([])            // 0（[] → "" → 0）
Number([5])           // 5（[5] → "5" → 5）

// 对象
({}).toString()       // "[object Object]"
({}).valueOf()        // {}（返回自身）
Number({})            // NaN（{} → "[object Object]" → NaN）

// Date 特殊情况（优先 toString）
new Date() + 1        // "Sat Jan... 1"（字符串拼接）
```

**Symbol.toPrimitive（ES6 高优先级）：**
```javascript
const obj = {
  [Symbol.toPrimitive](hint) {
    if (hint === "number") return 42
    if (hint === "string") return "hello"
    return "default"
  }
}

Number(obj)           // 42
String(obj)           // "hello"
obj + ""              // "default"
```

---

### 三、经典陷阱与常见面试题

#### 陷阱 1：[] == false 但 [] 是 truthy

```javascript
[] == false           // true ⚠️
// 过程：[] → "" → 0, false → 0, 0 == 0 为 true

if ([]) {
  console.log("执行")  // 会执行！因为 [] 转布尔为 true
}
```

#### 陷阱 2：{} + [] 与 [] + {}

```javascript
// 浏览器控制台（{} 被视为代码块）
{} + []               // 0 ⚠️ 相当于 +[]
[] + {}               // "[object Object]"

// 在表达式中（{} 视为对象）
({} + [])             // "[object Object]"
```

#### 陷阱 3：比较运算的非对称性

```javascript
"0" == 0              // true（字符串转数字）
0 == []               // true（[] → "" → 0）
"0" == []             // false ⚠️（都转数字："0" → 0, [] → 0，但规则是转字符串比较）

// 实际规则：
"0" == []
// "0" vs [].toString() → "0" vs "" → false
```

#### 陷阱 4：null 和 undefined 的特殊性

```javascript
null == undefined     // true ⚠️（ES 规范特殊规定）
null === undefined    // false

// 但它们不等于其他 falsy 值
null == 0             // false
undefined == 0        // false
null == false         // false
```

#### 陷阱 5：NaN 的独特性

```javascript
NaN == NaN            // false ⚠️
NaN === NaN           // false

// 正确判断 NaN
Number.isNaN(NaN)     // true
Object.is(NaN, NaN)   // true
```

#### 经典面试题

**题 1：实现 a == 1 && a == 2 && a == 3**
```javascript
// 方法1：利用对象转换
const a = {
  value: 1,
  valueOf() {
    return this.value++
  }
}
console.log(a == 1 && a == 2 && a == 3) // true

// 方法2：利用数组（toString 调用）
const a = [1, 2, 3]
a.toString = a.shift
console.log(a == 1 && a == 2 && a == 3) // true
```

**题 2：以下代码输出什么？**
```javascript
console.log([] + [])          // ""（两个空字符串拼接）
console.log([] + {})          // "[object Object]"
console.log({} + [])          // 控制台: 0 / 表达式: "[object Object]"
console.log(true + false)     // 1（1 + 0）
console.log("5" + 3 + 2)      // "532"（左到右，先字符串拼接）
console.log(5 + 3 + "2")      // "82"（先算术，后拼接）
```

---

### 四、最佳实践与避坑指南

#### 1. 优先使用显式转换
```javascript
// ❌ 不推荐（依赖隐式转换）
if (value) { }
const num = +"123"

// ✅ 推荐（明确意图）
if (Boolean(value)) { }
const num = Number("123")
```

#### 2. 使用严格相等（===）
```javascript
// ❌ 不推荐
"0" == 0              // true（可能导致逻辑错误）

// ✅ 推荐
"0" === 0             // false（类型不同直接返回 false）
```

#### 3. 数字转换首选 Number()
```javascript
// ❌ 不推荐（容易出错）
parseInt("123abc")    // 123（可能隐藏错误）

// ✅ 推荐（严格检查）
Number("123abc")      // NaN（便于错误处理）
if (Number.isNaN(result)) {
  // 处理无效输入
}
```

#### 4. 避免对象参与运算
```javascript
// ❌ 不推荐
const result = obj + 1

// ✅ 推荐
const result = Number(obj.value) + 1
```

#### 5. 使用现代 API
```javascript
// ❌ 老方法
isNaN(value)          // 会先转换再判断
value == null         // 同时匹配 null 和 undefined

// ✅ ES6+ 方法
Number.isNaN(value)   // 严格判断
value === null || value === undefined
// 或使用 ?? 运算符
value ?? defaultValue
```

---

## 转换规则速查表

| 转换目标 | 触发方式 | null | undefined | true/false | 数字 | 字符串 | [] | {} |
|---------|---------|------|-----------|-----------|------|--------|----|----|
| String | String() | "null" | "undefined" | "true"/"false" | "123" | 原值 | "1,2" | "[object Object]" |
| Number | Number() | 0 | NaN | 1/0 | 原值 | 解析结果 | 0 | NaN |
| Boolean | Boolean() | false | false | 原值 | 0→false<br>其他→true | ""→false<br>其他→true | true | true |

**记忆口诀：**
- **转字符串**：啥都能转，对象成 "[object Object]"
- **转数字**：null 是 0，undefined 是 NaN，空串是 0，对象基本 NaN
- **转布尔**：8 个 falsy（0、空串、null、undefined、NaN、false），其余全 truthy

掌握这些规则后，90% 的类型转换问题都能迎刃而解！
