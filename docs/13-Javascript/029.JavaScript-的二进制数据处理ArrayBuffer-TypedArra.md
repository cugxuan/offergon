---
title: JavaScript 的二进制数据处理（ArrayBuffer、TypedArray）
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-binary-data-arraybuffer-typedarray
ref:
---

## 核心要点

JavaScript 二进制数据处理基于三大核心 API：**ArrayBuffer**（固定长度原始二进制缓冲区）、**TypedArray**（类型化数组视图，如 Uint8Array、Float32Array）、**DataView**（灵活的多类型视图）。典型应用场景：**文件操作**（File API）、**网络通信**（WebSocket 二进制）、**Canvas 图像处理**、**音视频编解码**、**WebAssembly 内存交互**。关键特性：**零拷贝视图**、**字节序控制**、**高性能**、**Transferable Objects 支持**。

---

## 详细解答

### 一、为什么需要二进制数据处理

JavaScript 最初是为 Web 设计的脚本语言，主要处理文本数据（字符串）。但随着 Web 应用的发展，出现了大量二进制数据处理需求：

**典型场景：**
- 📁 **文件操作**：读取/上传图片、视频、PDF 等二进制文件
- 🌐 **网络通信**：WebSocket 发送/接收二进制数据
- 🖼️ **图像处理**：Canvas 像素操作、图像滤镜
- 🎵 **音视频**：Web Audio API、视频编解码
- 🔐 **加密**：Crypto API 处理密钥和加密数据
- ⚙️ **WebAssembly**：与 WASM 模块共享内存

**传统字符串方式的问题：**
```javascript
// 不良实践：用字符串处理二进制数据
const binaryString = '\x89PNG\r\n\x1a\n'; // 容易出错，性能差
```

**二进制 API 的优势：**
- ✅ 性能高（直接操作内存，无需编码转换）
- ✅ 类型安全（强制类型，避免数据损坏）
- ✅ 内存高效（零拷贝视图）
- ✅ 与底层 API 兼容（WebGL、WebAssembly、File API）

### 二、ArrayBuffer（数组缓冲区）

#### 2.1 什么是 ArrayBuffer

**ArrayBuffer** 是固定长度的**原始二进制数据缓冲区**。它本身无法直接读写，必须通过"视图"（TypedArray 或 DataView）访问。

**核心特点：**
- 固定长度（创建后不可改变大小）
- 连续内存块
- 无法直接访问内容
- 可以在 Web Workers 间转移（Transferable）

```javascript
// 创建 16 字节的 ArrayBuffer
const buffer = new ArrayBuffer(16);
console.log(buffer.byteLength); // 16

// 无法直接读写
console.log(buffer[0]); // undefined - 必须通过视图访问
```

#### 2.2 创建和基本操作

```javascript
// 创建 ArrayBuffer
const buffer = new ArrayBuffer(8); // 8 字节

// 属性
console.log(buffer.byteLength); // 8

// 切片（创建副本）
const slice = buffer.slice(0, 4); // 复制前 4 字节
console.log(slice.byteLength); // 4

// 判断是否是 ArrayBuffer
console.log(ArrayBuffer.isView(buffer)); // false - ArrayBuffer 本身不是视图
```

### 三、TypedArray（类型化数组）

#### 3.1 什么是 TypedArray

**TypedArray** 是一组类型化数组视图，用于读写 ArrayBuffer 中的数据。它不是构造函数，而是 9 种具体类型的统称。

**所有 TypedArray 类型：**

| 类型 | 字节数 | 描述 | 取值范围 |
|------|--------|------|---------|
| `Int8Array` | 1 | 8 位有符号整数 | -128 ~ 127 |
| `Uint8Array` | 1 | 8 位无符号整数 | 0 ~ 255 |
| `Uint8ClampedArray` | 1 | 8 位无符号整数（溢出截断） | 0 ~ 255 |
| `Int16Array` | 2 | 16 位有符号整数 | -32768 ~ 32767 |
| `Uint16Array` | 2 | 16 位无符号整数 | 0 ~ 65535 |
| `Int32Array` | 4 | 32 位有符号整数 | -2³¹ ~ 2³¹-1 |
| `Uint32Array` | 4 | 32 位无符号整数 | 0 ~ 2³²-1 |
| `Float32Array` | 4 | 32 位浮点数 | IEEE 754 单精度 |
| `Float64Array` | 8 | 64 位浮点数 | IEEE 754 双精度 |
| `BigInt64Array` | 8 | 64 位有符号整数（BigInt） | -2⁶³ ~ 2⁶³-1 |
| `BigUint64Array` | 8 | 64 位无符号整数（BigInt） | 0 ~ 2⁶⁴-1 |

#### 3.2 创建 TypedArray

**方式一：从 ArrayBuffer 创建（视图）**

```javascript
const buffer = new ArrayBuffer(16);

// 创建 Int32Array 视图（4 字节整数）
const int32View = new Int32Array(buffer);
console.log(int32View.length); // 4（16 字节 / 4 字节）

// 创建 Uint8Array 视图（1 字节整数）
const uint8View = new Uint8Array(buffer);
console.log(uint8View.length); // 16（16 字节 / 1 字节）

// 同一个 buffer 可以有多个视图
int32View[0] = 305419896; // 0x12345678
console.log(uint8View[0]); // 120（0x78，小端序）
console.log(uint8View[1]); // 86（0x56）
```

**方式二：指定偏移和长度**

```javascript
const buffer = new ArrayBuffer(16);

// 从字节 4 开始，长度为 8 字节的视图
const view = new Uint8Array(buffer, 4, 8);
console.log(view.byteOffset); // 4
console.log(view.byteLength); // 8
console.log(view.length); // 8
```

**方式三：直接创建（自动分配 ArrayBuffer）**

```javascript
// 创建长度为 8 的 Uint8Array
const uint8 = new Uint8Array(8);
console.log(uint8.buffer); // ArrayBuffer { byteLength: 8 }
console.log(uint8.byteLength); // 8

// 从数组创建
const arr = new Uint8Array([1, 2, 3, 4]);
console.log(arr); // Uint8Array(4) [1, 2, 3, 4]

// 从另一个 TypedArray 创建（复制数据）
const copy = new Uint8Array(arr);
copy[0] = 100;
console.log(arr[0]); // 1（原数组不变）
```

#### 3.3 TypedArray 操作

```javascript
const arr = new Uint8Array([10, 20, 30, 40, 50]);

// 1. 索引访问
console.log(arr[2]); // 30
arr[2] = 35;

// 2. 数组方法（类似普通数组）
arr.forEach((val, idx) => console.log(idx, val));
const doubled = arr.map(x => x * 2);
const filtered = arr.filter(x => x > 25);
const sum = arr.reduce((acc, x) => acc + x, 0);

// 3. 切片（创建新 TypedArray）
const slice = arr.slice(1, 4); // Uint8Array(3) [20, 30, 40]

// 4. 子数组（共享 buffer）
const subarray = arr.subarray(1, 4);
subarray[0] = 99;
console.log(arr[1]); // 99（共享底层 buffer）

// 5. 填充
arr.fill(0); // 全部填充为 0
arr.fill(255, 2, 4); // 索引 2-4 填充 255

// 6. 复制
const target = new Uint8Array(5);
target.set([1, 2, 3]); // 从索引 0 开始复制
target.set([4, 5], 3); // 从索引 3 开始复制
console.log(target); // Uint8Array(5) [1, 2, 3, 4, 5]

// 7. 反转
arr.reverse();

// 8. 排序
arr.sort((a, b) => a - b);
```

#### 3.4 Uint8ClampedArray 的特殊行为

```javascript
// 普通 Uint8Array：溢出回绕
const normal = new Uint8Array(2);
normal[0] = 256; // 256 % 256 = 0
normal[1] = -1;  // 256 + (-1) = 255
console.log(normal); // Uint8Array(2) [0, 255]

// Uint8ClampedArray：溢出截断
const clamped = new Uint8ClampedArray(2);
clamped[0] = 256; // 截断为 255
clamped[1] = -1;  // 截断为 0
console.log(clamped); // Uint8ClampedArray(2) [255, 0]

// Canvas ImageData 使用 Uint8ClampedArray
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
const imageData = ctx.createImageData(100, 100);
console.log(imageData.data); // Uint8ClampedArray(40000)
```

### 四、DataView（数据视图）

#### 4.1 什么是 DataView

**DataView** 提供更灵活的视图，支持：
- 读写任意位置的任意类型数据
- 控制字节序（大端/小端）
- 不对齐访问

**vs TypedArray：**
- TypedArray：固定类型、自动对齐、操作简单
- DataView：多类型混合、可控字节序、操作灵活

```javascript
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);

// 在同一个 buffer 中混合存储不同类型
view.setInt8(0, 127);        // 偏移 0：1 字节整数
view.setUint16(1, 65535);    // 偏移 1：2 字节整数
view.setFloat32(3, 3.14);    // 偏移 3：4 字节浮点数

// 读取数据
console.log(view.getInt8(0));      // 127
console.log(view.getUint16(1));    // 65535
console.log(view.getFloat32(3));   // 3.140000104904175
```

#### 4.2 DataView 方法

**读取方法：**
```javascript
const buffer = new ArrayBuffer(8);
const view = new DataView(buffer);

// 设置数据
view.setUint32(0, 0x12345678);

// 读取（默认大端序）
console.log(view.getUint32(0).toString(16)); // 12345678

// 读取（小端序）
console.log(view.getUint32(0, true).toString(16)); // 78563412
```

**所有读写方法：**
| 方法 | 字节数 | 说明 |
|------|--------|------|
| `getInt8() / setInt8()` | 1 | 有符号 8 位整数 |
| `getUint8() / setUint8()` | 1 | 无符号 8 位整数 |
| `getInt16() / setInt16()` | 2 | 有符号 16 位整数 |
| `getUint16() / setUint16()` | 2 | 无符号 16 位整数 |
| `getInt32() / setInt32()` | 4 | 有符号 32 位整数 |
| `getUint32() / setUint32()` | 4 | 无符号 32 位整数 |
| `getFloat32() / setFloat32()` | 4 | 32 位浮点数 |
| `getFloat64() / setFloat64()` | 8 | 64 位浮点数 |
| `getBigInt64() / setBigInt64()` | 8 | 有符号 64 位整数（BigInt） |
| `getBigUint64() / setBigUint64()` | 8 | 无符号 64 位整数（BigInt） |

#### 4.3 字节序（Endianness）

**大端序（Big-Endian）：** 高位字节存储在低地址
**小端序（Little-Endian）：** 低位字节存储在低地址

```javascript
const buffer = new ArrayBuffer(4);
const view = new DataView(buffer);

// 存储 0x12345678
view.setUint32(0, 0x12345678, false); // 大端序

const uint8 = new Uint8Array(buffer);
console.log([...uint8].map(b => b.toString(16)));
// ['12', '34', '56', '78'] - 大端序

// 存储为小端序
view.setUint32(0, 0x12345678, true);
console.log([...uint8].map(b => b.toString(16)));
// ['78', '56', '34', '12'] - 小端序

// 检测系统字节序
function isLittleEndian() {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setUint16(0, 256, true);
  return new Uint16Array(buffer)[0] === 256;
}
console.log('系统是小端序:', isLittleEndian()); // 大多数现代系统：true
```

### 五、实战案例

#### 5.1 案例一：读取文件二进制数据

```javascript
// 读取文件为 ArrayBuffer
async function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

// 分析 PNG 文件头
async function parsePNG(file) {
  const buffer = await readFileAsArrayBuffer(file);
  const view = new DataView(buffer);

  // PNG 文件签名：89 50 4E 47 0D 0A 1A 0A
  const signature = [
    view.getUint8(0).toString(16),
    view.getUint8(1).toString(16),
    view.getUint8(2).toString(16),
    view.getUint8(3).toString(16)
  ].join(' ');

  console.log('文件签名:', signature); // 89 50 4e 47

  // 读取第一个 chunk（IHDR）
  const chunkLength = view.getUint32(8); // 大端序
  const chunkType = String.fromCharCode(
    view.getUint8(12),
    view.getUint8(13),
    view.getUint8(14),
    view.getUint8(15)
  );

  console.log('第一个 chunk:', chunkType); // 'IHDR'
  console.log('chunk 长度:', chunkLength);

  // 读取图像宽高
  const width = view.getUint32(16);
  const height = view.getUint32(20);
  console.log('图像尺寸:', `${width}x${height}`);
}

// 使用
document.getElementById('file-input').addEventListener('change', e => {
  const file = e.target.files[0];
  if (file.type === 'image/png') {
    parsePNG(file);
  }
});
```

#### 5.2 案例二：Canvas 图像处理

```javascript
// 图像灰度化
function grayscaleImage(canvas) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data; // Uint8ClampedArray

  // RGBA 格式：每 4 字节表示一个像素
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];

    // 灰度公式
    const gray = 0.299 * r + 0.587 * g + 0.114 * b;

    data[i] = data[i + 1] = data[i + 2] = gray;
    // data[i + 3] 是 alpha 通道，不修改
  }

  ctx.putImageData(imageData, 0, 0);
}

// 图像反色
function invertImage(canvas) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = 255 - data[i];       // R
    data[i + 1] = 255 - data[i + 1]; // G
    data[i + 2] = 255 - data[i + 2]; // B
  }

  ctx.putImageData(imageData, 0, 0);
}
```

#### 5.3 案例三：WebSocket 二进制通信

```javascript
// 发送二进制数据
const socket = new WebSocket('wss://example.com');
socket.binaryType = 'arraybuffer'; // 设置接收类型

// 发送 Float32Array
socket.addEventListener('open', () => {
  const data = new Float32Array([1.5, 2.7, 3.9]);
  socket.send(data.buffer);
});

// 接收二进制数据
socket.addEventListener('message', event => {
  if (event.data instanceof ArrayBuffer) {
    const view = new DataView(event.data);

    // 协议示例：前 4 字节是消息类型，后续是数据
    const messageType = view.getUint32(0);

    switch (messageType) {
      case 1: // 文本消息
        const text = new TextDecoder().decode(event.data.slice(4));
        console.log('文本:', text);
        break;
      case 2: // 浮点数组
        const floats = new Float32Array(event.data, 4);
        console.log('浮点数组:', floats);
        break;
    }
  }
});
```

#### 5.4 案例四：自定义二进制协议

```javascript
// 定义协议：消息头（8 字节）+ 数据
// [0-3]: 消息类型（Uint32）
// [4-7]: 数据长度（Uint32）
// [8-n]: 实际数据

class BinaryProtocol {
  static HEADER_SIZE = 8;

  // 编码消息
  static encode(type, data) {
    const dataBytes = new TextEncoder().encode(data);
    const buffer = new ArrayBuffer(this.HEADER_SIZE + dataBytes.length);
    const view = new DataView(buffer);

    // 写入头部
    view.setUint32(0, type);
    view.setUint32(4, dataBytes.length);

    // 写入数据
    const uint8 = new Uint8Array(buffer);
    uint8.set(dataBytes, this.HEADER_SIZE);

    return buffer;
  }

  // 解码消息
  static decode(buffer) {
    const view = new DataView(buffer);

    // 读取头部
    const type = view.getUint32(0);
    const length = view.getUint32(4);

    // 读取数据
    const dataBytes = new Uint8Array(buffer, this.HEADER_SIZE, length);
    const data = new TextDecoder().decode(dataBytes);

    return { type, data };
  }
}

// 使用
const encoded = BinaryProtocol.encode(1, 'Hello World');
console.log('编码后:', new Uint8Array(encoded));

const decoded = BinaryProtocol.decode(encoded);
console.log('解码后:', decoded); // { type: 1, data: 'Hello World' }
```

#### 5.5 案例五：高性能数据传输（Transferable Objects）

```javascript
// 主线程
const worker = new Worker('worker.js');

// 创建大数组
const buffer = new ArrayBuffer(1024 * 1024 * 100); // 100MB
const data = new Uint8Array(buffer);
data[0] = 255;

console.log('传输前 buffer 大小:', buffer.byteLength); // 104857600

// 转移所有权（零拷贝）
worker.postMessage({ buffer }, [buffer]);

console.log('传输后 buffer 大小:', buffer.byteLength); // 0（已失去所有权）

// Worker 线程（worker.js）
self.addEventListener('message', e => {
  const buffer = e.data.buffer;
  console.log('Worker 收到 buffer:', buffer.byteLength); // 104857600

  const data = new Uint8Array(buffer);
  console.log('第一个字节:', data[0]); // 255

  // 处理数据...
  for (let i = 0; i < data.length; i++) {
    data[i] = (data[i] + 1) % 256;
  }

  // 转移回主线程
  self.postMessage({ buffer }, [buffer]);
});
```

### 六、文本编解码

#### 6.1 TextEncoder / TextDecoder

```javascript
// 字符串 → Uint8Array
const encoder = new TextEncoder();
const encoded = encoder.encode('Hello 世界');
console.log(encoded); // Uint8Array(12) [72, 101, 108, 108, 111, 32, 228, 184, 150, 231, 149, 140]

// Uint8Array → 字符串
const decoder = new TextDecoder('utf-8');
const decoded = decoder.decode(encoded);
console.log(decoded); // 'Hello 世界'

// 分块解码（流式处理）
const decoder2 = new TextDecoder();
const chunk1 = new Uint8Array([72, 101]); // 'He'
const chunk2 = new Uint8Array([108, 108, 111]); // 'llo'

console.log(decoder2.decode(chunk1, { stream: true })); // 'He'
console.log(decoder2.decode(chunk2)); // 'llo'

// 不同编码
const decoder3 = new TextDecoder('gbk');
// 注意：浏览器对某些编码支持有限
```

#### 6.2 Base64 编解码

```javascript
// ArrayBuffer → Base64
function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// Base64 → ArrayBuffer
function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const buffer = new ArrayBuffer(binary.length);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}

// 使用
const buffer = new Uint8Array([72, 101, 108, 108, 111]).buffer;
const base64 = arrayBufferToBase64(buffer);
console.log(base64); // 'SGVsbG8='

const restored = base64ToArrayBuffer(base64);
console.log(new Uint8Array(restored)); // Uint8Array(5) [72, 101, 108, 108, 111]
```

### 七、性能优化

#### 7.1 TypedArray vs 普通数组

```javascript
// 性能对比
const SIZE = 1000000;

// 普通数组
console.time('普通数组');
const normalArray = new Array(SIZE);
for (let i = 0; i < SIZE; i++) {
  normalArray[i] = i * 2;
}
console.timeEnd('普通数组'); // ~15ms

// TypedArray
console.time('TypedArray');
const typedArray = new Uint32Array(SIZE);
for (let i = 0; i < SIZE; i++) {
  typedArray[i] = i * 2;
}
console.timeEnd('TypedArray'); // ~5ms（快 3 倍）
```

#### 7.2 零拷贝视图

```javascript
// 不好：创建新数组（复制数据）
const buffer = new ArrayBuffer(1000000);
const copy = new Uint8Array(buffer).slice(); // 复制

// 好：使用 subarray（共享 buffer）
const view = new Uint8Array(buffer).subarray(0, 100); // 零拷贝
```

#### 7.3 批量操作

```javascript
// 不好：逐个赋值
const arr = new Uint8Array(1000);
for (let i = 0; i < 1000; i++) {
  arr[i] = i % 256;
}

// 好：批量操作
const arr2 = new Uint8Array(1000);
const source = new Uint8Array(Array.from({ length: 1000 }, (_, i) => i % 256));
arr2.set(source); // 批量复制，更快
```

### 八、注意事项与常见陷阱

#### 8.1 TypedArray 溢出

```javascript
const arr = new Uint8Array(2);
arr[0] = 256; // 溢出：256 % 256 = 0
arr[1] = -1;  // 负数：256 + (-1) = 255
console.log(arr); // Uint8Array(2) [0, 255]
```

#### 8.2 字节对齐

```javascript
// Int32Array 要求 4 字节对齐
const buffer = new ArrayBuffer(16);

// 正确：偏移量是 4 的倍数
const aligned = new Int32Array(buffer, 4, 2); // OK

// 错误：偏移量不对齐
try {
  const unaligned = new Int32Array(buffer, 1, 2); // RangeError
} catch (e) {
  console.error(e.message); // 偏移量必须是 4 的倍数
}
```

#### 8.3 浏览器兼容性

```javascript
// 检测支持
if (typeof ArrayBuffer !== 'undefined') {
  console.log('支持 ArrayBuffer');
}

if (typeof BigInt64Array !== 'undefined') {
  console.log('支持 BigInt TypedArray');
}
```

### 九、面试高频问题

**Q1: ArrayBuffer 和 TypedArray 的关系？**

A: ArrayBuffer 是原始二进制缓冲区，无法直接访问。TypedArray 是 ArrayBuffer 的"视图"，提供类型化的访问接口。可以在同一个 ArrayBuffer 上创建多个不同类型的视图：

```javascript
const buffer = new ArrayBuffer(8);
const int32View = new Int32Array(buffer); // 2 个元素
const uint8View = new Uint8Array(buffer); // 8 个元素
```

**Q2: TypedArray 和普通数组的区别？**

| 特性 | TypedArray | 普通数组 |
|------|-----------|---------|
| 类型 | 固定类型 | 任意类型 |
| 长度 | 固定（创建后不可变） | 动态 |
| 性能 | 更快（直接内存访问） | 较慢 |
| 方法 | 部分数组方法 | 全部数组方法 |
| 底层存储 | ArrayBuffer | JavaScript 对象 |

**Q3: 何时使用 DataView 而不是 TypedArray？**

A: 需要以下功能时使用 DataView：
- 在同一 buffer 中混合存储多种类型
- 控制字节序（大端/小端）
- 不对齐的内存访问
- 解析复杂二进制协议

```javascript
// 示例：解析混合类型协议
const buffer = new ArrayBuffer(10);
const view = new DataView(buffer);
view.setUint16(0, 300);      // 偏移 0：Uint16
view.setFloat32(2, 3.14);    // 偏移 2：Float32
view.setInt8(6, -10);        // 偏移 6：Int8
```

**Q4: Transferable Objects 的原理？**

A: 通过转移 ArrayBuffer 所有权而非复制数据，实现零拷贝传输。传输后原线程失去访问权，适合 Web Workers 间传递大数据：

```javascript
worker.postMessage({ buffer }, [buffer]); // 第二个参数是转移列表
console.log(buffer.byteLength); // 0（已失去所有权）
```

### 十、总结

JavaScript 二进制数据处理的核心要点：

1. **ArrayBuffer**：原始二进制缓冲区，固定长度，必须通过视图访问
2. **TypedArray**：类型化数组视图，9 种类型覆盖常见场景
3. **DataView**：灵活的多类型视图，支持字节序控制
4. **性能优势**：直接内存操作，比字符串/普通数组快 3-10 倍
5. **应用场景**：文件操作、网络通信、图像处理、WebAssembly
6. **零拷贝**：subarray、Transferable Objects 避免数据复制
7. **注意事项**：类型溢出、字节对齐、字节序

---

**参考资料：**
- MDN: ArrayBuffer - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
- MDN: TypedArray - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
- MDN: DataView - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView
- ECMAScript 规范：Structured Data - https://tc39.es/ecma262/#sec-structured-data
