---
title: JavaScript 的事件循环（Event Loop）详解
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: javascript-event-loop-explained
ref:
---

## 核心要点

- **单线程非阻塞**：JavaScript主线程单线程执行，通过事件循环实现异步非阻塞
- **调用栈+任务队列**：同步代码在调用栈执行，异步回调进入任务队列
- **宏任务+微任务**：微任务优先级高于宏任务，每次事件循环先清空微任务队列
- **浏览器vs Node.js**：两者在事件循环实现上有细微差异

## 详细回答

### 1. 事件循环基本概念

JavaScript是单线程语言，所有代码都在主线程上执行。为了实现异步非阻塞，JavaScript引入了**事件循环（Event Loop）**机制。

```javascript
// 示例：理解执行顺序
console.log('1'); // 同步代码，立即执行

setTimeout(() => {
    console.log('2'); // 宏任务，进入任务队列
}, 0);

Promise.resolve().then(() => {
    console.log('3'); // 微任务，优先执行
});

console.log('4'); // 同步代码，立即执行

// 输出顺序：1 -> 4 -> 3 -> 2
```

### 2. 事件循环的执行机制

#### 执行栈（Call Stack）
- 存储当前正在执行的函数调用
- 遵循后进先出（LIFO）原则
- 当栈为空时，事件循环开始检查任务队列

#### 任务队列（Task Queue）
分为两种类型：

**宏任务（MacroTask）**：
- `setTimeout`、`setInterval`
- `setImmediate`（Node.js）
- DOM事件回调
- HTTP请求回调

**微任务（MicroTask）**：
- `Promise.then/catch/finally`
- `queueMicrotask()`
- `MutationObserver`（浏览器）
- `process.nextTick`（Node.js，优先级最高）

### 3. 事件循环流程

```
1. 执行同步代码，直到调用栈清空
2. 检查微任务队列，执行所有微任务
3. 检查宏任务队列，取出一个宏任务执行
4. 重复步骤2-3，形成循环
```

#### 详细流程图：
```
┌─────────────────┐
│  执行同步代码    │
└─────────────────┘
         ↓
┌─────────────────┐
│ 调用栈是否为空？  │ ← ───┐
└─────────────────┘      │
         ↓ Yes            │
┌─────────────────┐      │
│ 执行所有微任务    │      │
└─────────────────┘      │
         ↓                │
┌─────────────────┐      │
│ 执行一个宏任务    │      │
└─────────────────┘      │
         ↓                │
         └────────────────┘
```

### 4. 复杂示例分析

```javascript
console.log('start');

setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(() => {
        console.log('promise1');
    });
}, 0);

setTimeout(() => {
    console.log('timeout2');
    Promise.resolve().then(() => {
        console.log('promise2');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('promise3');
    setTimeout(() => {
        console.log('timeout3');
    }, 0);
});

console.log('end');

// 执行顺序：
// start -> end -> promise3 -> timeout1 -> promise1 -> timeout2 -> promise2 -> timeout3
```

**分析过程：**
1. 同步代码：`start` → `end`
2. 微任务队列：执行`promise3`，同时添加`timeout3`到宏任务队列
3. 宏任务1：执行`timeout1`，添加`promise1`到微任务队列
4. 微任务：执行`promise1`
5. 宏任务2：执行`timeout2`，添加`promise2`到微任务队列
6. 微任务：执行`promise2`
7. 宏任务3：执行`timeout3`

### 5. 浏览器vs Node.js差异

#### 浏览器环境
- 每轮事件循环只处理一个宏任务
- 每个宏任务后立即清空所有微任务

#### Node.js环境
- 事件循环分为多个阶段（phases）
- 每个阶段处理特定类型的回调
- `process.nextTick`优先级最高

```javascript
// Node.js事件循环阶段
┌───────────────────────────┐
┌─>│           timers          │  // setTimeout, setInterval
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │  // 系统操作的回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │  // 内部使用
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           poll            │  // 获取新的I/O事件
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           check           │  // setImmediate
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │  // socket.on('close')
   └───────────────────────────┘
```

### 6. 实际应用场景

#### 性能优化
```javascript
// 避免长时间阻塞主线程
function heavyTask(data) {
    return new Promise(resolve => {
        // 将大任务分割成小块
        setTimeout(() => {
            // 处理数据
            resolve(processData(data));
        }, 0);
    });
}
```

#### 状态更新时机
```javascript
// React中的批处理更新
function handleClick() {
    // 这些setState会被批处理
    setState1(newValue1);
    setState2(newValue2);

    // 在微任务中执行，确保DOM已更新
    Promise.resolve().then(() => {
        // 读取最新的DOM状态
        console.log(ref.current.offsetHeight);
    });
}
```

### 7. 常见面试陷阱

```javascript
// 陷阱1：Promise构造函数是同步的
new Promise((resolve) => {
    console.log('1'); // 立即执行
    resolve();
}).then(() => {
    console.log('2'); // 微任务
});
console.log('3');
// 输出：1 -> 3 -> 2

// 陷阱2：async函数的执行时机
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end'); // 等价于Promise.then
}

async function async2() {
    console.log('async2');
}

async1();
console.log('main');
// 输出：async1 start -> async2 -> main -> async1 end
```

### 8. 总结

事件循环是JavaScript异步编程的核心机制，理解其原理对于：
- 写出正确的异步代码
- 避免回调地狱和竞态条件
- 优化程序性能
- 调试异步相关问题

都具有重要意义。掌握宏任务、微任务的执行顺序，能帮助我们预测代码的执行结果，编写更可靠的JavaScript应用。
