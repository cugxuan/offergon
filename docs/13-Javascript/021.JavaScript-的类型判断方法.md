---
title: JavaScript 的类型判断方法
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-type-checking-methods
ref:
---

## 核心要点

JavaScript 类型判断有四种主要方法：**typeof**（适合基本类型但无法区分对象细节）、**instanceof**（用于判断对象继承关系）、**Object.prototype.toString.call()**（最精确的类型判断）、**constructor**（可被篡改需谨慎使用）。推荐使用 toString 方法进行精确判断，typeof 用于快速判断基本类型。

---

## 详细解答

JavaScript 类型判断是面试中的高频考点，主要因为 JavaScript 是弱类型语言，需要在运行时准确识别数据类型。下面我将详细介绍四种主流的类型判断方法及其适用场景。

### 1. typeof 操作符

**基本用法：**
```javascript
typeof 42           // "number"
typeof "hello"      // "string"
typeof true         // "boolean"
typeof undefined    // "undefined"
typeof Symbol()     // "symbol"
typeof 9007199254740991n  // "bigint"
typeof function(){} // "function"
```

**优点：**
- 语法简洁，执行速度快
- 能准确判断除 null 外的所有基本类型
- 可以区分函数

**缺点和陷阱：**
```javascript
typeof null          // "object" ⚠️ 历史遗留bug
typeof []            // "object" ⚠️ 无法区分数组
typeof {}            // "object" ⚠️ 无法区分普通对象和其他对象
typeof new Date()    // "object" ⚠️ 无法识别具体对象类型
typeof /regex/       // "object" ⚠️ (某些引擎返回 "function")
```

**适用场景：**
- 判断基本数据类型（除 null）
- 快速判断是否为函数

### 2. instanceof 操作符

**原理：**
检查构造函数的 `prototype` 属性是否存在于对象的原型链上。

```javascript
[] instanceof Array              // true
new Date() instanceof Date       // true
/regex/ instanceof RegExp        // true

// 检查原型链
function Person() {}
const p = new Person()
p instanceof Person              // true
p instanceof Object              // true（原型链追溯）
```

**优点：**
- 能准确判断复杂数据类型（Array、Date、RegExp 等）
- 可以检测自定义类型
- 支持继承关系的判断

**缺点和局限：**
```javascript
// 1. 无法判断基本类型
"hello" instanceof String        // false ⚠️
42 instanceof Number             // false ⚠️

// 2. 跨 iframe 问题
const iframe = document.createElement('iframe')
document.body.appendChild(iframe)
const iframeArray = window.frames[0].Array
const arr = new iframeArray()
arr instanceof Array             // false ⚠️（不同的 Array 构造函数）

// 3. 原型链可被篡改
function Fake() {}
const obj = {}
Object.setPrototypeOf(obj, Fake.prototype)
obj instanceof Fake              // true ⚠️（但 obj 不是由 Fake 构造的）
```

**适用场景：**
- 判断对象的具体类型
- 检测继承关系
- 同一 JavaScript 执行环境内的类型判断

### 3. Object.prototype.toString.call()（最精确）

**原理：**
调用 Object 原型上的 toString 方法，返回 `[object Type]` 格式的字符串。

```javascript
Object.prototype.toString.call(42)         // "[object Number]"
Object.prototype.toString.call("hello")    // "[object String]"
Object.prototype.toString.call(true)       // "[object Boolean]"
Object.prototype.toString.call(undefined)  // "[object Undefined]"
Object.prototype.toString.call(null)       // "[object Null]"
Object.prototype.toString.call([])         // "[object Array]"
Object.prototype.toString.call({})         // "[object Object]"
Object.prototype.toString.call(function(){})  // "[object Function]"
Object.prototype.toString.call(new Date()) // "[object Date]"
Object.prototype.toString.call(/regex/)    // "[object RegExp]"
Object.prototype.toString.call(Symbol())   // "[object Symbol]"
Object.prototype.toString.call(Promise.resolve())  // "[object Promise]"
```

**封装工具函数：**
```javascript
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
}

getType(42)         // "number"
getType([])         // "array"
getType(null)       // "null"
getType(new Map())  // "map"
getType(new Set())  // "set"
```

**优点：**
- 能准确判断所有 JavaScript 内置类型
- 不受原型链篡改影响
- 解决跨 iframe 问题
- 可以判断 null

**缺点：**
- 语法较冗长
- 无法判断自定义类型（统一返回 `[object Object]`）
- 性能略低于 typeof

**适用场景：**
- 需要精确判断内置类型时
- 工具库中的类型判断函数
- 需要可靠性的场景

### 4. constructor 属性

**基本用法：**
```javascript
[].constructor === Array           // true
(42).constructor === Number        // true
"hello".constructor === String     // true
true.constructor === Boolean       // true

function Person() {}
const p = new Person()
p.constructor === Person           // true
```

**优点：**
- 可以判断基本类型（包装对象）
- 可以判断自定义类型
- 语法较简洁

**缺点和风险：**
```javascript
// 1. null 和 undefined 没有 constructor
null.constructor      // TypeError ⚠️
undefined.constructor // TypeError ⚠️

// 2. constructor 可被重写
function Person() {}
Person.prototype.constructor = Array
const p = new Person()
p.constructor === Array  // true ⚠️（但 p 不是数组）

// 3. 原型链断裂问题
function Parent() {}
function Child() {}
Child.prototype = Object.create(Parent.prototype)
// 此时 Child.prototype.constructor 指向 Parent ⚠️
const c = new Child()
c.constructor === Child  // false
```

**适用场景：**
- 在确保 constructor 未被篡改的代码中使用
- 快速判断对象的构造函数
- 配合其他方法作为辅助判断

---

## 实战对比与最佳实践

### 综合对比表

| 方法 | 基本类型 | 对象类型 | null | 自定义类型 | 跨iframe | 防篡改 | 性能 |
|------|---------|---------|------|-----------|---------|--------|------|
| typeof | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ⭐⭐⭐⭐⭐ |
| instanceof | ❌ | ✅ | ❌ | ✅ | ❌ | ❌ | ⭐⭐⭐⭐ |
| toString.call | ✅ | ✅ | ✅ | ❌ | ✅ | ✅ | ⭐⭐⭐ |
| constructor | ⚠️ | ✅ | ❌ | ✅ | ✅ | ❌ | ⭐⭐⭐⭐ |

### 推荐方案

**1. 通用类型判断工具函数：**
```javascript
function typeOf(value) {
  // 处理 null
  if (value === null) return 'null'

  // 基本类型直接用 typeof
  const baseType = typeof value
  if (baseType !== 'object') return baseType

  // 对象类型使用 toString
  return Object.prototype.toString.call(value)
    .slice(8, -1)
    .toLowerCase()
}

// 使用示例
typeOf(null)        // "null"
typeOf(42)          // "number"
typeOf([])          // "array"
typeOf(new Date())  // "date"
```

**2. 针对性判断：**
```javascript
// 判断数组（优先使用 ES5 方法）
Array.isArray([])   // true

// 判断 NaN
Number.isNaN(NaN)   // true
// 或 Object.is(value, NaN)

// 判断是否为纯对象
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]'
}

// 判断是否为 Promise
function isPromise(obj) {
  return obj instanceof Promise ||
    (obj && typeof obj.then === 'function')
}
```

**3. 实际项目中的选择策略：**
- **性能敏感场景**：优先使用 `typeof` 判断基本类型
- **需要判断数组**：使用 `Array.isArray()`
- **通用工具函数**：使用 `Object.prototype.toString.call()`
- **判断继承关系**：使用 `instanceof`
- **自定义类型检测**：结合 `instanceof` 和 `constructor`

---

## 面试加分点

1. **理解 typeof null 的历史原因**：JavaScript 最初版本中，值用 32 位存储，类型标签在低位。对象的类型标签是 000，而 null 表示为全 0，因此被误判为对象。

2. **知道 Symbol.toStringTag**：可以自定义 toString 行为
```javascript
class MyClass {
  get [Symbol.toStringTag]() {
    return 'MyClass'
  }
}
Object.prototype.toString.call(new MyClass())  // "[object MyClass]"
```

3. **了解鸭子类型（Duck Typing）**：在某些场景下通过检查特征方法判断类型
```javascript
function isArrayLike(obj) {
  return obj != null &&
    typeof obj.length === 'number' &&
    obj.length >= 0
}
```

这些知识点能够展现你对 JavaScript 类型系统的深入理解和实战经验。
