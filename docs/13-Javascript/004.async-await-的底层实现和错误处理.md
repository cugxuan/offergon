---
title: async/await 的底层实现和错误处理
tags:
  - JavaScript
  - 同步原语
status: robot
class: 前端JavaScript
slug: async-await-implementation-error-handling
ref:
---

## 核心要点

- **语法糖本质**：async/await是Promise + Generator的语法糖，底层基于迭代器协议
- **状态转换**：async函数总是返回Promise，await暂停函数执行等待Promise resolve
- **错误传播**：throw/reject会被转换为Promise rejection，支持try/catch同步写法
- **执行时机**：await后的代码相当于Promise.then中的微任务

## 详细回答

### 1. async/await底层原理

#### async函数的本质
```javascript
// async函数声明
async function fetchData() {
    return 'data';
}

// 等价于
function fetchData() {
    return Promise.resolve('data');
}

// 验证
console.log(fetchData()); // Promise {<fulfilled>: 'data'}
console.log(fetchData() instanceof Promise); // true
```

#### await的执行机制
```javascript
async function example() {
    console.log('1');
    const result = await Promise.resolve('2');
    console.log(result);
    console.log('3');
}

// 等价的Promise写法
function example() {
    return new Promise(resolve => {
        console.log('1');

        Promise.resolve('2').then(result => {
            console.log(result);
            console.log('3');
            resolve(undefined);
        });
    });
}
```

### 2. Generator + Promise实现async/await

#### 手写async/await
```javascript
// 模拟async/await的实现
function asyncToGenerator(generatorFunc) {
    return function (...args) {
        const generator = generatorFunc.apply(this, args);

        return new Promise((resolve, reject) => {
            function step(key, arg) {
                let result;
                try {
                    result = generator[key](arg);
                } catch (error) {
                    reject(error);
                    return;
                }

                const { value, done } = result;

                if (done) {
                    // Generator执行完成
                    resolve(value);
                } else {
                    // 将value转换为Promise
                    return Promise.resolve(value).then(
                        val => step('next', val),    // 成功时继续执行
                        err => step('throw', err)    // 失败时抛出错误
                    );
                }
            }

            step('next');
        });
    };
}

// 使用Generator实现async函数
function* fetchDataGenerator() {
    try {
        console.log('开始请求');
        const result1 = yield fetch('/api/data1');
        console.log('第一个请求结果:', result1);

        const result2 = yield fetch('/api/data2');
        console.log('第二个请求结果:', result2);

        return { result1, result2 };
    } catch (error) {
        console.error('请求失败:', error);
        throw error;
    }
}

// 转换为async函数
const fetchData = asyncToGenerator(fetchDataGenerator);

// 使用
fetchData().then(result => {
    console.log('最终结果:', result);
}).catch(error => {
    console.error('捕获错误:', error);
});
```

#### 更完整的实现
```javascript
function spawn(generatorFunc) {
    return function (...args) {
        const generator = generatorFunc.apply(this, args);

        return new Promise((resolve, reject) => {
            function step(key, arg) {
                let result;

                try {
                    result = generator[key](arg);
                } catch (error) {
                    reject(error);
                    return;
                }

                const { value, done } = result;

                if (done) {
                    resolve(value);
                } else {
                    // 支持各种类型的值
                    Promise.resolve(value).then(
                        val => step('next', val),
                        err => step('throw', err)
                    );
                }
            }

            step('next');
        });
    };
}

// 示例：复杂的异步流程
function* complexAsyncFlow() {
    try {
        // 串行请求
        const user = yield fetchUser();
        const posts = yield fetchUserPosts(user.id);

        // 并行请求
        const [comments, likes] = yield Promise.all([
            fetchComments(posts.map(p => p.id)),
            fetchLikes(posts.map(p => p.id))
        ]);

        return {
            user,
            posts: posts.map(post => ({
                ...post,
                comments: comments[post.id],
                likes: likes[post.id]
            }))
        };
    } catch (error) {
        console.error('流程执行失败:', error);
        throw new Error(`数据获取失败: ${error.message}`);
    }
}

const executeComplexFlow = spawn(complexAsyncFlow);
```

### 3. 错误处理机制

#### try/catch与Promise错误处理的对应
```javascript
// async/await错误处理
async function handleErrors() {
    try {
        const result1 = await riskyOperation1();
        const result2 = await riskyOperation2(result1);
        return result2;
    } catch (error) {
        console.error('操作失败:', error);
        throw new Error('处理失败');
    }
}

// 等价的Promise写法
function handleErrors() {
    return riskyOperation1()
        .then(result1 => riskyOperation2(result1))
        .catch(error => {
            console.error('操作失败:', error);
            throw new Error('处理失败');
        });
}
```

#### 错误类型处理
```javascript
async function advancedErrorHandling() {
    try {
        const data = await fetchData();
        return data;
    } catch (error) {
        // 根据错误类型进行不同处理
        if (error.name === 'NetworkError') {
            console.error('网络错误:', error.message);
            // 重试逻辑
            return await retryFetch();
        } else if (error.name === 'ValidationError') {
            console.error('数据验证错误:', error.message);
            throw new Error('数据格式不正确');
        } else {
            console.error('未知错误:', error);
            throw error;
        }
    }
}

// 重试机制实现
async function retryFetch(maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fetchData();
        } catch (error) {
            if (i === maxRetries - 1) {
                throw error;
            }
            console.log(`重试第${i + 1}次...`);
            await delay(1000 * Math.pow(2, i)); // 指数退避
        }
    }
}
```

#### 部分错误处理
```javascript
async function partialErrorHandling() {
    const results = [];
    const errors = [];

    // 处理多个异步操作，部分失败不影响整体
    const tasks = [
        { name: 'task1', fn: () => fetchData1() },
        { name: 'task2', fn: () => fetchData2() },
        { name: 'task3', fn: () => fetchData3() }
    ];

    for (const task of tasks) {
        try {
            const result = await task.fn();
            results.push({ name: task.name, result });
        } catch (error) {
            errors.push({ name: task.name, error });
            console.warn(`${task.name} 执行失败:`, error.message);
        }
    }

    return { results, errors };
}

// 使用Promise.allSettled的方式
async function allSettledApproach() {
    const tasks = [fetchData1(), fetchData2(), fetchData3()];
    const results = await Promise.allSettled(tasks);

    const successes = results
        .filter(result => result.status === 'fulfilled')
        .map(result => result.value);

    const failures = results
        .filter(result => result.status === 'rejected')
        .map(result => result.reason);

    return { successes, failures };
}
```

### 4. 执行时机与微任务

#### await的执行顺序
```javascript
async function asyncOrder() {
    console.log('1');

    const result = await new Promise(resolve => {
        console.log('2'); // Promise构造函数同步执行
        resolve('3');
    });

    console.log(result); // 微任务中执行
    console.log('4');
}

console.log('start');
asyncOrder();
console.log('end');

// 输出顺序：start → 1 → 2 → end → 3 → 4
```

#### 复杂的执行顺序分析
```javascript
async function complex() {
    console.log('async start');

    await new Promise(resolve => {
        console.log('promise start');
        resolve();
    });

    console.log('async middle');

    await Promise.resolve();

    console.log('async end');
}

console.log('script start');

setTimeout(() => console.log('setTimeout'), 0);

complex();

new Promise(resolve => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise1 then');
});

console.log('script end');

// 输出顺序：
// script start
// async start
// promise start
// promise1
// script end
// async middle
// promise1 then
// async end
// setTimeout
```

### 5. 性能优化与最佳实践

#### 并行vs串行执行
```javascript
// ❌ 串行执行（性能差）
async function sequential() {
    const result1 = await fetch('/api/data1'); // 等待1秒
    const result2 = await fetch('/api/data2'); // 再等待1秒
    const result3 = await fetch('/api/data3'); // 再等待1秒
    // 总计：3秒
    return [result1, result2, result3];
}

// ✅ 并行执行（性能好）
async function parallel() {
    const [result1, result2, result3] = await Promise.all([
        fetch('/api/data1'), // 同时开始
        fetch('/api/data2'), // 同时开始
        fetch('/api/data3')  // 同时开始
    ]);
    // 总计：1秒（最慢的那个）
    return [result1, result2, result3];
}

// 🔧 混合模式（部分依赖）
async function hybrid() {
    // 第一步：并行获取独立数据
    const [userData, configData] = await Promise.all([
        fetchUser(),
        fetchConfig()
    ]);

    // 第二步：基于第一步结果继续处理
    const [posts, permissions] = await Promise.all([
        fetchUserPosts(userData.id),
        fetchPermissions(userData.role)
    ]);

    return { userData, configData, posts, permissions };
}
```

#### 错误边界和资源清理
```javascript
async function withResourceCleanup() {
    const resource = await acquireResource();

    try {
        const result = await processWithResource(resource);
        return result;
    } finally {
        // 无论成功还是失败都会执行清理
        await releaseResource(resource);
    }
}

// 超时控制
async function withTimeout(asyncFn, timeoutMs) {
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('操作超时')), timeoutMs);
    });

    return Promise.race([
        asyncFn(),
        timeoutPromise
    ]);
}

// 使用示例
async function fetchWithTimeout() {
    try {
        const data = await withTimeout(
            () => fetch('/api/slow-endpoint'),
            5000 // 5秒超时
        );
        return data;
    } catch (error) {
        if (error.message === '操作超时') {
            console.warn('请求超时，使用缓存数据');
            return getCachedData();
        }
        throw error;
    }
}
```

### 6. 调试技巧

#### 错误栈追踪
```javascript
// 原始错误栈可能丢失上下文
async function badErrorHandling() {
    try {
        await riskyOperation();
    } catch (error) {
        throw error; // 丢失了当前函数的上下文
    }
}

// 保持错误栈的最佳实践
async function goodErrorHandling() {
    try {
        return await riskyOperation();
    } catch (error) {
        // 添加上下文信息
        error.context = 'goodErrorHandling function';
        throw error;
    }
}

// 创建自定义错误类
class AsyncOperationError extends Error {
    constructor(message, originalError, context) {
        super(message);
        this.name = 'AsyncOperationError';
        this.originalError = originalError;
        this.context = context;
        this.stack = originalError.stack;
    }
}

async function enhancedErrorHandling() {
    try {
        return await riskyOperation();
    } catch (error) {
        throw new AsyncOperationError(
            '异步操作失败',
            error,
            { function: 'enhancedErrorHandling', timestamp: Date.now() }
        );
    }
}
```

#### 性能监控
```javascript
async function monitoredAsyncFunction() {
    const startTime = performance.now();

    try {
        const result = await expensiveOperation();

        const endTime = performance.now();
        console.log(`操作耗时: ${endTime - startTime}ms`);

        return result;
    } catch (error) {
        const endTime = performance.now();
        console.error(`操作失败，耗时: ${endTime - startTime}ms`, error);
        throw error;
    }
}
```

### 7. 兼容性处理

#### Babel转换原理
```javascript
// 原始async/await代码
async function originalFunction() {
    const result = await fetch('/api/data');
    return result.json();
}

// Babel转换后的代码（简化版）
function originalFunction() {
    return _asyncToGenerator(function* () {
        const result = yield fetch('/api/data');
        return result.json();
    })();
}

function _asyncToGenerator(fn) {
    return function () {
        const gen = fn.apply(this, arguments);
        return new Promise((resolve, reject) => {
            function step(key, arg) {
                try {
                    const { value, done } = gen[key](arg);
                    if (done) {
                        resolve(value);
                    } else {
                        Promise.resolve(value).then(
                            val => step('next', val),
                            err => step('throw', err)
                        );
                    }
                } catch (error) {
                    reject(error);
                }
            }
            step('next');
        });
    };
}
```

### 8. 常见陷阱与解决方案

#### 陷阱1：循环中的async/await
```javascript
// ❌ 错误：串行执行
async function processItemsSerial(items) {
    const results = [];
    for (const item of items) {
        const result = await processItem(item); // 逐个等待
        results.push(result);
    }
    return results;
}

// ✅ 正确：并行执行
async function processItemsParallel(items) {
    const promises = items.map(item => processItem(item));
    return Promise.all(promises);
}

// 🔧 限制并发数量
async function processItemsWithConcurrency(items, concurrency = 3) {
    const results = [];
    for (let i = 0; i < items.length; i += concurrency) {
        const chunk = items.slice(i, i + concurrency);
        const chunkResults = await Promise.all(
            chunk.map(item => processItem(item))
        );
        results.push(...chunkResults);
    }
    return results;
}
```

#### 陷阱2：忘记await
```javascript
// ❌ 错误：忘记await
async function forgotAwait() {
    const result = asyncOperation(); // 返回Promise而不是值
    console.log(result); // [object Promise]
    return result;
}

// ✅ 正确：记得await
async function rememberedAwait() {
    const result = await asyncOperation();
    console.log(result); // 实际的值
    return result;
}
```

### 9. 总结

async/await的核心特性：

**底层实现：**
- 基于Promise + Generator的语法糖
- 通过迭代器协议实现暂停和恢复
- 编译时转换为状态机

**错误处理：**
- try/catch可以捕获异步错误
- 错误会自动转换为Promise rejection
- 支持精细化的错误处理策略

**性能优化：**
- 合理使用并行vs串行执行
- 避免不必要的await
- 实现超时和重试机制

**最佳实践：**
- 保持错误栈的完整性
- 合理处理资源清理
- 监控异步操作的性能

掌握async/await不仅要理解其语法，更要深入理解其底层原理和执行机制，这样才能写出高效、可靠的异步代码。
