---
title: Promise 的实现原理（手写 Promise）
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: promise-implementation-handwritten
ref:
---

## 核心要点

- **状态机制**：pending → fulfilled/rejected，状态不可逆转
- **异步执行**：then回调通过微任务队列异步执行
- **链式调用**：每个then返回新Promise，支持值穿透
- **错误冒泡**：未捕获的rejection会向下传播直到遇到catch

## 详细回答

### 1. Promise基本原理

#### Promise/A+规范核心
```javascript
// Promise状态
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

// Promise的三个核心特性：
// 1. 状态不可逆：pending → fulfilled 或 pending → rejected
// 2. 值的不变性：状态改变后，value/reason不再变化
// 3. 异步执行：then回调在下一个微任务中执行
```

### 2. 手写Promise完整实现

#### 基础版本
```javascript
class MyPromise {
    constructor(executor) {
        this.state = PENDING;
        this.value = undefined;
        this.reason = undefined;

        // 存储then的回调函数
        this.onFulfilledCallbacks = [];
        this.onRejectedCallbacks = [];

        const resolve = (value) => {
            if (this.state === PENDING) {
                this.state = FULFILLED;
                this.value = value;
                // 执行所有成功回调
                this.onFulfilledCallbacks.forEach(callback => callback());
            }
        };

        const reject = (reason) => {
            if (this.state === PENDING) {
                this.state = REJECTED;
                this.reason = reason;
                // 执行所有失败回调
                this.onRejectedCallbacks.forEach(callback => callback());
            }
        };

        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }

    then(onFulfilled, onRejected) {
        // 值穿透处理
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

        // 返回新的Promise实现链式调用
        return new MyPromise((resolve, reject) => {
            if (this.state === FULFILLED) {
                // 异步执行
                setTimeout(() => {
                    try {
                        const result = onFulfilled(this.value);
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                }, 0);
            } else if (this.state === REJECTED) {
                setTimeout(() => {
                    try {
                        const result = onRejected(this.reason);
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                }, 0);
            } else {
                // pending状态，存储回调
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            const result = onFulfilled(this.value);
                            resolve(result);
                        } catch (error) {
                            reject(error);
                        }
                    }, 0);
                });

                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            const result = onRejected(this.reason);
                            resolve(result);
                        } catch (error) {
                            reject(error);
                        }
                    }, 0);
                });
            }
        });
    }
}
```

#### 完整版本（处理Promise返回值）
```javascript
class MyPromise {
    constructor(executor) {
        this.state = PENDING;
        this.value = undefined;
        this.reason = undefined;
        this.onFulfilledCallbacks = [];
        this.onRejectedCallbacks = [];

        const resolve = (value) => {
            if (this.state === PENDING) {
                this.state = FULFILLED;
                this.value = value;
                this.onFulfilledCallbacks.forEach(callback => callback());
            }
        };

        const reject = (reason) => {
            if (this.state === PENDING) {
                this.state = REJECTED;
                this.reason = reason;
                this.onRejectedCallbacks.forEach(callback => callback());
            }
        };

        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }

    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

        return new MyPromise((resolve, reject) => {
            const handleCallback = (callback, fallback) => {
                try {
                    const result = callback();
                    // 关键：处理返回值是Promise的情况
                    this.resolvePromise(result, resolve, reject);
                } catch (error) {
                    fallback(error);
                }
            };

            if (this.state === FULFILLED) {
                // 微任务模拟（实际应该用queueMicrotask）
                setTimeout(() => handleCallback(() => onFulfilled(this.value), reject), 0);
            } else if (this.state === REJECTED) {
                setTimeout(() => handleCallback(() => onRejected(this.reason), reject), 0);
            } else {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => handleCallback(() => onFulfilled(this.value), reject), 0);
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => handleCallback(() => onRejected(this.reason), reject), 0);
                });
            }
        });
    }

    // 处理Promise返回值的关键方法
    resolvePromise(x, resolve, reject) {
        if (x === this) {
            reject(new TypeError('Chaining cycle detected for promise'));
            return;
        }

        if (x instanceof MyPromise) {
            x.then(resolve, reject);
        } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
            let called = false;
            try {
                const then = x.then;
                if (typeof then === 'function') {
                    then.call(
                        x,
                        (y) => {
                            if (called) return;
                            called = true;
                            this.resolvePromise(y, resolve, reject);
                        },
                        (r) => {
                            if (called) return;
                            called = true;
                            reject(r);
                        }
                    );
                } else {
                    resolve(x);
                }
            } catch (error) {
                if (called) return;
                called = true;
                reject(error);
            }
        } else {
            resolve(x);
        }
    }

    catch(onRejected) {
        return this.then(null, onRejected);
    }

    finally(onFinally) {
        return this.then(
            value => MyPromise.resolve(onFinally()).then(() => value),
            reason => MyPromise.resolve(onFinally()).then(() => { throw reason; })
        );
    }

    // 静态方法
    static resolve(value) {
        if (value instanceof MyPromise) {
            return value;
        }
        return new MyPromise(resolve => resolve(value));
    }

    static reject(reason) {
        return new MyPromise((resolve, reject) => reject(reason));
    }

    static all(promises) {
        return new MyPromise((resolve, reject) => {
            const results = [];
            let count = 0;

            if (promises.length === 0) {
                resolve(results);
                return;
            }

            promises.forEach((promise, index) => {
                MyPromise.resolve(promise).then(
                    value => {
                        results[index] = value;
                        count++;
                        if (count === promises.length) {
                            resolve(results);
                        }
                    },
                    reject
                );
            });
        });
    }

    static race(promises) {
        return new MyPromise((resolve, reject) => {
            promises.forEach(promise => {
                MyPromise.resolve(promise).then(resolve, reject);
            });
        });
    }

    static allSettled(promises) {
        return new MyPromise(resolve => {
            const results = [];
            let count = 0;

            if (promises.length === 0) {
                resolve(results);
                return;
            }

            promises.forEach((promise, index) => {
                MyPromise.resolve(promise).then(
                    value => {
                        results[index] = { status: 'fulfilled', value };
                        count++;
                        if (count === promises.length) {
                            resolve(results);
                        }
                    },
                    reason => {
                        results[index] = { status: 'rejected', reason };
                        count++;
                        if (count === promises.length) {
                            resolve(results);
                        }
                    }
                );
            });
        });
    }
}
```

### 3. 关键实现细节

#### 异步执行的实现
```javascript
// 真实Promise使用微任务
// 我们的实现用setTimeout模拟（实际是宏任务）
const asyncExecute = (callback) => {
    // 理想实现
    if (typeof queueMicrotask === 'function') {
        queueMicrotask(callback);
    } else {
        // 降级方案
        setTimeout(callback, 0);
    }
};
```

#### 值穿透机制
```javascript
// then的参数不是函数时的处理
onFulfilled = typeof onFulfilled === 'function'
    ? onFulfilled
    : value => value; // 值穿透

onRejected = typeof onRejected === 'function'
    ? onRejected
    : reason => { throw reason; }; // 错误冒泡

// 示例
Promise.resolve(1)
    .then() // 没有回调函数
    .then() // 没有回调函数
    .then(value => console.log(value)); // 输出：1
```

### 4. 测试用例

#### 基础功能测试
```javascript
// 测试1：基本resolve
console.log('=== 测试1：基本resolve ===');
new MyPromise(resolve => {
    setTimeout(() => resolve('success'), 1000);
}).then(value => {
    console.log('结果:', value); // 1秒后输出：结果: success
});

// 测试2：链式调用
console.log('=== 测试2：链式调用 ===');
new MyPromise(resolve => resolve(1))
    .then(value => value + 1)
    .then(value => value * 2)
    .then(value => console.log('最终结果:', value)); // 输出：最终结果: 4

// 测试3：错误处理
console.log('=== 测试3：错误处理 ===');
new MyPromise((resolve, reject) => {
    reject('error occurred');
}).catch(error => {
    console.log('捕获错误:', error); // 输出：捕获错误: error occurred
});

// 测试4：Promise.all
console.log('=== 测试4：Promise.all ===');
MyPromise.all([
    MyPromise.resolve(1),
    MyPromise.resolve(2),
    MyPromise.resolve(3)
]).then(results => {
    console.log('all结果:', results); // 输出：all结果: [1, 2, 3]
});
```

#### 边界情况测试
```javascript
// 测试5：返回Promise的情况
new MyPromise(resolve => resolve(1))
    .then(value => {
        return new MyPromise(resolve => {
            setTimeout(() => resolve(value * 2), 500);
        });
    })
    .then(value => {
        console.log('嵌套Promise结果:', value); // 0.5秒后输出：嵌套Promise结果: 2
    });

// 测试6：值穿透
new MyPromise(resolve => resolve('hello'))
    .then() // 没有回调
    .then() // 没有回调
    .then(value => console.log('穿透值:', value)); // 输出：穿透值: hello

// 测试7：同步resolve
new MyPromise(resolve => resolve('immediate'))
    .then(value => console.log('同步resolve:', value)); // 异步输出
```

### 5. 性能优化版本

```javascript
class OptimizedPromise {
    constructor(executor) {
        this.state = PENDING;
        this.value = undefined;
        this.reason = undefined;
        this.onFulfilledCallbacks = [];
        this.onRejectedCallbacks = [];

        const resolve = (value) => {
            if (this.state === PENDING) {
                this.state = FULFILLED;
                this.value = value;
                // 使用微任务批处理回调
                queueMicrotask(() => {
                    this.onFulfilledCallbacks.forEach(callback => callback());
                    this.onFulfilledCallbacks.length = 0; // 清空数组
                });
            }
        };

        const reject = (reason) => {
            if (this.state === PENDING) {
                this.state = REJECTED;
                this.reason = reason;
                queueMicrotask(() => {
                    this.onRejectedCallbacks.forEach(callback => callback());
                    this.onRejectedCallbacks.length = 0;
                });
            }
        };

        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }

    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

        return new OptimizedPromise((resolve, reject) => {
            const executeCallback = (callback) => {
                queueMicrotask(() => {
                    try {
                        const result = callback();
                        this.resolvePromise(result, resolve, reject);
                    } catch (error) {
                        reject(error);
                    }
                });
            };

            if (this.state === FULFILLED) {
                executeCallback(() => onFulfilled(this.value));
            } else if (this.state === REJECTED) {
                executeCallback(() => onRejected(this.reason));
            } else {
                this.onFulfilledCallbacks.push(() => executeCallback(() => onFulfilled(this.value)));
                this.onRejectedCallbacks.push(() => executeCallback(() => onRejected(this.reason)));
            }
        });
    }
}
```

### 6. 实际应用场景

#### 封装异步操作
```javascript
// 封装fetch
function myFetch(url) {
    return new MyPromise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.onload = () => {
            if (xhr.status === 200) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(`HTTP ${xhr.status}`));
            }
        };
        xhr.onerror = () => reject(new Error('Network error'));
        xhr.send();
    });
}

// 使用
myFetch('/api/data')
    .then(data => JSON.parse(data))
    .then(json => console.log(json))
    .catch(error => console.error('请求失败:', error));
```

#### 实现延迟函数
```javascript
function delay(ms) {
    return new MyPromise(resolve => setTimeout(resolve, ms));
}

// 链式延迟
delay(1000)
    .then(() => console.log('1秒后'))
    .then(() => delay(1000))
    .then(() => console.log('再过1秒'));
```

### 7. 与原生Promise的区别

#### 微任务vs宏任务
```javascript
// 原生Promise使用微任务
console.log('1');
Promise.resolve().then(() => console.log('2'));
console.log('3');
// 输出：1 → 3 → 2

// 我们的实现用setTimeout（宏任务）
console.log('1');
MyPromise.resolve().then(() => console.log('2'));
console.log('3');
// 输出：1 → 3 → 2（但延迟更高）
```

#### 错误处理的完整性
```javascript
// 原生Promise有更完整的错误处理
// 包括 unhandledrejection 事件等
window.addEventListener('unhandledrejection', event => {
    console.log('未处理的Promise拒绝:', event.reason);
});
```

### 8. 总结

手写Promise的关键点：

**核心机制：**
- 状态管理（pending/fulfilled/rejected）
- 回调存储与异步执行
- 链式调用与值穿透
- Promise返回值处理

**实现难点：**
- resolvePromise方法的正确实现
- 微任务的模拟
- 边界情况的处理（循环引用、thenable对象等）

**实际价值：**
- 深入理解异步编程机制
- 掌握Promise/A+规范
- 为学习async/await打下基础
- 提升JavaScript异步编程能力

这个实现虽然不能完全替代原生Promise，但能帮助深入理解Promise的工作原理，是面试和技术成长的重要知识点。
