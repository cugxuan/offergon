---
title: JavaScript 的作用域链和词法作用域
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: javascript-scope-chain-lexical-scope
ref:
---

## 核心要点

**词法作用域（Lexical Scope）** 指变量的作用域在代码编写时就确定，由函数定义位置决定而非调用位置。**作用域链（Scope Chain）** 是 JavaScript 查找变量的机制：从当前作用域开始，逐层向外查找，直至全局作用域。关键特性：内层函数可访问外层变量（闭包基础），外层无法访问内层；作用域链在函数定义时创建，不受调用位置影响。

---

## 详细解答

作用域是 JavaScript 最核心的概念之一，理解它能帮助你掌握闭包、模块化、变量提升等高级特性。

### 一、什么是作用域（Scope）

**定义：** 作用域决定了变量和函数的可访问范围，控制着变量的生命周期和可见性。

#### JavaScript 的三种作用域

**1. 全局作用域（Global Scope）**
```javascript
var globalVar = "全局变量"
let globalLet = "全局 let"
const globalConst = "全局 const"

function test() {
  console.log(globalVar)  // 可访问
}

test()
console.log(globalVar)     // 可访问
```

**特点：**
- 在任何地方都能访问
- 浏览器中挂载到 `window` 对象（Node.js 中是 `global`）
- 生命周期从程序开始到程序结束
- 容易造成命名冲突和内存泄漏

**2. 函数作用域（Function Scope）**
```javascript
function outer() {
  var funcVar = "函数变量"

  console.log(funcVar)     // 可访问

  function inner() {
    console.log(funcVar)   // 可访问（通过作用域链）
  }
  inner()
}

outer()
console.log(funcVar)       // ReferenceError ⚠️ 外部无法访问
```

**特点：**
- 使用 `var` 声明的变量具有函数作用域
- 函数外无法访问函数内变量
- 每次函数调用都创建新的作用域

**3. 块级作用域（Block Scope）**
```javascript
if (true) {
  let blockLet = "块级变量"
  const blockConst = "块级常量"
  var blockVar = "var 变量"

  console.log(blockLet)    // 可访问
}

console.log(blockVar)      // 可访问（var 无块级作用域）
console.log(blockLet)      // ReferenceError ⚠️
```

**特点：**
- `let` 和 `const` 具有块级作用域
- 块（`{}`）内声明的变量外部无法访问
- 包括 `if`、`for`、`while`、`{}`、`try/catch` 等

---

### 二、词法作用域（Lexical Scope）

#### 定义与原理

**词法作用域：** 变量的作用域在代码**编写时**就确定了，由函数**定义的位置**决定，而不是函数调用的位置。

```javascript
const name = "外层"

function outer() {
  const name = "中层"

  function inner() {
    console.log(name)  // 访问哪个 name？
  }

  return inner
}

const name2 = "全局"
const innerFunc = outer()
innerFunc()  // 输出: "中层" ⚠️（不是 "全局"）
```

**关键理解：**
- `inner` 函数定义在 `outer` 内部，所以它的作用域链包含 `outer` 的作用域
- 即使 `inner` 在 `outer` 外部调用，依然访问 `outer` 的 `name`
- 这就是**闭包**的基础原理

#### 对比：动态作用域（JavaScript 不采用）

```javascript
// 假设 JavaScript 采用动态作用域（实际不是）
const name = "全局"

function outer() {
  function inner() {
    console.log(name)  // 动态作用域会查找调用位置的 name
  }
  return inner
}

function caller() {
  const name = "caller 的 name"
  const innerFunc = outer()
  innerFunc()  // 动态作用域会输出 "caller 的 name"
               // 但 JavaScript 词法作用域输出 "全局"
}

caller()  // JavaScript 实际输出: "全局"
```

**JavaScript 使用词法作用域的好处：**
- 代码可预测性强（查看定义位置即可知道作用域）
- 便于静态分析和优化
- 支持闭包特性

---

### 三、作用域链（Scope Chain）

#### 定义与查找机制

**作用域链：** JavaScript 引擎查找变量时，从当前作用域开始，逐层向外（父作用域）查找，直到全局作用域为止。

```javascript
const global = "全局变量"

function outer() {
  const outerVar = "外层变量"

  function middle() {
    const middleVar = "中层变量"

    function inner() {
      const innerVar = "内层变量"

      console.log(innerVar)    // 1️⃣ 当前作用域找到
      console.log(middleVar)   // 2️⃣ 向上一层找到
      console.log(outerVar)    // 3️⃣ 向上两层找到
      console.log(global)      // 4️⃣ 向上三层（全局）找到
      console.log(notExist)    // ❌ ReferenceError
    }

    inner()
  }

  middle()
}

outer()
```

**查找顺序：**
```
inner 作用域 → middle 作用域 → outer 作用域 → 全局作用域 → ReferenceError
```

#### 作用域链的创建时机

**关键：** 作用域链在**函数定义时**创建，不是调用时！

```javascript
function createCounter() {
  let count = 0  // 存储在 createCounter 的作用域中

  return function increment() {
    count++  // increment 的作用域链包含 createCounter 的作用域
    console.log(count)
  }
}

const counter1 = createCounter()
counter1()  // 1
counter1()  // 2
counter1()  // 3

const counter2 = createCounter()
counter2()  // 1（新的作用域链，新的 count）
```

**原理分析：**
1. `createCounter` 执行时创建局部变量 `count`
2. 返回的 `increment` 函数定义时，其作用域链包含 `createCounter` 的作用域
3. 即使 `createCounter` 执行完毕，`increment` 依然能访问 `count`（闭包）
4. 每次调用 `createCounter` 都会创建新的作用域和新的 `count`

---

### 四、经典案例与陷阱

#### 陷阱 1：循环中的闭包（经典面试题）

```javascript
// ❌ 问题代码
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100)
}
// 输出: 3, 3, 3 ⚠️（不是 0, 1, 2）

// 原因：var 没有块级作用域，所有回调共享同一个 i
// 当 setTimeout 执行时，循环已结束，i 变成 3
```

**解决方案 1：使用 let（ES6+）**
```javascript
// ✅ 推荐方案
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100)
}
// 输出: 0, 1, 2 ✅

// 原理：let 具有块级作用域，每次迭代创建新的 i
```

**解决方案 2：IIFE 创建新作用域**
```javascript
// ✅ ES5 兼容方案
for (var i = 0; i < 3; i++) {
  (function(j) {  // 立即执行函数创建新作用域
    setTimeout(function() {
      console.log(j)
    }, 100)
  })(i)  // 传入当前 i 的值
}
// 输出: 0, 1, 2 ✅
```

**解决方案 3：bind 绑定参数**
```javascript
// ✅ 另一种方案
for (var i = 0; i < 3; i++) {
  setTimeout(
    function(j) {
      console.log(j)
    }.bind(null, i),  // 绑定当前 i
    100
  )
}
// 输出: 0, 1, 2 ✅
```

#### 陷阱 2：嵌套函数的变量遮蔽（Shadowing）

```javascript
const name = "全局"

function outer() {
  const name = "外层"

  function inner() {
    const name = "内层"  // 遮蔽外层的 name
    console.log(name)     // "内层"
  }

  inner()
  console.log(name)       // "外层"
}

outer()
console.log(name)         // "全局"
```

**理解要点：**
- 内层变量会"遮蔽"外层同名变量
- 作用域链查找遇到第一个匹配变量就停止
- 无法在内层访问被遮蔽的外层变量（除非用对象引用）

**访问被遮蔽变量的技巧：**
```javascript
const obj = { name: "全局" }

function outer() {
  const name = "外层"

  function inner() {
    const name = "内层"
    console.log(name)       // "内层"
    console.log(obj.name)   // "全局"（通过对象访问）
    // 无法访问 outer 的 name
  }

  inner()
}

outer()
```

#### 陷阱 3：this 不遵循词法作用域

```javascript
const obj = {
  name: "对象",

  method: function() {
    console.log(this.name)  // "对象"

    function inner() {
      console.log(this.name)  // undefined ⚠️
      // this 指向全局对象（严格模式下为 undefined）
    }
    inner()
  }
}

obj.method()
```

**解决方案：箭头函数（词法 this）**
```javascript
const obj = {
  name: "对象",

  method: function() {
    const inner = () => {
      console.log(this.name)  // "对象" ✅
      // 箭头函数的 this 继承自外层（词法作用域）
    }
    inner()
  }
}

obj.method()
```

#### 陷阱 4：eval 和 with 破坏词法作用域

```javascript
// ❌ eval 可以修改作用域（严格模式禁止）
function test() {
  var x = 1
  eval("var x = 2")  // 在当前作用域创建变量
  console.log(x)     // 2 ⚠️
}

test()

// ❌ with 创建动态作用域（已废弃）
const obj = { a: 1 }
with (obj) {
  console.log(a)     // 1
  a = 2              // 修改 obj.a
}
console.log(obj.a)   // 2
```

**最佳实践：避免使用 `eval` 和 `with`，它们会：**
- 破坏词法作用域的可预测性
- 阻止 JavaScript 引擎优化
- 引发安全问题

---

### 五、作用域与闭包

#### 闭包的本质

**闭包：** 函数和其词法环境的组合，使函数能访问外层作用域的变量，即使外层函数已经执行完毕。

```javascript
function createWallet() {
  let balance = 0  // 私有变量

  return {
    deposit(amount) {
      balance += amount
      return balance
    },
    withdraw(amount) {
      if (balance >= amount) {
        balance -= amount
        return balance
      }
      return "余额不足"
    },
    getBalance() {
      return balance
    }
  }
}

const wallet = createWallet()
console.log(wallet.deposit(100))    // 100
console.log(wallet.withdraw(30))    // 70
console.log(wallet.getBalance())    // 70
console.log(wallet.balance)         // undefined ⚠️ 无法直接访问
```

**闭包的作用：**
- 创建私有变量（数据封装）
- 实现模块化模式
- 保持状态（如计数器、缓存）
- 实现函数工厂

#### 闭包的内存管理

```javascript
// ⚠️ 内存泄漏风险
function createLeak() {
  const largeData = new Array(1000000).fill("data")

  return function() {
    console.log("函数保持着对 largeData 的引用")
    // 即使不使用 largeData，它也无法被垃圾回收
  }
}

const leak = createLeak()  // largeData 常驻内存
```

**最佳实践：**
```javascript
// ✅ 只保留需要的数据
function createOptimized() {
  const largeData = new Array(1000000).fill("data")
  const summary = largeData.length  // 提取需要的信息

  return function() {
    console.log(`数据长度: ${summary}`)
    // largeData 可以被垃圾回收
  }
}

const optimized = createOptimized()
```

---

### 六、作用域最佳实践

#### 1. 优先使用 let 和 const

```javascript
// ❌ 不推荐（var 无块级作用域）
for (var i = 0; i < 10; i++) {
  // ...
}
console.log(i)  // 10（泄漏到外部）

// ✅ 推荐（let 有块级作用域）
for (let i = 0; i < 10; i++) {
  // ...
}
console.log(i)  // ReferenceError
```

#### 2. 减少全局变量

```javascript
// ❌ 不推荐（污染全局命名空间）
var config = {}
var utils = {}
var data = {}

// ✅ 推荐（命名空间模式）
const MyApp = {
  config: {},
  utils: {},
  data: {}
}

// ✅ 更推荐（ES6 模块）
// config.js
export const config = {}

// utils.js
export const utils = {}
```

#### 3. 利用 IIFE 创建作用域（ES5 兼容）

```javascript
// ❌ 变量泄漏
var temp = "临时数据"
// ... 其他代码可能误用 temp

// ✅ IIFE 隔离作用域
(function() {
  var temp = "临时数据"
  // temp 只在此作用域有效
})()
```

#### 4. 函数声明提前，避免混淆

```javascript
// ❌ 不推荐（难以理解）
function outer() {
  inner()  // 可以调用（函数声明提升）

  function inner() {
    console.log("inner")
  }
}

// ✅ 推荐（清晰可读）
function outer() {
  function inner() {
    console.log("inner")
  }

  inner()
}
```

---

### 七、作用域链可视化理解

```javascript
// 代码结构
const global = "G"

function level1() {
  const L1 = "L1"

  function level2() {
    const L2 = "L2"

    function level3() {
      const L3 = "L3"
      console.log(global, L1, L2, L3)
    }

    level3()
  }

  level2()
}

level1()

// 作用域链可视化：
/*
┌─────────────────────────────────────┐
│ 全局作用域                            │
│ global: "G"                          │
│ level1: [Function]                  │
│  ↓                                   │
│  ┌──────────────────────────────┐   │
│  │ level1 作用域                 │   │
│  │ L1: "L1"                     │   │
│  │ level2: [Function]           │   │
│  │  ↓                           │   │
│  │  ┌────────────────────────┐  │   │
│  │  │ level2 作用域          │  │   │
│  │  │ L2: "L2"              │  │   │
│  │  │ level3: [Function]    │  │   │
│  │  │  ↓                    │  │   │
│  │  │  ┌─────────────────┐  │  │   │
│  │  │  │ level3 作用域   │  │  │   │
│  │  │  │ L3: "L3"       │  │  │   │
│  │  │  │                │  │  │   │
│  │  │  │ 作用域链：      │  │  │   │
│  │  │  │ L3 → L2 → L1 →│  │  │   │
│  │  │  │ → global       │  │  │   │
│  │  │  └─────────────────┘  │  │   │
│  │  └────────────────────────┘  │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
*/
```

---

## 面试加分点

1. **解释闭包与作用域链的关系**：闭包是函数能够记住并访问其词法作用域，即使函数在其词法作用域之外执行。作用域链是实现闭包的底层机制。

2. **V8 引擎的作用域优化**：V8 会分析哪些外层变量被内层函数引用，只保留这些变量（避免整个作用域常驻内存）。

3. **暂时性死区（TDZ）**：
```javascript
console.log(x)  // ReferenceError（不是 undefined）
let x = 5

// let/const 在声明前无法访问（暂时性死区）
// var 会提升并初始化为 undefined
```

4. **模块作用域**：ES6 模块有自己的作用域，不污染全局
```javascript
// module.js
const privateVar = "私有"  // 不会泄漏到全局
export const publicVar = "公开"
```

掌握作用域链和词法作用域，是理解 JavaScript 执行机制、闭包、模块化的关键基础！
