---
title: JavaScript 的 Map 和 WeakMap 的区别
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: map-vs-weakmap-difference
ref:
---

## 核心要点

1. **键的类型**:Map 支持任意类型作为键,WeakMap 只支持对象作为键
2. **垃圾回收**:WeakMap 的键是弱引用,不阻止垃圾回收;Map 是强引用
3. **可遍历性**:Map 可遍历,WeakMap 不可遍历且无 size 属性
4. **应用场景**:WeakMap 适合存储对象私有数据和 DOM 节点关联数据,防止内存泄漏

---

## 详细解答

### 一、基本概念对比

#### 1. Map 数据结构

Map 是 ES6 引入的键值对集合,相比传统对象有以下特点:

```javascript
// 创建 Map
const map = new Map();

// 任意类型作为键
map.set('string', '字符串键');
map.set(123, '数字键');
map.set(true, '布尔键');
map.set({id: 1}, '对象键');
map.set(function(){}, '函数键');

console.log(map.size); // 5

// 遍历 Map
for (let [key, value] of map) {
  console.log(key, value);
}

// 常用方法
map.get('string');     // 获取值
map.has(123);          // 检查键是否存在
map.delete(true);      // 删除键值对
map.clear();           // 清空所有
```

#### 2. WeakMap 数据结构

WeakMap 是弱引用的 Map,有严格的限制:

```javascript
// 创建 WeakMap
const weakMap = new WeakMap();

const obj1 = {id: 1};
const obj2 = {id: 2};

// 只能使用对象作为键
weakMap.set(obj1, '对象1的数据');
weakMap.set(obj2, '对象2的数据');

// 以下操作会报错
// weakMap.set('string', 'value');  // TypeError
// weakMap.set(123, 'value');       // TypeError

// 获取和检查
weakMap.get(obj1);     // '对象1的数据'
weakMap.has(obj2);     // true
weakMap.delete(obj1);  // 删除

// 不支持的操作
// weakMap.size;       // undefined
// weakMap.clear();    // 不存在
// for...of 遍历      // 不可遍历
```

### 二、核心区别详解

#### 1. 键的类型限制

**Map**: 任意类型都可以作为键

```javascript
const map = new Map();

// 原始值作为键
map.set('name', '张三');
map.set(42, '答案');
map.set(undefined, '未定义');
map.set(null, '空值');
map.set(Symbol('id'), '符号');

// 引用值作为键
map.set([], '数组键');
map.set({}, '对象键');
map.set(new Date(), '日期键');
```

**WeakMap**: 仅支持对象(不包括 null)

```javascript
const weakMap = new WeakMap();

// 正确用法
weakMap.set({}, '对象');
weakMap.set([], '数组');
weakMap.set(function(){}, '函数');

// 错误用法(会抛出 TypeError)
try {
  weakMap.set(1, 'number');      // ❌
  weakMap.set('key', 'string');  // ❌
  weakMap.set(null, 'null');     // ❌
} catch(e) {
  console.log(e.message); // Invalid value used as weak map key
}
```

#### 2. 引用类型差异(关键区别)

**Map 强引用**: 阻止垃圾回收

```javascript
const map = new Map();

let obj = {data: 'important'};
map.set(obj, 'metadata');

// 即使删除外部引用,Map 仍持有对象
obj = null;

// 对象不会被垃圾回收,因为 Map 仍引用它
// map 中的键值对依然存在
console.log(map.size); // 1
```

**WeakMap 弱引用**: 不阻止垃圾回收

```javascript
const weakMap = new WeakMap();

let obj = {data: 'important'};
weakMap.set(obj, 'metadata');

// 删除外部引用后
obj = null;

// 对象可以被垃圾回收
// weakMap 中的键值对会自动消失
// 注意:无法验证 weakMap.size,因为它不存在
```

#### 3. 可遍历性

**Map 可遍历**:

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

// 多种遍历方式
map.forEach((value, key) => {
  console.log(key, value);
});

for (let [key, value] of map) {
  console.log(key, value);
}

// 获取迭代器
console.log([...map.keys()]);    // ['a', 'b', 'c']
console.log([...map.values()]);  // [1, 2, 3]
console.log([...map.entries()]); // [['a', 1], ['b', 2], ['c', 3]]

// 获取大小
console.log(map.size); // 3
```

**WeakMap 不可遍历**:

```javascript
const weakMap = new WeakMap();
weakMap.set({}, 'value1');
weakMap.set({}, 'value2');

// 以下操作都不支持
// weakMap.forEach()     // ❌ 不存在
// for...of weakMap      // ❌ 不可迭代
// weakMap.keys()        // ❌ 不存在
// weakMap.values()      // ❌ 不存在
// weakMap.entries()     // ❌ 不存在
// weakMap.size          // ❌ undefined

// 只有 get、set、has、delete 四个方法
```

为什么 WeakMap 不可遍历?因为键是弱引用,随时可能被垃圾回收,无法保证遍历结果的稳定性。

### 三、应用场景对比

#### 1. Map 的应用场景

**场景1:需要非字符串键的场景**

```javascript
// 对象作为配置的键
const elementStyles = new Map();
const button = document.querySelector('button');
const input = document.querySelector('input');

elementStyles.set(button, {
  color: 'blue',
  fontSize: '16px'
});

elementStyles.set(input, {
  border: '1px solid #ccc',
  padding: '10px'
});

// 应用样式
function applyStyles(element) {
  const styles = elementStyles.get(element);
  if (styles) {
    Object.assign(element.style, styles);
  }
}
```

**场景2:需要遍历的键值对集合**

```javascript
// 缓存管理
class Cache {
  constructor() {
    this.cache = new Map();
  }

  set(key, value, ttl = 60000) {
    this.cache.set(key, {
      value,
      expires: Date.now() + ttl
    });
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() > item.expires) {
      this.cache.delete(key);
      return null;
    }

    return item.value;
  }

  // 清理过期缓存(需要遍历)
  cleanup() {
    const now = Date.now();
    for (let [key, item] of this.cache) {
      if (now > item.expires) {
        this.cache.delete(key);
      }
    }
  }

  size() {
    return this.cache.size;
  }
}
```

**场景3:需要知道数据量的场景**

```javascript
// 统计分析
class Analytics {
  constructor() {
    this.events = new Map();
  }

  track(event, data) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push({
      data,
      timestamp: Date.now()
    });
  }

  getEventCount(event) {
    return this.events.get(event)?.length || 0;
  }

  getAllEvents() {
    return Array.from(this.events.keys());
  }

  getTotalEvents() {
    return this.events.size;
  }
}
```

#### 2. WeakMap 的应用场景

**场景1:存储对象私有数据(最常见)**

```javascript
// 使用 WeakMap 实现真正的私有属性
const privateData = new WeakMap();

class User {
  constructor(name, password) {
    this.name = name; // 公开属性

    // 私有数据存储在 WeakMap 中
    privateData.set(this, {
      password: password,
      createdAt: new Date()
    });
  }

  validatePassword(input) {
    const data = privateData.get(this);
    return data.password === input;
  }

  getAccountAge() {
    const data = privateData.get(this);
    return Date.now() - data.createdAt;
  }
}

const user = new User('张三', 'secret123');
console.log(user.name);              // '张三' (可访问)
console.log(user.password);          // undefined (无法访问)
console.log(user.validatePassword('secret123')); // true

// 当 user 对象被销毁时,privateData 中的数据自动回收
```

**场景2:DOM 节点关联数据(防止内存泄漏)**

```javascript
// 为 DOM 节点存储元数据
const domMetadata = new WeakMap();

function attachMetadata(element, data) {
  domMetadata.set(element, data);
}

function getMetadata(element) {
  return domMetadata.get(element);
}

// 使用示例
const button = document.createElement('button');
attachMetadata(button, {
  clickCount: 0,
  lastClicked: null
});

button.addEventListener('click', () => {
  const meta = getMetadata(button);
  meta.clickCount++;
  meta.lastClicked = new Date();
});

// 关键优势:当 DOM 节点被移除时
document.body.removeChild(button);
// domMetadata 中的数据会自动被垃圾回收,不会造成内存泄漏

// 如果使用 Map,即使 DOM 节点移除,数据仍会保留
```

**场景3:对象状态标记**

```javascript
// 标记对象是否已处理,避免重复处理
const processed = new WeakMap();

function processObject(obj) {
  // 检查是否已处理
  if (processed.has(obj)) {
    console.log('对象已处理过');
    return;
  }

  // 执行处理逻辑
  console.log('处理对象:', obj);

  // 标记为已处理
  processed.set(obj, true);
}

const data1 = {id: 1};
processObject(data1); // '处理对象: {id: 1}'
processObject(data1); // '对象已处理过'

// 当 data1 不再使用时,标记会自动清除
```

**场景4:缓存计算结果(针对对象)**

```javascript
// 缓存对象的计算结果
const computeCache = new WeakMap();

function expensiveCompute(obj) {
  // 检查缓存
  if (computeCache.has(obj)) {
    console.log('从缓存返回');
    return computeCache.get(obj);
  }

  // 执行耗时计算
  console.log('执行计算');
  const result = Object.keys(obj).reduce((sum, key) => {
    return sum + (typeof obj[key] === 'number' ? obj[key] : 0);
  }, 0);

  // 缓存结果
  computeCache.set(obj, result);
  return result;
}

const data = {a: 1, b: 2, c: 3};
console.log(expensiveCompute(data)); // '执行计算' 6
console.log(expensiveCompute(data)); // '从缓存返回' 6

// 对象被回收时,缓存自动清除,不占用内存
```

### 四、内存管理对比

#### 1. Map 的内存管理

```javascript
// Map 会导致内存泄漏的场景
const cache = new Map();

function cacheUserData(userId) {
  const user = fetchUser(userId); // 假设获取用户对象
  cache.set(user, {
    cachedAt: Date.now(),
    metadata: 'some data'
  });
  return user;
}

// 问题:即使 user 对象在业务代码中不再使用
// cache 仍然持有引用,导致对象无法回收
// 需要手动管理

// 解决方案:手动清理
function clearUserCache(user) {
  cache.delete(user);
}
```

#### 2. WeakMap 的自动内存管理

```javascript
// WeakMap 自动管理内存
const cache = new WeakMap();

function cacheUserData(userId) {
  const user = fetchUser(userId);
  cache.set(user, {
    cachedAt: Date.now(),
    metadata: 'some data'
  });
  return user;
}

// 优势:当 user 对象没有其他引用时
// 垃圾回收器会自动回收对象和缓存数据
// 无需手动清理
```

### 五、性能对比

```javascript
// 性能测试
function performanceTest() {
  const map = new Map();
  const weakMap = new WeakMap();
  const objects = Array.from({length: 100000}, (_, i) => ({id: i}));

  // Map 写入性能
  console.time('Map set');
  objects.forEach(obj => map.set(obj, obj.id));
  console.timeEnd('Map set');

  // WeakMap 写入性能
  console.time('WeakMap set');
  objects.forEach(obj => weakMap.set(obj, obj.id));
  console.timeEnd('WeakMap set');

  // Map 读取性能
  console.time('Map get');
  objects.forEach(obj => map.get(obj));
  console.timeEnd('Map get');

  // WeakMap 读取性能
  console.time('WeakMap get');
  objects.forEach(obj => weakMap.get(obj));
  console.timeEnd('WeakMap get');
}

// 结论:
// 1. 单次操作性能相近
// 2. WeakMap 在内存管理上有优势
// 3. Map 在需要遍历的场景下更灵活
```

### 六、选择建议

**使用 Map 的情况**:
- 需要使用非对象类型作为键(字符串、数字等)
- 需要遍历所有键值对
- 需要知道集合大小(`size`)
- 需要手动控制数据的生命周期
- 实现缓存、配置管理、状态管理等

**使用 WeakMap 的情况**:
- 只使用对象作为键
- 不需要遍历
- 希望自动清理不再使用的数据
- 存储对象的私有数据
- 关联 DOM 节点数据,防止内存泄漏
- 实现对象级别的标记或缓存

### 七、完整对比表

| 特性 | Map | WeakMap |
|------|-----|---------|
| 键类型 | 任意类型 | 仅对象(不含 null) |
| 引用类型 | 强引用 | 弱引用 |
| 垃圾回收 | 阻止键被回收 | 不阻止键被回收 |
| 可遍历性 | 可遍历(forEach, for...of) | 不可遍历 |
| size 属性 | 有 | 无 |
| clear() 方法 | 有 | 无 |
| keys/values/entries | 有 | 无 |
| 内存泄漏风险 | 需手动管理 | 自动管理 |
| 主要用途 | 通用键值对集合 | 对象私有数据、DOM 关联 |

---

## 面试回答模板

**简洁版**:

Map 和 WeakMap 的核心区别有三点:

1. **键的类型不同**:Map 支持任意类型作为键,WeakMap 只能用对象作为键
2. **引用方式不同**:Map 是强引用会阻止垃圾回收,WeakMap 是弱引用不影响垃圾回收
3. **功能特性不同**:Map 可遍历且有 size 属性,WeakMap 不可遍历也没有 size

WeakMap 主要用于存储对象的私有数据和 DOM 节点关联数据,能有效防止内存泄漏。

**详细版**:

Map 和 WeakMap 是 ES6 引入的两种键值对数据结构,主要区别包括:

首先是**键的类型限制**,Map 可以使用任意类型作为键,包括原始值和对象;而 WeakMap 只接受对象作为键,使用原始值会报错。

其次是**引用类型差异**,这是最关键的区别。Map 使用强引用,即使外部不再引用某个对象,只要 Map 中还存在该对象作为键,它就不会被垃圾回收;而 WeakMap 使用弱引用,当键对象没有其他引用时,会被自动回收,WeakMap 中对应的键值对也会消失。

第三是**遍历能力**,Map 支持 forEach、for...of 等遍历方式,有 size 属性和 keys/values/entries 等方法;WeakMap 不支持任何遍历操作,也没有 size 属性,只有 get/set/has/delete 四个方法。

在**应用场景**上,Map 适合需要遍历、统计或使用非对象键的场景,比如缓存管理、配置存储等;WeakMap 则适合存储对象的元数据和私有属性,特别是在处理 DOM 节点时能有效防止内存泄漏,因为当 DOM 节点被移除后,关联数据会自动被回收。

比如我们可以用 WeakMap 实现类的私有属性:创建一个模块级的 WeakMap,在构造函数中将 this 作为键存储私有数据,这样外部无法访问,且对象销毁时数据自动清理。
