---
title: JavaScript 的严格模式和非严格模式
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: strict-mode-vs-sloppy-mode
ref:
---

## 核心要点

严格模式是 ES5 引入的语法限制模式，通过 `"use strict"` 声明启用。主要特性：**禁止隐式全局变量**、**this 不默认指向全局**、**禁止删除变量/函数**、**参数名唯一**、**禁用八进制字面量**、**eval 独立作用域**。目的是消除 JavaScript 语法的不合理和不安全之处，提高编译效率和代码质量。

---

## 详细解答

### 一、什么是严格模式

**严格模式（Strict Mode）** 是 ES5（2009 年）引入的一种 JavaScript 运行模式,通过在代码顶部或函数顶部添加 `"use strict"` 指令来启用。它会对 JavaScript 的语法和运行时行为施加更严格的限制,帮助开发者编写更健壮、更安全的代码。

```javascript
// 全局严格模式
"use strict";
var x = 10;

// 函数级严格模式
function myFunction() {
  "use strict";
  var y = 20;
}
```

### 二、严格模式 vs 非严格模式的核心差异

#### 1. **变量声明限制**

**非严格模式：** 允许隐式创建全局变量（忘记 var/let/const）

```javascript
// 非严格模式
function test() {
  x = 10; // 自动创建全局变量 x
}
test();
console.log(x); // 10 - 全局污染
```

**严格模式：** 禁止隐式全局变量，必须显式声明

```javascript
"use strict";
function test() {
  x = 10; // ReferenceError: x is not defined
}
```

#### 2. **this 绑定规则**

**非严格模式：** 普通函数调用时 this 默认指向 window（浏览器）或 global（Node.js）

```javascript
function showThis() {
  console.log(this); // window (浏览器环境)
}
showThis();
```

**严格模式：** 普通函数调用时 this 为 undefined

```javascript
"use strict";
function showThis() {
  console.log(this); // undefined
}
showThis();
```

这避免了意外修改全局对象的风险：

```javascript
"use strict";
function Person(name) {
  this.name = name; // 如果忘记 new 关键字,会报错而不是污染全局
}
Person("Alice"); // TypeError: Cannot set property 'name' of undefined
```

#### 3. **删除操作限制**

**非严格模式：** 删除不可删除的属性会静默失败

```javascript
var x = 10;
delete x; // 返回 false,但不报错
console.log(x); // 10

delete Object.prototype; // 返回 false,不报错
```

**严格模式：** 删除变量、函数、不可删除属性会抛出错误

```javascript
"use strict";
var x = 10;
delete x; // SyntaxError: Delete of an unqualified identifier in strict mode

function test() {}
delete test; // SyntaxError

delete Object.prototype; // TypeError: Cannot delete property
```

#### 4. **函数参数限制**

**非严格模式：** 允许重复参数名

```javascript
function sum(a, a, c) {
  return a + a + c; // 第二个 a 会覆盖第一个
}
console.log(sum(1, 2, 3)); // 7 (2 + 2 + 3)
```

**严格模式：** 禁止重复参数名

```javascript
"use strict";
function sum(a, a, c) { // SyntaxError: Duplicate parameter name not allowed
  return a + a + c;
}
```

#### 5. **八进制字面量**

**非严格模式：** 支持八进制字面量（0 前缀）

```javascript
var num = 010; // 八进制 8
console.log(num); // 8
```

**严格模式：** 禁止八进制字面量

```javascript
"use strict";
var num = 010; // SyntaxError: Octal literals are not allowed in strict mode
// 必须使用 0o 前缀
var num = 0o10; // 正确写法
```

#### 6. **eval 和 arguments 限制**

**非严格模式：** eval 中声明的变量会泄漏到外部作用域

```javascript
eval("var x = 10");
console.log(x); // 10
```

**严格模式：** eval 有独立作用域

```javascript
"use strict";
eval("var x = 10");
console.log(x); // ReferenceError: x is not defined
```

**非严格模式：** 可以给 arguments 赋值

```javascript
function test() {
  arguments = [1, 2, 3]; // 允许
}
```

**严格模式：** 禁止修改 arguments

```javascript
"use strict";
function test() {
  arguments = [1, 2, 3]; // SyntaxError
}
```

#### 7. **with 语句**

**非严格模式：** 允许 with 语句（会导致作用域混乱）

```javascript
var obj = { x: 10 };
with (obj) {
  console.log(x); // 10
}
```

**严格模式：** 禁止 with 语句

```javascript
"use strict";
with (obj) { // SyntaxError: Strict mode code may not include a with statement
  console.log(x);
}
```

#### 8. **只读属性赋值**

**非严格模式：** 给只读属性赋值会静默失败

```javascript
var obj = {};
Object.defineProperty(obj, "x", { value: 10, writable: false });
obj.x = 20; // 不报错,但赋值失败
console.log(obj.x); // 10
```

**严格模式：** 抛出 TypeError

```javascript
"use strict";
var obj = {};
Object.defineProperty(obj, "x", { value: 10, writable: false });
obj.x = 20; // TypeError: Cannot assign to read only property 'x'
```

### 三、严格模式的其他特性

1. **禁止使用未来保留字作为变量名**
   - 如 `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, `yield`

2. **函数必须在顶层或函数内声明**
   ```javascript
   "use strict";
   if (true) {
     function test() {} // 在某些环境下可能报错
   }
   ```

3. **arguments.callee 和 arguments.caller 不可用**
   ```javascript
   "use strict";
   function test() {
     console.log(arguments.callee); // TypeError
   }
   ```

### 四、严格模式的优势

1. **消除 JavaScript 语法的不合理、不严谨之处**
   - 防止意外创建全局变量
   - 防止删除错误导致的静默失败

2. **提高编译器效率，增加运行速度**
   - 禁用 with 和 eval 泄漏后，作用域链更简单
   - 引擎可以做更多优化

3. **为未来的 JavaScript 版本做铺垫**
   - 保留关键字为未来功能预留空间
   - ES6 模块和 class 默认就是严格模式

4. **增强代码安全性**
   - this 为 undefined 避免意外修改全局对象
   - 禁止访问调用栈信息（arguments.caller）

### 五、实践建议

1. **ES6+ 项目默认使用严格模式**
   - ES6 模块（import/export）自动启用严格模式
   - class 声明内部自动是严格模式

   ```javascript
   // ES6 模块自动严格模式
   export function test() {
     x = 10; // ReferenceError
   }

   // class 内部自动严格模式
   class MyClass {
     constructor() {
       y = 20; // ReferenceError
     }
   }
   ```

2. **旧项目迁移建议**
   - 在文件顶部添加 `"use strict"`
   - 逐步修复报错代码
   - 使用 ESLint 自动检测严格模式问题

3. **避免全局严格模式的坑**
   - 合并第三方非严格模式代码时可能冲突
   - 建议使用 IIFE 或模块化方案隔离

   ```javascript
   (function() {
     "use strict";
     // 你的代码
   })();
   ```

### 六、面试高频问题

**Q: 为什么 ES6 模块和 class 默认使用严格模式？**

A: ES6 设计时认为严格模式更符合现代 JavaScript 开发的最佳实践，能避免很多历史遗留问题。模块和 class 是新特性，没有向后兼容包袱，因此默认采用严格模式，强制开发者编写更规范的代码。

**Q: 严格模式能被关闭吗？**

A: 不能。一旦启用严格模式，无法在同一作用域内关闭。但可以通过函数作用域隔离：

```javascript
"use strict";
function strictFunc() {
  // 严格模式
}

(function() {
  // 这里依然是严格模式（继承自外部）
  // 无法关闭
})();
```

**Q: 严格模式会影响性能吗？**

A: 通常会小幅提升性能。因为禁用了 with、eval 泄漏等特性，JavaScript 引擎可以做更多优化。但性能提升有限，主要价值在于代码质量和安全性。

### 七、总结对比表

| 特性 | 非严格模式 | 严格模式 |
|------|-----------|---------|
| 未声明变量 | 自动创建全局变量 | 抛出 ReferenceError |
| 函数 this | window/global | undefined |
| 删除变量/函数 | 静默失败 | 抛出 SyntaxError |
| 重复参数 | 允许 | 抛出 SyntaxError |
| 八进制字面量 | 支持 0 前缀 | 禁止（需用 0o） |
| eval 作用域 | 泄漏到外部 | 独立作用域 |
| with 语句 | 允许 | 禁止 |
| 只读属性赋值 | 静默失败 | 抛出 TypeError |
| arguments.callee | 可用 | 禁止 |

---

**参考资料：**
- MDN: Strict mode - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode
- ECMAScript 5.1 规范 - Annex C
- 《你不知道的 JavaScript（中卷）》- 附录 B
