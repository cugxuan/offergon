---
title: JavaScript 的深拷贝和浅拷贝实现
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: deep-copy-shallow-copy-javascript
ref:
---

## 核心要点

1. **浅拷贝**:只复制第一层属性,引用类型属性仍共享同一内存地址
2. **深拷贝**:递归复制所有层级,创建完全独立的副本
3. **浅拷贝方法**:`Object.assign()`、扩展运算符(`...`)、`Array.prototype.slice()`
4. **深拷贝方法**:`JSON.parse(JSON.stringify())`、递归实现、`structuredClone()`、第三方库(lodash.cloneDeep)

---

## 详细解答

### 一、浅拷贝(Shallow Copy)

#### 1. 概念理解

浅拷贝创建一个新对象,将原对象的属性值复制到新对象中。对于**原始类型**(number、string、boolean 等)的值,直接复制值本身;对于**引用类型**(对象、数组)的值,只复制引用地址,不复制实际内容。

```javascript
// 浅拷贝的问题
const original = {
  name: '张三',           // 原始类型
  age: 25,                // 原始类型
  address: {              // 引用类型(嵌套对象)
    city: '北京',
    district: '海淀区'
  },
  hobbies: ['读书', '跑步']  // 引用类型(数组)
};

// 浅拷贝
const shallowCopy = { ...original };

// 修改第一层原始类型 - 互不影响
shallowCopy.name = '李四';
console.log(original.name);  // '张三' (未改变)
console.log(shallowCopy.name); // '李四'

// 修改嵌套对象 - 相互影响(共享同一地址)
shallowCopy.address.city = '上海';
console.log(original.address.city);  // '上海' (被修改了!)
console.log(shallowCopy.address.city); // '上海'

// 修改数组 - 相互影响
shallowCopy.hobbies.push('游泳');
console.log(original.hobbies);  // ['读书', '跑步', '游泳'] (被修改了!)
console.log(shallowCopy.hobbies); // ['读书', '跑步', '游泳']
```

**原理图解**:

```
浅拷贝:
original        shallowCopy
   ↓                 ↓
{                {
  name: '张三'     name: '张三'     (独立的值)
  address: ───→    address: ───→   (指向同一个对象)
            ↓                 ↓
          { city: '北京' }
}                }
```

#### 2. 浅拷贝的实现方法

**方法1:扩展运算符(...) - 推荐**

```javascript
// 对象浅拷贝
const obj = { a: 1, b: { c: 2 } };
const copy1 = { ...obj };

// 数组浅拷贝
const arr = [1, 2, [3, 4]];
const copy2 = [...arr];
```

**方法2:Object.assign()**

```javascript
// 语法:Object.assign(target, ...sources)
const obj = { a: 1, b: { c: 2 } };
const copy = Object.assign({}, obj);

// 合并多个对象
const merged = Object.assign({}, obj1, obj2, obj3);
```

**方法3:Array.prototype.slice()**

```javascript
// 仅适用于数组
const arr = [1, 2, [3, 4]];
const copy = arr.slice();

// 等价于
const copy2 = arr.slice(0);
```

**方法4:Array.prototype.concat()**

```javascript
const arr = [1, 2, [3, 4]];
const copy = arr.concat();

// 或合并数组
const copy2 = [].concat(arr);
```

**方法5:手动实现浅拷贝**

```javascript
function shallowClone(obj) {
  // 处理非对象类型
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  // 区分数组和对象
  const clone = Array.isArray(obj) ? [] : {};

  // 复制第一层属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = obj[key];
    }
  }

  return clone;
}

// 测试
const original = {
  name: '张三',
  age: 25,
  address: { city: '北京' }
};

const copy = shallowClone(original);
copy.address.city = '上海';
console.log(original.address.city); // '上海' (被影响)
```

#### 3. 浅拷贝的应用场景

```javascript
// 场景1:合并对象配置
const defaultConfig = {
  timeout: 3000,
  retries: 3,
  cache: true
};

const userConfig = {
  timeout: 5000,
  debug: true
};

// 合并配置(浅拷贝足够)
const finalConfig = { ...defaultConfig, ...userConfig };
// { timeout: 5000, retries: 3, cache: true, debug: true }

// 场景2:React/Vue 中的状态更新
const state = { count: 0, user: { name: '张三' } };

// 更新状态需要创建新对象(浅拷贝)
const newState = { ...state, count: state.count + 1 };

// 场景3:数组的简单复制
const items = ['apple', 'banana', 'orange'];
const itemsCopy = [...items]; // 快速复制
```

### 二、深拷贝(Deep Copy)

#### 1. 概念理解

深拷贝会递归地复制所有层级的属性,创建一个完全独立的新对象,任何层级的修改都不会相互影响。

```javascript
const original = {
  name: '张三',
  address: {
    city: '北京',
    detail: {
      street: '中关村大街',
      number: 1
    }
  },
  hobbies: ['读书', ['编程', 'JavaScript']]
};

// 深拷贝(假设使用某种深拷贝方法)
const deepCopy = deepClone(original);

// 修改任何层级都互不影响
deepCopy.address.detail.street = '海淀路';
deepCopy.hobbies[1][0] = 'Java';

console.log(original.address.detail.street); // '中关村大街' (未改变)
console.log(original.hobbies[1][0]); // '编程' (未改变)
```

**原理图解**:

```
深拷贝:
original                    deepCopy
   ↓                           ↓
{                           {
  address: ──→ {obj1}         address: ──→ {obj2} (新对象)
               ↓                           ↓
            {detail: ──→ {obj3}         {detail: ──→ {obj4} (新对象)
}                           }
```

#### 2. 深拷贝的实现方法

**方法1:JSON.parse(JSON.stringify()) - 简单但有限制**

```javascript
const original = {
  name: '张三',
  age: 25,
  address: {
    city: '北京',
    district: '海淀区'
  },
  hobbies: ['读书', '跑步']
};

const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.address.city = '上海';
console.log(original.address.city); // '北京' (未改变)
```

**JSON 方法的局限性**:

```javascript
const obj = {
  // ✅ 支持的类型
  string: 'text',
  number: 123,
  boolean: true,
  null: null,
  array: [1, 2, 3],
  nested: { a: { b: 1 } },

  // ❌ 不支持的类型
  undefined: undefined,        // 丢失
  symbol: Symbol('id'),        // 丢失
  function: () => {},          // 丢失
  date: new Date(),            // 变成字符串
  regexp: /test/g,             // 变成空对象 {}
  map: new Map([['a', 1]]),    // 变成空对象 {}
  set: new Set([1, 2, 3]),     // 变成空对象 {}

  // ❌ 特殊情况
  circular: null               // 循环引用会报错
};

obj.circular = obj; // 循环引用

const copy = JSON.parse(JSON.stringify(obj));

console.log(copy.undefined);  // undefined (属性丢失)
console.log(copy.function);   // undefined (属性丢失)
console.log(copy.date);       // 字符串 "2025-10-11T..."
console.log(copy.regexp);     // {} (空对象)

// 循环引用会抛出错误
// Uncaught TypeError: Converting circular structure to JSON
```

**方法2:structuredClone() - 现代浏览器推荐**

这是 HTML 标准提供的新 API,支持更多类型。

```javascript
const original = {
  name: '张三',
  date: new Date(),
  regexp: /test/gi,
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3]),
  buffer: new ArrayBuffer(8),
  nested: {
    deep: {
      value: 123
    }
  }
};

// 使用 structuredClone
const deepCopy = structuredClone(original);

deepCopy.nested.deep.value = 999;
console.log(original.nested.deep.value); // 123 (未改变)
console.log(deepCopy.date instanceof Date); // true (保持类型)
console.log(deepCopy.map instanceof Map); // true (保持类型)
```

**structuredClone 的限制**:

```javascript
const obj = {
  // ✅ 支持
  date: new Date(),
  regexp: /test/,
  map: new Map(),
  set: new Set(),
  arrayBuffer: new ArrayBuffer(8),
  typedArray: new Uint8Array([1, 2, 3]),

  // ❌ 不支持
  function: () => {},          // 抛出 DataCloneError
  symbol: Symbol('id'),        // 抛出 DataCloneError
  domNode: document.body,      // 抛出 DataCloneError
  error: new Error('test')     // 部分支持
};

// 函数、Symbol、DOM 节点会报错
// Uncaught DOMException: Failed to execute 'structuredClone'
```

**方法3:递归实现完整版深拷贝**

```javascript
function deepClone(obj, hash = new WeakMap()) {
  // 1. 处理 null 和 undefined
  if (obj === null) return null;
  if (obj === undefined) return undefined;

  // 2. 处理原始类型
  if (typeof obj !== 'object') return obj;

  // 3. 处理 Date
  if (obj instanceof Date) return new Date(obj);

  // 4. 处理 RegExp
  if (obj instanceof RegExp) return new RegExp(obj);

  // 5. 处理循环引用
  if (hash.has(obj)) return hash.get(obj);

  // 6. 处理数组和对象
  // 创建新对象,保持原型链
  const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));

  // 存储到 hash 中,解决循环引用
  hash.set(obj, clone);

  // 7. 处理 Symbol 作为 key 的情况
  const keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];

  for (const key of keys) {
    // 递归复制每个属性
    clone[key] = deepClone(obj[key], hash);
  }

  return clone;
}

// 测试基本功能
const original = {
  // 原始类型
  string: 'text',
  number: 123,
  boolean: true,
  null: null,
  undefined: undefined,

  // 特殊对象
  date: new Date('2025-10-11'),
  regexp: /test/gi,

  // 嵌套结构
  nested: {
    deep: {
      value: 'nested value'
    }
  },

  // 数组
  array: [1, 2, [3, 4]],

  // Symbol 键
  [Symbol('id')]: 'symbol-value'
};

// 循环引用
original.self = original;

const copy = deepClone(original);

// 验证
console.log(copy.nested.deep.value); // 'nested value'
console.log(copy.date instanceof Date); // true
console.log(copy.regexp instanceof RegExp); // true
console.log(copy.self === copy); // true (循环引用正确处理)
console.log(copy === original); // false (不同对象)

// 修改不影响原对象
copy.nested.deep.value = 'changed';
console.log(original.nested.deep.value); // 'nested value' (未改变)
```

**方法4:增强版深拷贝(处理更多类型)**

```javascript
function deepCloneAdvanced(obj, hash = new WeakMap()) {
  // null 或 undefined
  if (obj == null) return obj;

  // 原始类型
  if (typeof obj !== 'object') return obj;

  // 循环引用
  if (hash.has(obj)) return hash.get(obj);

  // 特殊对象类型
  const Constructor = obj.constructor;

  switch (Constructor) {
    case Date:
      return new Date(obj);

    case RegExp:
      const flags = /\w+$/.exec(obj) || '';
      return new RegExp(obj.source, flags[0]);

    case Map:
      const mapClone = new Map();
      hash.set(obj, mapClone);
      obj.forEach((value, key) => {
        mapClone.set(deepCloneAdvanced(key, hash), deepCloneAdvanced(value, hash));
      });
      return mapClone;

    case Set:
      const setClone = new Set();
      hash.set(obj, setClone);
      obj.forEach(value => {
        setClone.add(deepCloneAdvanced(value, hash));
      });
      return setClone;

    case ArrayBuffer:
      return obj.slice(0);

    case Int8Array:
    case Uint8Array:
    case Uint8ClampedArray:
    case Int16Array:
    case Uint16Array:
    case Int32Array:
    case Uint32Array:
    case Float32Array:
    case Float64Array:
      return new Constructor(obj);
  }

  // 数组或普通对象
  const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  hash.set(obj, clone);

  // 拷贝所有可枚举属性(包括 Symbol)
  Reflect.ownKeys(obj).forEach(key => {
    clone[key] = deepCloneAdvanced(obj[key], hash);
  });

  return clone;
}

// 测试
const testObj = {
  map: new Map([['key1', { nested: 'value' }]]),
  set: new Set([1, 2, { obj: 'in set' }]),
  buffer: new ArrayBuffer(8),
  typedArray: new Uint8Array([1, 2, 3]),
  nested: {
    array: [1, 2, { deep: 'value' }]
  }
};

const cloned = deepCloneAdvanced(testObj);

console.log(cloned.map instanceof Map); // true
console.log(cloned.map.get('key1')); // { nested: 'value' }
console.log(cloned.map.get('key1') === testObj.map.get('key1')); // false (深拷贝)
```

**方法5:使用第三方库(lodash.cloneDeep)**

```javascript
// 安装:npm install lodash
import _ from 'lodash';

const original = {
  a: 1,
  b: { c: { d: 2 } },
  e: [1, 2, { f: 3 }],
  date: new Date(),
  func: () => {},  // lodash 也无法拷贝函数
};

const deepCopy = _.cloneDeep(original);

deepCopy.b.c.d = 999;
console.log(original.b.c.d); // 2 (未改变)
```

### 三、深拷贝的关键问题处理

#### 1. 循环引用处理

```javascript
// 问题:循环引用导致无限递归
const obj = { name: '张三' };
obj.self = obj; // 循环引用

// 解决方案:使用 WeakMap 记录已拷贝对象
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  // 检查是否已拷贝过
  if (hash.has(obj)) {
    return hash.get(obj); // 返回已拷贝的对象
  }

  const clone = Array.isArray(obj) ? [] : {};

  // 存储映射关系
  hash.set(obj, clone);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], hash);
    }
  }

  return clone;
}

// 测试
const original = { name: '张三' };
original.self = original;
original.nested = { parent: original };

const copy = deepClone(original);
console.log(copy.self === copy); // true
console.log(copy.nested.parent === copy); // true
console.log(copy === original); // false
```

**为什么用 WeakMap**:

```javascript
// WeakMap vs Map

// 使用 Map:即使原对象被回收,Map 仍持有引用(内存泄漏)
function badDeepClone(obj, hash = new Map()) {
  // ...
}

// 使用 WeakMap:原对象回收时,WeakMap 中的条目自动删除
function goodDeepClone(obj, hash = new WeakMap()) {
  // ...
}
```

#### 2. 原型链处理

```javascript
// 保持原型链
function deepCloneWithProto(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (hash.has(obj)) {
    return hash.get(obj);
  }

  // 使用 Object.create 保持原型链
  const clone = Array.isArray(obj)
    ? []
    : Object.create(Object.getPrototypeOf(obj));

  hash.set(obj, clone);

  // 使用 Reflect.ownKeys 获取所有属性(包括 Symbol)
  Reflect.ownKeys(obj).forEach(key => {
    clone[key] = deepCloneWithProto(obj[key], hash);
  });

  return clone;
}

// 测试
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log(`Hi, I'm ${this.name}`);
  }
}

const person = new Person('张三');
const cloned = deepCloneWithProto(person);

console.log(cloned instanceof Person); // true (保持原型)
cloned.sayHi(); // "Hi, I'm 张三" (方法可用)
```

#### 3. 不可枚举属性处理

```javascript
function deepCloneAll(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (hash.has(obj)) {
    return hash.get(obj);
  }

  const clone = Array.isArray(obj)
    ? []
    : Object.create(Object.getPrototypeOf(obj));

  hash.set(obj, clone);

  // 获取所有属性描述符(包括不可枚举属性)
  const descriptors = Object.getOwnPropertyDescriptors(obj);

  for (let key in descriptors) {
    const descriptor = descriptors[key];

    if (descriptor.value !== undefined) {
      descriptor.value = deepCloneAll(descriptor.value, hash);
    }

    // 定义属性,保留原属性特性
    Object.defineProperty(clone, key, descriptor);
  }

  return clone;
}

// 测试
const obj = {};
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false,  // 不可枚举
  writable: true,
  configurable: true
});

const cloned = deepCloneAll(obj);
console.log(cloned.hidden); // 'secret' (保留了不可枚举属性)
console.log(Object.keys(cloned)); // [] (仍然不可枚举)
```

### 四、性能对比与选择建议

#### 1. 性能测试

```javascript
function performanceTest() {
  // 创建测试数据
  const createTestData = () => ({
    string: 'test',
    number: 123,
    array: Array.from({ length: 1000 }, (_, i) => i),
    nested: {
      level1: {
        level2: {
          level3: {
            data: Array.from({ length: 100 }, (_, i) => ({ id: i }))
          }
        }
      }
    }
  });

  const data = createTestData();

  // 测试 JSON 方法
  console.time('JSON.parse(JSON.stringify())');
  for (let i = 0; i < 1000; i++) {
    JSON.parse(JSON.stringify(data));
  }
  console.timeEnd('JSON.parse(JSON.stringify())');

  // 测试 structuredClone
  console.time('structuredClone');
  for (let i = 0; i < 1000; i++) {
    structuredClone(data);
  }
  console.timeEnd('structuredClone');

  // 测试递归实现
  console.time('deepClone (recursive)');
  for (let i = 0; i < 1000; i++) {
    deepClone(data);
  }
  console.timeEnd('deepClone (recursive)');
}

// 典型结果:
// JSON.parse(JSON.stringify()): ~50ms (最快,但有限制)
// structuredClone: ~80ms (较快,支持更多类型)
// deepClone (recursive): ~150ms (最慢,但最灵活)
```

#### 2. 方法选择建议

```javascript
// 决策树
function chooseCopyMethod(data) {
  // 1. 简单数据(无函数、Date、RegExp 等特殊类型)
  //    且数据量大 → JSON 方法(最快)
  if (isSimpleData(data)) {
    return JSON.parse(JSON.stringify(data));
  }

  // 2. 现代浏览器环境,有 Date、Map、Set 等类型
  //    且无函数 → structuredClone(推荐)
  if (typeof structuredClone === 'function') {
    return structuredClone(data);
  }

  // 3. 需要拷贝函数、处理复杂原型链
  //    或需要自定义拷贝逻辑 → 递归实现
  return deepClone(data);

  // 4. 生产环境,追求稳定性 → lodash.cloneDeep
  // return _.cloneDeep(data);
}

function isSimpleData(obj) {
  // 检查是否只包含简单类型
  // 实现略...
}
```

### 五、实际应用场景

#### 1. React/Vue 状态管理

```javascript
// React 中的不可变更新
class TodoList extends React.Component {
  state = {
    todos: [
      { id: 1, text: '学习', completed: false }
    ]
  };

  toggleTodo = (id) => {
    // 深拷贝后修改
    const newTodos = deepClone(this.state.todos);
    const todo = newTodos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;
    }

    this.setState({ todos: newTodos });
  };
}

// 更好的方式:使用 map (浅拷贝 + 不可变更新)
toggleTodo = (id) => {
  this.setState({
    todos: this.state.todos.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    )
  });
};
```

#### 2. 表单数据备份与重置

```javascript
class FormComponent {
  constructor() {
    this.originalData = null;
    this.formData = {
      username: '',
      profile: {
        age: 0,
        address: {
          city: '',
          street: ''
        }
      }
    };
  }

  // 开始编辑时备份
  startEdit(data) {
    this.formData = deepClone(data);
    this.originalData = deepClone(data); // 保存原始数据
  }

  // 重置表单
  reset() {
    this.formData = deepClone(this.originalData);
  }

  // 检查是否修改
  hasChanges() {
    return JSON.stringify(this.formData) !== JSON.stringify(this.originalData);
  }
}
```

#### 3. 防止对象污染

```javascript
// API 响应数据处理
async function fetchUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  const userData = await response.json();

  // 深拷贝防止污染原始数据
  const processedData = deepClone(userData);

  // 安全地进行数据转换
  processedData.fullName = `${processedData.firstName} ${processedData.lastName}`;
  processedData.age = calculateAge(processedData.birthday);

  return processedData;
  // 原始 userData 未被修改
}
```

#### 4. 撤销/重做功能

```javascript
class HistoryManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }

  // 保存状态
  saveState(state) {
    // 删除当前位置之后的历史
    this.history = this.history.slice(0, this.currentIndex + 1);

    // 深拷贝保存
    this.history.push(deepClone(state));
    this.currentIndex++;
  }

  // 撤销
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return deepClone(this.history[this.currentIndex]);
    }
    return null;
  }

  // 重做
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      return deepClone(this.history[this.currentIndex]);
    }
    return null;
  }
}

// 使用示例
const history = new HistoryManager();
let canvas = { shapes: [] };

// 绘制形状
canvas.shapes.push({ type: 'circle', x: 100, y: 100 });
history.saveState(canvas);

canvas.shapes.push({ type: 'rect', x: 200, y: 200 });
history.saveState(canvas);

// 撤销
canvas = history.undo();
console.log(canvas.shapes.length); // 1
```

### 六、面试回答模板

**简洁版**:

深拷贝和浅拷贝的区别在于拷贝的层级深度:

**浅拷贝**只复制对象的第一层属性,对于嵌套的引用类型仍然共享内存地址。常用方法有扩展运算符、`Object.assign()`、`Array.slice()`等。

**深拷贝**会递归复制所有层级,创建完全独立的副本。常用方法有:
1. `JSON.parse(JSON.stringify())` - 简单但不支持函数、Date、RegExp 等类型
2. `structuredClone()` - 现代浏览器推荐,支持更多类型
3. 递归实现 - 最灵活,需要处理循环引用问题

实现深拷贝的关键是使用 `WeakMap` 解决循环引用,用 `Reflect.ownKeys` 处理 Symbol 键。

**详细版**:

深拷贝和浅拷贝是 JavaScript 中对象复制的两种方式:

**浅拷贝**创建一个新对象,将原对象的第一层属性值复制过去。对于原始类型的值会直接复制,但对于引用类型的值只复制引用地址,导致嵌套对象仍然共享同一内存空间。常见实现方式包括扩展运算符 `{...obj}`、`Object.assign()`、以及数组的 `slice()` 和 `concat()` 方法。

**深拷贝**则递归地复制对象的所有层级,创建一个完全独立的副本,任何层级的修改都不会相互影响。主要实现方式有:

1. `JSON.parse(JSON.stringify())` 是最简单的方法,但有明显局限:无法处理函数、undefined、Symbol,会丢失 Date、RegExp 等类型,且不支持循环引用

2. `structuredClone()` 是 HTML 标准提供的新 API,支持 Date、Map、Set、ArrayBuffer 等更多类型,但仍不支持函数和 DOM 节点

3. 手动递归实现是最灵活的方案,核心要点包括:
   - 使用 `WeakMap` 存储已拷贝对象来解决循环引用
   - 用 `Reflect.ownKeys()` 获取包括 Symbol 在内的所有属性
   - 针对 Date、RegExp、Map、Set 等特殊类型分别处理
   - 使用 `Object.create(Object.getPrototypeOf(obj))` 保持原型链

在性能方面,JSON 方法最快,structuredClone 次之,递归实现最慢但最灵活。实际开发中,简单数据用 JSON 方法,现代项目推荐 structuredClone,需要拷贝函数或复杂场景用递归实现,生产环境可以使用 lodash 的 `cloneDeep` 确保稳定性。

深拷贝常用于 React/Vue 的状态管理、表单数据备份、撤销重做功能等场景,确保数据的不可变性和独立性。
