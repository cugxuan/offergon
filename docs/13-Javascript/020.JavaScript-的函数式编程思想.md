---
title: JavaScript 的函数式编程思想
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-functional-programming-concepts
ref:
---

## 核心要点

1. **核心理念**:函数是一等公民,强调声明式编程、数据不可变、无副作用
2. **关键概念**:纯函数、高阶函数、柯里化、函数组合、不可变数据
3. **优势**:代码可预测、易测试、易维护、支持并发、便于调试
4. **应用**:React/Redux、数据处理管道、状态管理、工具库(Ramda/Lodash)

---

## 详细解答

### 一、函数式编程基本概念

#### 1. 什么是函数式编程

函数式编程(Functional Programming, FP)是一种**编程范式**,它将计算过程视为数学函数的求值,强调使用函数来构建程序,避免改变状态和可变数据。

**核心思想**:
- 函数是一等公民(First-Class Functions)
- 声明式编程而非命令式
- 数据不可变(Immutability)
- 避免副作用(Side Effects)
- 函数组合(Function Composition)

```javascript
// 命令式编程(Imperative):描述"怎么做"
const numbers = [1, 2, 3, 4, 5];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}
console.log(sum); // 15

// 函数式编程(Functional):描述"做什么"
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15

// 更清晰的声明式写法
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 表达意图:将数组归约为一个和
```

#### 2. 函数是一等公民

在 JavaScript 中,函数是一等公民,意味着函数可以:

```javascript
// 1. 赋值给变量
const greet = function(name) {
  return `Hello, ${name}`;
};

// 2. 作为参数传递
function executeFunc(fn, value) {
  return fn(value);
}
executeFunc(greet, 'Alice'); // "Hello, Alice"

// 3. 作为返回值
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}
const double = createMultiplier(2);
double(5); // 10

// 4. 存储在数据结构中
const operations = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
  divide: (a, b) => a / b
};

operations.add(10, 5); // 15

// 5. 拥有属性和方法
function myFunc() {}
myFunc.description = 'My custom function';
console.log(myFunc.description); // "My custom function"
```

#### 3. 声明式 vs 命令式

```javascript
// 命令式:关注过程,逐步告诉计算机怎么做
function imperativeFilter(arr) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] % 2 === 0) {
      result.push(arr[i]);
    }
  }
  return result;
}

// 声明式:关注结果,描述想要什么
function declarativeFilter(arr) {
  return arr.filter(n => n % 2 === 0);
}

// 实际应用对比
const users = [
  { name: 'Alice', age: 25, active: true },
  { name: 'Bob', age: 30, active: false },
  { name: 'Charlie', age: 35, active: true }
];

// 命令式:获取活跃用户名
function getActiveUserNamesImperative(users) {
  const result = [];
  for (let i = 0; i < users.length; i++) {
    if (users[i].active) {
      result.push(users[i].name);
    }
  }
  return result;
}

// 声明式:获取活跃用户名
const getActiveUserNamesDeclarative = users =>
  users
    .filter(user => user.active)
    .map(user => user.name);

console.log(getActiveUserNamesDeclarative(users)); // ['Alice', 'Charlie']
```

### 二、函数式编程核心概念

#### 1. 纯函数(Pure Functions)

纯函数是函数式编程的基石,满足两个条件:
1. **相同输入总是返回相同输出**(引用透明性)
2. **没有副作用**

```javascript
// ✅ 纯函数
function add(a, b) {
  return a + b;
}

add(2, 3); // 5
add(2, 3); // 5 (总是返回相同结果)

function multiply(arr, factor) {
  return arr.map(n => n * factor); // 不修改原数组
}

// ❌ 非纯函数(有副作用)
let count = 0;
function incrementImpure() {
  count++; // 修改外部变量(副作用)
  return count;
}

incrementImpure(); // 1
incrementImpure(); // 2 (相同调用,不同结果)

// ❌ 非纯函数(修改参数)
function addItemImpure(arr, item) {
  arr.push(item); // 修改了原数组(副作用)
  return arr;
}

// ✅ 纯函数版本
function addItem(arr, item) {
  return [...arr, item]; // 返回新数组,不修改原数组
}

// 纯函数的优势
const numbers = [1, 2, 3];

// 可预测性
console.log(add(5, 10)); // 总是 15
console.log(add(5, 10)); // 总是 15

// 可测试性
test('add function', () => {
  expect(add(2, 3)).toBe(5);
  expect(add(-1, 1)).toBe(0);
  expect(add(0, 0)).toBe(0);
});

// 可缓存(Memoization)
function memoize(fn) {
  const cache = {};
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache[key]) {
      console.log('从缓存返回');
      return cache[key];
    }
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const expensiveAdd = memoize(add);
expensiveAdd(2, 3); // 计算
expensiveAdd(2, 3); // 从缓存返回
```

**副作用(Side Effects)的常见形式**:

```javascript
// 1. 修改全局变量
let globalVar = 0;
function hasSideEffect1() {
  globalVar++; // ❌ 副作用
}

// 2. 修改参数
function hasSideEffect2(obj) {
  obj.value = 10; // ❌ 副作用
}

// 3. 发起网络请求
function hasSideEffect3() {
  fetch('/api/data'); // ❌ 副作用
}

// 4. 操作 DOM
function hasSideEffect4() {
  document.body.innerHTML = 'text'; // ❌ 副作用
}

// 5. 打印日志
function hasSideEffect5(x) {
  console.log(x); // ❌ 副作用(I/O 操作)
  return x * 2;
}

// 6. 抛出异常
function hasSideEffect6(x) {
  if (x < 0) throw new Error('Negative'); // ❌ 副作用
  return x;
}

// 7. 使用随机数或时间
function hasSideEffect7() {
  return Math.random(); // ❌ 副作用(不可预测)
}

function hasSideEffect8() {
  return new Date(); // ❌ 副作用(每次不同)
}
```

**实际开发中如何处理副作用**:

```javascript
// 策略:将副作用推到边界
// 核心逻辑使用纯函数,在边界处理副作用

// ✅ 纯函数处理核心逻辑
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

function applyDiscount(total, discountPercent) {
  return total * (1 - discountPercent / 100);
}

function formatPrice(price) {
  return `$${price.toFixed(2)}`;
}

// ❌ 副作用在边界处理
function displayTotal(items, discount) {
  // 纯函数计算
  const total = calculateTotal(items);
  const discounted = applyDiscount(total, discount);
  const formatted = formatPrice(discounted);

  // 副作用(DOM 操作)在最后执行
  document.getElementById('total').textContent = formatted;
}

// 更好的方式:分离副作用
function getDisplayTotal(items, discount) {
  // 纯函数
  const total = calculateTotal(items);
  const discounted = applyDiscount(total, discount);
  return formatPrice(discounted);
}

// 副作用由调用者处理
const result = getDisplayTotal(items, 10);
document.getElementById('total').textContent = result; // 副作用
```

#### 2. 数据不可变(Immutability)

不可变数据是指数据一旦创建就不能被修改,任何"修改"都会产生新的数据副本。

```javascript
// ❌ 可变数据
const person = { name: 'Alice', age: 25 };
person.age = 26; // 直接修改
console.log(person); // { name: 'Alice', age: 26 }

// ✅ 不可变数据
const person = { name: 'Alice', age: 25 };
const updatedPerson = { ...person, age: 26 }; // 创建新对象
console.log(person);        // { name: 'Alice', age: 25 } (未变)
console.log(updatedPerson); // { name: 'Alice', age: 26 }

// 数组的不可变操作
const numbers = [1, 2, 3];

// ❌ 可变操作
numbers.push(4);    // 修改原数组
numbers[0] = 0;     // 修改原数组
numbers.sort();     // 修改原数组

// ✅ 不可变操作
const added = [...numbers, 4];           // 添加元素
const updated = numbers.map((n, i) =>    // 更新元素
  i === 0 ? 0 : n
);
const sorted = [...numbers].sort();      // 排序(先复制)

// 深层嵌套对象的不可变更新
const state = {
  user: {
    profile: {
      name: 'Alice',
      address: {
        city: 'Beijing',
        street: 'Main St'
      }
    }
  }
};

// ❌ 可变更新
state.user.profile.address.city = 'Shanghai';

// ✅ 不可变更新(手动)
const newState = {
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      address: {
        ...state.user.profile.address,
        city: 'Shanghai'
      }
    }
  }
};

// ✅ 使用工具库简化(Immer)
import produce from 'immer';

const newState = produce(state, draft => {
  draft.user.profile.address.city = 'Shanghai';
});

// 不可变数据的优势
// 1. 可预测性
const original = { count: 0 };
const incremented = { ...original, count: original.count + 1 };
console.log(original.count);    // 0 (未改变)
console.log(incremented.count); // 1

// 2. 时间旅行调试(Redux DevTools)
const history = [];
let state = { count: 0 };

history.push(state);
state = { ...state, count: 1 };
history.push(state);
state = { ...state, count: 2 };
history.push(state);

// 可以回到任意历史状态
console.log(history[0]); // { count: 0 }
console.log(history[1]); // { count: 1 }
console.log(history[2]); // { count: 2 }

// 3. 优化性能(React.memo, shouldComponentUpdate)
function shouldUpdate(prevProps, nextProps) {
  // 浅比较即可判断是否变化
  return prevProps.data !== nextProps.data;
}
```

**实现不可变数据结构的工具**:

```javascript
// 1. Object.freeze(浅冻结)
const obj = Object.freeze({ name: 'Alice', age: 25 });
obj.age = 26; // 严格模式下报错,非严格模式下静默失败
console.log(obj.age); // 25

// 2. 深冻结
function deepFreeze(obj) {
  Object.freeze(obj);
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value);
    }
  });
  return obj;
}

const state = deepFreeze({
  user: { name: 'Alice' }
});

// state.user.name = 'Bob'; // 报错

// 3. Immutable.js
import { Map, List } from 'immutable';

const map = Map({ a: 1, b: 2 });
const newMap = map.set('b', 3);

console.log(map.get('b'));    // 2
console.log(newMap.get('b')); // 3

// 4. Immer(推荐)
import produce from 'immer';

const state = { count: 0, user: { name: 'Alice' } };

const newState = produce(state, draft => {
  draft.count++;
  draft.user.name = 'Bob';
});

console.log(state);    // { count: 0, user: { name: 'Alice' } }
console.log(newState); // { count: 1, user: { name: 'Bob' } }
```

#### 3. 高阶函数(Higher-Order Functions)

高阶函数是**接受函数作为参数或返回函数**的函数。

```javascript
// 1. 接受函数作为参数
function map(arr, fn) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(fn(arr[i]));
  }
  return result;
}

map([1, 2, 3], n => n * 2); // [2, 4, 6]

// 2. 返回函数
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const triple = createMultiplier(3);
triple(5); // 15

// 3. 既接受函数又返回函数
function createLogger(prefix) {
  return function(message) {
    console.log(`[${prefix}] ${message}`);
  };
}

const errorLogger = createLogger('ERROR');
errorLogger('Something went wrong'); // [ERROR] Something went wrong

// 常用高阶函数
const numbers = [1, 2, 3, 4, 5];

// map:转换
numbers.map(n => n * 2); // [2, 4, 6, 8, 10]

// filter:筛选
numbers.filter(n => n % 2 === 0); // [2, 4]

// reduce:归约
numbers.reduce((sum, n) => sum + n, 0); // 15

// forEach:遍历(有副作用,不纯)
numbers.forEach(n => console.log(n));

// some:是否有元素满足
numbers.some(n => n > 3); // true

// every:是否所有元素满足
numbers.every(n => n > 0); // true

// find:查找第一个满足的元素
numbers.find(n => n > 3); // 4

// 实际应用:装饰器模式
function withLogging(fn) {
  return function(...args) {
    console.log(`调用 ${fn.name}, 参数:`, args);
    const result = fn(...args);
    console.log(`返回值:`, result);
    return result;
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = withLogging(add);
loggedAdd(2, 3);
// 调用 add, 参数: [2, 3]
// 返回值: 5

// 实际应用:错误处理
function withErrorHandling(fn) {
  return function(...args) {
    try {
      return fn(...args);
    } catch (error) {
      console.error('Error:', error.message);
      return null;
    }
  };
}

const safeParseJSON = withErrorHandling(JSON.parse);
safeParseJSON('{"valid": "json"}'); // { valid: 'json' }
safeParseJSON('invalid json');      // null (不抛出错误)
```

#### 4. 函数组合(Function Composition)

函数组合是将多个函数组合成一个新函数的技术。

```javascript
// compose:从右到左执行
function compose(...fns) {
  return value => fns.reduceRight((acc, fn) => fn(acc), value);
}

// pipe:从左到右执行(更直观)
function pipe(...fns) {
  return value => fns.reduce((acc, fn) => fn(acc), value);
}

// 示例函数
const add10 = x => x + 10;
const multiply2 = x => x * 2;
const subtract5 = x => x - 5;

// compose:从右到左
const composedFn = compose(subtract5, multiply2, add10);
composedFn(5); // (5 + 10) * 2 - 5 = 25

// pipe:从左到右(更符合思维习惯)
const pipedFn = pipe(add10, multiply2, subtract5);
pipedFn(5); // (5 + 10) * 2 - 5 = 25

// 实际应用:数据处理
const users = [
  { name: 'Alice', age: 25, active: true },
  { name: 'Bob', age: 30, active: false },
  { name: 'Charlie', age: 35, active: true },
  { name: 'David', age: 28, active: true }
];

// 定义纯函数
const filterActive = users => users.filter(u => u.active);
const sortByAge = users => [...users].sort((a, b) => a.age - b.age);
const mapToNames = users => users.map(u => u.name);
const joinWithComma = names => names.join(', ');

// 组合函数
const getActiveUserNamesSorted = pipe(
  filterActive,
  sortByAge,
  mapToNames,
  joinWithComma
);

console.log(getActiveUserNamesSorted(users));
// "Alice, David, Charlie"

// 实际应用:字符串处理
const trim = str => str.trim();
const toLowerCase = str => str.toLowerCase();
const splitWords = str => str.split(' ');
const capitalizeFirst = word => word.charAt(0).toUpperCase() + word.slice(1);
const capitalizeWords = words => words.map(capitalizeFirst);
const joinWords = words => words.join(' ');

const titleCase = pipe(
  trim,
  toLowerCase,
  splitWords,
  capitalizeWords,
  joinWords
);

console.log(titleCase('  hello WORLD  ')); // "Hello World"

// 实际应用:表单验证
const isNotEmpty = value => value.trim() !== '';
const isEmail = value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
const isMinLength = min => value => value.length >= min;

function validate(...validators) {
  return value => validators.every(validator => validator(value));
}

const validateEmail = validate(isNotEmpty, isEmail);
const validatePassword = validate(isNotEmpty, isMinLength(8));

console.log(validateEmail('test@example.com')); // true
console.log(validateEmail('invalid'));          // false
console.log(validatePassword('password123'));   // true
console.log(validatePassword('short'));         // false
```

#### 5. 柯里化(Currying)

柯里化是将多参数函数转换为一系列单参数函数的技术(详见第19题)。

```javascript
// 柯里化示例
const curry = fn => {
  return function curried(...args) {
    return args.length >= fn.length
      ? fn.apply(this, args)
      : (...nextArgs) => curried(...args, ...nextArgs);
  };
};

const add = curry((a, b, c) => a + b + c);

add(1)(2)(3);     // 6
add(1, 2)(3);     // 6
add(1)(2, 3);     // 6

// 与函数组合配合
const map = curry((fn, arr) => arr.map(fn));
const filter = curry((predicate, arr) => arr.filter(predicate));
const reduce = curry((fn, initial, arr) => arr.reduce(fn, initial));

const double = x => x * 2;
const isEven = x => x % 2 === 0;
const sum = (acc, x) => acc + x;

const processNumbers = pipe(
  filter(isEven),
  map(double),
  reduce(sum, 0)
);

processNumbers([1, 2, 3, 4, 5]); // 12
```

### 三、函数式编程实践

#### 1. Point-Free 风格

Point-Free(无参数)风格是指函数定义中不显式声明参数。

```javascript
// 非 Point-Free
const getNames = users => users.map(user => user.name);

// Point-Free
const prop = key => obj => obj[key];
const map = fn => arr => arr.map(fn);
const getName = prop('name');
const getNames = map(getName);

// 实际应用
const users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
];

getNames(users); // ['Alice', 'Bob']

// 复杂示例:完全 Point-Free
const filterActive = filter(prop('active'));
const sortByAge = sortBy(prop('age'));
const mapToNames = map(prop('name'));

const getActiveUserNames = pipe(
  filterActive,
  sortByAge,
  mapToNames
);

// 优点:清晰表达意图,无需临时变量
// 缺点:可读性可能降低(需要团队熟悉)
```

#### 2. 递归替代循环

函数式编程偏好递归而非循环。

```javascript
// 循环方式
function sumLoop(arr) {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
    total += arr[i];
  }
  return total;
}

// 递归方式
function sumRecursive(arr) {
  if (arr.length === 0) return 0;
  return arr[0] + sumRecursive(arr.slice(1));
}

// 尾递归优化
function sumTailRecursive(arr, acc = 0) {
  if (arr.length === 0) return acc;
  return sumTailRecursive(arr.slice(1), acc + arr[0]);
}

// 实际应用:树遍历
const tree = {
  value: 1,
  children: [
    {
      value: 2,
      children: [
        { value: 4, children: [] },
        { value: 5, children: [] }
      ]
    },
    {
      value: 3,
      children: [
        { value: 6, children: [] }
      ]
    }
  ]
};

// 递归遍历
function sumTree(node) {
  if (!node) return 0;
  return node.value + node.children.reduce(
    (sum, child) => sum + sumTree(child),
    0
  );
}

console.log(sumTree(tree)); // 21

// 递归查找
function findInTree(node, predicate) {
  if (!node) return null;
  if (predicate(node)) return node;

  for (const child of node.children) {
    const found = findInTree(child, predicate);
    if (found) return found;
  }

  return null;
}

const node5 = findInTree(tree, node => node.value === 5);
console.log(node5); // { value: 5, children: [] }
```

#### 3. 延迟求值(Lazy Evaluation)

延迟求值是指只在需要时才计算值。

```javascript
// 惰性序列
function* lazyRange(start, end) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}

// 只在迭代时才生成值
const numbers = lazyRange(1, 1000000);

for (const n of numbers) {
  console.log(n);
  if (n >= 5) break; // 只生成了 1-5,不会生成全部
}

// 惰性 map
function* lazyMap(iterable, fn) {
  for (const item of iterable) {
    yield fn(item);
  }
}

// 惰性 filter
function* lazyFilter(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) {
      yield item;
    }
  }
}

// 惰性链式调用
const result = lazyFilter(
  lazyMap(lazyRange(1, 100), n => n * 2),
  n => n % 4 === 0
);

// 只在需要时计算
for (const n of result) {
  console.log(n); // 4, 8, 12, ...
  if (n >= 20) break;
}

// 实际应用:无限序列
function* fibonacci() {
  let [a, b] = [0, 1];
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fibs = fibonacci();
console.log(fibs.next().value); // 0
console.log(fibs.next().value); // 1
console.log(fibs.next().value); // 1
console.log(fibs.next().value); // 2
console.log(fibs.next().value); // 3
```

### 四、函数式编程在 JavaScript 中的应用

#### 1. React 函数式组件

```javascript
// 函数式组件:纯函数,相同 props 返回相同 UI
function UserCard({ user }) {
  return (
    <div className="card">
      <h2>{user.name}</h2>
      <p>Age: {user.age}</p>
    </div>
  );
}

// 高阶组件:接受组件返回组件
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) return <Spinner />;
    return <Component {...props} />;
  };
}

const UserCardWithLoading = withLoading(UserCard);

// Hooks:函数式状态管理
function Counter() {
  const [count, setCount] = useState(0);

  // 纯函数更新状态
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);

  return (
    <div>
      <button onClick={decrement}>-</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  );
}

// 自定义 Hook:复用逻辑
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

#### 2. Redux 状态管理

```javascript
// Reducer:纯函数,相同输入返回相同输出
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

// Selector:纯函数,从 state 派生数据
const selectCount = state => state.counter.count;
const selectDoubleCount = state => selectCount(state) * 2;

// Middleware:函数组合
const logger = store => next => action => {
  console.log('dispatching', action);
  const result = next(action);
  console.log('next state', store.getState());
  return result;
};

const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

// 组合 Reducer
function combineReducers(reducers) {
  return (state = {}, action) => {
    return Object.keys(reducers).reduce((nextState, key) => {
      nextState[key] = reducers[key](state[key], action);
      return nextState;
    }, {});
  };
}

const rootReducer = combineReducers({
  counter: counterReducer,
  user: userReducer
});
```

#### 3. RxJS 响应式编程

```javascript
import { fromEvent, interval } from 'rxjs';
import { map, filter, debounceTime, take } from 'rxjs/operators';

// 搜索框输入
const searchBox = document.querySelector('#search');
const search$ = fromEvent(searchBox, 'input').pipe(
  map(event => event.target.value),
  debounceTime(500),
  filter(value => value.length > 2),
  // 发起搜索请求
);

search$.subscribe(value => {
  console.log('搜索:', value);
});

// 点击事件流
const button = document.querySelector('#button');
const clicks$ = fromEvent(button, 'click');

// 双击检测
clicks$.pipe(
  buffer(clicks$.pipe(debounceTime(250))),
  map(list => list.length),
  filter(count => count === 2)
).subscribe(() => {
  console.log('双击');
});

// 定时器
interval(1000).pipe(
  take(5),
  map(n => n + 1)
).subscribe(n => {
  console.log(`倒计时: ${n}`);
});
```

#### 4. 数据处理管道

```javascript
// 复杂数据转换
const rawData = [
  { id: 1, name: 'Alice', score: 85, subject: 'Math', date: '2025-01-01' },
  { id: 2, name: 'Bob', score: 92, subject: 'Math', date: '2025-01-02' },
  { id: 3, name: 'Alice', score: 78, subject: 'English', date: '2025-01-03' },
  { id: 4, name: 'Charlie', score: 88, subject: 'Math', date: '2025-01-04' }
];

// 函数式数据处理
const pipe = (...fns) => value => fns.reduce((acc, fn) => fn(acc), value);

const filterMath = data => data.filter(d => d.subject === 'Math');
const sortByScore = data => [...data].sort((a, b) => b.score - a.b);
const groupByName = data => data.reduce((groups, item) => {
  const name = item.name;
  if (!groups[name]) groups[name] = [];
  groups[name].push(item);
  return groups;
}, {});
const calculateAverage = groups => Object.entries(groups).map(([name, items]) => ({
  name,
  average: items.reduce((sum, item) => sum + item.score, 0) / items.length
}));

const processData = pipe(
  filterMath,
  groupByName,
  calculateAverage,
  data => data.sort((a, b) => b.average - a.average)
);

console.log(processData(rawData));
// [
//   { name: 'Bob', average: 92 },
//   { name: 'Charlie', average: 88 },
//   { name: 'Alice', average: 85 }
// ]
```

### 五、函数式编程的优缺点

#### 1. 优点

```javascript
// 1. 可预测性:纯函数,相同输入总是相同输出
const add = (a, b) => a + b;
add(2, 3); // 总是 5

// 2. 易于测试:不依赖外部状态
test('add function', () => {
  expect(add(2, 3)).toBe(5);
  expect(add(-1, 1)).toBe(0);
});

// 3. 并发安全:不可变数据避免竞态条件
// 多线程环境下安全

// 4. 易于调试:无副作用,不用担心隐式状态变化
const result = pipe(
  step1,
  step2,
  step3
)(data);
// 每一步都可以独立测试和调试

// 5. 代码复用:高阶函数和组合
const double = x => x * 2;
const filterEven = filter(x => x % 2 === 0);

// 复用在不同场景
const doubledEvens = pipe(filterEven, map(double));

// 6. 延迟执行:需要时才计算
const expensiveOperation = pipe(
  step1,
  step2,
  step3
);
// 定义时不执行,调用时才执行
```

#### 2. 缺点

```javascript
// 1. 学习曲线:概念抽象
const getActiveUserNames = pipe(
  filter(prop('active')),
  map(prop('name'))
);
// 需要理解高阶函数、组合等概念

// 2. 性能开销:创建新数据结构
// 每次操作都创建新对象/数组
const updated = { ...state, value: newValue };
const newArr = [...arr, newItem];

// 3. 栈溢出风险:深度递归
function sumRecursive(arr) {
  if (arr.length === 0) return 0;
  return arr[0] + sumRecursive(arr.slice(1));
}
// 大数组可能栈溢出

// 解决方案:尾递归优化或使用循环

// 4. 调试困难:链式调用难以断点
const result = data
  .filter(x => x > 0)
  .map(x => x * 2)
  .reduce((sum, x) => sum + x, 0);
// 链式调用中间状态难以查看

// 解决方案:添加 tap 函数
const tap = fn => value => {
  fn(value);
  return value;
};

const result = pipe(
  filter(x => x > 0),
  tap(console.log), // 查看中间结果
  map(x => x * 2),
  tap(console.log), // 查看中间结果
  reduce((sum, x) => sum + x, 0)
)(data);
```

### 六、函数式编程最佳实践

#### 1. 优先使用纯函数

```javascript
// ❌ 避免
let total = 0;
function addToTotal(value) {
  total += value;
}

// ✅ 推荐
function add(total, value) {
  return total + value;
}

const newTotal = add(total, 5);
```

#### 2. 保持数据不可变

```javascript
// ❌ 避免
function addItem(arr, item) {
  arr.push(item);
  return arr;
}

// ✅ 推荐
function addItem(arr, item) {
  return [...arr, item];
}
```

#### 3. 使用组合而非继承

```javascript
// ❌ 继承
class Animal {
  eat() { console.log('eating'); }
}
class Dog extends Animal {
  bark() { console.log('barking'); }
}

// ✅ 组合
const canEat = state => ({
  eat: () => console.log('eating')
});

const canBark = state => ({
  bark: () => console.log('barking')
});

const Dog = state => ({
  ...canEat(state),
  ...canBark(state)
});
```

#### 4. 将副作用推到边界

```javascript
// ✅ 核心逻辑纯函数
function calculatePrice(items, taxRate) {
  const subtotal = items.reduce((sum, item) => sum + item.price, 0);
  const tax = subtotal * taxRate;
  return subtotal + tax;
}

// 副作用在边界
async function checkout(items, taxRate) {
  // 纯函数计算
  const total = calculatePrice(items, taxRate);

  // 副作用:API 调用
  await fetch('/api/checkout', {
    method: 'POST',
    body: JSON.stringify({ total })
  });

  // 副作用:UI 更新
  updateUI(total);
}
```

### 七、推荐工具库

```javascript
// 1. Ramda:完整的函数式工具库
import R from 'ramda';

const users = [/* ... */];
const getActiveUserNames = R.pipe(
  R.filter(R.prop('active')),
  R.map(R.prop('name')),
  R.join(', ')
);

// 2. Lodash/fp:Lodash 的函数式版本
import { flow, filter, map } from 'lodash/fp';

const getActiveUserNames = flow(
  filter('active'),
  map('name')
);

// 3. Immutable.js:不可变数据结构
import { Map, List } from 'immutable';

const map = Map({ a: 1, b: 2 });
const newMap = map.set('c', 3);

// 4. Immer:简化不可变更新
import produce from 'immer';

const newState = produce(state, draft => {
  draft.user.name = 'Alice';
});
```

### 八、面试回答模板

**简洁版**:

函数式编程是一种编程范式,核心思想是:
1. **函数是一等公民**:可以作为参数传递和返回
2. **纯函数**:相同输入返回相同输出,无副作用
3. **不可变数据**:数据一旦创建不可修改
4. **函数组合**:将小函数组合成大函数

**优势**:代码可预测、易测试、易维护、并发安全。

**应用**:React 组件、Redux reducer、数据处理管道、RxJS 响应式编程。

**详细版**:

函数式编程(FP)是一种将计算过程视为数学函数求值的编程范式,与面向对象编程(OOP)并列为主流编程范式。

**核心理念**包括:

1. **函数是一等公民**:函数可以赋值给变量、作为参数传递、作为返回值,这使得高阶函数成为可能

2. **纯函数**:是 FP 的基石,要求相同输入总是返回相同输出(引用透明性),且没有副作用(不修改外部状态、不进行 I/O 操作)。纯函数的优势是可预测、易测试、可缓存

3. **数据不可变**:任何"修改"都创建新的数据副本,保证原数据不变。这避免了共享可变状态带来的问题,使得时间旅行调试和性能优化成为可能

4. **声明式编程**:关注"做什么"而非"怎么做",如 `arr.filter(isEven)` 比循环更能表达意图

5. **函数组合**:将多个小函数组合成大函数,如 `pipe(step1, step2, step3)`,提高代码复用性

**JavaScript 中的应用**非常广泛:React 推崇函数式组件和 Hooks;Redux 使用纯 reducer 管理状态;RxJS 用函数式处理事件流;Ramda/Lodash 提供函数式工具。

**优势**:代码可预测性强,易于测试(纯函数无需 mock),易于调试(无隐式状态),并发安全(不可变数据),支持代码复用和组合。

**注意事项**:有学习曲线,创建新数据结构有性能开销,深度递归可能栈溢出。实践中要权衡,核心业务逻辑用纯函数,副作用推到边界,适度使用而非教条主义。
