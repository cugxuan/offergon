---
title: Service Worker 和 PWA 应用
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: service-worker-and-pwa
ref:
---

## 核心要点

Service Worker 是独立于网页运行的**后台脚本代理**，是 PWA（渐进式 Web 应用）的核心技术。主要功能：**离线缓存**（Cache API）、**网络请求拦截**（fetch 事件）、**推送通知**、**后台同步**。生命周期包括：**注册 → 安装 → 激活 → 空闲/终止 → 更新**。PWA 特性需满足：**HTTPS**、**manifest.json**、**注册 Service Worker**，实现类原生应用体验（可安装、离线可用、推送通知）。

---

## 详细解答

### 一、Service Worker 概述

#### 1.1 什么是 Service Worker

**Service Worker** 是一种特殊的 Web Worker，充当 Web 应用、浏览器和网络之间的**代理服务器**。它运行在独立的后台线程，可以拦截和处理网络请求，实现离线访问、资源缓存、推送通知等功能。

**核心特点：**
- **独立线程**：不阻塞主线程，无法访问 DOM
- **事件驱动**：响应 install、activate、fetch、push 等事件
- **生命周期管理**：自动休眠和唤醒，节省资源
- **HTTPS 必需**：确保安全（localhost 例外）
- **作用域控制**：基于路径的作用域规则

#### 1.2 Service Worker vs Web Worker

| 特性 | Service Worker | Web Worker |
|------|---------------|-----------|
| **用途** | 网络代理、离线缓存、推送 | 后台计算 |
| **生命周期** | 独立于页面（后台常驻） | 与页面绑定 |
| **作用域** | 多个页面共享 | 单个页面 |
| **网络拦截** | ✅ 支持（fetch 事件） | ❌ 不支持 |
| **持久化** | 可持久化状态 | 页面关闭即销毁 |
| **协议要求** | 必须 HTTPS | 无要求 |

### 二、Service Worker 生命周期

#### 2.1 完整生命周期

```
   注册（Register）
         ↓
   安装（Installing）
         ↓
   等待（Waiting）← 旧版本 Service Worker 仍在使用
         ↓
   激活（Activating）
         ↓
   已激活（Activated）
         ↓
   空闲/终止（Idle/Terminated）
         ↓
   事件触发时唤醒
```

#### 2.2 生命周期事件详解

**1. 注册阶段（Register）**

在主线程中注册 Service Worker：

```javascript
// 主页面 main.js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js', {
    scope: '/' // 作用域，默认为 sw.js 所在目录
  })
  .then(registration => {
    console.log('Service Worker 注册成功:', registration.scope);
  })
  .catch(error => {
    console.error('Service Worker 注册失败:', error);
  });
}
```

**2. 安装阶段（Install）**

首次注册或 Service Worker 文件更新时触发：

```javascript
// sw.js
const CACHE_NAME = 'my-app-v1';
const CACHE_URLS = [
  '/',
  '/index.html',
  '/styles.css',
  '/script.js',
  '/logo.png'
];

self.addEventListener('install', event => {
  console.log('Service Worker 安装中...');

  // 预缓存资源
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
      console.log('缓存文件...');
      return cache.addAll(CACHE_URLS);
    })
  );

  // 跳过等待，立即激活（可选）
  // self.skipWaiting();
});
```

**3. 激活阶段（Activate）**

安装成功后，等待旧版本失效后激活：

```javascript
self.addEventListener('activate', event => {
  console.log('Service Worker 激活中...');

  // 清理旧缓存
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            console.log('删除旧缓存:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );

  // 立即控制所有页面（可选）
  // return self.clients.claim();
});
```

**4. 拦截请求（Fetch）**

激活后拦截所有网络请求：

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      // 缓存命中则返回，否则请求网络
      return cachedResponse || fetch(event.request);
    })
  );
});
```

#### 2.3 更新机制

```javascript
// 检测到新 Service Worker 时
navigator.serviceWorker.register('/sw.js').then(registration => {
  registration.addEventListener('updatefound', () => {
    const newWorker = registration.installing;
    console.log('发现新 Service Worker');

    newWorker.addEventListener('statechange', () => {
      if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
        // 新版本已安装，但旧版本仍在控制页面
        console.log('新内容可用，请刷新页面');
        // 可以提示用户刷新
      }
    });
  });
});
```

### 三、缓存策略

#### 3.1 缓存优先（Cache First）

优先从缓存读取，缓存未命中时请求网络。适合静态资源。

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      return cachedResponse || fetch(event.request);
    })
  );
});
```

#### 3.2 网络优先（Network First）

优先请求网络，失败时回退到缓存。适合动态内容。

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(networkResponse => {
        // 网络请求成功，更新缓存
        const responseClone = networkResponse.clone();
        caches.open(CACHE_NAME).then(cache => {
          cache.put(event.request, responseClone);
        });
        return networkResponse;
      })
      .catch(() => {
        // 网络失败，返回缓存
        return caches.match(event.request);
      })
  );
});
```

#### 3.3 仅缓存（Cache Only）

只返回缓存，不请求网络。适合完全离线场景。

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(caches.match(event.request));
});
```

#### 3.4 仅网络（Network Only）

只请求网络，不使用缓存。适合实时性要求高的 API。

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(fetch(event.request));
});
```

#### 3.5 Stale-While-Revalidate（陈旧内容同时重新验证）

返回缓存（即使过期），同时在后台更新缓存。适合需要快速响应的资源。

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return cache.match(event.request).then(cachedResponse => {
        // 后台更新缓存
        const fetchPromise = fetch(event.request).then(networkResponse => {
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });

        // 优先返回缓存
        return cachedResponse || fetchPromise;
      });
    })
  );
});
```

#### 3.6 综合策略（按资源类型区分）

```javascript
self.addEventListener('fetch', event => {
  const { request } = event;
  const url = new URL(request.url);

  // API 请求：网络优先
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirst(request));
  }
  // 静态资源：缓存优先
  else if (request.destination === 'image' || request.destination === 'style') {
    event.respondWith(cacheFirst(request));
  }
  // HTML 页面：Stale-While-Revalidate
  else if (request.destination === 'document') {
    event.respondWith(staleWhileRevalidate(request));
  }
  // 默认：网络优先
  else {
    event.respondWith(networkFirst(request));
  }
});

// 缓存优先
function cacheFirst(request) {
  return caches.match(request).then(cached => cached || fetch(request));
}

// 网络优先
function networkFirst(request) {
  return fetch(request).catch(() => caches.match(request));
}

// Stale-While-Revalidate
function staleWhileRevalidate(request) {
  return caches.open(CACHE_NAME).then(cache => {
    return cache.match(request).then(cached => {
      const fetchPromise = fetch(request).then(response => {
        cache.put(request, response.clone());
        return response;
      });
      return cached || fetchPromise;
    });
  });
}
```

### 四、PWA（渐进式 Web 应用）

#### 4.1 什么是 PWA

**PWA（Progressive Web App）** 是一种 Web 应用开发方法论，利用现代 Web 技术提供类似原生应用的用户体验。

**核心特性：**
- ✅ **渐进式**：兼容所有浏览器，逐步增强
- ✅ **响应式**：适配各种屏幕尺寸
- ✅ **离线可用**：Service Worker 缓存实现离线访问
- ✅ **类应用体验**：全屏运行，无浏览器地址栏
- ✅ **可安装**：添加到主屏幕，生成桌面图标
- ✅ **推送通知**：支持消息推送
- ✅ **安全**：必须 HTTPS
- ✅ **可发现**：搜索引擎可索引

#### 4.2 PWA 必备要素

**1. manifest.json（应用清单）**

定义应用元数据和安装行为：

```json
{
  "name": "我的 PWA 应用",
  "short_name": "PWA 应用",
  "description": "一个渐进式 Web 应用示例",
  "start_url": "/",
  "display": "standalone", // fullscreen, standalone, minimal-ui, browser
  "background_color": "#ffffff",
  "theme_color": "#4285f4",
  "orientation": "portrait", // portrait, landscape, any
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable" // 支持遮罩图标
    }
  ]
}
```

**在 HTML 中引用：**

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PWA 应用</title>

  <!-- 引用 manifest -->
  <link rel="manifest" href="/manifest.json">

  <!-- iOS 支持 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png">

  <!-- 主题颜色 -->
  <meta name="theme-color" content="#4285f4">
</head>
<body>
  <h1>欢迎使用 PWA</h1>

  <script>
    // 注册 Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js');
    }
  </script>
</body>
</html>
```

**2. Service Worker（服务工作者）**

前面已详细介绍，这里展示完整示例：

```javascript
// sw.js
const CACHE_NAME = 'pwa-v1';
const CACHE_URLS = [
  '/',
  '/index.html',
  '/styles.css',
  '/script.js',
  '/manifest.json',
  '/icons/icon-192x192.png'
];

// 安装：预缓存核心资源
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => cache.addAll(CACHE_URLS))
  );
  self.skipWaiting(); // 立即激活
});

// 激活：清理旧缓存
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(keys => {
      return Promise.all(
        keys.filter(key => key !== CACHE_NAME).map(key => caches.delete(key))
      );
    })
  );
  return self.clients.claim(); // 立即控制所有页面
});

// 拦截请求：缓存策略
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(cached => {
      return cached || fetch(event.request).then(response => {
        // 动态缓存新资源
        return caches.open(CACHE_NAME).then(cache => {
          cache.put(event.request, response.clone());
          return response;
        });
      });
    }).catch(() => {
      // 离线页面兜底
      if (event.request.destination === 'document') {
        return caches.match('/offline.html');
      }
    })
  );
});
```

**3. HTTPS**

PWA 必须在 HTTPS 环境下运行（localhost 除外）：

```bash
# 本地开发可使用 mkcert 生成证书
mkcert -install
mkcert localhost
```

#### 4.3 应用安装提示

```javascript
// 监听安装提示事件
let deferredPrompt;

window.addEventListener('beforeinstallprompt', event => {
  // 阻止默认提示
  event.preventDefault();
  deferredPrompt = event;

  // 显示自定义安装按钮
  const installButton = document.getElementById('install-button');
  installButton.style.display = 'block';

  installButton.addEventListener('click', async () => {
    // 显示安装提示
    deferredPrompt.prompt();

    // 等待用户选择
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`用户选择: ${outcome}`); // 'accepted' 或 'dismissed'

    deferredPrompt = null;
    installButton.style.display = 'none';
  });
});

// 监听安装成功事件
window.addEventListener('appinstalled', () => {
  console.log('PWA 安装成功');
  deferredPrompt = null;
});
```

### 五、推送通知

#### 5.1 请求通知权限

```javascript
// 请求通知权限
async function requestNotificationPermission() {
  const permission = await Notification.requestPermission();

  if (permission === 'granted') {
    console.log('通知权限已授予');
    return true;
  } else if (permission === 'denied') {
    console.log('通知权限被拒绝');
    return false;
  } else {
    console.log('用户未决定');
    return false;
  }
}

// 显示本地通知（主线程）
function showNotification() {
  if (Notification.permission === 'granted') {
    new Notification('PWA 通知', {
      body: '这是一条测试通知',
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: 'test-notification', // 相同 tag 会覆盖旧通知
      requireInteraction: false, // 是否需要用户交互才关闭
      data: { url: '/page' } // 自定义数据
    });
  }
}
```

#### 5.2 Service Worker 推送通知

```javascript
// sw.js
self.addEventListener('push', event => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || '新消息';
  const options = {
    body: data.body || '您有新的消息',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    data: data.url
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// 点击通知事件
self.addEventListener('notificationclick', event => {
  event.notification.close();

  // 打开关联页面
  const url = event.notification.data || '/';
  event.waitUntil(
    clients.openWindow(url)
  );
});
```

#### 5.3 订阅推送服务（使用 VAPID）

```javascript
// 主线程订阅推送
async function subscribeToPush() {
  const registration = await navigator.serviceWorker.ready;

  // VAPID 公钥（需要从服务器获取）
  const vapidPublicKey = 'YOUR_PUBLIC_KEY';
  const convertedKey = urlBase64ToUint8Array(vapidPublicKey);

  // 订阅推送
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true, // 所有推送必须显示通知
    applicationServerKey: convertedKey
  });

  // 将订阅信息发送到服务器
  await fetch('/api/subscribe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(subscription)
  });

  console.log('推送订阅成功:', subscription);
}

// Base64 转 Uint8Array
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = atob(base64);
  return Uint8Array.from([...rawData].map(char => char.charCodeAt(0)));
}
```

### 六、后台同步

```javascript
// 注册后台同步
async function registerSync() {
  const registration = await navigator.serviceWorker.ready;
  await registration.sync.register('sync-tag');
  console.log('后台同步已注册');
}

// sw.js 处理后台同步
self.addEventListener('sync', event => {
  if (event.tag === 'sync-tag') {
    event.waitUntil(
      // 执行同步任务（如上传离线数据）
      syncData()
    );
  }
});

async function syncData() {
  // 从 IndexedDB 读取离线数据
  const data = await getOfflineData();

  // 上传到服务器
  await fetch('/api/sync', {
    method: 'POST',
    body: JSON.stringify(data)
  });

  console.log('数据同步完成');
}
```

### 七、实战：完整 PWA 示例

#### 项目结构

```
pwa-demo/
├── index.html
├── manifest.json
├── sw.js
├── app.js
├── styles.css
├── offline.html
└── icons/
    ├── icon-72x72.png
    ├── icon-192x192.png
    └── icon-512x512.png
```

#### app.js（主应用逻辑）

```javascript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(reg => console.log('SW 注册成功', reg))
    .catch(err => console.error('SW 注册失败', err));
}

// 监听 SW 更新
navigator.serviceWorker.addEventListener('controllerchange', () => {
  console.log('Service Worker 已更新，刷新页面生效');
  // 可以提示用户刷新
});

// 安装提示
let deferredPrompt;
const installBtn = document.getElementById('install-btn');

window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = 'block';
});

installBtn?.addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`安装结果: ${outcome}`);
    deferredPrompt = null;
    installBtn.style.display = 'none';
  }
});

// 请求通知权限
document.getElementById('notify-btn')?.addEventListener('click', async () => {
  const permission = await Notification.requestPermission();
  if (permission === 'granted') {
    new Notification('PWA 通知测试', {
      body: '通知功能正常工作',
      icon: '/icons/icon-192x192.png'
    });
  }
});
```

### 八、调试与测试

#### 8.1 Chrome DevTools

1. **Application 面板**
   - Service Workers：查看状态、手动更新、卸载
   - Cache Storage：查看缓存内容
   - Manifest：验证 manifest.json

2. **Lighthouse 审计**
   - 自动检测 PWA 合规性
   - 提供优化建议

#### 8.2 测试清单

- ✅ HTTPS 或 localhost
- ✅ manifest.json 配置正确
- ✅ Service Worker 注册成功
- ✅ 离线时页面可访问
- ✅ 添加到主屏幕功能正常
- ✅ 推送通知工作
- ✅ 性能达标（Lighthouse PWA 分数 > 90）

### 九、常见问题与最佳实践

#### 9.1 Service Worker 不更新？

**原因：** 浏览器缓存 Service Worker 文件（24 小时）

**解决：**
```javascript
// 开发环境禁用缓存
navigator.serviceWorker.register('/sw.js', { updateViaCache: 'none' });

// 或在 SW 文件添加 HTTP 头
Cache-Control: max-age=0
```

#### 9.2 如何强制更新？

```javascript
// 检查更新
navigator.serviceWorker.register('/sw.js').then(registration => {
  setInterval(() => {
    registration.update(); // 每小时检查一次
  }, 3600000);
});
```

#### 9.3 缓存策略选择

- 📄 **HTML 文档**：Network First 或 Stale-While-Revalidate
- 🖼️ **图片/字体**：Cache First
- 📦 **JS/CSS**：Stale-While-Revalidate
- 🌐 **API 数据**：Network First
- 📱 **离线页面**：仅缓存

#### 9.4 缓存管理

```javascript
// 限制缓存数量
async function limitCacheSize(cacheName, maxItems) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  if (keys.length > maxItems) {
    await cache.delete(keys[0]); // 删除最旧的
    limitCacheSize(cacheName, maxItems); // 递归
  }
}

// 在 fetch 事件中调用
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open('dynamic-cache').then(async cache => {
      const response = await fetch(event.request);
      cache.put(event.request, response.clone());
      await limitCacheSize('dynamic-cache', 50); // 限制 50 项
      return response;
    })
  );
});
```

### 十、面试高频问题

**Q1: PWA 和原生应用的区别？**

| 特性 | PWA | 原生应用 |
|------|-----|---------|
| 安装 | 无需应用商店 | 需要商店审核 |
| 更新 | 自动更新（访问时） | 需用户手动更新 |
| 性能 | 接近原生 | 最优 |
| 离线能力 | 依赖缓存 | 完整离线 |
| 系统集成 | 有限（通知、传感器） | 完整集成 |
| 开发成本 | 低（一套代码） | 高（多平台开发） |

**Q2: Service Worker 能访问 DOM 吗？**

A: 不能。Service Worker 运行在独立线程，无法访问 DOM。需要通过 `postMessage` 与主线程通信：

```javascript
// SW 发送消息给主线程
self.clients.matchAll().then(clients => {
  clients.forEach(client => client.postMessage({ type: 'update' }));
});

// 主线程接收消息
navigator.serviceWorker.addEventListener('message', event => {
  console.log('收到 SW 消息:', event.data);
});
```

**Q3: 如何保证 Service Worker 更新后立即生效？**

A: 在 install 事件中调用 `skipWaiting()`，在 activate 事件中调用 `clients.claim()`：

```javascript
self.addEventListener('install', () => {
  self.skipWaiting(); // 跳过等待，立即激活
});

self.addEventListener('activate', () => {
  self.clients.claim(); // 立即控制所有页面
});
```

**Q4: PWA 能否访问设备硬件？**

A: 可以部分访问（通过 Web API）：
- ✅ 地理位置（Geolocation API）
- ✅ 相机/麦克风（MediaDevices API）
- ✅ 传感器（加速度计、陀螺仪等）
- ✅ 蓝牙（Web Bluetooth API，实验性）
- ❌ NFC、指纹识别等高级功能支持有限

### 十一、总结

Service Worker 和 PWA 代表了 Web 应用的未来方向，核心要点：

1. **Service Worker**：后台脚本代理，实现离线缓存和请求拦截
2. **生命周期**：注册 → 安装 → 激活 → 拦截请求
3. **缓存策略**：Cache First、Network First、Stale-While-Revalidate
4. **PWA 三要素**：HTTPS + manifest.json + Service Worker
5. **核心能力**：离线访问、应用安装、推送通知、后台同步
6. **开发建议**：合理选择缓存策略、注意更新机制、限制缓存大小

---

**参考资料：**
- MDN: Service Worker API - https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
- Google Developers: Progressive Web Apps - https://web.dev/progressive-web-apps/
- Service Worker Cookbook - https://serviceworke.rs/
- Workbox（Google PWA 工具库）- https://developers.google.com/web/tools/workbox
