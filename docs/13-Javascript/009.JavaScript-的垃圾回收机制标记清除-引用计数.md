---
title: JavaScript 的垃圾回收机制（标记清除、引用计数）
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: javascript-garbage-collection-mark-sweep-reference-counting
ref:
---

## 核心要点
- **标记清除算法**：现代JavaScript引擎主流的GC算法，解决循环引用问题
- **引用计数算法**：早期算法，无法处理循环引用，现已基本废弃
- **分代回收策略**：年轻代频繁回收，老年代偶尔回收，提升性能

## 详细解答

### 1. 垃圾回收基础概念

JavaScript是一门自动内存管理的语言，开发者无需手动释放内存。垃圾回收器(GC)会自动识别和释放不再使用的内存。

```javascript
// 内存分配和释放示例
function createObjects() {
    const obj1 = { name: 'Object 1' }; // 分配内存
    const obj2 = { name: 'Object 2' }; // 分配内存

    // 函数执行完毕，obj1和obj2失去引用
    // 垃圾回收器会自动回收这些对象的内存
    return obj1.name;
}

createObjects(); // 执行后，相关对象会被标记为可回收
```

### 2. 引用计数算法

#### 2.1 工作原理

引用计数跟踪每个对象被引用的次数，当引用次数为0时立即释放内存。

```javascript
// 引用计数示例
let obj1 = { name: 'A' }; // obj1引用计数 = 1
let obj2 = obj1;          // obj1引用计数 = 2

obj1 = null;              // obj1引用计数 = 1
obj2 = null;              // obj1引用计数 = 0，立即被回收
```

#### 2.2 循环引用问题

```javascript
// 循环引用导致内存泄漏
function createCircularReference() {
    const objA = { name: 'A' };
    const objB = { name: 'B' };

    objA.ref = objB; // A引用B
    objB.ref = objA; // B引用A，形成循环

    // 函数结束后，objA和objB仍然互相引用
    // 引用计数永远不会为0，无法被回收
}

createCircularReference(); // 在引用计数算法下会造成内存泄漏
```

#### 2.3 引用计数的问题

```javascript
// DOM节点循环引用（IE8及以下版本）
function attachHandler() {
    const element = document.getElementById('button');

    element.onclick = function() {
        // 事件处理器引用element
        console.log(element.id);
    };

    // element的onclick属性引用函数
    // 函数的作用域又引用element
    // 形成循环引用，在老版本IE中不会被回收
}

// 解决方案：手动破除循环引用
function attachHandlerFixed() {
    const element = document.getElementById('button');

    element.onclick = function() {
        console.log(element.id);
    };

    // 页面卸载时手动清除
    window.addEventListener('beforeunload', function() {
        element.onclick = null;
    });
}
```

### 3. 标记清除算法

#### 3.1 工作原理

标记清除分为两个阶段：
1. **标记阶段**：从根对象开始，标记所有可达的对象
2. **清除阶段**：回收所有未被标记的对象

```javascript
// 标记清除示例
function demonstrateMarkAndSweep() {
    // 全局变量（根对象可达）
    globalVar = { name: 'Global' };

    function innerFunction() {
        const localVar = { name: 'Local' }; // 通过作用域链可达

        const circularA = { name: 'A' };
        const circularB = { name: 'B' };
        circularA.ref = circularB;
        circularB.ref = circularA;

        // 即使有循环引用，但没有被根对象引用
        // 在标记阶段不会被标记，会被清除

        globalVar.child = localVar; // 使localVar从根可达
    }

    innerFunction();
    // circularA和circularB会被回收
    // localVar通过globalVar仍然可达，不会被回收
}
```

#### 3.2 可达性分析

```javascript
// 可达性示例
let root = {
    child1: {
        name: 'Child1',
        data: new Array(1000000).fill('data')
    },
    child2: {
        name: 'Child2',
        ref: null
    }
};

// child1和child2都可达
root.child2.ref = root.child1; // 增加对child1的引用

// 断开child1的引用
root.child1 = null;

// child1仍然通过root.child2.ref可达，不会被回收
// 如果想让child1被回收，需要断开所有引用
root.child2.ref = null; // 现在child1不可达，会被回收
```

### 4. 现代JavaScript引擎的GC策略

#### 4.1 分代回收

```javascript
// V8引擎的分代回收策略

// 年轻代（新生代）- 小而频繁的GC
function createYoungGeneration() {
    // 新创建的对象首先分配在年轻代
    const newObjects = [];

    for (let i = 0; i < 1000; i++) {
        newObjects.push({
            id: i,
            data: new Array(100).fill(i)
        });
    }

    // 年轻代很快会触发Minor GC
    return newObjects;
}

// 老年代 - 大而不频繁的GC
let longLivedObject = {
    // 长期存活的对象会被提升到老年代
    cache: new Map(),
    config: { /* 配置数据 */ }
};

// 对象在年轻代存活多个GC周期后会被提升到老年代
```

#### 4.2 增量标记

```javascript
// 增量标记避免长时间停顿
class IncrementalGCDemo {
    constructor() {
        this.largeDataStructure = new Map();

        // 创建大量对象
        for (let i = 0; i < 100000; i++) {
            this.largeDataStructure.set(i, {
                id: i,
                data: new Array(100).fill(i)
            });
        }
    }

    processData() {
        // 在处理过程中，GC会增量进行标记
        // 避免一次性标记所有对象造成的停顿

        for (const [key, value] of this.largeDataStructure) {
            // 处理数据
            value.processed = true;

            // GC可能在这里进行增量标记
            if (key % 1000 === 0) {
                // 模拟可能的GC时机
                console.log(`Processed ${key} items`);
            }
        }
    }
}
```

#### 4.3 并发标记

```javascript
// 并发标记（Concurrent Marking）
class ConcurrentGCDemo {
    constructor() {
        this.workers = [];
        this.sharedData = {
            counter: 0,
            results: []
        };
    }

    startWorkers() {
        // 主线程继续执行业务逻辑
        setInterval(() => {
            this.sharedData.counter++;
            this.sharedData.results.push(Math.random());

            // 在主线程执行的同时
            // GC可以在后台线程进行并发标记

            if (this.sharedData.results.length > 10000) {
                // 清理旧数据
                this.sharedData.results = this.sharedData.results.slice(-1000);
            }
        }, 1);
    }
}
```

### 5. 内存泄漏场景和GC限制

#### 5.1 闭包造成的内存泄漏

```javascript
// 闭包保持外部变量引用
function createClosure() {
    const largeData = new Array(1000000).fill('data');

    return function(index) {
        // 闭包引用了整个largeData数组
        return largeData[index];
    };
}

const accessor = createClosure();
// largeData无法被GC回收，因为闭包仍然引用它

// 优化版本
function createOptimizedClosure() {
    const largeData = new Array(1000000).fill('data');
    const needed = largeData.slice(0, 10); // 只保留需要的部分

    return function(index) {
        return needed[index];
    };
    // largeData在函数结束后可以被回收
}
```

#### 5.2 事件监听器泄漏

```javascript
class ComponentWithLeak {
    constructor() {
        this.data = new Array(100000).fill('data');

        // 添加事件监听器
        document.addEventListener('click', this.handleClick.bind(this));
        window.addEventListener('resize', this.handleResize.bind(this));
    }

    handleClick() {
        // 访问this.data
        console.log(this.data.length);
    }

    handleResize() {
        // 访问this.data
        console.log('Resized');
    }

    // 没有清理方法，组件销毁后仍然被事件监听器引用
}

// 修复版本
class ComponentFixed {
    constructor() {
        this.data = new Array(100000).fill('data');

        // 保存bound函数的引用以便移除
        this.boundHandleClick = this.handleClick.bind(this);
        this.boundHandleResize = this.handleResize.bind(this);

        document.addEventListener('click', this.boundHandleClick);
        window.addEventListener('resize', this.boundHandleResize);
    }

    handleClick() {
        console.log(this.data.length);
    }

    handleResize() {
        console.log('Resized');
    }

    destroy() {
        // 清理事件监听器
        document.removeEventListener('click', this.boundHandleClick);
        window.removeEventListener('resize', this.boundHandleResize);

        // 清理数据引用
        this.data = null;
    }
}
```

#### 5.3 定时器泄漏

```javascript
class TimerLeak {
    constructor() {
        this.data = new Array(100000).fill('data');

        // 定时器保持对this的引用
        setInterval(() => {
            console.log(this.data.length);
        }, 1000);

        // 没有清理定时器的方法
    }
}

// 修复版本
class TimerFixed {
    constructor() {
        this.data = new Array(100000).fill('data');

        this.timer = setInterval(() => {
            console.log(this.data.length);
        }, 1000);
    }

    destroy() {
        clearInterval(this.timer);
        this.data = null;
    }
}
```

### 6. WeakMap和WeakSet

#### 6.1 弱引用的作用

```javascript
// WeakMap不阻止键被垃圾回收
const regularMap = new Map();
const weakMap = new WeakMap();

function demonstrateWeakReferences() {
    let obj1 = { name: 'Object 1' };
    let obj2 = { name: 'Object 2' };

    // 常规Map保持强引用
    regularMap.set(obj1, 'value for obj1');

    // WeakMap保持弱引用
    weakMap.set(obj2, 'value for obj2');

    console.log(regularMap.size); // 1
    console.log(weakMap.has(obj2)); // true

    // 移除对象引用
    obj1 = null; // obj1仍然被regularMap引用，不会被回收
    obj2 = null; // obj2可能被垃圾回收，weakMap中的条目也会消失

    // 强制垃圾回收（仅在某些环境中可用）
    if (global.gc) {
        global.gc();
    }

    console.log(regularMap.size); // 仍然是1
    console.log(weakMap.has(obj2)); // 可能是false（如果obj2被回收）
}
```

#### 6.2 WeakMap的应用场景

```javascript
// 私有属性实现
const privateData = new WeakMap();

class Person {
    constructor(name, age) {
        // 使用WeakMap存储私有数据
        privateData.set(this, {
            name: name,
            age: age,
            ssn: Math.random().toString(36)
        });
    }

    getName() {
        return privateData.get(this).name;
    }

    getAge() {
        return privateData.get(this).age;
    }

    // SSN无法从外部访问
}

const person = new Person('Alice', 30);
console.log(person.getName()); // "Alice"

// person被回收时，privateData中的条目也会自动清理
person = null;
```

### 7. 内存监控和分析

#### 7.1 内存使用监控

```javascript
// 监控内存使用情况
class MemoryMonitor {
    constructor() {
        this.samples = [];
    }

    takeSnapshot() {
        if (performance.memory) {
            const memory = {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit,
                timestamp: Date.now()
            };

            this.samples.push(memory);
            console.log('Memory Usage:', {
                used: `${(memory.used / 1024 / 1024).toFixed(2)} MB`,
                total: `${(memory.total / 1024 / 1024).toFixed(2)} MB`,
                usage: `${((memory.used / memory.total) * 100).toFixed(2)}%`
            });

            return memory;
        }
    }

    startMonitoring(interval = 5000) {
        return setInterval(() => {
            this.takeSnapshot();
        }, interval);
    }

    getMemoryTrend() {
        if (this.samples.length < 2) return null;

        const first = this.samples[0];
        const last = this.samples[this.samples.length - 1];

        return {
            growth: last.used - first.used,
            trend: last.used > first.used ? 'increasing' : 'decreasing'
        };
    }
}

// 使用示例
const monitor = new MemoryMonitor();
const monitoringId = monitor.startMonitoring(1000);

// 停止监控
// clearInterval(monitoringId);
```

#### 7.2 模拟内存压力测试

```javascript
class MemoryStressTest {
    constructor() {
        this.allocations = [];
    }

    allocateMemory(sizeMB) {
        const bytes = sizeMB * 1024 * 1024;
        const buffer = new ArrayBuffer(bytes);
        this.allocations.push(buffer);

        console.log(`Allocated ${sizeMB}MB, total allocations: ${this.allocations.length}`);
    }

    releaseMemory(count = 1) {
        for (let i = 0; i < count && this.allocations.length > 0; i++) {
            this.allocations.pop();
        }

        console.log(`Released ${count} allocations, remaining: ${this.allocations.length}`);
    }

    forceGC() {
        // 创建大量临时对象触发GC
        for (let i = 0; i < 100000; i++) {
            const temp = { id: i, data: new Array(100).fill(i) };
        }

        console.log('Attempted to trigger GC');
    }

    runStressTest() {
        console.log('Starting memory stress test...');

        // 分配内存
        for (let i = 0; i < 10; i++) {
            this.allocateMemory(10); // 分配10MB
        }

        // 释放部分内存
        this.releaseMemory(5);

        // 尝试触发GC
        this.forceGC();

        // 再次分配
        for (let i = 0; i < 5; i++) {
            this.allocateMemory(20); // 分配20MB
        }
    }
}
```

### 8. 优化GC性能的最佳实践

#### 8.1 减少对象分配

```javascript
// 避免频繁创建临时对象
class ObjectPooling {
    constructor() {
        this.pool = [];
        this.inUse = new Set();
    }

    // 对象池模式
    acquire() {
        let obj;

        if (this.pool.length > 0) {
            obj = this.pool.pop();
        } else {
            obj = this.createNewObject();
        }

        this.inUse.add(obj);
        return obj;
    }

    release(obj) {
        if (this.inUse.has(obj)) {
            this.inUse.delete(obj);
            this.resetObject(obj);
            this.pool.push(obj);
        }
    }

    createNewObject() {
        return {
            x: 0,
            y: 0,
            data: new Array(100)
        };
    }

    resetObject(obj) {
        obj.x = 0;
        obj.y = 0;
        obj.data.fill(0);
    }
}

// 使用对象池
const pool = new ObjectPooling();

function processData() {
    const objects = [];

    // 从池中获取对象而不是创建新对象
    for (let i = 0; i < 1000; i++) {
        const obj = pool.acquire();
        obj.x = i;
        obj.y = i * 2;
        objects.push(obj);
    }

    // 处理完毕后归还给池
    objects.forEach(obj => pool.release(obj));
}
```

#### 8.2 避免意外的全局变量

```javascript
// 错误：意外创建全局变量
function badFunction() {
    // 忘记声明变量，创建了全局变量
    leakedVariable = new Array(100000).fill('data');

    // 这个全局变量永远不会被GC回收
}

// 正确：使用严格模式和正确声明
'use strict';

function goodFunction() {
    // 正确声明局部变量
    const localVariable = new Array(100000).fill('data');

    // 函数结束后可以被GC回收
}
```

#### 8.3 合理使用缓存

```javascript
class CacheManager {
    constructor(maxSize = 1000) {
        this.cache = new Map();
        this.maxSize = maxSize;
        this.accessOrder = [];
    }

    get(key) {
        if (this.cache.has(key)) {
            // 更新访问顺序（LRU）
            this.updateAccessOrder(key);
            return this.cache.get(key);
        }
        return null;
    }

    set(key, value) {
        if (this.cache.size >= this.maxSize) {
            // 移除最久未访问的项
            const oldestKey = this.accessOrder.shift();
            this.cache.delete(oldestKey);
        }

        this.cache.set(key, value);
        this.updateAccessOrder(key);
    }

    updateAccessOrder(key) {
        const index = this.accessOrder.indexOf(key);
        if (index > -1) {
            this.accessOrder.splice(index, 1);
        }
        this.accessOrder.push(key);
    }

    clear() {
        this.cache.clear();
        this.accessOrder = [];
    }
}
```

### 9. 不同JavaScript引擎的GC实现

#### 9.1 V8引擎（Chrome, Node.js）

```javascript
// V8的Orinoco垃圾回收器特点演示
class V8GCDemo {
    constructor() {
        // V8使用分代回收
        this.youngGeneration = []; // Scavenger算法
        this.oldGeneration = [];   // Mark-Compact算法
    }

    demonstrateGenerationalGC() {
        // 新对象分配在年轻代
        for (let i = 0; i < 1000; i++) {
            this.youngGeneration.push({
                id: i,
                data: new Array(100).fill(i)
            });
        }

        // 模拟对象老化
        setTimeout(() => {
            // 存活的对象会被提升到老年代
            this.oldGeneration = [...this.youngGeneration];
            this.youngGeneration = [];
        }, 100);
    }
}
```

#### 9.2 SpiderMonkey引擎（Firefox）

```javascript
// Firefox的增量GC和并发GC
class SpiderMonkeyGCDemo {
    constructor() {
        this.data = new Map();
    }

    demonstrateIncrementalGC() {
        // 创建大量对象
        for (let i = 0; i < 50000; i++) {
            this.data.set(i, {
                value: new Array(200).fill(i),
                refs: []
            });
        }

        // 创建复杂的引用关系
        for (let i = 0; i < 50000; i++) {
            const obj = this.data.get(i);
            for (let j = 0; j < 5; j++) {
                const refIndex = Math.floor(Math.random() * 50000);
                obj.refs.push(this.data.get(refIndex));
            }
        }

        // Firefox会使用增量GC来处理这种复杂的对象图
    }
}
```

### 10. 总结

JavaScript垃圾回收机制的发展历程：

1. **引用计数时代**：简单但有循环引用问题
2. **标记清除时代**：解决循环引用，但有停顿问题
3. **现代GC时代**：分代、增量、并发，性能优异

**理解GC机制的重要性**：
- **性能优化**：避免不必要的内存分配和泄漏
- **架构设计**：合理设计对象生命周期
- **问题排查**：快速定位内存相关问题
- **代码质量**：写出内存友好的JavaScript代码

**最佳实践总结**：
- 及时清理事件监听器和定时器
- 合理使用闭包，避免意外保持引用
- 利用WeakMap/WeakSet处理临时关联
- 监控内存使用，及时发现问题
- 使用对象池减少GC压力
