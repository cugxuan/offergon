---
title: JavaScript 的 == 和 === 的区别
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: js-double-equals-vs-triple-equals
ref:
---

## 核心要点

**==（相等运算符）** 会进行类型转换后比较，**===（全等运算符）** 不做类型转换直接比较类型和值。关键差异：`"5" == 5` 为 true，`"5" === 5` 为 false；`null == undefined` 为 true，`null === undefined` 为 false。最佳实践：**始终使用 ===**，避免类型转换带来的不可预测行为，除非明确需要兼容 null/undefined 判断。

---

## 详细解答

这是 JavaScript 面试中必考题目之一，也是实际开发中最容易引发 bug 的地方。理解两者的区别能显著提升代码质量。

### 一、基本定义

#### === 全等运算符（Strict Equality）

**比较规则：**
1. 先比较类型，类型不同直接返回 `false`
2. 类型相同再比较值
3. 不进行任何类型转换

```javascript
5 === 5               // true（类型相同，值相同）
5 === "5"             // false（类型不同，直接返回 false）
null === undefined    // false（类型不同）
NaN === NaN           // false（NaN 的特殊规则）
0 === -0              // true（正负零视为相等）
```

**特殊情况：**
```javascript
// 1. NaN 永不相等
NaN === NaN           // false
Number.isNaN(NaN)     // 正确判断方式

// 2. 对象比较的是引用
{} === {}             // false（不同的对象引用）
[] === []             // false
const obj = {}
obj === obj           // true（同一引用）

// 3. 正负零相等
0 === -0              // true
Object.is(0, -0)      // false（更严格的相等判断）
```

#### == 相等运算符（Loose Equality）

**比较规则：**
1. 类型相同，直接比较值（类似 ===）
2. **类型不同，尝试类型转换后再比较**
3. 遵循复杂的转换规则（见下文）

```javascript
5 == 5                // true
5 == "5"              // true（"5" 转换为数字 5）
null == undefined     // true（ES 规范特殊规定）
0 == false            // true（false 转换为 0）
[] == false           // true（[] → "" → 0, false → 0）
```

---

### 二、== 的类型转换规则（重点）

#### 规则 1：null 和 undefined 特殊处理

```javascript
null == undefined     // true ⚠️（ES 规范明确规定）
null === undefined    // false

// 但它们不等于其他值
null == 0             // false
null == false         // false
undefined == 0        // false
```

**实用技巧：**
```javascript
// 常用于同时检测 null 和 undefined
if (value == null) {
  // value 是 null 或 undefined
}

// 等价于
if (value === null || value === undefined) {
  // ...
}
```

#### 规则 2：字符串与数字比较

**字符串转换为数字：**
```javascript
"5" == 5              // true（"5" → 5）
"10" == 10            // true
"" == 0               // true（"" → 0）
" " == 0              // true（" " → 0）
"abc" == NaN          // false（"abc" → NaN）
```

#### 规则 3：布尔值转换为数字

**布尔值先转数字：**
```javascript
true == 1             // true（true → 1）
false == 0            // true（false → 0）
true == "1"           // true（true → 1, "1" → 1）
false == ""           // true（false → 0, "" → 0）

// 陷阱
true == "true"        // false（true → 1, "true" → NaN）
false == "false"      // false（false → 0, "false" → NaN）
```

#### 规则 4：对象与原始值比较

**对象转换为原始值（ToPrimitive）：**
```javascript
// 数组
[1] == 1              // true（[1] → "1" → 1）
[1, 2] == "1,2"       // true（[1,2] → "1,2"）
[] == 0               // true（[] → "" → 0）
[] == false           // true（[] → "" → 0, false → 0）

// 对象
{} == "[object Object]"  // 无法直接测试（语法问题）
({}.toString() == "[object Object]")  // true

// 自定义转换
const obj = {
  valueOf() { return 42 }
}
obj == 42             // true（调用 valueOf）
```

#### 规则 5：比较双方都是对象

**比较引用地址：**
```javascript
[] == []              // false（不同引用）
{} == {}              // false
const arr = []
arr == arr            // true（同一引用）
```

---

### 三、完整转换流程图

```
x == y 的判断流程：

1. 类型相同？
   ├─ 是 → 直接比较值（类似 ===）
   └─ 否 ↓

2. null == undefined？
   ├─ 是 → 返回 true
   └─ 否 ↓

3. 数字 == 字符串？
   ├─ 是 → 字符串转数字，再比较
   └─ 否 ↓

4. 布尔值参与比较？
   ├─ 是 → 布尔值转数字（true→1, false→0），再比较
   └─ 否 ↓

5. 对象 == 原始值？
   ├─ 是 → 对象调用 ToPrimitive 转原始值，再比较
   └─ 否 ↓

6. 返回 false
```

---

### 四、经典陷阱与面试题

#### 陷阱 1：空数组和布尔值

```javascript
[] == false           // true ⚠️
// 过程：false → 0, [] → "" → 0, 0 == 0 为 true

// 但
if ([]) {
  console.log("执行")  // 会执行！[] 转布尔为 true
}

// 结论：[] 转布尔为 true，但 [] == false 为 true
```

#### 陷阱 2：传递性失效

```javascript
// 正常的传递性：a == b && b == c → a == c
"0" == 0              // true
0 == []               // true
"0" == []             // false ⚠️（传递性失效！）

// 原因："0" 与 [] 都转字符串比较
// "0" vs [].toString() → "0" vs "" → false
```

#### 陷阱 3：多个 falsy 值不相等

```javascript
// 以下都是 falsy 值，但互不相等
false == 0            // true
false == ""           // true
false == []           // true

// 但
0 == ""               // true
0 == []               // true
"" == []              // true ⚠️

// 更糟的情况
false == null         // false ⚠️
false == undefined    // false ⚠️
0 == null             // false ⚠️
```

#### 陷阱 4：字符串数字的非对称性

```javascript
"1" == 1              // true
1 == "1"              // true（对称）

// 但
"01" == 1             // true
1 == "01"             // true（看起来正常）

"10" == 10            // true
10 == "10"            // true

// 陷阱
"010" == 10           // true ⚠️（"010" → 10，不是八进制）
```

#### 面试题：以下代码输出什么？

```javascript
console.log([] == ![])           // true ⚠️
// 过程：
// ![] → false（[] 转布尔为 true，取反为 false）
// [] == false
// [] → "" → 0, false → 0
// 0 == 0 → true

console.log([] == [])            // false（不同引用）

console.log({} == !{})           // false
// {} → "[object Object]" → NaN
// !{} → false → 0
// NaN == 0 → false

console.log("" == 0)             // true
console.log(0 == "")             // true
console.log("0" == 0)            // true
console.log(0 == "0")            // true
console.log("" == "0")           // false ⚠️（都是字符串，直接比较）

console.log(null == 0)           // false
console.log(undefined == 0)      // false
console.log(null == undefined)   // true
```

---

### 五、性能对比

```javascript
// 性能测试（运行 1000 万次）
const str = "5"
const num = 5

// === 更快（无类型转换）
console.time("===")
for (let i = 0; i < 10000000; i++) {
  str === num
}
console.timeEnd("===")  // 约 5ms

// == 较慢（需要类型转换）
console.time("==")
for (let i = 0; i < 10000000; i++) {
  str == num
}
console.timeEnd("==")   // 约 15ms
```

**结论：=== 性能更优，因为跳过类型转换步骤。**

---

### 六、最佳实践

#### 1. 默认使用 ===

```javascript
// ❌ 不推荐（行为不可预测）
if (value == 5) { }

// ✅ 推荐（明确类型检查）
if (value === 5) { }
```

#### 2. 仅在检测 null/undefined 时使用 ==

```javascript
// ✅ 唯一推荐的 == 使用场景
if (value == null) {
  // value 是 null 或 undefined
}

// 更明确的写法
if (value === null || value === undefined) {
  // ...
}

// ES2020+ 使用 ?? 运算符
const result = value ?? defaultValue
```

#### 3. 类型转换后再比较

```javascript
// ❌ 不推荐（依赖隐式转换）
if (userInput == 5) { }

// ✅ 推荐（显式转换）
if (Number(userInput) === 5) { }
if (parseInt(userInput, 10) === 5) { }
```

#### 4. 使用 ESLint 强制规则

```javascript
// .eslintrc.js
{
  rules: {
    "eqeqeq": ["error", "always"]  // 强制使用 ===
  }
}
```

#### 5. 特殊值使用专用 API

```javascript
// ❌ 不推荐
if (value == NaN) { }         // 永远为 false
if (value !== value) { }      // NaN 判断的 hack

// ✅ 推荐
if (Number.isNaN(value)) { }

// ❌ 不推荐
if (value == null) { }        // 可以用，但不够明确

// ✅ 推荐
if (value === undefined) { }
if (value === null) { }
if (value == null) { }        // 仅在明确需要同时检测时使用
```

---

### 七、对比总结表

| 特性 | == | === |
|------|-----|------|
| **类型检查** | 转换后比较 | 必须类型相同 |
| **性能** | 较慢（需转换） | 较快（无转换） |
| **可预测性** | 低（规则复杂） | 高（直接比较） |
| **`"5" vs 5`** | true | false |
| **`null vs undefined`** | true | false |
| **`[] vs false`** | true | false |
| **`0 vs ""`** | true | false |
| **推荐程度** | 仅用于 null 检测 | 默认使用 |

---

### 八、记忆技巧

**== 的五大转换规则（按优先级）：**

1. **null == undefined**（特殊规定，返回 true）
2. **数字 == 字符串** → 字符串转数字
3. **布尔值参与** → 布尔值转数字（true→1, false→0）
4. **对象 == 原始值** → 对象调用 ToPrimitive
5. **类型相同或都无法转换** → 直接比较或返回 false

**口诀：**
- **===**：严格妈妈，类型不同直接拒绝
- **==**：宽松爸爸，想方设法凑成一对（但可能乱点鸳鸯谱）

**最佳建议：**
> 把 == 当作「已弃用」对待，除了 `value == null` 这一个例外场景，其余全用 ===。

这样能避免 95% 的类型转换陷阱，代码更健壮、更易维护！
