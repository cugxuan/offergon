---
title: JavaScript 的 this 指向规则
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-this-binding-rules
ref:
---

## 核心要点
- **调用位置决定this**：函数调用方式决定this绑定，不是定义位置
- **绑定优先级**：new绑定 > 显式绑定 > 隐式绑定 > 默认绑定
- **箭头函数特殊性**：继承外层作用域的this，无法被call/apply/bind改变

## 详细解答

### 1. this绑定的四种规则

#### 1.1 默认绑定（独立函数调用）

```javascript
function sayHello() {
    console.log(this); // 浏览器中指向window，Node.js中指向global
}

sayHello(); // 默认绑定

// 严格模式下
'use strict';
function strictFunction() {
    console.log(this); // undefined
}
strictFunction();
```

#### 1.2 隐式绑定（对象方法调用）

```javascript
const person = {
    name: 'Alice',
    sayName: function() {
        console.log(this.name); // this指向person对象
    }
};

person.sayName(); // "Alice"

// 隐式丢失
const getName = person.sayName;
getName(); // undefined (严格模式) 或 window.name (非严格模式)

// 回调函数中的隐式丢失
function callCallback(callback) {
    callback(); // 独立调用，this丢失
}

callCallback(person.sayName); // undefined
```

#### 1.3 显式绑定（call/apply/bind）

```javascript
const person1 = { name: 'Alice' };
const person2 = { name: 'Bob' };

function introduce() {
    console.log(`Hi, I'm ${this.name}`);
}

// call：立即调用，参数逐个传递
introduce.call(person1); // "Hi, I'm Alice"

// apply：立即调用，参数数组传递
introduce.apply(person2); // "Hi, I'm Bob"

// bind：返回新函数，延迟调用
const boundIntroduce = introduce.bind(person1);
boundIntroduce(); // "Hi, I'm Alice"
```

#### 1.4 new绑定（构造函数调用）

```javascript
function Person(name) {
    this.name = name;
    this.sayName = function() {
        console.log(this.name);
    };
}

const alice = new Person('Alice');
alice.sayName(); // "Alice" - this指向新创建的实例

// new绑定的过程
function myNew(Constructor, ...args) {
    // 1. 创建新对象
    const obj = {};

    // 2. 设置原型链
    Object.setPrototypeOf(obj, Constructor.prototype);

    // 3. 绑定this并执行构造函数
    const result = Constructor.apply(obj, args);

    // 4. 返回对象
    return typeof result === 'object' ? result : obj;
}
```

### 2. 绑定优先级

```javascript
function test() {
    console.log(this.name);
}

const obj1 = { name: 'obj1', test };
const obj2 = { name: 'obj2' };

// 1. new vs 隐式绑定
function Foo(name) {
    this.name = name;
}
Foo.prototype.test = test;

const foo = new Foo('new binding');
foo.test(); // "new binding" - new绑定优先

// 2. 显式 vs 隐式绑定
obj1.test.call(obj2); // "obj2" - 显式绑定优先

// 3. 显式 vs new绑定
const boundTest = test.bind(obj1);
const newObj = new boundTest(); // new绑定优先，this指向新对象

// 优先级：new > 显式 > 隐式 > 默认
```

### 3. 箭头函数的this

```javascript
const obj = {
    name: 'Alice',

    // 普通函数
    normalFunction: function() {
        console.log(this.name); // this指向obj

        // 内部箭头函数
        const arrowFunction = () => {
            console.log(this.name); // 继承外层this，指向obj
        };

        arrowFunction();

        // 内部普通函数
        function innerFunction() {
            console.log(this.name); // this指向全局对象或undefined
        }

        innerFunction();
    },

    // 箭头函数作为方法
    arrowMethod: () => {
        console.log(this.name); // 继承全局作用域的this
    }
};

obj.normalFunction(); // "Alice", "Alice", undefined
obj.arrowMethod(); // undefined (或全局对象的name)

// 箭头函数无法改变this指向
const person = { name: 'Bob' };
obj.arrowMethod.call(person); // 仍然是undefined，call无效
```

### 4. 实际场景中的this问题

#### 4.1 事件处理器

```javascript
class Button {
    constructor(element) {
        this.element = element;
        this.clickCount = 0;

        // 错误：this丢失
        this.element.addEventListener('click', this.handleClick);

        // 正确：绑定this
        this.element.addEventListener('click', this.handleClick.bind(this));

        // 或使用箭头函数
        this.element.addEventListener('click', () => this.handleClick());
    }

    handleClick() {
        this.clickCount++;
        console.log(`Clicked ${this.clickCount} times`);
    }
}
```

#### 4.2 定时器

```javascript
class Timer {
    constructor() {
        this.seconds = 0;
    }

    start() {
        // 错误：this丢失
        setInterval(this.tick, 1000);

        // 正确方式1：bind
        setInterval(this.tick.bind(this), 1000);

        // 正确方式2：箭头函数
        setInterval(() => this.tick(), 1000);

        // 正确方式3：保存this
        const self = this;
        setInterval(function() {
            self.tick();
        }, 1000);
    }

    tick() {
        this.seconds++;
        console.log(`${this.seconds} seconds`);
    }
}
```

#### 4.3 数组方法

```javascript
class NumberProcessor {
    constructor(numbers) {
        this.numbers = numbers;
        this.multiplier = 2;
    }

    process() {
        // 错误：this丢失
        const doubled = this.numbers.map(function(num) {
            return num * this.multiplier; // this是undefined
        });

        // 正确方式1：箭头函数
        const doubled1 = this.numbers.map(num => num * this.multiplier);

        // 正确方式2：传递thisArg
        const doubled2 = this.numbers.map(function(num) {
            return num * this.multiplier;
        }, this);

        // 正确方式3：bind
        const doubled3 = this.numbers.map(function(num) {
            return num * this.multiplier;
        }.bind(this));

        return doubled1;
    }
}
```

### 5. 复杂场景分析

#### 5.1 对象方法链式调用

```javascript
const calculator = {
    value: 0,

    add(num) {
        this.value += num;
        return this; // 返回this实现链式调用
    },

    multiply(num) {
        this.value *= num;
        return this;
    },

    getValue() {
        return this.value;
    }
};

const result = calculator.add(5).multiply(2).getValue(); // 10
```

#### 5.2 构造函数返回对象

```javascript
function Person(name) {
    this.name = name;

    // 返回普通对象会覆盖this
    return {
        name: 'Override',
        age: 25
    };
}

function Animal(name) {
    this.name = name;

    // 返回原始值不影响this
    return 'ignored';
}

const person = new Person('Alice'); // { name: 'Override', age: 25 }
const animal = new Animal('Dog'); // Animal { name: 'Dog' }
```

### 6. ES6类中的this

```javascript
class MyClass {
    constructor() {
        this.value = 42;

        // 方法中的this
        this.boundMethod = this.method.bind(this);

        // 箭头函数属性
        this.arrowMethod = () => {
            console.log(this.value);
        };
    }

    method() {
        console.log(this.value);
    }

    // 静态方法中的this指向类本身
    static staticMethod() {
        console.log(this === MyClass); // true
    }
}

const instance = new MyClass();
const { method, boundMethod, arrowMethod } = instance;

method(); // undefined (this丢失)
boundMethod(); // 42
arrowMethod(); // 42
```

### 7. 常见this陷阱

#### 7.1 对象字面量中的this

```javascript
const obj = {
    name: 'Object',

    // 错误：箭头函数继承全局this
    arrowSayName: () => {
        console.log(this.name); // undefined
    },

    // 正确：普通函数
    sayName: function() {
        console.log(this.name); // "Object"
    },

    // 嵌套对象
    nested: {
        name: 'Nested',
        sayName: function() {
            console.log(this.name); // "Nested" - this指向nested对象
        }
    }
};
```

#### 7.2 立即执行函数

```javascript
const obj = {
    name: 'Alice',

    init: function() {
        // IIFE中的this
        (function() {
            console.log(this.name); // undefined - 默认绑定
        })();

        // 箭头函数IIFE
        (() => {
            console.log(this.name); // "Alice" - 继承外层this
        })();
    }
};
```

### 8. this绑定实用技巧

#### 8.1 保存this引用

```javascript
function Timer() {
    const self = this; // 保存this引用
    this.seconds = 0;

    setInterval(function() {
        self.seconds++; // 使用保存的引用
    }, 1000);
}
```

#### 8.2 使用解构赋值

```javascript
const obj = {
    name: 'Alice',
    greet() {
        return `Hello, ${this.name}`;
    }
};

// 解构会丢失this
const { greet } = obj;
console.log(greet()); // "Hello, undefined"

// 解决方案：重新绑定
const boundGreet = obj.greet.bind(obj);
console.log(boundGreet()); // "Hello, Alice"
```

### 9. 面试常考题目

```javascript
// Q1: 输出结果
var name = 'Global';

const person = {
    name: 'Alice',
    sayName: function() {
        console.log(this.name);
    }
};

const sayName = person.sayName;
sayName(); // "Global" (非严格模式) 或 undefined (严格模式)

// Q2: 箭头函数this
const obj = {
    name: 'Test',
    method: () => {
        console.log(this.name);
    }
};

obj.method(); // undefined - 箭头函数继承全局this

// Q3: 构造函数this
function Constructor() {
    this.value = 1;

    return {
        value: 2
    };
}

const instance = new Constructor();
console.log(instance.value); // 2 - 返回的对象覆盖了this
```

### 10. 最佳实践

1. **明确调用方式**：根据函数调用方式预判this指向
2. **使用箭头函数**：需要保持外层this时使用箭头函数
3. **显式绑定**：在回调函数中使用bind明确this指向
4. **避免this丢失**：解构方法时要注意重新绑定
5. **严格模式**：使用严格模式避免意外的全局绑定

### 总结

this绑定是JavaScript中最容易出错的概念之一，理解其规则对于：
- 避免运行时错误
- 正确使用回调函数
- 设计可靠的面向对象代码
- 理解框架内部机制

都非常重要。记住关键原则：**调用位置决定this指向**，掌握四种绑定规则及其优先级即可应对大部分场景。
