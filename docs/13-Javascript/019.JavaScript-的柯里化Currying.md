---
title: JavaScript 的柯里化（Currying）
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-currying
ref:
---

## 核心要点

1. **定义**:柯里化是将多参数函数转换为一系列单参数函数的技术
2. **原理**:利用闭包保存参数,逐步收集参数直到满足原函数执行条件
3. **优势**:参数复用、延迟执行、函数组合、提高代码可读性
4. **应用**:参数预设、动态创建函数、函数式编程、Redux 中间件

---

## 详细解答

### 一、柯里化的基本概念

#### 1. 什么是柯里化

柯里化(Currying)是函数式编程中的一个重要概念,指**将接受多个参数的函数转换为一系列只接受单个参数的函数**的技术。

**基本示例**:

```javascript
// 普通函数(接受多个参数)
function add(a, b, c) {
  return a + b + c;
}

add(1, 2, 3); // 6

// 柯里化后的函数(逐个接受参数)
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

curriedAdd(1)(2)(3); // 6

// 或者使用箭头函数更简洁
const curriedAdd = a => b => c => a + b + c;
curriedAdd(1)(2)(3); // 6
```

#### 2. 柯里化的特点

```javascript
// 1. 逐步传参
const add = a => b => c => a + b + c;

const add1 = add(1);       // 部分应用,返回函数
const add1And2 = add1(2);  // 继续部分应用,返回函数
const result = add1And2(3); // 6,最终得到结果

// 2. 参数复用
const add10 = add(10);     // 固定第一个参数为 10
console.log(add10(5)(2));  // 17
console.log(add10(3)(7));  // 20
console.log(add10(1)(9));  // 20

// 3. 延迟执行
const addFunc = add(1)(2); // 还未执行完整计算
// ... 其他代码
const finalResult = addFunc(3); // 在需要时才完成计算
```

#### 3. 柯里化 vs 普通函数

```javascript
// 普通函数:一次性传入所有参数
function multiply(a, b, c) {
  return a * b * c;
}

multiply(2, 3, 4); // 24

// 柯里化函数:分步传入参数
const curriedMultiply = a => b => c => a * b * c;

// 用法1:一次性调用
curriedMultiply(2)(3)(4); // 24

// 用法2:分步调用
const multiplyBy2 = curriedMultiply(2);
const multiplyBy2And3 = multiplyBy2(3);
const result = multiplyBy2And3(4); // 24

// 用法3:创建专用函数
const double = curriedMultiply(2)(1); // 固定前两个参数
console.log(double(5));  // 10
console.log(double(10)); // 20
```

### 二、柯里化的实现

#### 1. 简单版柯里化

```javascript
/**
 * 简单柯里化实现
 * 限制:只支持固定参数数量,必须一个个传参
 */
function curry(fn) {
  // 获取原函数的参数个数
  const arity = fn.length;

  return function curried(...args) {
    // 如果参数足够,直接执行
    if (args.length >= arity) {
      return fn.apply(this, args);
    }

    // 参数不够,返回新函数继续收集参数
    return function(...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}

// 测试
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3));     // 6
console.log(curriedAdd(1, 2)(3));     // 6
console.log(curriedAdd(1)(2, 3));     // 6
console.log(curriedAdd(1, 2, 3));     // 6
```

#### 2. 完整版柯里化

```javascript
/**
 * 完整柯里化实现
 * 支持:
 * 1. 多参数传递
 * 2. 占位符
 * 3. this 绑定
 */
function curry(fn, arity = fn.length) {
  // 定义占位符
  const PLACEHOLDER = curry.placeholder || '_';

  return function curried(...args) {
    // 过滤出有效参数(非占位符)
    const validArgs = args.filter(arg => arg !== PLACEHOLDER);

    // 如果有效参数数量达到要求,且没有占位符,执行函数
    if (validArgs.length >= arity && !args.includes(PLACEHOLDER)) {
      return fn.apply(this, args);
    }

    // 返回新函数继续收集参数
    return function(...nextArgs) {
      // 合并参数,用新参数替换占位符
      const mergedArgs = args.map(arg =>
        arg === PLACEHOLDER && nextArgs.length > 0
          ? nextArgs.shift()
          : arg
      );

      // 将剩余新参数追加到末尾
      return curried.apply(this, mergedArgs.concat(nextArgs));
    };
  };
}

// 设置占位符
curry.placeholder = '_';

// 测试
function sum(a, b, c, d) {
  return a + b + c + d;
}

const curriedSum = curry(sum);

// 基本用法
console.log(curriedSum(1)(2)(3)(4));           // 10
console.log(curriedSum(1, 2)(3, 4));           // 10
console.log(curriedSum(1, 2, 3, 4));           // 10

// 使用占位符
const _ = curry.placeholder;
console.log(curriedSum(1, _, 3)(2, 4));        // 10
console.log(curriedSum(_, 2, _, 4)(1)(3));     // 10
console.log(curriedSum(_, _, 3, _)(1, 2, 4));  // 10
```

#### 3. 不定参数柯里化

```javascript
/**
 * 不定参数柯里化
 * 适用于参数数量不固定的情况
 * 需要显式调用来结束收集
 */
function curryUnlimited(fn) {
  // 收集的参数
  const args = [];

  function curried(...newArgs) {
    // 如果没有传参,执行函数
    if (newArgs.length === 0) {
      return fn.apply(this, args);
    }

    // 收集参数,返回自身继续收集
    args.push(...newArgs);
    return curried;
  }

  return curried;
}

// 测试:实现一个求和函数
function sum(...nums) {
  return nums.reduce((total, num) => total + num, 0);
}

const curriedSum = curryUnlimited(sum);

const result = curriedSum(1)(2)(3)(4)(5)(); // 必须调用空参数来结束
console.log(result); // 15

// 另一种方式:使用 toString 自动执行
function curryAuto(fn) {
  const args = [];

  function curried(...newArgs) {
    if (newArgs.length === 0) {
      return fn.apply(this, args);
    }
    args.push(...newArgs);
    return curried;
  }

  // 重写 toString 方法
  curried.toString = function() {
    return fn.apply(this, args);
  };

  // 重写 valueOf 方法
  curried.valueOf = function() {
    return fn.apply(this, args);
  };

  return curried;
}

const autoSum = curryAuto(sum);
console.log(autoSum(1)(2)(3)(4) + 0);  // 10,通过 valueOf 自动执行
```

#### 4. 偏函数实现(Partial Application)

偏函数与柯里化类似,但一次可以固定多个参数。

```javascript
/**
 * 偏函数实现
 * 与柯里化的区别:柯里化是逐个传参,偏函数可以一次固定多个参数
 */
function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn.apply(this, presetArgs.concat(laterArgs));
  };
}

// 测试
function greet(greeting, name, punctuation) {
  return `${greeting}, ${name}${punctuation}`;
}

// 固定第一个参数
const sayHello = partial(greet, 'Hello');
console.log(sayHello('Alice', '!'));  // "Hello, Alice!"
console.log(sayHello('Bob', '.'));    // "Hello, Bob."

// 固定前两个参数
const sayHelloToAlice = partial(greet, 'Hello', 'Alice');
console.log(sayHelloToAlice('!'));    // "Hello, Alice!"
console.log(sayHelloToAlice('?'));    // "Hello, Alice?"

// 支持占位符的偏函数
function partialWithPlaceholder(fn, ...presetArgs) {
  const PLACEHOLDER = partialWithPlaceholder.placeholder || '_';

  return function(...laterArgs) {
    let laterIndex = 0;
    const mergedArgs = presetArgs.map(arg =>
      arg === PLACEHOLDER ? laterArgs[laterIndex++] : arg
    );

    return fn.apply(this, mergedArgs.concat(laterArgs.slice(laterIndex)));
  };
}

partialWithPlaceholder.placeholder = '_';

// 使用占位符
const _ = partialWithPlaceholder.placeholder;
const greetAlice = partialWithPlaceholder(greet, _, 'Alice', _);
console.log(greetAlice('Hi', '!'));   // "Hi, Alice!"
console.log(greetAlice('Hey', '?'));  // "Hey, Alice?"
```

### 三、柯里化的应用场景

#### 1. 参数复用

```javascript
// 场景:日志记录器
function log(level, timestamp, message) {
  console.log(`[${level}] ${timestamp}: ${message}`);
}

const curriedLog = curry(log);

// 创建不同级别的日志函数
const infoLog = curriedLog('INFO');
const errorLog = curriedLog('ERROR');
const debugLog = curriedLog('DEBUG');

// 使用
const now = new Date().toISOString();
infoLog(now)('用户登录');        // [INFO] 2025-10-11T...: 用户登录
errorLog(now)('数据库连接失败');  // [ERROR] 2025-10-11T...: 数据库连接失败
debugLog(now)('调试信息');       // [DEBUG] 2025-10-11T...: 调试信息

// 进一步固定时间戳
const infoLogNow = infoLog(now);
infoLogNow('操作A完成');
infoLogNow('操作B完成');
```

#### 2. 延迟执行与惰性求值

```javascript
// 场景:数据验证器
const validate = curry((rule, message, value) => {
  if (!rule(value)) {
    throw new Error(message);
  }
  return value;
});

// 定义验证规则
const isRequired = validate(
  val => val !== null && val !== undefined && val !== '',
  '此字段不能为空'
);

const isEmail = validate(
  val => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val),
  '邮箱格式不正确'
);

const minLength = min => validate(
  val => val.length >= min,
  `最小长度为 ${min} 个字符`
);

// 使用验证器
try {
  const email = isRequired('test@example.com');
  const validEmail = isEmail(email);
  const validPassword = minLength(8)('password123');

  console.log('验证通过');
} catch (error) {
  console.error('验证失败:', error.message);
}

// 组合多个验证器
function pipe(...fns) {
  return value => fns.reduce((result, fn) => fn(result), value);
}

const validateUser = pipe(
  isRequired,
  isEmail
);

try {
  validateUser('invalid-email'); // 抛出错误:邮箱格式不正确
} catch (error) {
  console.error(error.message);
}
```

#### 3. 动态创建函数

```javascript
// 场景:DOM 操作辅助函数
const setStyle = curry((property, value, element) => {
  element.style[property] = value;
  return element;
});

// 创建专用的样式设置函数
const setColor = setStyle('color');
const setBackgroundColor = setStyle('backgroundColor');
const setFontSize = setStyle('fontSize');

// 使用
const element = document.querySelector('#myElement');

setColor('red')(element);
setBackgroundColor('blue')(element);
setFontSize('16px')(element);

// 链式调用
const setRedText = setColor('red');
const setBlueBackground = setBackgroundColor('blue');

[...document.querySelectorAll('.highlight')]
  .map(setRedText)
  .map(setBlueBackground);

// 场景:HTTP 请求封装
const request = curry((method, url, data, config) => {
  return fetch(url, {
    method,
    body: JSON.stringify(data),
    ...config
  });
});

// 创建不同类型的请求函数
const get = request('GET');
const post = request('POST');
const put = request('PUT');
const del = request('DELETE');

// 创建特定 API 的请求函数
const apiPost = post('/api');
const createUser = apiPost('/users');
const updateUser = put('/api')('/users');

// 使用
createUser({ name: 'Alice', age: 25 })({ headers: { 'Content-Type': 'application/json' } })
  .then(res => res.json())
  .then(data => console.log(data));
```

#### 4. 函数组合

```javascript
// 场景:数据处理管道
const map = curry((fn, arr) => arr.map(fn));
const filter = curry((predicate, arr) => arr.filter(predicate));
const reduce = curry((fn, initial, arr) => arr.reduce(fn, initial));

// 组合函数
function compose(...fns) {
  return value => fns.reduceRight((result, fn) => fn(result), value);
}

function pipe(...fns) {
  return value => fns.reduce((result, fn) => fn(result), value);
}

// 数据处理示例
const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 定义处理步骤
const double = x => x * 2;
const isEven = x => x % 2 === 0;
const sum = (acc, x) => acc + x;

// 使用 pipe 组合(从左到右)
const processData = pipe(
  filter(isEven),        // 筛选偶数
  map(double),           // 每个数翻倍
  reduce(sum, 0)         // 求和
);

console.log(processData(data)); // 60
// 流程: [1,2,3,4,5,6,7,8,9,10]
//    -> [2,4,6,8,10] (筛选偶数)
//    -> [4,8,12,16,20] (翻倍)
//    -> 60 (求和)

// 实际应用:处理用户数据
const users = [
  { name: 'Alice', age: 25, active: true },
  { name: 'Bob', age: 30, active: false },
  { name: 'Charlie', age: 35, active: true },
  { name: 'David', age: 28, active: true }
];

const getActiveUsers = filter(user => user.active);
const getNames = map(user => user.name);
const joinNames = names => names.join(', ');

const getActiveUserNames = pipe(
  getActiveUsers,
  getNames,
  joinNames
);

console.log(getActiveUserNames(users)); // "Alice, Charlie, David"
```

#### 5. React 高阶组件

```javascript
// 场景:React HOC(高阶组件)
const withLoading = curry((LoadingComponent, WrappedComponent, props) => {
  return props.isLoading
    ? <LoadingComponent />
    : <WrappedComponent {...props} />;
});

const withAuth = curry((LoginComponent, WrappedComponent, props) => {
  return props.isAuthenticated
    ? <WrappedComponent {...props} />
    : <LoginComponent />;
});

// 创建专用的 HOC
const withDefaultLoading = withLoading(<Spinner />);
const withDefaultAuth = withAuth(<LoginPage />);

// 使用
function UserProfile(props) {
  return <div>{props.user.name}</div>;
}

const ProtectedUserProfile = withDefaultAuth(withDefaultLoading(UserProfile));

// 使用组件
<ProtectedUserProfile
  isAuthenticated={true}
  isLoading={false}
  user={{ name: 'Alice' }}
/>
```

#### 6. Redux 中间件

```javascript
// Redux 中间件的柯里化实现
const logger = store => next => action => {
  console.log('dispatching', action);
  const result = next(action);
  console.log('next state', store.getState());
  return result;
};

const thunk = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

// 使用中间件
const middleware = [logger, thunk];

// 应用中间件
const store = createStore(
  reducer,
  applyMiddleware(...middleware)
);

// 自定义中间件:API 调用
const apiMiddleware = curry((apiClient, store, next, action) => {
  if (action.type !== 'API_REQUEST') {
    return next(action);
  }

  const { endpoint, method, data, onSuccess, onError } = action.payload;

  return apiClient[method](endpoint, data)
    .then(response => {
      store.dispatch(onSuccess(response));
      return response;
    })
    .catch(error => {
      store.dispatch(onError(error));
      throw error;
    });
});

// 配置 API 客户端
const api = {
  get: (url) => fetch(url).then(r => r.json()),
  post: (url, data) => fetch(url, { method: 'POST', body: JSON.stringify(data) })
};

const configuredApiMiddleware = apiMiddleware(api);
```

#### 7. 函数式编程工具函数

```javascript
// 场景:实用工具函数库
const curry = require('./curry'); // 假设已实现

// 数组操作
const map = curry((fn, arr) => arr.map(fn));
const filter = curry((predicate, arr) => arr.filter(predicate));
const reduce = curry((fn, initial, arr) => arr.reduce(fn, initial));
const find = curry((predicate, arr) => arr.find(predicate));
const some = curry((predicate, arr) => arr.some(predicate));
const every = curry((predicate, arr) => arr.every(predicate));

// 对象操作
const prop = curry((key, obj) => obj[key]);
const pick = curry((keys, obj) =>
  keys.reduce((result, key) => {
    if (key in obj) result[key] = obj[key];
    return result;
  }, {})
);
const omit = curry((keys, obj) =>
  Object.keys(obj)
    .filter(key => !keys.includes(key))
    .reduce((result, key) => {
      result[key] = obj[key];
      return result;
    }, {})
);

// 字符串操作
const split = curry((separator, str) => str.split(separator));
const join = curry((separator, arr) => arr.join(separator));
const replace = curry((pattern, replacement, str) => str.replace(pattern, replacement));
const match = curry((pattern, str) => str.match(pattern));

// 逻辑操作
const equals = curry((a, b) => a === b);
const gt = curry((a, b) => b > a);
const lt = curry((a, b) => b < a);
const gte = curry((a, b) => b >= a);
const lte = curry((a, b) => b <= a);

// 使用示例:数据转换
const data = [
  { id: 1, name: 'Alice', email: 'alice@example.com', age: 25 },
  { id: 2, name: 'Bob', email: 'bob@example.com', age: 30 },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', age: 35 }
];

const getName = prop('name');
const getEmail = prop('email');
const isAdult = user => user.age >= 18;
const isOver30 = user => user.age > 30;

// 获取所有成年人的名字
const adultNames = pipe(
  filter(isAdult),
  map(getName)
);

console.log(adultNames(data)); // ['Alice', 'Bob', 'Charlie']

// 获取30岁以上用户的邮箱
const over30Emails = pipe(
  filter(isOver30),
  map(getEmail)
);

console.log(over30Emails(data)); // ['charlie@example.com']

// 提取特定字段
const pickNameAndEmail = pick(['name', 'email']);
const simplifiedUsers = map(pickNameAndEmail)(data);

console.log(simplifiedUsers);
// [
//   { name: 'Alice', email: 'alice@example.com' },
//   { name: 'Bob', email: 'bob@example.com' },
//   { name: 'Charlie', email: 'charlie@example.com' }
// ]
```

### 四、柯里化的优缺点

#### 1. 优点

```javascript
// 优点1:参数复用,减少重复代码
const multiply = curry((a, b, c) => a * b * c);
const multiplyBy2 = multiply(2);

// 不用每次都传入 2
console.log(multiplyBy2(3)(4));  // 24
console.log(multiplyBy2(5)(6));  // 60

// 优点2:提高代码可读性
// 普通写法
users.filter(u => u.age > 18).map(u => u.name);

// 柯里化写法
const over18 = filter(user => user.age > 18);
const getNames = map(prop('name'));
const getAdultNames = pipe(over18, getNames);

getAdultNames(users); // 更清晰的表达意图

// 优点3:便于函数组合
const processString = pipe(
  trim,
  toLowerCase,
  split(' '),
  map(capitalize),
  join(' ')
);

processString('  hello WORLD  '); // "Hello World"

// 优点4:延迟执行,提高性能
const expensiveCalculation = curry((a, b, c) => {
  console.log('执行复杂计算...');
  return a * b * c;
});

const step1 = expensiveCalculation(2);  // 不执行
const step2 = step1(3);                 // 不执行
// ... 其他逻辑
const result = step2(4);                // 此时才执行

// 优点5:支持点自由(Point-Free)风格
// 传统风格
const getActiveUserNames = users =>
  users.filter(u => u.active).map(u => u.name);

// Point-Free 风格(无需声明参数)
const getActiveUserNames = pipe(
  filter(prop('active')),
  map(prop('name'))
);
```

#### 2. 缺点

```javascript
// 缺点1:可读性问题(对不熟悉的人)
// 柯里化写法
const result = curry(fn)(a)(b)(c)(d);

// 普通写法更直观
const result = fn(a, b, c, d);

// 缺点2:性能开销(创建多层闭包)
// 柯里化版本
const curriedSum = curry((a, b, c, d, e) => a + b + c + d + e);
curriedSum(1)(2)(3)(4)(5); // 创建了 5 层闭包

// 普通版本(性能更好)
function sum(a, b, c, d, e) {
  return a + b + c + d + e;
}
sum(1, 2, 3, 4, 5); // 一次调用

// 缺点3:调试困难
const complexPipe = pipe(
  step1,
  step2,
  step3,
  step4
);

// 报错时难以定位是哪一步出问题

// 解决方案:添加调试函数
const debug = label => value => {
  console.log(label, value);
  return value;
};

const debugPipe = pipe(
  step1,
  debug('after step1'),
  step2,
  debug('after step2'),
  step3,
  debug('after step3'),
  step4
);

// 缺点4:类型推导困难(TypeScript)
// TypeScript 中柯里化的类型定义非常复杂
type Curry<P extends any[], R> = /* 复杂的类型定义 */;

// 解决方案:使用工具库(如 ramda)提供的类型定义
```

### 五、柯里化与相关概念的区别

#### 1. 柯里化 vs 偏函数

```javascript
// 柯里化:逐个传参,每次返回新函数
const curriedAdd = curry((a, b, c) => a + b + c);
curriedAdd(1)(2)(3);  // 必须一个个传

// 偏函数:一次可以固定多个参数
const partialAdd = partial((a, b, c) => a + b + c, 1);
partialAdd(2, 3);     // 可以一次传多个

// 柯里化总是返回单参数函数
const step1 = curriedAdd(1);     // 接受 1 个参数
const step2 = step1(2);           // 接受 1 个参数
const result = step2(3);          // 接受 1 个参数

// 偏函数返回的函数可以接受多个参数
const partialStep = partialAdd;   // 接受 2 个参数
const result = partialStep(2, 3); // 一次传入
```

#### 2. 柯里化 vs 闭包

```javascript
// 闭包:内部函数访问外部变量
function makeCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}

const counter = makeCounter();
counter(); // 1
counter(); // 2

// 柯里化:使用闭包保存参数,逐步收集
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return (...nextArgs) => curried(...args, ...nextArgs);
  };
}

// 柯里化是闭包的一种应用,但闭包不一定是柯里化
```

#### 3. 柯里化 vs 高阶函数

```javascript
// 高阶函数:接受函数作为参数或返回函数
function higherOrder(fn) {
  return function(...args) {
    console.log('Before');
    const result = fn(...args);
    console.log('After');
    return result;
  };
}

// 柯里化是一种特殊的高阶函数
// 特点:返回的函数用于收集参数,直到满足原函数执行条件

// 所有柯里化函数都是高阶函数
// 但不是所有高阶函数都是柯里化函数
```

### 六、实际开发建议

#### 1. 何时使用柯里化

```javascript
// ✅ 适合使用柯里化的场景

// 1. 需要参数复用
const request = curry((method, url, data) => {/* ... */});
const get = request('GET');
const post = request('POST');

// 2. 函数组合
const processData = pipe(
  filter(isValid),
  map(transform),
  reduce(sum, 0)
);

// 3. 配置化函数
const logger = curry((level, time, msg) => {/* ... */});
const infoLogger = logger('INFO');

// ❌ 不适合使用柯里化的场景

// 1. 简单的一次性函数
// 不要这样
const add = curry((a, b) => a + b);
add(1)(2);

// 应该这样
const add = (a, b) => a + b;
add(1, 2);

// 2. 性能关键路径
// 避免在循环中使用柯里化
for (let i = 0; i < 1000000; i++) {
  curriedFn(a)(b)(c); // 性能损耗
}

// 3. 团队不熟悉函数式编程
// 降低代码可读性,不利于维护
```

#### 2. 推荐的工具库

```javascript
// Lodash/fp
import { curry, map, filter } from 'lodash/fp';

const users = [/* ... */];
const getActiveNames = map('name')(filter({ active: true })(users));

// Ramda
import R from 'ramda';

const getActiveNames = R.pipe(
  R.filter(R.prop('active')),
  R.map(R.prop('name'))
);

// 自己实现(小项目)
const curry = fn => {
  return function curried(...args) {
    return args.length >= fn.length
      ? fn.apply(this, args)
      : (...nextArgs) => curried(...args, ...nextArgs);
  };
};
```

### 七、面试回答模板

**简洁版**:

柯里化是将多参数函数转换为一系列单参数函数的技术。

**核心思想**:通过闭包逐步收集参数,直到参数足够时执行原函数。

**主要优势**:
1. 参数复用 - 固定部分参数创建新函数
2. 延迟执行 - 分步传参,最后才执行
3. 函数组合 - 便于 pipe 和 compose
4. 提高可读性 - 支持 Point-Free 风格

**实现要点**:使用递归和闭包,判断参数数量是否满足,不满足则继续返回函数收集参数。

**应用场景**:日志记录、权限校验、数据验证、Redux 中间件、React HOC。

**详细版**:

柯里化(Currying)是函数式编程中的重要技术,指将接受多个参数的函数转换为一系列只接受单个参数的函数的过程。

**核心原理**是利用闭包保存已传入的参数,每次调用时收集新参数,直到参数数量满足原函数要求时才真正执行。例如 `add(1, 2, 3)` 柯里化后变成 `add(1)(2)(3)`。

**实现方式**:基础版本通过递归实现,检查当前参数数量,如果少于原函数参数个数,返回新函数继续收集参数,否则执行原函数。完整版本还需要支持多参数传递、占位符、this 绑定等特性。

**主要优势**包括:
1. **参数复用**:固定部分参数创建专用函数,如 `logger('INFO')` 创建专门的 info 日志函数
2. **延迟执行**:分步传参,可以在合适时机才完成计算
3. **函数组合**:便于使用 pipe 和 compose 构建数据处理管道
4. **提高可读性**:支持 Point-Free 风格,避免声明临时变量

**实际应用**非常广泛:在 Redux 中间件中使用三层柯里化 `store => next => action`;在 React 中创建可配置的高阶组件;在数据处理中组合 map、filter、reduce 等操作;在工具函数库(如 Ramda)中作为核心实现方式。

**需要注意**的是柯里化会带来一定性能开销,因为会创建多层闭包,调试也相对困难。在实际开发中,应该在适合的场景使用,如需要参数复用或函数组合时。对于简单的一次性函数,普通实现更合适。推荐使用 Lodash/fp 或 Ramda 等成熟的函数式库,而不是手动实现。
