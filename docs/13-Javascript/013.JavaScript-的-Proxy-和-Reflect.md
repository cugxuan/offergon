---
title: JavaScript 的 Proxy 和 Reflect
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: javascript-proxy-and-reflect
ref:
---

## 核心要点总结

**Proxy元编程**：拦截和自定义对象操作（属性访问、赋值、枚举、函数调用等）的强大机制
**Reflect反射API**：提供拦截操作的默认行为，与Proxy配合使用，规范化元编程操作
**应用场景**：数据绑定、验证、缓存、观察者模式、API代理等高级编程模式

## 详细回答

### 1. Proxy基础概念

Proxy是ES6引入的元编程特性，允许拦截并自定义基本操作（如属性查找、赋值、枚举、函数调用等）。

**基本语法**：
```javascript
const proxy = new Proxy(target, handler);
```

- `target`：被包装的原始对象
- `handler`：定义哪些操作被拦截以及如何重新定义被拦截的操作

**简单示例**：
```javascript
// 基本用法
const person = {
  name: 'John',
  age: 30
};

const personProxy = new Proxy(person, {
  get(target, property, receiver) {
    console.log(`访问属性: ${property}`);
    return target[property];
  },

  set(target, property, value, receiver) {
    console.log(`设置属性: ${property} = ${value}`);
    target[property] = value;
    return true;
  }
});

personProxy.name; // 输出: 访问属性: name
personProxy.age = 31; // 输出: 设置属性: age = 31
```

### 2. Proxy Handler方法详解

Proxy支持13种不同的handler方法（陷阱），可以拦截对象的各种操作：

**属性访问陷阱**：
```javascript
const target = { a: 1, b: 2 };

const proxy = new Proxy(target, {
  // 拦截属性读取
  get(target, property, receiver) {
    console.log(`读取属性: ${property}`);
    if (property in target) {
      return target[property];
    } else {
      return `属性 ${property} 不存在`;
    }
  },

  // 拦截属性设置
  set(target, property, value, receiver) {
    console.log(`设置属性: ${property} = ${value}`);
    if (typeof value === 'number') {
      target[property] = value;
      return true;
    } else {
      throw new TypeError('值必须是数字');
    }
  },

  // 拦截 in 操作符
  has(target, property) {
    console.log(`检查属性: ${property}`);
    return property in target;
  },

  // 拦截 delete 操作
  deleteProperty(target, property) {
    console.log(`删除属性: ${property}`);
    if (property in target) {
      delete target[property];
      return true;
    }
    return false;
  }
});

proxy.a; // 读取属性: a
proxy.c; // 读取属性: c -> "属性 c 不存在"
proxy.c = 3; // 设置属性: c = 3
'a' in proxy; // 检查属性: a
delete proxy.b; // 删除属性: b
```

**函数调用陷阱**：
```javascript
function target(a, b) {
  return a + b;
}

const functionProxy = new Proxy(target, {
  // 拦截函数调用
  apply(target, thisArg, argumentsList) {
    console.log(`调用函数，参数: ${argumentsList}`);
    // 参数验证
    if (argumentsList.every(arg => typeof arg === 'number')) {
      return target.apply(thisArg, argumentsList);
    } else {
      throw new TypeError('所有参数必须是数字');
    }
  },

  // 拦截 new 操作符
  construct(target, argumentsList, newTarget) {
    console.log(`使用 new 调用，参数: ${argumentsList}`);
    return new target(...argumentsList);
  }
});

functionProxy(1, 2); // 调用函数，参数: 1,2 -> 3
new functionProxy(1, 2); // 使用 new 调用，参数: 1,2
```

**属性枚举陷阱**：
```javascript
const target = { a: 1, b: 2, c: 3 };

const proxy = new Proxy(target, {
  // 拦截 Object.getOwnPropertyNames()
  ownKeys(target) {
    console.log('获取自有属性列表');
    return Object.getOwnPropertyNames(target).filter(key => key !== 'c');
  },

  // 拦截 Object.getPropertyDescriptor()
  getOwnPropertyDescriptor(target, property) {
    console.log(`获取属性描述符: ${property}`);
    return Object.getOwnPropertyDescriptor(target, property);
  },

  // 拦截 Object.defineProperty()
  defineProperty(target, property, descriptor) {
    console.log(`定义属性: ${property}`);
    return Object.defineProperty(target, property, descriptor);
  }
});

Object.keys(proxy); // 获取自有属性列表 -> ['a', 'b']
Object.getOwnPropertyDescriptor(proxy, 'a'); // 获取属性描述符: a
```

### 3. Reflect API详解

Reflect是ES6引入的内置对象，提供拦截JavaScript操作的方法。这些方法与Proxy的handler方法一一对应。

**为什么需要Reflect**：
1. 将`Object`的一些明显属于语言内部的方法移植到`Reflect`上
2. 修改某些`Object`方法的返回结果，让其变得更合理
3. 让`Object`操作都变成函数行为
4. `Reflect`方法与`Proxy`方法一一对应

**Reflect与传统操作对比**：
```javascript
const obj = { name: 'John', age: 30 };

// 传统方式 vs Reflect方式

// 属性访问
console.log(obj.name);                    // 传统
console.log(Reflect.get(obj, 'name'));    // Reflect

// 属性设置
obj.age = 31;                             // 传统
Reflect.set(obj, 'age', 31);              // Reflect

// 检查属性存在
console.log('name' in obj);               // 传统
console.log(Reflect.has(obj, 'name'));    // Reflect

// 删除属性
delete obj.age;                           // 传统
Reflect.deleteProperty(obj, 'age');       // Reflect

// 获取属性列表
console.log(Object.keys(obj));            // 传统
console.log(Reflect.ownKeys(obj));        // Reflect
```

**Reflect的优势**：
```javascript
// 更好的错误处理
const obj = {};

// 传统方式：可能抛出异常
try {
  Object.defineProperty(obj, 'name', {
    value: 'John',
    writable: false
  });
} catch (e) {
  console.log('定义属性失败');
}

// Reflect方式：返回布尔值
const success = Reflect.defineProperty(obj, 'name', {
  value: 'John',
  writable: false
});

if (success) {
  console.log('属性定义成功');
} else {
  console.log('属性定义失败');
}
```

### 4. Proxy + Reflect最佳实践

将Proxy和Reflect结合使用，可以确保代理对象的行为与原对象保持一致：

```javascript
const target = {
  name: 'John',
  age: 30
};

const proxy = new Proxy(target, {
  get(target, property, receiver) {
    console.log(`访问属性: ${property}`);
    // 使用Reflect确保正确的行为
    return Reflect.get(target, property, receiver);
  },

  set(target, property, value, receiver) {
    console.log(`设置属性: ${property} = ${value}`);

    // 数据验证
    if (property === 'age' && typeof value !== 'number') {
      throw new TypeError('age必须是数字');
    }

    // 使用Reflect执行默认行为
    return Reflect.set(target, property, value, receiver);
  },

  has(target, property) {
    console.log(`检查属性: ${property}`);
    return Reflect.has(target, property);
  },

  deleteProperty(target, property) {
    console.log(`删除属性: ${property}`);
    if (property === 'name') {
      console.log('name属性不能删除');
      return false;
    }
    return Reflect.deleteProperty(target, property);
  }
});
```

### 5. 实际应用场景

**1. 数据验证和转换**：
```javascript
function createValidatedUser(userData) {
  const user = { ...userData };

  return new Proxy(user, {
    set(target, property, value) {
      // 验证规则
      const validations = {
        name: (val) => typeof val === 'string' && val.length > 0,
        age: (val) => typeof val === 'number' && val >= 0 && val <= 150,
        email: (val) => typeof val === 'string' && val.includes('@')
      };

      if (validations[property]) {
        if (!validations[property](value)) {
          throw new Error(`Invalid ${property}: ${value}`);
        }
      }

      // 数据转换
      if (property === 'name') {
        value = value.trim().toLowerCase();
      }

      return Reflect.set(target, property, value);
    }
  });
}

const user = createValidatedUser({});
user.name = ' JOHN '; // 自动转换为 'john'
user.age = 25;        // 验证通过
// user.age = -5;     // 抛出错误
```

**2. 属性访问日志记录**：
```javascript
function createLogger(target, loggerName = 'Unknown') {
  return new Proxy(target, {
    get(target, property, receiver) {
      const value = Reflect.get(target, property, receiver);

      if (typeof value === 'function') {
        return function(...args) {
          console.log(`[${loggerName}] 调用方法: ${property}(${args.join(', ')})`);
          const result = value.apply(this, args);
          console.log(`[${loggerName}] 方法返回:`, result);
          return result;
        };
      } else {
        console.log(`[${loggerName}] 访问属性: ${property} = ${value}`);
        return value;
      }
    },

    set(target, property, value, receiver) {
      console.log(`[${loggerName}] 设置属性: ${property} = ${value}`);
      return Reflect.set(target, property, value, receiver);
    }
  });
}

const calculator = createLogger({
  add(a, b) { return a + b; },
  subtract(a, b) { return a - b; }
}, 'Calculator');

calculator.add(5, 3); // 记录方法调用和返回值
```

**3. 属性的默认值和计算属性**：
```javascript
function createDefaultObject(defaults = {}) {
  return new Proxy({}, {
    get(target, property) {
      if (property in target) {
        return target[property];
      }

      // 计算属性
      if (property === 'fullName') {
        return `${target.firstName || ''} ${target.lastName || ''}`.trim();
      }

      // 默认值
      if (property in defaults) {
        return defaults[property];
      }

      return undefined;
    },

    set(target, property, value) {
      return Reflect.set(target, property, value);
    }
  });
}

const person = createDefaultObject({
  age: 0,
  country: 'Unknown'
});

person.firstName = 'John';
person.lastName = 'Doe';
console.log(person.fullName); // 'John Doe'
console.log(person.age);      // 0 (默认值)
console.log(person.country);  // 'Unknown' (默认值)
```

**4. API代理和缓存**：
```javascript
function createApiProxy(baseUrl, cacheTime = 5000) {
  const cache = new Map();

  return new Proxy({}, {
    get(target, endpoint) {
      return async function(params = {}) {
        const cacheKey = `${endpoint}:${JSON.stringify(params)}`;

        // 检查缓存
        if (cache.has(cacheKey)) {
          const { data, timestamp } = cache.get(cacheKey);
          if (Date.now() - timestamp < cacheTime) {
            console.log(`从缓存返回: ${endpoint}`);
            return data;
          }
        }

        // 发起API请求
        console.log(`API请求: ${endpoint}`);
        const url = new URL(endpoint, baseUrl);
        Object.entries(params).forEach(([key, value]) => {
          url.searchParams.set(key, value);
        });

        try {
          const response = await fetch(url);
          const data = await response.json();

          // 缓存结果
          cache.set(cacheKey, {
            data,
            timestamp: Date.now()
          });

          return data;
        } catch (error) {
          console.error(`API请求失败: ${endpoint}`, error);
          throw error;
        }
      };
    }
  });
}

const api = createApiProxy('https://api.example.com');

// 用法
api.users({ page: 1, limit: 10 });  // API请求
api.users({ page: 1, limit: 10 });  // 从缓存返回
```

**5. 观察者模式实现**：
```javascript
function createObservable(target, observer) {
  return new Proxy(target, {
    set(target, property, value, receiver) {
      const oldValue = target[property];
      const result = Reflect.set(target, property, value, receiver);

      if (oldValue !== value) {
        observer({
          type: 'set',
          property,
          oldValue,
          newValue: value,
          target
        });
      }

      return result;
    },

    deleteProperty(target, property) {
      const oldValue = target[property];
      const result = Reflect.deleteProperty(target, property);

      if (result) {
        observer({
          type: 'delete',
          property,
          oldValue,
          target
        });
      }

      return result;
    }
  });
}

// 使用示例
const data = createObservable(
  { name: 'John', age: 30 },
  (change) => {
    console.log('数据变化:', change);
  }
);

data.name = 'Jane';  // 输出: 数据变化: { type: 'set', property: 'name', oldValue: 'John', newValue: 'Jane', target: ... }
delete data.age;     // 输出: 数据变化: { type: 'delete', property: 'age', oldValue: 30, target: ... }
```

### 6. 性能考虑和限制

**性能影响**：
```javascript
// 性能测试
const target = { value: 0 };
const proxy = new Proxy(target, {
  get(target, property) {
    return Reflect.get(target, property);
  },
  set(target, property, value) {
    return Reflect.set(target, property, value);
  }
});

// 直接访问 vs 代理访问性能对比
console.time('直接访问');
for (let i = 0; i < 1000000; i++) {
  target.value = i;
}
console.timeEnd('直接访问');

console.time('代理访问');
for (let i = 0; i < 1000000; i++) {
  proxy.value = i;
}
console.timeEnd('代理访问');
```

**Proxy的限制**：
```javascript
// 1. 内置对象的特殊行为可能无法代理
const date = new Date();
const dateProxy = new Proxy(date, {
  get(target, property) {
    console.log(`访问Date属性: ${property}`);
    return Reflect.get(target, property);
  }
});

// 某些Date方法可能无法正常工作
// dateProxy.getTime(); // 可能出现问题

// 2. Proxy无法拦截某些内部操作
const map = new Map();
const mapProxy = new Proxy(map, {
  get(target, property) {
    return Reflect.get(target, property);
  }
});

// Map的内部实现不会触发Proxy陷阱
mapProxy.set('key', 'value'); // 可能不会按预期工作

// 3. 代理的代理可能出现意外行为
const target = {};
const proxy1 = new Proxy(target, {});
const proxy2 = new Proxy(proxy1, {});
console.log(proxy2 === proxy1); // false
```

### 7. 最佳实践和注意事项

**1. 始终使用Reflect**：
```javascript
// 好的做法
const proxy = new Proxy(target, {
  get(target, property, receiver) {
    // 使用Reflect确保正确的this绑定
    return Reflect.get(target, property, receiver);
  }
});

// 避免的做法
const proxy = new Proxy(target, {
  get(target, property) {
    // 直接访问可能丢失this绑定
    return target[property];
  }
});
```

**2. 合理处理异常**：
```javascript
const proxy = new Proxy(target, {
  set(target, property, value, receiver) {
    try {
      // 验证逻辑
      validateProperty(property, value);
      return Reflect.set(target, property, value, receiver);
    } catch (error) {
      console.error(`设置属性失败: ${property}`, error);
      return false; // 返回false表示设置失败
    }
  }
});
```

**3. 避免无限递归**：
```javascript
const proxy = new Proxy(target, {
  get(target, property, receiver) {
    if (property === 'self') {
      return receiver; // 返回代理自身
    }
    return Reflect.get(target, property, receiver);
  }
});

// 避免这样的陷阱
// proxy.self.self.self... // 可能导致问题
```

Proxy和Reflect是JavaScript中强大的元编程工具，能够实现许多高级编程模式。正确使用它们可以大大提升代码的灵活性和表达力，但也需要注意性能影响和使用限制。
