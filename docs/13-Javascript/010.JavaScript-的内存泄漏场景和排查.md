---
title: JavaScript 的内存泄漏场景和排查
tags:
  - JavaScript
  - 内存管理
status: robot
class: 前端JavaScript
slug: js-memory-leak-scenarios-and-debugging
ref:
---

## 核心要点
- **常见泄漏场景**：事件监听器、定时器、闭包、DOM引用、全局变量
- **检测工具**：Chrome DevTools、Performance API、内存分析器
- **预防策略**：及时清理、弱引用、对象池、生命周期管理

## 详细解答

### 1. 内存泄漏基础概念

内存泄漏是指程序中不再使用的内存无法被垃圾回收器回收，导致可用内存逐渐减少。在JavaScript中，虽然有自动垃圾回收机制，但仍然可能因为错误的编程模式导致内存泄漏。

```javascript
// 内存泄漏示例
let leakedArray = [];

function createLeak() {
    const data = new Array(100000).fill('data');

    // 意外地将大数据添加到全局数组
    leakedArray.push(data);

    // 即使函数结束，data仍然被全局数组引用，无法回收
}

// 每次调用都会泄漏约800KB内存
for (let i = 0; i < 100; i++) {
    createLeak();
}

console.log(`Leaked ${leakedArray.length} arrays`); // 100个数组永远不会被回收
```

### 2. 常见内存泄漏场景

#### 2.1 事件监听器泄漏

```javascript
// 场景1：忘记移除事件监听器
class ComponentWithLeak {
    constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.data = new Array(50000).fill('large data');

        // 添加事件监听器
        this.handleClick = this.handleClick.bind(this);
        this.element.addEventListener('click', this.handleClick);

        // 组件销毁时没有移除监听器
        // DOM元素通过事件监听器持有组件实例的引用
    }

    handleClick() {
        console.log('Processing data:', this.data.length);
    }

    // 缺少cleanup方法
}

// 修复版本
class ComponentFixed {
    constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.data = new Array(50000).fill('large data');

        this.handleClick = this.handleClick.bind(this);
        this.element.addEventListener('click', this.handleClick);
    }

    handleClick() {
        console.log('Processing data:', this.data.length);
    }

    destroy() {
        // 正确移除事件监听器
        this.element.removeEventListener('click', this.handleClick);

        // 清理数据引用
        this.data = null;
        this.element = null;
    }
}

// 场景2：委托事件的错误使用
class EventDelegationLeak {
    constructor() {
        this.cache = new Map();

        // 错误：每次都添加新的监听器
        this.setupEventDelegation();
    }

    setupEventDelegation() {
        document.addEventListener('click', (e) => {
            if (e.target.matches('.dynamic-button')) {
                // 处理逻辑中引用了this.cache
                this.cache.set(e.target.id, Date.now());
            }
        });

        // 多次调用setupEventDelegation会添加多个监听器
        // 每个监听器都持有组件实例的引用
    }
}

// 修复版本
class EventDelegationFixed {
    constructor() {
        this.cache = new Map();
        this.boundHandler = this.handleDelegatedClick.bind(this);

        document.addEventListener('click', this.boundHandler);
    }

    handleDelegatedClick(e) {
        if (e.target.matches('.dynamic-button')) {
            this.cache.set(e.target.id, Date.now());
        }
    }

    destroy() {
        document.removeEventListener('click', this.boundHandler);
        this.cache.clear();
        this.cache = null;
    }
}
```

#### 2.2 定时器和异步操作泄漏

```javascript
// 场景1：setInterval泄漏
class TimerLeak {
    constructor() {
        this.data = new Array(100000).fill('timer data');
        this.counter = 0;

        // 忘记保存timer ID
        setInterval(() => {
            this.counter++;
            console.log(`Counter: ${this.counter}, Data size: ${this.data.length}`);
        }, 1000);

        // 无法清除定时器，组件永远不会被回收
    }
}

// 修复版本
class TimerFixed {
    constructor() {
        this.data = new Array(100000).fill('timer data');
        this.counter = 0;

        // 保存timer ID
        this.timerId = setInterval(() => {
            this.counter++;
            console.log(`Counter: ${this.counter}, Data size: ${this.data.length}`);
        }, 1000);
    }

    destroy() {
        clearInterval(this.timerId);
        this.data = null;
    }
}

// 场景2：Promise和async/await泄漏
class AsyncLeak {
    constructor() {
        this.cache = new Map();
        this.startAsyncOperations();
    }

    async startAsyncOperations() {
        // 长期运行的异步循环
        while (true) {
            try {
                const data = await this.fetchData();
                this.cache.set(Date.now(), data);

                // 缓存无限增长
                if (this.cache.size > 1000) {
                    // 应该清理旧数据，但忘记了
                }

                await new Promise(resolve => setTimeout(resolve, 100));
            } catch (error) {
                console.error('Fetch error:', error);
            }
        }
    }

    async fetchData() {
        // 模拟API调用
        return new Array(1000).fill('api data');
    }
}

// 修复版本
class AsyncFixed {
    constructor() {
        this.cache = new Map();
        this.isRunning = true;
        this.maxCacheSize = 1000;
        this.startAsyncOperations();
    }

    async startAsyncOperations() {
        while (this.isRunning) {
            try {
                const data = await this.fetchData();
                this.cache.set(Date.now(), data);

                // 限制缓存大小
                if (this.cache.size > this.maxCacheSize) {
                    const oldestKey = Math.min(...this.cache.keys());
                    this.cache.delete(oldestKey);
                }

                await new Promise(resolve => setTimeout(resolve, 100));
            } catch (error) {
                console.error('Fetch error:', error);
            }
        }
    }

    async fetchData() {
        return new Array(1000).fill('api data');
    }

    destroy() {
        this.isRunning = false;
        this.cache.clear();
        this.cache = null;
    }
}
```

#### 2.3 闭包泄漏

```javascript
// 场景1：闭包保持大对象引用
function createClosureLeak() {
    const largeData = new Array(1000000).fill('large data');
    const smallData = { id: 1, name: 'small' };

    // 返回的函数只使用smallData，但闭包保持整个作用域
    return function() {
        return smallData.name;
    };
}

const leakyFunction = createClosureLeak();
// largeData永远不会被回收

// 修复版本1：分离需要的数据
function createClosureFixed1() {
    const largeData = new Array(1000000).fill('large data');
    const smallData = { id: 1, name: 'small' };

    // 提取需要的值
    const name = smallData.name;

    return function() {
        return name; // 只引用需要的值
    };
    // largeData和smallData可以被回收
}

// 修复版本2：使用IIFE清理引用
function createClosureFixed2() {
    const largeData = new Array(1000000).fill('large data');
    const smallData = { id: 1, name: 'small' };

    return (function(name) {
        // 在IIFE中处理数据，清理外部引用
        return function() {
            return name;
        };
    })(smallData.name);
}

// 场景2：事件处理器闭包泄漏
class ClosureEventLeak {
    constructor() {
        this.largeCache = new Map();
        this.setupEventHandlers();
    }

    setupEventHandlers() {
        const buttons = document.querySelectorAll('.action-button');

        buttons.forEach(button => {
            // 每个按钮的事件处理器都捕获了整个this
            button.addEventListener('click', () => {
                this.handleButtonClick(button.id);
            });
        });
    }

    handleButtonClick(buttonId) {
        // 只使用buttonId，但闭包保持整个this.largeCache的引用
        console.log('Button clicked:', buttonId);
    }
}

// 修复版本
class ClosureEventFixed {
    constructor() {
        this.largeCache = new Map();
        this.eventHandlers = new Map();
        this.setupEventHandlers();
    }

    setupEventHandlers() {
        const buttons = document.querySelectorAll('.action-button');

        buttons.forEach(button => {
            // 使用bind避免闭包
            const handler = this.handleButtonClick.bind(this, button.id);
            button.addEventListener('click', handler);

            // 保存处理器引用以便清理
            this.eventHandlers.set(button, handler);
        });
    }

    handleButtonClick(buttonId) {
        console.log('Button clicked:', buttonId);
    }

    destroy() {
        this.eventHandlers.forEach((handler, button) => {
            button.removeEventListener('click', handler);
        });
        this.eventHandlers.clear();
        this.largeCache.clear();
    }
}
```

#### 2.4 DOM引用泄漏

```javascript
// 场景1：分离的DOM节点
class DOMReferenceLeak {
    constructor() {
        this.container = document.getElementById('container');
        this.childNodes = [];

        this.createDOMElements();
    }

    createDOMElements() {
        for (let i = 0; i < 1000; i++) {
            const div = document.createElement('div');
            div.textContent = `Item ${i}`;
            div.dataset.index = i;

            // 保存DOM节点引用
            this.childNodes.push(div);
            this.container.appendChild(div);
        }
    }

    removeAllElements() {
        // 错误：只从DOM中移除，但JavaScript仍然持有引用
        this.container.innerHTML = '';

        // this.childNodes仍然引用已分离的DOM节点
        // 这些节点无法被垃圾回收
    }
}

// 修复版本
class DOMReferenceFixed {
    constructor() {
        this.container = document.getElementById('container');
        this.childNodes = [];

        this.createDOMElements();
    }

    createDOMElements() {
        for (let i = 0; i < 1000; i++) {
            const div = document.createElement('div');
            div.textContent = `Item ${i}`;
            div.dataset.index = i;

            this.childNodes.push(div);
            this.container.appendChild(div);
        }
    }

    removeAllElements() {
        // 正确：同时清理DOM和JavaScript引用
        this.childNodes.forEach(node => {
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
        });

        // 清理JavaScript引用
        this.childNodes = [];
    }

    destroy() {
        this.removeAllElements();
        this.container = null;
    }
}

// 场景2：循环引用（DOM和JavaScript对象）
class CircularReferenceLeak {
    constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.data = new Array(10000).fill('data');

        // 创建循环引用
        this.element.component = this; // DOM引用组件
        this.element.onclick = () => {
            this.handleClick(); // 事件处理器引用组件
        };
    }

    handleClick() {
        console.log('Data length:', this.data.length);
    }

    // 没有破除循环引用的清理方法
}

// 修复版本
class CircularReferenceFixed {
    constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.data = new Array(10000).fill('data');

        this.element.component = this;
        this.boundHandler = this.handleClick.bind(this);
        this.element.addEventListener('click', this.boundHandler);
    }

    handleClick() {
        console.log('Data length:', this.data.length);
    }

    destroy() {
        // 破除循环引用
        this.element.removeEventListener('click', this.boundHandler);
        delete this.element.component;

        this.element = null;
        this.data = null;
        this.boundHandler = null;
    }
}
```

#### 2.5 全局变量泄漏

```javascript
// 场景1：意外的全局变量
function accidentalGlobal() {
    // 忘记声明变量，创建全局变量
    leakedData = new Array(100000).fill('data');

    for (i = 0; i < 1000; i++) { // 忘记声明i
        // 处理逻辑
    }

    // leakedData和i成为全局变量，永远不会被回收
}

// 修复版本：使用严格模式
'use strict';

function properDeclaration() {
    const data = new Array(100000).fill('data'); // 正确声明

    for (let i = 0; i < 1000; i++) { // 正确声明
        // 处理逻辑
    }

    // 函数结束后，data和i可以被回收
}

// 场景2：全局缓存无限增长
const globalCache = new Map();

function addToGlobalCache(key, data) {
    globalCache.set(key, data);

    // 缓存永远不会清理，无限增长
}

// 使用LRU缓存修复
class LRUCache {
    constructor(maxSize = 1000) {
        this.maxSize = maxSize;
        this.cache = new Map();
    }

    get(key) {
        if (this.cache.has(key)) {
            const value = this.cache.get(key);
            // 更新访问顺序
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return null;
    }

    set(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
            // 删除最旧的条目
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        this.cache.set(key, value);
    }

    clear() {
        this.cache.clear();
    }
}

const managedCache = new LRUCache(500);
```

### 3. 内存泄漏检测工具

#### 3.1 Chrome DevTools Memory面板

```javascript
// 内存快照分析示例
class MemoryLeakDetection {
    constructor() {
        this.leakyData = [];
        this.counter = 0;
    }

    // 故意创建内存泄漏用于演示
    createLeak() {
        const data = {
            id: this.counter++,
            payload: new Array(10000).fill(`data-${this.counter}`),
            timestamp: Date.now()
        };

        this.leakyData.push(data);

        console.log(`Created leak #${this.counter}, total: ${this.leakyData.length}`);
    }

    // 分析内存使用
    analyzeMemory() {
        if (performance.memory) {
            const memory = performance.memory;
            console.log({
                used: `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
                total: `${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
                limit: `${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`
            });
        }
    }

    // 提供清理方法用于测试
    cleanup() {
        this.leakyData = [];
        console.log('Memory cleaned up');
    }
}

// 使用方法：
// 1. 在Chrome中打开DevTools → Memory
// 2. 运行以下代码创建泄漏
const detector = new MemoryLeakDetection();

// 创建内存泄漏
const leakInterval = setInterval(() => {
    detector.createLeak();
    detector.analyzeMemory();
}, 100);

// 在DevTools中拍摄Heap Snapshot，观察内存增长
// 停止泄漏并清理
// setTimeout(() => {
//     clearInterval(leakInterval);
//     detector.cleanup();
// }, 5000);
```

#### 3.2 Performance API监控

```javascript
class PerformanceMemoryMonitor {
    constructor() {
        this.samples = [];
        this.isMonitoring = false;
    }

    startMonitoring(interval = 1000) {
        if (this.isMonitoring) return;

        this.isMonitoring = true;

        this.monitoringId = setInterval(() => {
            this.takeSample();
        }, interval);

        console.log('Memory monitoring started');
    }

    stopMonitoring() {
        if (!this.isMonitoring) return;

        clearInterval(this.monitoringId);
        this.isMonitoring = false;

        console.log('Memory monitoring stopped');
        this.generateReport();
    }

    takeSample() {
        const sample = {
            timestamp: Date.now(),
            memory: null,
            gc: this.detectGC()
        };

        if (performance.memory) {
            sample.memory = {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }

        this.samples.push(sample);

        // 检测内存泄漏
        this.checkForLeak();
    }

    detectGC() {
        // 简单的GC检测逻辑
        const lastSample = this.samples[this.samples.length - 1];
        if (lastSample && lastSample.memory) {
            const currentUsed = performance.memory.usedJSHeapSize;
            const lastUsed = lastSample.memory.used;

            // 如果内存使用量显著下降，可能发生了GC
            return currentUsed < lastUsed * 0.9;
        }

        return false;
    }

    checkForLeak() {
        if (this.samples.length < 10) return;

        const recent = this.samples.slice(-10);
        const trend = this.calculateTrend(recent);

        if (trend > 50000) { // 50KB/s 增长率
            console.warn('Potential memory leak detected:', {
                trendPerSecond: `${(trend / 1024).toFixed(2)} KB/s`,
                currentUsage: `${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`
            });
        }
    }

    calculateTrend(samples) {
        if (samples.length < 2) return 0;

        const first = samples[0];
        const last = samples[samples.length - 1];

        const timeDiff = (last.timestamp - first.timestamp) / 1000; // 秒
        const memoryDiff = last.memory.used - first.memory.used;

        return memoryDiff / timeDiff; // 字节/秒
    }

    generateReport() {
        if (this.samples.length === 0) return;

        const first = this.samples[0];
        const last = this.samples[this.samples.length - 1];

        const report = {
            duration: `${((last.timestamp - first.timestamp) / 1000).toFixed(2)} seconds`,
            samples: this.samples.length,
            memoryGrowth: `${((last.memory.used - first.memory.used) / 1024 / 1024).toFixed(2)} MB`,
            averageTrend: `${(this.calculateTrend(this.samples) / 1024).toFixed(2)} KB/s`,
            gcEvents: this.samples.filter(s => s.gc).length
        };

        console.log('Memory Monitoring Report:', report);
        return report;
    }
}

// 使用示例
const monitor = new PerformanceMemoryMonitor();
monitor.startMonitoring(500); // 每500ms采样一次

// 模拟内存泄漏
const leakyArray = [];
const leakInterval = setInterval(() => {
    leakyArray.push(new Array(1000).fill('leak'));
}, 100);

// 10秒后停止监控
setTimeout(() => {
    clearInterval(leakInterval);
    monitor.stopMonitoring();
}, 10000);
```

#### 3.3 自定义内存分析器

```javascript
class CustomMemoryAnalyzer {
    constructor() {
        this.objectCounts = new Map();
        this.objectSizes = new Map();
        this.creationStacks = new Map();
    }

    // 跟踪对象创建
    trackObject(obj, type, size = 0) {
        const id = this.generateObjectId(obj);

        // 记录对象类型和数量
        this.objectCounts.set(type, (this.objectCounts.get(type) || 0) + 1);

        // 记录对象大小
        if (size > 0) {
            this.objectSizes.set(id, { type, size, created: Date.now() });
        }

        // 记录创建栈（在开发环境中）
        if (typeof Error !== 'undefined') {
            this.creationStacks.set(id, new Error().stack);
        }

        return id;
    }

    // 跟踪对象销毁
    untrackObject(obj, type) {
        const id = this.generateObjectId(obj);

        this.objectCounts.set(type, Math.max(0, (this.objectCounts.get(type) || 0) - 1));
        this.objectSizes.delete(id);
        this.creationStacks.delete(id);
    }

    generateObjectId(obj) {
        // 简单的对象ID生成（实际应用中可能需要更复杂的方案）
        if (!obj._memoryTrackerId) {
            obj._memoryTrackerId = `obj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        return obj._memoryTrackerId;
    }

    // 生成内存报告
    generateReport() {
        const report = {
            objectCounts: Object.fromEntries(this.objectCounts),
            totalTrackedObjects: this.objectSizes.size,
            memoryByType: this.calculateMemoryByType(),
            oldestObjects: this.findOldestObjects(10),
            suspiciousObjects: this.findSuspiciousObjects()
        };

        console.log('Memory Analysis Report:', report);
        return report;
    }

    calculateMemoryByType() {
        const memoryByType = new Map();

        for (const { type, size } of this.objectSizes.values()) {
            memoryByType.set(type, (memoryByType.get(type) || 0) + size);
        }

        return Object.fromEntries(memoryByType);
    }

    findOldestObjects(count = 10) {
        const objects = Array.from(this.objectSizes.entries())
            .map(([id, data]) => ({ id, ...data }))
            .sort((a, b) => a.created - b.created)
            .slice(0, count);

        return objects;
    }

    findSuspiciousObjects() {
        const now = Date.now();
        const oneMinuteAgo = now - 60000;

        // 查找存活超过1分钟的大对象
        const suspicious = Array.from(this.objectSizes.entries())
            .filter(([id, data]) => data.created < oneMinuteAgo && data.size > 10000)
            .map(([id, data]) => ({
                id,
                ...data,
                age: now - data.created,
                stack: this.creationStacks.get(id)
            }));

        return suspicious;
    }
}

// 使用示例
const analyzer = new CustomMemoryAnalyzer();

// 包装对象创建函数
function createTrackedArray(size, type = 'Array') {
    const arr = new Array(size).fill('data');
    analyzer.trackObject(arr, type, size * 8); // 估算内存大小
    return arr;
}

function createTrackedObject(data, type = 'Object') {
    const obj = { ...data };
    analyzer.trackObject(obj, type, JSON.stringify(data).length * 2);
    return obj;
}

// 测试内存跟踪
const trackedObjects = [];

for (let i = 0; i < 100; i++) {
    trackedObjects.push(createTrackedArray(1000, 'TestArray'));
    trackedObjects.push(createTrackedObject({ id: i, data: 'test' }, 'TestObject'));
}

// 生成分析报告
setTimeout(() => {
    analyzer.generateReport();
}, 2000);
```

### 4. 内存泄漏预防策略

#### 4.1 生命周期管理

```javascript
// 统一的组件生命周期管理
class ComponentLifecycleManager {
    constructor() {
        this.components = new Set();
        this.globalCleanupHandlers = new Set();

        // 监听页面卸载事件
        window.addEventListener('beforeunload', () => {
            this.cleanupAll();
        });
    }

    register(component) {
        this.components.add(component);

        // 确保组件有destroy方法
        if (typeof component.destroy !== 'function') {
            console.warn('Component should implement destroy() method', component);
        }

        return component;
    }

    unregister(component) {
        this.components.delete(component);
    }

    addGlobalCleanupHandler(handler) {
        this.globalCleanupHandlers.add(handler);
    }

    cleanupAll() {
        // 清理所有注册的组件
        for (const component of this.components) {
            try {
                if (typeof component.destroy === 'function') {
                    component.destroy();
                }
            } catch (error) {
                console.error('Error destroying component:', error);
            }
        }

        // 执行全局清理处理器
        for (const handler of this.globalCleanupHandlers) {
            try {
                handler();
            } catch (error) {
                console.error('Error in global cleanup handler:', error);
            }
        }

        this.components.clear();
        this.globalCleanupHandlers.clear();
    }
}

// 全局生命周期管理器
const lifecycleManager = new ComponentLifecycleManager();

// 基础组件类
class BaseComponent {
    constructor() {
        this.isDestroyed = false;
        this.eventListeners = new Map();
        this.timers = new Set();
        this.asyncOperations = new Set();

        // 自动注册到生命周期管理器
        lifecycleManager.register(this);
    }

    addEventListener(element, event, handler, options) {
        const boundHandler = handler.bind(this);
        element.addEventListener(event, boundHandler, options);

        // 记录事件监听器以便清理
        if (!this.eventListeners.has(element)) {
            this.eventListeners.set(element, []);
        }
        this.eventListeners.get(element).push({ event, handler: boundHandler, options });

        return boundHandler;
    }

    setTimeout(callback, delay) {
        const timerId = setTimeout(() => {
            this.timers.delete(timerId);
            if (!this.isDestroyed) {
                callback();
            }
        }, delay);

        this.timers.add(timerId);
        return timerId;
    }

    setInterval(callback, interval) {
        const timerId = setInterval(() => {
            if (!this.isDestroyed) {
                callback();
            } else {
                clearInterval(timerId);
            }
        }, interval);

        this.timers.add(timerId);
        return timerId;
    }

    async fetch(url, options) {
        const abortController = new AbortController();
        this.asyncOperations.add(abortController);

        try {
            const response = await fetch(url, {
                ...options,
                signal: abortController.signal
            });

            this.asyncOperations.delete(abortController);
            return response;
        } catch (error) {
            this.asyncOperations.delete(abortController);

            if (error.name === 'AbortError') {
                console.log('Fetch was aborted');
                return null;
            }

            throw error;
        }
    }

    destroy() {
        if (this.isDestroyed) return;

        this.isDestroyed = true;

        // 清理事件监听器
        for (const [element, listeners] of this.eventListeners) {
            for (const { event, handler, options } of listeners) {
                element.removeEventListener(event, handler, options);
            }
        }
        this.eventListeners.clear();

        // 清理定时器
        for (const timerId of this.timers) {
            clearTimeout(timerId);
            clearInterval(timerId);
        }
        this.timers.clear();

        // 取消异步操作
        for (const controller of this.asyncOperations) {
            controller.abort();
        }
        this.asyncOperations.clear();

        // 从生命周期管理器中注销
        lifecycleManager.unregister(this);
    }
}

// 使用示例
class MyComponent extends BaseComponent {
    constructor(elementId) {
        super();

        this.element = document.getElementById(elementId);
        this.data = new Array(10000).fill('component data');

        this.setupEventListeners();
        this.startPeriodicUpdate();
    }

    setupEventListeners() {
        // 使用基类的方法自动管理事件监听器
        this.addEventListener(this.element, 'click', this.handleClick);
        this.addEventListener(window, 'resize', this.handleResize);
    }

    startPeriodicUpdate() {
        // 使用基类的方法自动管理定时器
        this.setInterval(() => {
            this.updateData();
        }, 1000);
    }

    async loadData() {
        // 使用基类的方法自动管理异步操作
        try {
            const response = await this.fetch('/api/data');
            if (response) {
                const data = await response.json();
                this.processData(data);
            }
        } catch (error) {
            console.error('Failed to load data:', error);
        }
    }

    handleClick(event) {
        console.log('Element clicked');
    }

    handleResize(event) {
        console.log('Window resized');
    }

    updateData() {
        // 更新数据逻辑
        console.log('Data updated');
    }

    processData(data) {
        // 处理数据逻辑
        console.log('Processing data:', data.length);
    }

    destroy() {
        // 清理组件特定的资源
        this.data = null;
        this.element = null;

        // 调用基类的destroy方法
        super.destroy();
    }
}
```

#### 4.2 弱引用使用

```javascript
// 使用WeakMap避免内存泄漏
class WeakReferenceExample {
    constructor() {
        // 使用WeakMap存储DOM元素的私有数据
        this.elementData = new WeakMap();
        this.elementHandlers = new WeakMap();
    }

    attachToElement(element, data) {
        // 存储元素关联的数据
        this.elementData.set(element, data);

        // 创建事件处理器
        const handler = (event) => {
            const elementData = this.elementData.get(element);
            console.log('Element clicked:', elementData);
        };

        // 存储处理器引用
        this.elementHandlers.set(element, handler);
        element.addEventListener('click', handler);

        // 当element被移除时，WeakMap中的条目会自动清理
    }

    detachFromElement(element) {
        const handler = this.elementHandlers.get(element);
        if (handler) {
            element.removeEventListener('click', handler);
            this.elementHandlers.delete(element);
        }

        this.elementData.delete(element);
    }

    getElementData(element) {
        return this.elementData.get(element);
    }
}

// 观察者模式中使用WeakSet
class WeakObserverPattern {
    constructor() {
        this.observers = new WeakSet();
    }

    addObserver(observer) {
        this.observers.add(observer);
    }

    removeObserver(observer) {
        this.observers.delete(observer);
    }

    notifyObservers(data) {
        // 注意：WeakSet不能直接遍历
        // 需要保持对观察者的强引用来通知它们
        console.log('Notifying observers with data:', data);
    }
}

// 改进的观察者模式
class ImprovedObserverPattern {
    constructor() {
        this.observers = new Set();
        this.observerData = new WeakMap();
    }

    addObserver(observer, data = {}) {
        this.observers.add(observer);
        this.observerData.set(observer, data);
    }

    removeObserver(observer) {
        this.observers.delete(observer);
        this.observerData.delete(observer);
    }

    notifyObservers(data) {
        // 使用WeakMap检查观察者是否还有效
        const validObservers = Array.from(this.observers).filter(observer => {
            return this.observerData.has(observer);
        });

        validObservers.forEach(observer => {
            if (typeof observer.update === 'function') {
                observer.update(data);
            }
        });
    }

    cleanup() {
        // 清理无效的观察者
        for (const observer of this.observers) {
            if (!this.observerData.has(observer)) {
                this.observers.delete(observer);
            }
        }
    }
}
```

### 5. 最佳实践总结

#### 5.1 开发阶段预防

```javascript
// 1. 使用严格模式
'use strict';

// 2. 使用TypeScript或JSDoc进行类型检查
/**
 * @param {HTMLElement} element
 * @param {Function} callback
 * @param {Object} options
 */
function addManagedEventListener(element, callback, options = {}) {
    // 实现带自动清理的事件监听器
}

// 3. 使用ESLint规则检测潜在问题
// eslint-disable-next-line no-unused-vars
const unusedVariable = 'This will be caught by ESLint';

// 4. 建立代码审查检查列表
class CodeReviewChecklist {
    static checkForMemoryLeaks(code) {
        const issues = [];

        // 检查事件监听器
        if (code.includes('addEventListener') && !code.includes('removeEventListener')) {
            issues.push('Event listeners may not be properly cleaned up');
        }

        // 检查定时器
        if ((code.includes('setInterval') || code.includes('setTimeout')) &&
            !code.includes('clear')) {
            issues.push('Timers may not be properly cleared');
        }

        // 检查全局变量
        if (code.includes('window.') && code.includes('=')) {
            issues.push('Potential global variable assignment');
        }

        return issues;
    }
}
```

#### 5.2 生产环境监控

```javascript
// 内存泄漏监控服务
class MemoryLeakMonitoringService {
    constructor() {
        this.config = {
            maxMemoryUsage: 100 * 1024 * 1024, // 100MB
            memoryGrowthThreshold: 10 * 1024 * 1024, // 10MB/min
            monitoringInterval: 30000, // 30秒
            reportingEndpoint: '/api/memory-reports'
        };

        this.samples = [];
        this.isMonitoring = false;
        this.alertsSent = new Set();
    }

    startMonitoring() {
        if (this.isMonitoring) return;

        this.isMonitoring = true;
        this.monitoringInterval = setInterval(() => {
            this.collectSample();
        }, this.config.monitoringInterval);

        console.log('Memory leak monitoring started');
    }

    stopMonitoring() {
        if (!this.isMonitoring) return;

        clearInterval(this.monitoringInterval);
        this.isMonitoring = false;

        console.log('Memory leak monitoring stopped');
    }

    collectSample() {
        if (!performance.memory) return;

        const sample = {
            timestamp: Date.now(),
            used: performance.memory.usedJSHeapSize,
            total: performance.memory.totalJSHeapSize,
            limit: performance.memory.jsHeapSizeLimit,
            url: window.location.href,
            userAgent: navigator.userAgent
        };

        this.samples.push(sample);

        // 保留最近50个样本
        if (this.samples.length > 50) {
            this.samples.shift();
        }

        this.analyzeMemoryTrend();
    }

    analyzeMemoryTrend() {
        if (this.samples.length < 5) return;

        const recent = this.samples.slice(-5);
        const memoryGrowth = recent[recent.length - 1].used - recent[0].used;
        const timeSpan = recent[recent.length - 1].timestamp - recent[0].timestamp;
        const growthRate = (memoryGrowth / timeSpan) * 60000; // MB/min

        // 检查内存使用超限
        const currentUsage = recent[recent.length - 1].used;
        if (currentUsage > this.config.maxMemoryUsage) {
            this.sendAlert('HIGH_MEMORY_USAGE', {
                currentUsage: currentUsage / 1024 / 1024,
                limit: this.config.maxMemoryUsage / 1024 / 1024
            });
        }

        // 检查内存增长过快
        if (growthRate > this.config.memoryGrowthThreshold) {
            this.sendAlert('RAPID_MEMORY_GROWTH', {
                growthRate: growthRate / 1024 / 1024,
                threshold: this.config.memoryGrowthThreshold / 1024 / 1024
            });
        }
    }

    sendAlert(type, data) {
        // 避免重复发送相同类型的警报
        if (this.alertsSent.has(type)) return;

        this.alertsSent.add(type);

        const alert = {
            type,
            timestamp: Date.now(),
            data,
            samples: this.samples.slice(-10), // 最近10个样本
            userAgent: navigator.userAgent,
            url: window.location.href
        };

        // 发送到监控服务
        this.reportToService(alert);

        // 本地日志
        console.error('Memory leak alert:', alert);

        // 5分钟后允许再次发送同类型警报
        setTimeout(() => {
            this.alertsSent.delete(type);
        }, 5 * 60 * 1000);
    }

    async reportToService(alert) {
        try {
            await fetch(this.config.reportingEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(alert)
            });
        } catch (error) {
            console.error('Failed to report memory alert:', error);
        }
    }

    getMemoryReport() {
        if (this.samples.length === 0) return null;

        const first = this.samples[0];
        const last = this.samples[this.samples.length - 1];

        return {
            duration: last.timestamp - first.timestamp,
            startMemory: first.used / 1024 / 1024,
            endMemory: last.used / 1024 / 1024,
            growth: (last.used - first.used) / 1024 / 1024,
            samples: this.samples.length,
            averageUsage: this.samples.reduce((sum, s) => sum + s.used, 0) / this.samples.length / 1024 / 1024
        };
    }
}

// 全局内存监控
const memoryMonitor = new MemoryLeakMonitoringService();

// 在应用启动时开始监控
if (typeof window !== 'undefined') {
    memoryMonitor.startMonitoring();

    // 页面卸载时停止监控并发送最终报告
    window.addEventListener('beforeunload', () => {
        const report = memoryMonitor.getMemoryReport();
        if (report) {
            console.log('Final memory report:', report);
        }
        memoryMonitor.stopMonitoring();
    });
}
```

### 总结

JavaScript内存泄漏是一个复杂但可控的问题，通过：

**预防策略**：
- 养成良好的编码习惯
- 建立完善的生命周期管理
- 合理使用弱引用和事件委托
- 实施代码审查和自动化检测

**检测工具**：
- Chrome DevTools Memory面板
- Performance API监控
- 自定义分析器和监控服务

**修复方法**：
- 及时清理事件监听器和定时器
- 破除循环引用
- 限制缓存大小
- 使用对象池等优化技术

可以有效避免内存泄漏问题，保证应用的稳定性和性能。在现代Web开发中，这些实践已经成为高质量JavaScript代码的基本要求。
