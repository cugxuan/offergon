---
title: JavaScript 的执行上下文和变量提升
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: execution-context-and-variable-hoisting
ref:
---

## 核心要点

**执行上下文（Execution Context）** 是 JavaScript 代码执行的环境，包含变量对象、作用域链、this 绑定。分为**全局上下文**、**函数上下文**、**Eval 上下文**。**变量提升（Hoisting）** 指在代码执行前，`var` 声明的变量和函数声明会被提升到作用域顶部（变量提升后初始化为 undefined，函数整体提升）。`let/const` 存在暂时性死区（TDZ），不会初始化。

---

## 详细解答

执行上下文和变量提升是理解 JavaScript 运行机制的核心概念，掌握它们能帮你理解变量查找、闭包、this 指向等高级特性。

### 一、什么是执行上下文（Execution Context）

#### 定义

**执行上下文：** JavaScript 代码的执行环境，包含了代码执行所需的所有信息。

**三种类型：**

1. **全局执行上下文（Global Execution Context）**
   - 程序启动时创建，只有一个
   - 浏览器中创建 `window` 对象，Node.js 中创建 `global` 对象
   - 所有不在函数内的代码都在全局上下文中执行

2. **函数执行上下文（Function Execution Context）**
   - 每次函数调用时创建新的上下文
   - 可以有无数个
   - 函数执行完毕后销毁（闭包除外）

3. **Eval 执行上下文（Eval Execution Context）**
   - `eval()` 函数内的代码执行时创建
   - 不推荐使用，存在安全和性能问题

---

### 二、执行上下文的组成

每个执行上下文包含三个重要部分：

#### 1. 变量对象（Variable Object，VO）/ 词法环境（Lexical Environment）

**存储内容：**
- 变量声明（`var`、`let`、`const`）
- 函数声明
- 函数参数（仅函数上下文）

```javascript
function test(a, b) {
  var x = 10
  let y = 20
  const z = 30

  function inner() {}
}

// test 的变量对象包含：
// - 参数: a, b
// - var 变量: x
// - let/const 变量: y, z
// - 函数声明: inner
```

#### 2. 作用域链（Scope Chain）

**定义：** 当前执行上下文的变量对象 + 所有父级执行上下文的变量对象。

```javascript
const global = "全局"

function outer() {
  const outerVar = "外层"

  function inner() {
    const innerVar = "内层"
    console.log(innerVar, outerVar, global)
  }

  inner()
}

// inner 的作用域链：
// [inner VO] → [outer VO] → [global VO]
```

#### 3. this 绑定

**this 的值在函数调用时确定，取决于调用方式：**

```javascript
// 1. 全局上下文
console.log(this)  // window（浏览器）或 global（Node.js）

// 2. 函数调用
function test() {
  console.log(this)  // window（非严格模式）或 undefined（严格模式）
}
test()

// 3. 方法调用
const obj = {
  method() {
    console.log(this)  // obj
  }
}
obj.method()

// 4. 构造函数
function Person(name) {
  this.name = name
  console.log(this)  // 新创建的对象
}
new Person("Alice")

// 5. 箭头函数（继承外层 this）
const obj2 = {
  method: function() {
    const arrow = () => {
      console.log(this)  // obj2（继承自 method）
    }
    arrow()
  }
}
obj2.method()
```

---

### 三、执行上下文的生命周期

#### 阶段 1：创建阶段（Creation Phase）

**执行的操作（按顺序）：**

1. **创建变量对象（VO）/ 词法环境**
   - 扫描函数参数，创建参数属性
   - 扫描函数声明，创建函数属性（**整个函数提升**）
   - 扫描变量声明（`var`），创建属性并初始化为 `undefined`（**变量提升**）
   - `let`/`const` 声明被记录但不初始化（**暂时性死区**）

2. **创建作用域链**
   - 将当前 VO + 父级作用域链组合

3. **确定 this 的值**
   - 根据调用方式绑定 this

#### 阶段 2：执行阶段（Execution Phase）

**执行的操作：**
- 按代码顺序执行
- 变量赋值
- 函数调用
- 代码逻辑执行

---

### 四、变量提升（Hoisting）详解

#### 什么是变量提升

**定义：** JavaScript 引擎在执行代码前，会将变量和函数声明"提升"到当前作用域的顶部。

**注意：** 只有声明被提升，赋值不会提升。

#### 1. var 变量提升

```javascript
console.log(x)  // undefined ⚠️（不是 ReferenceError）
var x = 5
console.log(x)  // 5

// 等价于（引擎实际执行）：
var x           // 声明提升到顶部
console.log(x)  // undefined（已声明但未赋值）
x = 5           // 赋值保持原位
console.log(x)  // 5
```

**函数作用域的提升：**
```javascript
function test() {
  console.log(a)  // undefined
  var a = 10
  console.log(a)  // 10
}

// 等价于：
function test() {
  var a           // 提升到函数顶部
  console.log(a)  // undefined
  a = 10
  console.log(a)  // 10
}
```

#### 2. 函数声明提升

**函数声明会整体提升：**
```javascript
test()  // "执行了"（可以在声明前调用）

function test() {
  console.log("执行了")
}

// 等价于：
function test() {
  console.log("执行了")
}
test()
```

**函数表达式不会提升：**
```javascript
test()  // TypeError: test is not a function ⚠️

var test = function() {
  console.log("执行了")
}

// 等价于：
var test        // 只提升变量声明
test()          // undefined()，报错
test = function() {
  console.log("执行了")
}
```

#### 3. let 和 const 的提升（暂时性死区 TDZ）

**let/const 也会提升，但不会初始化：**
```javascript
console.log(x)  // ReferenceError ⚠️ 暂时性死区
let x = 5

// 从作用域开始到声明之间，x 处于"暂时性死区"
// 访问会报错
```

**对比 var：**
```javascript
// var: 提升 + 初始化为 undefined
console.log(a)  // undefined
var a = 1

// let: 提升但不初始化（TDZ）
console.log(b)  // ReferenceError
let b = 2

// const: 提升但不初始化（TDZ），且必须立即赋值
console.log(c)  // ReferenceError
const c = 3
```

**TDZ 的作用范围：**
```javascript
let x = "外层"

if (true) {
  // TDZ 开始
  console.log(x)  // ReferenceError ⚠️
  // 不会访问外层的 x，因为块内有 let x 声明

  let x = "内层"  // TDZ 结束
  console.log(x)  // "内层"
}
```

---

### 五、经典案例与陷阱

#### 陷阱 1：函数声明与变量声明冲突

**规则：函数声明优先级高于变量声明**

```javascript
console.log(foo)  // [Function: foo] ⚠️

var foo = "变量"
function foo() {
  console.log("函数")
}

console.log(foo)  // "变量"

// 等价于：
function foo() {  // 函数声明先提升
  console.log("函数")
}
var foo           // 变量声明提升（但不覆盖已有的函数）
console.log(foo)  // [Function: foo]
foo = "变量"      // 赋值执行
console.log(foo)  // "变量"
```

#### 陷阱 2：重复的 var 声明

```javascript
var x = 1
var x = 2
console.log(x)  // 2

// var 允许重复声明（实际上第二个 var 被忽略）
// 等价于：
var x
x = 1
x = 2  // 只是重新赋值
```

**对比 let：**
```javascript
let y = 1
let y = 2  // SyntaxError: Identifier 'y' has already been declared ⚠️
```

#### 陷阱 3：循环中的变量提升

```javascript
// var 没有块级作用域
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// 输出: 3, 3, 3 ⚠️

// 等价于：
var i  // 提升到外层
for (i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// 所有回调共享同一个 i
```

**对比 let：**
```javascript
// let 有块级作用域
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// 输出: 0, 1, 2 ✅
// 每次迭代创建新的 i
```

#### 陷阱 4：函数内的变量提升

```javascript
var x = "全局"

function test() {
  console.log(x)  // undefined ⚠️（不是 "全局"）
  var x = "局部"
  console.log(x)  // "局部"
}

test()

// 等价于：
function test() {
  var x           // 局部变量提升，遮蔽全局 x
  console.log(x)  // undefined
  x = "局部"
  console.log(x)  // "局部"
}
```

#### 陷阱 5：条件语句中的函数声明（非标准行为）

```javascript
// 不同浏览器行为可能不同
console.log(foo)  // undefined（Chrome）或 function（其他）

if (true) {
  function foo() {
    console.log("foo")
  }
}

console.log(foo)  // function
```

**最佳实践：避免在块内使用函数声明**
```javascript
// ❌ 不推荐
if (condition) {
  function test() {}
}

// ✅ 推荐（使用函数表达式）
if (condition) {
  const test = function() {}
}
```

---

### 六、执行上下文栈（Call Stack）

#### 调用栈的工作机制

```javascript
function first() {
  console.log("first 开始")
  second()
  console.log("first 结束")
}

function second() {
  console.log("second 开始")
  third()
  console.log("second 结束")
}

function third() {
  console.log("third 执行")
}

first()

// 执行栈变化：
/*
1. [全局上下文]
2. [全局上下文, first]         → "first 开始"
3. [全局上下文, first, second] → "second 开始"
4. [全局上下文, first, second, third] → "third 执行"
5. [全局上下文, first, second] → "second 结束"
6. [全局上下文, first]         → "first 结束"
7. [全局上下文]
*/
```

**输出顺序：**
```
first 开始
second 开始
third 执行
second 结束
first 结束
```

#### 栈溢出（Stack Overflow）

```javascript
function recursion() {
  recursion()  // 无限递归
}

recursion()  // RangeError: Maximum call stack size exceeded
```

**调用栈大小限制：**
- Chrome V8: 约 10000 - 15000 层
- Firefox: 约 50000 层
- Node.js: 可通过 `--stack-size` 调整

---

### 七、完整的执行过程示例

```javascript
var globalVar = "全局变量"

function outer(x) {
  var outerVar = "外层变量"

  function inner(y) {
    var innerVar = "内层变量"
    console.log(globalVar, outerVar, innerVar, x, y)
  }

  inner(20)
}

outer(10)
```

**执行流程：**

**1. 创建全局执行上下文**
```javascript
GlobalContext = {
  VO: {
    globalVar: undefined,  // var 提升
    outer: <function>      // 函数声明提升
  },
  scopeChain: [GlobalVO],
  this: window
}
```

**2. 执行全局代码（赋值）**
```javascript
GlobalContext.VO.globalVar = "全局变量"
```

**3. 调用 outer(10)，创建 outer 执行上下文**
```javascript
OuterContext = {
  VO: {
    x: 10,
    outerVar: undefined,  // var 提升
    inner: <function>     // 函数声明提升
  },
  scopeChain: [OuterVO, GlobalVO],
  this: window
}

// 执行栈：[Global, Outer]
```

**4. 执行 outer 代码（赋值）**
```javascript
OuterContext.VO.outerVar = "外层变量"
```

**5. 调用 inner(20)，创建 inner 执行上下文**
```javascript
InnerContext = {
  VO: {
    y: 20,
    innerVar: undefined  // var 提升
  },
  scopeChain: [InnerVO, OuterVO, GlobalVO],
  this: window
}

// 执行栈：[Global, Outer, Inner]
```

**6. 执行 inner 代码**
```javascript
InnerContext.VO.innerVar = "内层变量"

// console.log 时查找变量：
// - globalVar: InnerVO → OuterVO → GlobalVO ✅ 找到
// - outerVar:  InnerVO → OuterVO ✅ 找到
// - innerVar:  InnerVO ✅ 找到
// - x:         InnerVO → OuterVO ✅ 找到
// - y:         InnerVO ✅ 找到

// 输出: "全局变量 外层变量 内层变量 10 20"
```

**7. 销毁上下文**
```javascript
// inner 执行完毕，销毁 InnerContext
// 执行栈：[Global, Outer]

// outer 执行完毕，销毁 OuterContext
// 执行栈：[Global]
```

---

### 八、最佳实践

#### 1. 避免使用 var

```javascript
// ❌ 不推荐（var 易造成意外提升）
function test() {
  console.log(x)  // undefined
  var x = 10
}

// ✅ 推荐（let/const 有 TDZ 保护）
function test() {
  console.log(x)  // ReferenceError（更易发现错误）
  let x = 10
}
```

#### 2. 变量先声明后使用

```javascript
// ❌ 不推荐（依赖提升）
console.log(x)
var x = 5

// ✅ 推荐（清晰明确）
let x = 5
console.log(x)
```

#### 3. 函数声明放在作用域顶部

```javascript
// ❌ 不推荐（依赖提升，难以阅读）
doSomething()

function doSomething() {
  // ...
}

// ✅ 推荐（声明在前，逻辑清晰）
function doSomething() {
  // ...
}

doSomething()
```

#### 4. 使用严格模式

```javascript
"use strict"

// 严格模式禁止：
// - 未声明变量直接赋值
// - delete 不可删除的属性
// - eval/with 创建变量
// - 函数参数重名
// 等等
```

---

### 九、面试加分点

#### 1. 解释 let/const 是否有提升

```javascript
// 误区：let/const 不提升
// 正确：let/const 也提升，但有暂时性死区

let x = "outer"

{
  console.log(x)  // ReferenceError（不是 "outer"）
  // 如果 let 不提升，应该访问外层的 x
  // 但因为提升了（只是不初始化），产生了 TDZ
  let x = "inner"
}
```

#### 2. 描述执行上下文的创建过程

**创建阶段（Creation Phase）：**
1. 绑定 this
2. 创建词法环境（let/const/function）
3. 创建变量环境（var）

**执行阶段（Execution Phase）：**
1. 变量赋值
2. 执行代码

#### 3. 理解调用栈与异步

```javascript
console.log("1")

setTimeout(() => {
  console.log("2")
}, 0)

console.log("3")

// 输出: 1, 3, 2

// 原因：setTimeout 的回调进入任务队列，等调用栈清空后执行
```

#### 4. V8 的优化

- **内联缓存（Inline Caching）**：优化属性访问
- **隐藏类（Hidden Classes）**：优化对象属性访问
- **逃逸分析（Escape Analysis）**：优化对象分配

掌握执行上下文和变量提升，能帮你理解 JavaScript 的运行机制，写出更高质量的代码！
