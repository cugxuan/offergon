---
title: Web Workers 的使用和通信机制
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: web-workers-usage-and-communication
ref:
---

## 核心要点

Web Workers 是 HTML5 提供的**浏览器多线程解决方案**，允许在后台线程执行 JavaScript 而不阻塞主线程 UI。通过 `postMessage/onmessage` 进行**消息传递通信**（数据拷贝或 Transferable 转移）。典型应用场景：**大数据计算**、**图像/视频处理**、**加密解密**、**长轮询**。注意 Worker 无法访问 DOM、window、document、parent 对象，但支持 WebSocket、IndexedDB、fetch 等 API。

---

## 详细解答

### 一、Web Workers 概述

#### 1.1 什么是 Web Workers

**Web Workers** 是 HTML5 标准的一部分，让 JavaScript 可以在浏览器后台线程中运行，与主线程并行执行任务。这解决了 JavaScript 单线程模型的痛点——**避免耗时任务阻塞 UI 渲染**。

**核心特点：**
- 真正的多线程（不是异步模拟）
- 独立的全局上下文（不共享作用域）
- 消息传递机制通信（非共享内存）
- 受同源策略限制

#### 1.2 为什么需要 Web Workers

JavaScript 是单线程语言，所有任务在主线程上执行：

```javascript
// 坏例子：阻塞主线程
function heavyComputation() {
  let result = 0;
  for (let i = 0; i < 1e9; i++) {
    result += Math.sqrt(i);
  }
  return result;
}

// 执行期间页面完全卡死，无法响应用户操作
console.log(heavyComputation());
```

**问题：**
- 长时间计算会导致页面卡顿
- 用户交互无响应
- 动画停止渲染

**解决方案：**
- 使用 Web Workers 将计算任务放到后台线程
- 主线程继续响应用户操作

### 二、Web Workers 的类型

#### 2.1 Dedicated Workers（专用 Worker）

最常用类型，由单个页面创建和使用，无法被多个页面共享。

```javascript
// 主线程创建 Worker
const worker = new Worker('worker.js');

// worker.js 中执行后台任务
```

#### 2.2 Shared Workers（共享 Worker）

可以被多个同源页面共享访问，适合多标签页通信场景。

```javascript
// 多个页面可以连接同一个 Shared Worker
const worker = new SharedWorker('shared-worker.js');
worker.port.start();
```

#### 2.3 Service Workers

独立于网页的后台进程，主要用于 PWA（渐进式 Web 应用），支持离线缓存、推送通知等。

```javascript
// 注册 Service Worker
navigator.serviceWorker.register('/sw.js');
```

**本文重点讨论 Dedicated Workers（专用 Worker）**

### 三、Web Workers 的基本使用

#### 3.1 创建 Worker

**主线程代码（main.js）：**

```javascript
// 检查浏览器支持
if (window.Worker) {
  // 创建 Worker 实例
  const worker = new Worker('worker.js');

  // 监听 Worker 消息
  worker.onmessage = function(event) {
    console.log('主线程收到消息:', event.data);
  };

  // 发送消息给 Worker
  worker.postMessage('Hello Worker');

  // 错误处理
  worker.onerror = function(error) {
    console.error('Worker 错误:', error.message);
  };
} else {
  console.log('浏览器不支持 Web Workers');
}
```

**Worker 线程代码（worker.js）：**

```javascript
// Worker 全局作用域是 self（不是 window）
self.onmessage = function(event) {
  console.log('Worker 收到消息:', event.data);

  // 执行耗时任务
  const result = heavyComputation();

  // 返回结果给主线程
  self.postMessage(result);
};

function heavyComputation() {
  let sum = 0;
  for (let i = 0; i < 1e8; i++) {
    sum += Math.sqrt(i);
  }
  return sum;
}
```

#### 3.2 终止 Worker

```javascript
// 主线程主动终止
worker.terminate();

// Worker 自行终止
self.close();
```

### 四、通信机制详解

#### 4.1 消息传递（Message Passing）

Web Workers 采用**结构化克隆算法**（Structured Clone Algorithm）进行数据传输：

**支持的数据类型：**
- 基本类型（string, number, boolean, null, undefined）
- 对象和数组
- Date, RegExp
- Blob, File, FileList
- ArrayBuffer, TypedArray
- ImageData
- Map, Set（部分浏览器）

**不支持的数据类型：**
- 函数
- DOM 节点
- Symbol
- Error 对象（部分属性会丢失）

**示例：**

```javascript
// 主线程
const data = {
  numbers: [1, 2, 3, 4, 5],
  config: { precision: 2 }
};
worker.postMessage(data);

// Worker 线程
self.onmessage = function(e) {
  const { numbers, config } = e.data;
  const result = numbers.map(n => n.toFixed(config.precision));
  self.postMessage(result);
};
```

**注意：** 数据传输是**拷贝**而非引用，修改一方不会影响另一方。

#### 4.2 Transferable Objects（可转移对象）

对于大型二进制数据（如 ArrayBuffer），拷贝性能开销大。可使用 **Transferable Objects** 实现**所有权转移**（零拷贝）。

**原理：** 数据所有权从主线程转移到 Worker，主线程失去访问权。

```javascript
// 主线程
const buffer = new ArrayBuffer(1024 * 1024 * 100); // 100MB
const uint8View = new Uint8Array(buffer);
uint8View[0] = 255;

// 转移 ArrayBuffer（第二个参数是转移列表）
worker.postMessage({ buffer }, [buffer]);

console.log(buffer.byteLength); // 0 - 主线程已失去访问权

// Worker 线程
self.onmessage = function(e) {
  const buffer = e.data.buffer;
  console.log(buffer.byteLength); // 104857600 - Worker 获得所有权

  // 处理数据...
  const result = processBuffer(buffer);

  // 转移回主线程
  self.postMessage({ result }, [result]);
};
```

**支持 Transferable 的类型：**
- ArrayBuffer
- MessagePort
- ImageBitmap
- OffscreenCanvas

**性能对比：**

```javascript
// 拷贝方式：100MB 数据需要 ~200ms
worker.postMessage({ buffer });

// 转移方式：几乎瞬时完成
worker.postMessage({ buffer }, [buffer]);
```

#### 4.3 双向通信流程图

```
主线程                        Worker 线程
  │                               │
  ├──── postMessage() ────────────>│
  │         (序列化)               │ onmessage 触发
  │                               │ 执行任务
  │<──── postMessage() ────────────┤
  │ onmessage 触发    (序列化)     │
  │                               │
```

### 五、Worker 的作用域和限制

#### 5.1 Worker 全局作用域

Worker 运行在独立的全局上下文 **WorkerGlobalScope** 中：

```javascript
// Worker 中的全局对象是 self（不是 window）
console.log(self); // WorkerGlobalScope

// 可以省略 self
postMessage('Hello'); // 等同于 self.postMessage('Hello')
```

#### 5.2 可用的 API

**支持的 API：**
- **定时器：** `setTimeout`, `setInterval`, `clearTimeout`, `clearInterval`
- **网络请求：** `fetch`, `XMLHttpRequest`
- **存储：** `IndexedDB`, `Cache API`
- **Web Sockets：** `WebSocket`
- **通知：** `Notification`（需要权限）
- **编码：** `TextEncoder`, `TextDecoder`, `atob`, `btoa`
- **工具：** `console`, `navigator`, `location`（只读）
- **加密：** `crypto.subtle`

**不支持的 API：**
- **DOM 操作：** 无法访问 `document`, `window`
- **父对象：** 无法访问 `parent`, `opener`
- **DOM 事件：** 无法监听 `click`, `scroll` 等
- **某些 BOM API：** `alert`, `confirm`, `prompt`

#### 5.3 加载外部脚本

Worker 可以通过 `importScripts()` 加载外部 JS 文件：

```javascript
// Worker 中加载第三方库
importScripts('lodash.min.js', 'utils.js');

// 同步加载，阻塞执行直到加载完成
const result = _.map([1, 2, 3], n => n * 2);
```

**注意：**
- 支持加载多个脚本
- 加载是同步的
- 受同源策略限制

### 六、实战案例

#### 6.1 案例一：大数据排序

**主线程：**

```javascript
// main.js
const worker = new Worker('sort-worker.js');

// 生成 100 万随机数
const data = Array.from({ length: 1e6 }, () => Math.random());

console.time('排序耗时');

worker.postMessage(data);

worker.onmessage = function(e) {
  console.timeEnd('排序耗时');
  console.log('排序完成，前 10 个元素:', e.data.slice(0, 10));
};
```

**Worker 线程：**

```javascript
// sort-worker.js
self.onmessage = function(e) {
  const data = e.data;

  // 快速排序（不阻塞主线程）
  data.sort((a, b) => a - b);

  // 返回排序结果
  self.postMessage(data);
};
```

#### 6.2 案例二：图像处理（灰度化）

**主线程：**

```html
<canvas id="canvas"></canvas>
<input type="file" id="upload" accept="image/*">

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const worker = new Worker('image-worker.js');

document.getElementById('upload').onchange = function(e) {
  const file = e.target.files[0];
  const img = new Image();

  img.onload = function() {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);

    // 获取图像数据
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    // 发送给 Worker 处理
    worker.postMessage({ imageData }, [imageData.data.buffer]);
  };

  img.src = URL.createObjectURL(file);
};

worker.onmessage = function(e) {
  // 显示处理后的图像
  ctx.putImageData(e.data.imageData, 0, 0);
};
</script>
```

**Worker 线程：**

```javascript
// image-worker.js
self.onmessage = function(e) {
  const imageData = e.data.imageData;
  const data = imageData.data;

  // 灰度化算法
  for (let i = 0; i < data.length; i += 4) {
    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    data[i] = data[i + 1] = data[i + 2] = gray;
  }

  // 返回处理后的图像数据
  self.postMessage({ imageData }, [data.buffer]);
};
```

#### 6.3 案例三：实时进度反馈

**主线程：**

```javascript
const worker = new Worker('progress-worker.js');

worker.postMessage({ iterations: 1e9 });

worker.onmessage = function(e) {
  if (e.data.type === 'progress') {
    console.log(`进度: ${e.data.percent}%`);
    // 更新进度条 UI
    document.getElementById('progress').value = e.data.percent;
  } else if (e.data.type === 'complete') {
    console.log('任务完成，结果:', e.data.result);
  }
};
```

**Worker 线程：**

```javascript
// progress-worker.js
self.onmessage = function(e) {
  const iterations = e.data.iterations;
  let result = 0;

  for (let i = 0; i < iterations; i++) {
    result += Math.sqrt(i);

    // 每完成 1% 报告一次进度
    if (i % (iterations / 100) === 0) {
      self.postMessage({
        type: 'progress',
        percent: Math.floor(i / iterations * 100)
      });
    }
  }

  // 任务完成
  self.postMessage({
    type: 'complete',
    result: result
  });
};
```

#### 6.4 案例四：Worker 池（Worker Pool）

对于频繁的短任务，可以创建 Worker 池复用 Worker 实例：

```javascript
class WorkerPool {
  constructor(workerScript, poolSize = 4) {
    this.workers = [];
    this.taskQueue = [];

    // 创建 Worker 池
    for (let i = 0; i < poolSize; i++) {
      const worker = new Worker(workerScript);
      worker.onmessage = (e) => this.handleResult(i, e);
      this.workers.push({ instance: worker, busy: false });
    }
  }

  execute(data) {
    return new Promise((resolve) => {
      this.taskQueue.push({ data, resolve });
      this.runNext();
    });
  }

  runNext() {
    const idleWorker = this.workers.find(w => !w.busy);
    if (!idleWorker || this.taskQueue.length === 0) return;

    const task = this.taskQueue.shift();
    idleWorker.busy = true;
    idleWorker.task = task;
    idleWorker.instance.postMessage(task.data);
  }

  handleResult(workerIndex, event) {
    const worker = this.workers[workerIndex];
    worker.task.resolve(event.data);
    worker.busy = false;
    this.runNext();
  }

  terminate() {
    this.workers.forEach(w => w.instance.terminate());
  }
}

// 使用示例
const pool = new WorkerPool('compute-worker.js', 4);

async function processTasks() {
  const tasks = Array.from({ length: 100 }, (_, i) => i);
  const results = await Promise.all(
    tasks.map(task => pool.execute(task))
  );
  console.log('所有任务完成:', results);
}

processTasks();
```

### 七、性能优化建议

#### 7.1 何时使用 Web Workers

**适用场景：**
- ✅ 大数据计算（排序、统计、算法）
- ✅ 图像/视频处理（滤镜、编解码）
- ✅ 加密解密（AES、RSA）
- ✅ 数据压缩/解压
- ✅ 语法高亮、代码格式化
- ✅ 长轮询、WebSocket 连接管理
- ✅ 离线数据同步

**不适用场景：**
- ❌ 轻量级计算（Worker 创建开销大于计算本身）
- ❌ 需要频繁访问 DOM
- ❌ 需要实时交互（消息传递有延迟）

#### 7.2 性能最佳实践

1. **复用 Worker 实例**
   ```javascript
   // 不好：每次任务创建新 Worker
   function runTask(data) {
     const worker = new Worker('worker.js'); // 创建开销大
     worker.postMessage(data);
   }

   // 好：复用 Worker
   const worker = new Worker('worker.js');
   function runTask(data) {
     worker.postMessage(data);
   }
   ```

2. **使用 Transferable Objects 传输大数据**
   ```javascript
   // 不好：拷贝 100MB 数据
   worker.postMessage({ buffer });

   // 好：转移所有权（零拷贝）
   worker.postMessage({ buffer }, [buffer]);
   ```

3. **避免频繁通信**
   ```javascript
   // 不好：逐个发送数据
   for (let i = 0; i < 1000; i++) {
     worker.postMessage(i);
   }

   // 好：批量发送
   worker.postMessage(Array.from({ length: 1000 }, (_, i) => i));
   ```

4. **合理控制 Worker 数量**
   ```javascript
   // 通常不超过 CPU 核心数
   const poolSize = navigator.hardwareConcurrency || 4;
   ```

### 八、调试技巧

#### 8.1 Chrome DevTools 调试

1. 打开 Chrome DevTools → Sources 面板
2. Worker 脚本会显示在 **Threads** 侧边栏
3. 可以设置断点、查看调用栈
4. Console 面板会显示 Worker 中的 `console.log` 输出

#### 8.2 错误处理

```javascript
// 主线程捕获 Worker 错误
worker.onerror = function(error) {
  console.error('Worker 错误:', error.message);
  console.error('文件:', error.filename);
  console.error('行号:', error.lineno);
};

// Worker 中捕获异常
self.onerror = function(error) {
  console.error('Worker 内部错误:', error);
  // 可以选择通知主线程
  self.postMessage({ type: 'error', message: error.message });
  return true; // 阻止错误传播到主线程
};
```

### 九、兼容性与 Polyfill

#### 9.1 浏览器支持

- ✅ Chrome 4+
- ✅ Firefox 3.5+
- ✅ Safari 4+
- ✅ Edge 12+
- ✅ iOS Safari 5+
- ❌ IE 10+（有限支持）

#### 9.2 优雅降级

```javascript
function runTask(data, callback) {
  if (window.Worker) {
    const worker = new Worker('worker.js');
    worker.postMessage(data);
    worker.onmessage = (e) => callback(e.data);
  } else {
    // 降级到主线程执行
    setTimeout(() => {
      const result = processData(data);
      callback(result);
    }, 0);
  }
}
```

### 十、面试高频问题

**Q1: Web Workers 和 Service Workers 的区别？**

| 特性 | Web Workers | Service Workers |
|------|------------|----------------|
| 用途 | 后台计算任务 | PWA、离线缓存、推送 |
| 生命周期 | 与页面绑定 | 独立于页面 |
| 作用域 | 单个页面 | 多个页面共享 |
| 网络拦截 | 不支持 | 支持（fetch 事件） |

**Q2: 为什么 Worker 不能访问 DOM？**

A: 浏览器引擎的 UI 渲染是单线程的（避免竞态条件）。如果 Worker 可以修改 DOM，会导致主线程和 Worker 同时操作 DOM 引发数据竞争和渲染冲突。因此设计上 Worker 完全隔离 DOM 访问，只能通过消息传递与主线程通信。

**Q3: 如何在 Worker 中使用第三方库（如 lodash）？**

A: 使用 `importScripts()` 加载：

```javascript
// Worker 中
importScripts('https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js');
const result = _.chunk([1, 2, 3, 4], 2);
```

**Q4: Worker 通信会序列化函数吗？**

A: 不会。函数无法通过 `postMessage` 传递，尝试发送会报错或被忽略：

```javascript
worker.postMessage({ fn: () => {} }); // 函数会丢失
```

如需传递逻辑，可以传递字符串然后用 `eval` 或 `new Function()`（不推荐），或者在 Worker 中预定义函数集合，主线程传递函数名调用。

### 十一、总结

Web Workers 是前端性能优化的重要工具，掌握其通信机制和使用场景能显著提升应用性能。核心要点：

1. **消息传递通信**：通过 `postMessage/onmessage` 传递数据（拷贝）
2. **Transferable Objects**：大数据传输使用所有权转移（零拷贝）
3. **作用域隔离**：无法访问 DOM，但支持 fetch、IndexedDB 等 API
4. **合理使用**：适合耗时计算，不适合轻量任务和频繁 DOM 操作
5. **Worker 池**：复用实例提高性能
6. **错误处理**：主线程和 Worker 都需要 `onerror` 监听

---

**参考资料：**
- MDN: Web Workers API - https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API
- HTML Living Standard: Workers - https://html.spec.whatwg.org/multipage/workers.html
- Google Developers: Using Web Workers - https://web.dev/workers-overview/
