---
title: ES6+ 的新特性（解构、扩展运算符、可选链）
tags:
  - 前端JavaScript
status: robot
class: 前端JavaScript
slug: es6-destructuring-spread-optional-chaining
ref:
---

## 核心要点总结

**解构赋值**：快速提取数组/对象属性，支持默认值、重命名、嵌套解构的语法糖
**扩展运算符**：...语法实现数组/对象的展开、合并、浅拷贝和函数参数处理
**可选链**：?.运算符安全访问嵌套属性，避免TypeError，简化条件判断逻辑

## 详细回答

### 1. 解构赋值（Destructuring Assignment）

解构赋值是ES6引入的语法糖，允许从数组和对象中提取值并赋给变量。

**数组解构**：
```javascript
// 基本数组解构
const [a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3

// 跳过某些元素
const [first, , third] = [1, 2, 3];
console.log(first, third); // 1 3

// 默认值
const [x = 10, y = 20] = [1];
console.log(x, y); // 1 20

// 剩余元素
const [head, ...tail] = [1, 2, 3, 4];
console.log(head); // 1
console.log(tail); // [2, 3, 4]

// 变量交换
let m = 1, n = 2;
[m, n] = [n, m];
console.log(m, n); // 2 1

// 嵌套数组解构
const [a, [b, c]] = [1, [2, 3]];
console.log(a, b, c); // 1 2 3

// 函数返回值解构
function getCoordinates() {
  return [10, 20];
}
const [x, y] = getCoordinates();
```

**对象解构**：
```javascript
// 基本对象解构
const { name, age } = { name: 'John', age: 30, city: 'NYC' };
console.log(name, age); // John 30

// 重命名变量
const { name: userName, age: userAge } = { name: 'John', age: 30 };
console.log(userName, userAge); // John 30

// 默认值
const { name = 'Anonymous', score = 0 } = { name: 'John' };
console.log(name, score); // John 0

// 默认值+重命名
const { name: userName = 'Anonymous' } = {};
console.log(userName); // Anonymous

// 嵌套对象解构
const user = {
  id: 1,
  profile: {
    name: 'John',
    contact: {
      email: 'john@example.com'
    }
  }
};
const { profile: { name, contact: { email } } } = user;
console.log(name, email); // John john@example.com

// 剩余属性
const { name, ...rest } = { name: 'John', age: 30, city: 'NYC' };
console.log(name); // John
console.log(rest); // { age: 30, city: 'NYC' }
```

**函数参数解构**：
```javascript
// 对象参数解构
function createUser({ name, age = 18, isAdmin = false }) {
  return { name, age, isAdmin };
}
createUser({ name: 'John', age: 25 });

// 数组参数解构
function sum([a, b, c = 0]) {
  return a + b + c;
}
sum([1, 2]); // 3

// 复杂参数解构
function processData({
  data: { items = [] } = {},
  options: { sort = true, filter = null } = {}
} = {}) {
  // 处理逻辑
}
```

### 2. 扩展运算符（Spread Operator）

扩展运算符（...）用于展开可迭代对象，在多种场景下提供简洁的语法。

**数组扩展运算符**：
```javascript
// 数组展开
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// 数组浅拷贝
const original = [1, 2, 3];
const copy = [...original];
copy.push(4); // 不影响original

// 数组合并（替代concat）
const merged = [...arr1, 0, ...arr2, 7]; // [1, 2, 3, 0, 4, 5, 6, 7]

// 字符串转数组
const chars = [...'hello']; // ['h', 'e', 'l', 'l', 'o']

// 类数组转数组
const nodeList = document.querySelectorAll('div');
const elements = [...nodeList];

// 数组去重（配合Set）
const unique = [...new Set([1, 2, 2, 3, 3])]; // [1, 2, 3]

// 最大值/最小值
const numbers = [1, 5, 3, 9, 2];
const max = Math.max(...numbers); // 9
const min = Math.min(...numbers); // 1
```

**对象扩展运算符**：
```javascript
// 对象展开
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const combined = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// 对象浅拷贝
const original = { name: 'John', age: 30 };
const copy = { ...original };

// 对象合并与覆盖
const user = { name: 'John', age: 30 };
const updates = { age: 31, city: 'NYC' };
const updated = { ...user, ...updates }; // { name: 'John', age: 31, city: 'NYC' }

// 条件属性添加
const includeEmail = true;
const user = {
  name: 'John',
  age: 30,
  ...(includeEmail && { email: 'john@example.com' })
};

// 删除属性（配合解构）
const { password, ...publicUser } = fullUser;

// 嵌套对象合并（注意：扩展运算符只进行浅拷贝）
const user = {
  name: 'John',
  preferences: { theme: 'dark' }
};
const updates = {
  preferences: { language: 'en' }
};
// 错误方式：会覆盖整个preferences
const wrong = { ...user, ...updates }; // preferences只有language

// 正确方式：递归合并
const correct = {
  ...user,
  preferences: { ...user.preferences, ...updates.preferences }
};
```

**函数参数中的扩展运算符**：
```javascript
// 剩余参数（Rest Parameters）
function sum(first, ...rest) {
  console.log(first); // 第一个参数
  console.log(rest);  // 剩余参数数组
  return rest.reduce((acc, val) => acc + val, first);
}
sum(1, 2, 3, 4); // first=1, rest=[2,3,4]

// 函数调用时展开数组
function multiply(a, b, c) {
  return a * b * c;
}
const args = [2, 3, 4];
const result = multiply(...args); // 等价于multiply(2, 3, 4)

// 复制函数参数
function cloneArray(arr) {
  return [...arr];
}

// 可变参数函数
function createLogger(...levels) {
  return function(level, message) {
    if (levels.includes(level)) {
      console.log(`[${level}] ${message}`);
    }
  };
}
const logger = createLogger('info', 'warn', 'error');
```

### 3. 可选链（Optional Chaining）

可选链操作符（?.）ES2020引入，安全地访问嵌套对象属性。

**基本用法**：
```javascript
// 传统方式：冗长的安全检查
const user = {
  profile: {
    contact: {
      email: 'john@example.com'
    }
  }
};

// 传统安全访问
const email = user && user.profile && user.profile.contact && user.profile.contact.email;

// 可选链：简洁安全
const email = user?.profile?.contact?.email;
console.log(email); // 'john@example.com'

// 处理undefined情况
const missingUser = null;
const email = missingUser?.profile?.contact?.email;
console.log(email); // undefined（不会报错）
```

**方法调用的可选链**：
```javascript
const api = {
  users: {
    fetch() {
      return ['John', 'Jane'];
    }
  }
};

// 安全调用方法
const users = api?.users?.fetch?.();
console.log(users); // ['John', 'Jane']

// 方法不存在时
const result = api?.admin?.deleteAll?.();
console.log(result); // undefined（不会报错）

// 动态方法调用
const methodName = 'fetch';
const users = api?.users?.[methodName]?.();
```

**数组访问的可选链**：
```javascript
const data = {
  items: [
    { name: 'Item 1' },
    { name: 'Item 2' }
  ]
};

// 安全访问数组元素
const firstItem = data?.items?.[0]?.name;
console.log(firstItem); // 'Item 1'

// 数组不存在时
const missingData = {};
const item = missingData?.items?.[0]?.name;
console.log(item); // undefined

// 动态索引访问
const index = 1;
const secondItem = data?.items?.[index]?.name;
```

**与空值合并操作符结合**：
```javascript
// 空值合并操作符（??）ES2020
const user = {
  name: 'John',
  profile: {
    avatar: null
  }
};

// 提供默认值
const avatar = user?.profile?.avatar ?? '/default-avatar.png';
const theme = user?.preferences?.theme ?? 'light';

// 注意：??只在null或undefined时使用默认值
const count = user?.profile?.count ?? 0; // count为0时不会使用默认值
```

### 4. 实际应用场景

**API数据处理**：
```javascript
// 处理API响应
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    const data = await response.json();

    // 安全解构API响应
    const {
      user: {
        name = 'Unknown',
        email = '',
        profile: {
          avatar = '/default-avatar.png',
          preferences: {
            theme = 'light',
            language = 'en'
          } = {}
        } = {}
      } = {}
    } = data;

    return { name, email, avatar, theme, language };
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}

// 使用可选链处理响应
function displayUser(userData) {
  const name = userData?.user?.name ?? 'Guest';
  const avatar = userData?.user?.profile?.avatar ?? '/default.png';
  const theme = userData?.user?.preferences?.theme ?? 'light';

  // 渲染用户界面
}
```

**React组件中的应用**：
```javascript
// React组件props解构
function UserCard({
  user: {
    name,
    email,
    profile: {
      avatar = '/default.png',
      bio = ''
    } = {}
  } = {},
  onEdit,
  ...props
}) {
  return (
    <div {...props}>
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>{email}</p>
      {bio && <p>{bio}</p>}
      <button onClick={onEdit?.bind(null, user)}>
        Edit
      </button>
    </div>
  );
}

// 状态更新
const [user, setUser] = useState({});

// 更新嵌套状态
const updateProfile = (profileData) => {
  setUser(prev => ({
    ...prev,
    profile: {
      ...prev.profile,
      ...profileData
    }
  }));
};
```

**配置对象处理**：
```javascript
// 配置合并
function createConfig(userConfig = {}) {
  const defaultConfig = {
    server: {
      port: 3000,
      host: 'localhost'
    },
    database: {
      url: 'mongodb://localhost:27017',
      options: {
        useNewUrlParser: true
      }
    }
  };

  // 深度合并配置
  return {
    ...defaultConfig,
    ...userConfig,
    server: {
      ...defaultConfig.server,
      ...userConfig.server
    },
    database: {
      ...defaultConfig.database,
      ...userConfig.database,
      options: {
        ...defaultConfig.database.options,
        ...userConfig.database?.options
      }
    }
  };
}
```

### 5. 性能和注意事项

**扩展运算符性能**：
```javascript
// 大数组拷贝性能对比
const largeArray = new Array(100000).fill().map((_, i) => i);

// 扩展运算符（适中性能）
console.time('spread');
const copy1 = [...largeArray];
console.timeEnd('spread');

// Array.from（更好性能）
console.time('Array.from');
const copy2 = Array.from(largeArray);
console.timeEnd('Array.from');

// slice（最佳性能）
console.time('slice');
const copy3 = largeArray.slice();
console.timeEnd('slice');
```

**内存使用注意**：
```javascript
// 避免不必要的对象拷贝
const updateUserName = (users, userId, newName) => {
  // 效率较低：每次都创建新数组
  return users.map(user =>
    user.id === userId
      ? { ...user, name: newName }
      : user
  );
};

// 更高效的方式
const updateUserName = (users, userId, newName) => {
  const index = users.findIndex(user => user.id === userId);
  if (index === -1) return users;

  const newUsers = [...users];
  newUsers[index] = { ...users[index], name: newName };
  return newUsers;
};
```

**可选链的短路特性**：
```javascript
// 可选链会短路，提高性能
const expensiveOperation = () => {
  console.log('expensive operation executed');
  return { value: 42 };
};

const obj = null;
// expensiveOperation不会被调用
const result = obj?.someProperty?.expensiveOperation()?.value;
```

这些ES6+特性大大提升了JavaScript的表达能力和代码简洁性，是现代JavaScript开发的基础工具。掌握它们的使用场景和注意事项，能够写出更优雅、更安全的代码。
