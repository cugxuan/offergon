---
title: JavaScript 的性能优化技巧
tags:
  - JavaScript
status: robot
class: 前端JavaScript
slug: javascript-performance-optimization-techniques
ref:
---

## 核心要点

JavaScript 性能优化涵盖多个层面：**代码层面**（避免强制同步布局、减少重排重绘、使用事件委托、防抖节流）、**内存管理**（避免内存泄漏、合理使用闭包、WeakMap/WeakSet）、**算法优化**（时间复杂度优化、缓存计算结果）、**异步优化**（Web Workers、requestIdleCallback）、**打包优化**（代码分割、Tree Shaking、懒加载）、**网络优化**（资源压缩、CDN、HTTP/2）。关键原则：**测量优先**、**避免过早优化**、**关注用户体验指标**（FCP、LCP、TTI、CLS）。

---

## 详细解答

### 一、性能优化的基本原则

#### 1.1 性能优化三步法

1. **测量（Measure）**：使用工具识别瓶颈
2. **优化（Optimize）**：针对性改进
3. **验证（Verify）**：再次测量确认效果

**重要原则：**
- ❌ 避免过早优化（Premature optimization is the root of all evil）
- ✅ 先写可读性好的代码，再根据数据优化
- ✅ 优先优化影响最大的部分（80/20 法则）

#### 1.2 性能指标（Web Vitals）

**核心 Web 指标：**
- **LCP（Largest Contentful Paint）**：最大内容绘制 < 2.5s
- **FID（First Input Delay）**：首次输入延迟 < 100ms
- **CLS（Cumulative Layout Shift）**：累积布局偏移 < 0.1

**其他关键指标：**
- **FCP（First Contentful Paint）**：首次内容绘制
- **TTI（Time to Interactive）**：可交互时间
- **TBT（Total Blocking Time）**：总阻塞时间

### 二、DOM 操作优化

#### 2.1 减少重排（Reflow）和重绘（Repaint）

**重排：** 改变元素几何属性（位置、尺寸）导致重新计算布局
**重绘：** 改变元素外观（颜色、背景）但不影响布局

```javascript
// ❌ 不好：多次触发重排
const el = document.getElementById('box');
el.style.width = '100px';  // 重排
el.style.height = '100px'; // 重排
el.style.margin = '10px';  // 重排

// ✅ 好：批量修改（一次重排）
el.style.cssText = 'width: 100px; height: 100px; margin: 10px;';

// ✅ 或使用 class
el.className = 'optimized-box';
```

**避免强制同步布局（Forced Synchronous Layout）：**

```javascript
// ❌ 不好：读写交替导致强制同步布局
const boxes = document.querySelectorAll('.box');
boxes.forEach(box => {
  const width = box.offsetWidth; // 读取（触发布局计算）
  box.style.width = width + 10 + 'px'; // 写入（修改样式）
  // 下一次读取又会触发新的布局计算
});

// ✅ 好：分离读写操作
const boxes = document.querySelectorAll('.box');
const widths = [];

// 先统一读取
boxes.forEach(box => {
  widths.push(box.offsetWidth);
});

// 再统一写入
boxes.forEach((box, i) => {
  box.style.width = widths[i] + 10 + 'px';
});
```

#### 2.2 使用文档片段（DocumentFragment）

```javascript
// ❌ 不好：多次插入 DOM（多次重排）
const list = document.getElementById('list');
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.appendChild(li); // 每次都触发重排
}

// ✅ 好：使用 DocumentFragment（一次重排）
const list = document.getElementById('list');
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
list.appendChild(fragment); // 一次性插入

// ✅ 更好：使用 innerHTML（更快）
const items = Array.from({ length: 1000 }, (_, i) =>
  `<li>Item ${i}</li>`
).join('');
list.innerHTML = items;
```

#### 2.3 虚拟滚动（Virtual Scrolling）

只渲染可见区域的 DOM 元素，适合长列表：

```javascript
class VirtualList {
  constructor(container, items, itemHeight) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.startIndex = 0;

    this.render();
    this.container.addEventListener('scroll', () => this.onScroll());
  }

  onScroll() {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    this.render();
  }

  render() {
    const endIndex = this.startIndex + this.visibleCount;
    const visibleItems = this.items.slice(this.startIndex, endIndex);

    // 更新容器高度（模拟完整列表）
    const totalHeight = this.items.length * this.itemHeight;
    this.container.style.height = totalHeight + 'px';

    // 只渲染可见项
    const html = visibleItems.map((item, i) => {
      const top = (this.startIndex + i) * this.itemHeight;
      return `<div style="position: absolute; top: ${top}px; height: ${this.itemHeight}px">${item}</div>`;
    }).join('');

    this.container.innerHTML = html;
  }
}

// 使用
const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
new VirtualList(document.getElementById('list'), items, 50);
```

### 三、事件优化

#### 3.1 事件委托（Event Delegation）

```javascript
// ❌ 不好：为每个按钮绑定事件（内存消耗大）
const buttons = document.querySelectorAll('button');
buttons.forEach(btn => {
  btn.addEventListener('click', handleClick);
});

// ✅ 好：事件委托到父元素（一个监听器）
document.getElementById('container').addEventListener('click', e => {
  if (e.target.matches('button')) {
    handleClick(e);
  }
});
```

#### 3.2 防抖（Debounce）

延迟执行，只执行最后一次：

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 使用：搜索框输入
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(e => {
  console.log('搜索:', e.target.value);
  // 发送 API 请求
}, 300));
```

#### 3.3 节流（Throttle）

限制执行频率，固定时间间隔执行一次：

```javascript
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}

// 使用：滚动事件
window.addEventListener('scroll', throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 200));
```

#### 3.4 requestAnimationFrame 优化动画

```javascript
// ❌ 不好：使用 setInterval
let position = 0;
setInterval(() => {
  position += 1;
  element.style.left = position + 'px';
}, 16); // 约 60fps

// ✅ 好：使用 requestAnimationFrame
let position = 0;
function animate() {
  position += 1;
  element.style.left = position + 'px';
  if (position < 500) {
    requestAnimationFrame(animate);
  }
}
requestAnimationFrame(animate);
```

### 四、内存管理

#### 4.1 避免内存泄漏

**常见内存泄漏场景：**

```javascript
// 1. 未清理的定时器
const timer = setInterval(() => {
  console.log('运行中');
}, 1000);
// ✅ 记得清理
clearInterval(timer);

// 2. 未移除的事件监听器
function addListener() {
  const btn = document.getElementById('btn');
  btn.addEventListener('click', handleClick);
}
// ✅ 组件销毁时移除
function cleanup() {
  btn.removeEventListener('click', handleClick);
}

// 3. 闭包引用
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  return function() {
    console.log(largeData[0]); // 闭包持有 largeData 引用
  };
}
// ✅ 避免不必要的闭包引用

// 4. DOM 引用
const elements = [];
document.querySelectorAll('.item').forEach(el => {
  elements.push(el); // 即使 DOM 移除，elements 仍持有引用
});
// ✅ 使用 WeakMap
const elements = new WeakMap();
```

#### 4.2 使用 WeakMap 和 WeakSet

```javascript
// 普通 Map：强引用，阻止垃圾回收
const cache = new Map();
let obj = { data: 'large data' };
cache.set(obj, 'value');
obj = null; // obj 仍被 cache 引用，无法回收

// WeakMap：弱引用，允许垃圾回收
const cache = new WeakMap();
let obj = { data: 'large data' };
cache.set(obj, 'value');
obj = null; // obj 可以被垃圾回收

// 应用：关联 DOM 元素数据
const elementData = new WeakMap();
function attachData(element, data) {
  elementData.set(element, data);
}
// 当 element 从 DOM 移除后，自动清理
```

### 五、算法与数据结构优化

#### 5.1 时间复杂度优化

```javascript
// ❌ 不好：O(n²) 查找重复
function hasDuplicates(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) return true;
    }
  }
  return false;
}

// ✅ 好：O(n) 使用 Set
function hasDuplicates(arr) {
  return new Set(arr).size !== arr.length;
}
```

#### 5.2 缓存计算结果（Memoization）

```javascript
// 斐波那契数列（朴素递归：指数时间复杂度）
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}

// ✅ Memoization 优化：O(n)
function fibMemo() {
  const cache = {};
  return function fib(n) {
    if (n in cache) return cache[n];
    if (n <= 1) return n;
    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n];
  };
}
const fib = fibMemo();
console.log(fib(100)); // 瞬间完成
```

#### 5.3 使用合适的数据结构

```javascript
// 频繁查找：使用 Map/Set 而非数组
// ❌ 不好：O(n) 查找
const users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
function findUser(id) {
  return users.find(u => u.id === id); // O(n)
}

// ✅ 好：O(1) 查找
const usersMap = new Map([
  [1, { id: 1, name: 'Alice' }],
  [2, { id: 2, name: 'Bob' }]
]);
function findUser(id) {
  return usersMap.get(id); // O(1)
}
```

### 六、异步优化

#### 6.1 Web Workers 分离耗时任务

```javascript
// 主线程
const worker = new Worker('heavy-task.js');
worker.postMessage({ data: largeArray });
worker.onmessage = e => {
  console.log('结果:', e.data);
};

// heavy-task.js
self.onmessage = e => {
  const result = heavyComputation(e.data);
  self.postMessage(result);
};
```

#### 6.2 requestIdleCallback 利用空闲时间

```javascript
// 在浏览器空闲时执行低优先级任务
function processQueue(queue) {
  requestIdleCallback(deadline => {
    while (deadline.timeRemaining() > 0 && queue.length > 0) {
      const task = queue.shift();
      task();
    }
    if (queue.length > 0) {
      processQueue(queue); // 继续处理剩余任务
    }
  });
}

// 使用
const tasks = [task1, task2, task3, /* ... */];
processQueue(tasks);
```

#### 6.3 分批处理大数据

```javascript
// ❌ 不好：一次处理 10 万条数据（阻塞 UI）
function processData(data) {
  data.forEach(item => {
    // 复杂处理
  });
}
processData(largeArray); // UI 冻结

// ✅ 好：分批处理
async function processBatch(data, batchSize = 1000) {
  for (let i = 0; i < data.length; i += batchSize) {
    const batch = data.slice(i, i + batchSize);
    batch.forEach(item => {
      // 复杂处理
    });
    // 让出控制权给浏览器
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}
processBatch(largeArray);
```

### 七、代码层面优化

#### 7.1 避免不必要的计算

```javascript
// ❌ 不好：每次循环都计算 length
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// ✅ 好：缓存 length
const len = arr.length;
for (let i = 0; i < len; i++) {
  console.log(arr[i]);
}

// ✅ 更好：使用 for...of（性能相近且可读性好）
for (const item of arr) {
  console.log(item);
}
```

#### 7.2 对象属性访问优化

```javascript
// ❌ 不好：多次访问深层属性
function getFullName(user) {
  return user.profile.personal.firstName + ' ' + user.profile.personal.lastName;
}

// ✅ 好：解构赋值
function getFullName(user) {
  const { firstName, lastName } = user.profile.personal;
  return `${firstName} ${lastName}`;
}
```

#### 7.3 使用位运算

```javascript
// 判断奇偶
// ❌ 慢：num % 2 === 0
// ✅ 快：(num & 1) === 0

// 取整
// ❌ 慢：Math.floor(num)
// ✅ 快：num | 0 或 ~~num

// 乘以 2 的幂
// ❌ 慢：num * 8
// ✅ 快：num << 3
```

#### 7.4 字符串拼接优化

```javascript
// ❌ 不好：大量字符串拼接
let html = '';
for (let i = 0; i < 1000; i++) {
  html += '<li>Item ' + i + '</li>';
}

// ✅ 好：使用数组 join
const parts = [];
for (let i = 0; i < 1000; i++) {
  parts.push(`<li>Item ${i}</li>`);
}
const html = parts.join('');

// ✅ 更好：模板字符串 + map
const html = Array.from({ length: 1000 }, (_, i) =>
  `<li>Item ${i}</li>`
).join('');
```

### 八、打包与加载优化

#### 8.1 代码分割（Code Splitting）

```javascript
// 动态 import（Webpack 自动分割）
button.addEventListener('click', async () => {
  const module = await import('./heavyModule.js');
  module.init();
});

// React 路由懒加载
const Home = React.lazy(() => import('./Home'));
const About = React.lazy(() => import('./About'));
```

#### 8.2 Tree Shaking

```javascript
// ❌ 导入整个库
import _ from 'lodash';
_.debounce(fn, 300);

// ✅ 只导入需要的函数
import debounce from 'lodash/debounce';
debounce(fn, 300);

// ✅ 使用支持 Tree Shaking 的库
import { debounce } from 'lodash-es';
```

#### 8.3 资源预加载

```html
<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="https://api.example.com">

<!-- 预连接（DNS + TCP + TLS） -->
<link rel="preconnect" href="https://cdn.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>

<!-- 预获取（空闲时加载） -->
<link rel="prefetch" href="next-page.js">
```

#### 8.4 图片优化

```html
<!-- 响应式图片 -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.jpg" type="image/jpeg">
  <img src="image.jpg" alt="Description" loading="lazy">
</picture>

<!-- 懒加载 -->
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

```javascript
// Intersection Observer 实现懒加载
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

### 九、性能监控

#### 9.1 Performance API

```javascript
// 测量函数执行时间
performance.mark('start');
expensiveOperation();
performance.mark('end');
performance.measure('operation', 'start', 'end');

const measure = performance.getEntriesByName('operation')[0];
console.log(`耗时: ${measure.duration}ms`);

// 监控页面加载性能
window.addEventListener('load', () => {
  const perfData = performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  const domReadyTime = perfData.domContentLoadedEventEnd - perfData.navigationStart;
  console.log(`页面加载耗时: ${pageLoadTime}ms`);
  console.log(`DOM Ready 耗时: ${domReadyTime}ms`);
});
```

#### 9.2 Web Vitals 监控

```javascript
// 使用 web-vitals 库
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  console.log(metric);
  // 上报到分析平台
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

#### 9.3 Long Task 监控

```javascript
// 监控长任务（>50ms）
const observer = new PerformanceObserver(list => {
  list.getEntries().forEach(entry => {
    console.warn(`长任务检测: ${entry.duration}ms`, entry);
  });
});
observer.observe({ entryTypes: ['longtask'] });
```

### 十、实战案例

#### 10.1 优化大型列表渲染

```javascript
// 使用 React + react-window
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index]}
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

#### 10.2 优化搜索功能

```javascript
// 防抖 + 缓存 + 取消请求
let abortController = null;
const cache = new Map();

const debouncedSearch = debounce(async (query) => {
  // 检查缓存
  if (cache.has(query)) {
    return cache.get(query);
  }

  // 取消之前的请求
  if (abortController) {
    abortController.abort();
  }

  // 创建新的请求
  abortController = new AbortController();

  try {
    const response = await fetch(`/api/search?q=${query}`, {
      signal: abortController.signal
    });
    const data = await response.json();

    // 缓存结果
    cache.set(query, data);
    return data;
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('请求已取消');
    }
  }
}, 300);
```

### 十一、面试高频问题

**Q1: 重排和重绘的区别？如何优化？**

A:
- **重排（Reflow）**：元素几何属性变化，浏览器重新计算布局。触发条件：修改宽高、添加/删除 DOM、改变字体大小等
- **重绘（Repaint）**：元素外观变化但不影响布局。触发条件：改变颜色、背景、阴影等

优化方法：
1. 批量修改样式（使用 class 或 cssText）
2. 避免强制同步布局（分离读写操作）
3. 使用 `transform` 和 `opacity`（只触发合成，不触发重排重绘）
4. 使用 `will-change` 提示浏览器优化

**Q2: 如何检测内存泄漏？**

A:
1. Chrome DevTools Memory 面板：
   - 拍摄堆快照对比
   - 记录时间线查看内存增长趋势
2. Performance Monitor：实时监控内存使用
3. 代码审查：检查未清理的定时器、事件监听器、闭包引用

**Q3: 防抖和节流的区别？**

| 特性 | 防抖（Debounce） | 节流（Throttle） |
|------|----------------|----------------|
| 执行时机 | 最后一次触发后延迟执行 | 固定时间间隔执行 |
| 适用场景 | 搜索框输入、窗口 resize | 滚动事件、鼠标移动 |
| 执行次数 | 多次触发只执行一次 | 固定频率执行 |

**Q4: `requestAnimationFrame` vs `setTimeout`？**

A:
- **requestAnimationFrame**：
  - 浏览器下次重绘前执行（约 60fps）
  - 自动适应屏幕刷新率
  - 标签页不可见时自动暂停
  - 更适合动画

- **setTimeout**：
  - 指定延迟后执行
  - 不保证精确时间
  - 后台标签页可能被限流
  - 更适合定时任务

### 十二、总结

JavaScript 性能优化的核心要点：

1. **DOM 优化**：减少重排重绘、批量操作、虚拟滚动
2. **事件优化**：事件委托、防抖节流、requestAnimationFrame
3. **内存管理**：避免泄漏、使用 WeakMap、及时清理
4. **算法优化**：降低时间复杂度、缓存计算、合适数据结构
5. **异步优化**：Web Workers、分批处理、requestIdleCallback
6. **代码优化**：避免冗余计算、合理使用闭包、位运算
7. **打包优化**：代码分割、Tree Shaking、懒加载
8. **监控与测量**：Performance API、Web Vitals、Long Task

**优化金字塔（优先级从高到低）：**
```
         关键渲染路径（FCP、LCP）
              ↑
         JavaScript 执行时间
              ↑
         资源加载优化
              ↑
         代码细节优化
```

---

**参考资料：**
- Google Web Fundamentals: Performance - https://web.dev/performance/
- MDN: Performance API - https://developer.mozilla.org/en-US/docs/Web/API/Performance
- Chrome DevTools: Performance - https://developer.chrome.com/docs/devtools/performance/
- Web Vitals - https://web.dev/vitals/
- JavaScript 性能优化指南 - https://github.com/GoogleChrome/web-vitals
