---
title: Redis 的主从复制原理，全量复制和增量复制的区别
tags:
  - Redis
  - 缓存
class: 缓存
slug: redis-master-slave-replication-full-partial-diff
ref:
---

## 核心要点

Redis 主从复制通过 PSYNC 命令实现,分为全量复制(首次同步,传输 RDB)和增量复制(断线重连,传输积压缓冲区命令)。主从复制是异步的,保证高性能但可能有短暂数据不一致。

## 详细回答

### 主从复制架构

```
     Master (读写)
       ↙  ↓  ↘
   Slave1 Slave2 Slave3 (只读)
```

**作用**:
- 数据冗余备份
- 读写分离,提升性能
- 高可用基础(配合哨兵)

### 复制流程

#### 1. 建立连接
```bash
# Slave 配置
slaveof <masterip> <masterport>
# 或运行时执行
SLAVEOF 192.168.1.100 6379
```

**步骤**:
1. Slave 发送 PSYNC 命令到 Master
2. Master 响应,决定全量复制还是增量复制

#### 2. 全量复制 (Full Resynchronization)

**触发时机**:
- 首次连接 Master
- runid 不匹配(Master 重启过)
- 复制积压缓冲区数据不足

**流程**:
```
Slave                          Master
  |                               |
  |--- PSYNC runid offset ------->|
  |                               |
  |<--- +FULLRESYNC runid offset -|
  |                               | (1) BGSAVE 生成 RDB
  |                               | (2) 记录 RDB 后的写命令到缓冲区
  |<--- RDB 文件 ------------------|
  | (3) 清空旧数据,加载 RDB        |
  |                               |
  |<--- 缓冲区命令 ----------------|
  | (4) 执行缓冲区命令             |
```

**详细步骤**:
1. **Slave 发送 PSYNC**:
   - 首次: `PSYNC ? -1`
   - 重连: `PSYNC <runid> <offset>`

2. **Master 执行 BGSAVE**:
   - Fork 子进程生成 RDB 文件
   - 主进程继续处理命令

3. **Master 发送 RDB 文件**:
   - 网络传输 RDB 到 Slave
   - 同时将新的写命令记录到**复制缓冲区**

4. **Slave 加载 RDB**:
   - 清空当前数据库
   - 加载 RDB 文件到内存

5. **Master 发送缓冲区命令**:
   - 将 RDB 生成期间的增量命令发送给 Slave

6. **进入命令传播阶段**:
   - Master 持续将写命令发送给 Slave

**缺点**:
- RDB 生成耗时,fork 可能阻塞
- 网络传输大文件耗时
- Slave 加载 RDB 期间不可用

#### 3. 增量复制 (Partial Resynchronization)

**触发时机**:
- Slave 断线重连
- runid 匹配
- offset 在复制积压缓冲区范围内

**流程**:
```
Slave                          Master
  |                               |
  |--- PSYNC runid offset ------->|
  |                               | (检查 offset 是否在积压缓冲区)
  |<--- +CONTINUE ---------------|
  |                               |
  |<--- 增量命令 -----------------|
  | (执行缺失的命令)               |
```

**关键概念**:

1. **Replication ID (runid)**:
   - Master 启动时生成的唯一 ID
   - 用于标识 Master 实例

2. **Replication Offset (复制偏移量)**:
   - Master 和 Slave 各自维护
   - 记录已复制的命令字节数
   - Master offset = 已发送的命令字节数
   - Slave offset = 已接收的命令字节数

3. **Replication Backlog (复制积压缓冲区)**:
   - Master 维护的 FIFO 队列(默认 1MB)
   - 保存最近的写命令
   - 配置: `repl-backlog-size 1mb`

**优点**:
- 只传输增量数据,速度快
- Slave 可快速恢复同步
- 对 Master 影响小

**限制**:
- offset 超出积压缓冲区范围则降级为全量复制

### 全量复制 vs 增量复制

| 特性 | 全量复制 | 增量复制 |
|------|---------|---------|
| 触发时机 | 首次同步/runid 不匹配 | 断线重连/offset 在范围内 |
| 数据传输 | 整个数据集(RDB) | 缺失的命令 |
| 耗时 | 长(取决于数据量) | 短(取决于缺失命令量) |
| Master 开销 | 大(BGSAVE+网络传输) | 小(只发命令) |
| Slave 可用性 | 加载期间不可用 | 基本可用 |
| 网络流量 | 大 | 小 |

### 无盘复制 (Diskless Replication)

**传统方式**: Master → 磁盘 RDB → 网络 → Slave

**无盘方式**: Master → 网络直接传输 → Slave

**配置**:
```bash
repl-diskless-sync yes
repl-diskless-sync-delay 5  # 等待更多 Slave 连接
```

**适用场景**:
- 磁盘性能差但网络好
- 多个 Slave 同时全量同步

### 异步复制与数据一致性

**特点**:
- Master 写入成功后立即返回,不等待 Slave 确认
- Slave 异步接收并执行命令

**数据延迟**:
```bash
# 查看主从延迟
INFO replication
# 关注 master_repl_offset 和 slave_repl_offset 差值
```

**最小 Slave 写入保证**:
```bash
min-slaves-to-write 1        # 至少 1 个 Slave 在线
min-slaves-max-lag 10        # 延迟不超过 10 秒
```
- 如果条件不满足,Master 拒绝写入

### 实践建议

1. **合理配置积压缓冲区**:
   - 根据网络断开时间和写入速率计算
   - `repl-backlog-size = 写入速率 × 断开时间 × 2`

2. **监控主从延迟**:
   - 定期检查 offset 差值
   - 设置告警阈值

3. **避免全量复制**:
   - 保持网络稳定
   - 增大复制积压缓冲区
   - Master 避免频繁重启

4. **读写分离注意**:
   - 从库可能有数据延迟
   - 对一致性要求高的读请求仍走主库

5. **从库只读**:
   ```bash
   slave-read-only yes  # 避免从库写入
   ```
