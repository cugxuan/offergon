---
title: 设计一个视频会议系统（WebRTC）
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: design-video-conference-system-webrtc
ref:
---

## 核心要点

**架构层面：** 信令服务器（WebSocket）+ TURN/STUN服务器 + SFU媒体转发服务器 + 录制服务 + 管理后台

**关键技术：** WebRTC P2P连接、ICE打洞、SDP协商、媒体流转发、编解码适配、带宽自适应

**核心挑战：** 多人会议性能优化、网络穿透、弱网对抗、延迟控制、音视频同步、录制存储

## 详细回答

### 一、系统需求分析

#### 1.1 功能性需求
- **基础音视频能力**：实时音视频通话、屏幕共享、文字聊天
- **会议管理**：创建/加入会议、成员管理、主持人控制（静音、踢人）
- **录制回放**：云端录制、本地录制、回放功能
- **协作功能**：白板共享、文档共享、举手发言
- **设备控制**：摄像头/麦克风切换、虚拟背景、美颜

#### 1.2 非功能性需求
- **低延迟**：端到端延迟 < 300ms
- **高并发**：单会议支持 100+ 并发用户
- **可用性**：99.9% SLA保证
- **弱网对抗**：30% 丢包率下仍可用
- **跨平台**：Web、iOS、Android、桌面端

### 二、技术架构设计

#### 2.1 整体架构

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   浏览器    │     │  移动端App  │     │   桌面端    │
│  (WebRTC)   │     │  (WebRTC)   │     │  (WebRTC)   │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                   │                   │
       └───────────────────┼───────────────────┘
                           │
              ┌────────────▼────────────┐
              │   信令服务器（Signal）    │
              │   - WebSocket 长连接    │
              │   - 房间状态管理        │
              │   - SDP 协商中转        │
              └────────────┬────────────┘
                           │
       ┌───────────────────┼───────────────────┐
       │                   │                   │
┌──────▼──────┐   ┌────────▼────────┐   ┌─────▼──────┐
│ STUN/TURN   │   │   SFU 媒体服务   │   │  录制服务  │
│  服务器      │   │  - 媒体转发      │   │  - 视频编码│
│  - NAT穿透  │   │  - 带宽适配      │   │  - 存储    │
└─────────────┘   │  - 混流/转码     │   └────────────┘
                  └─────────┬────────┘
                            │
                  ┌─────────▼────────┐
                  │   Redis 集群     │
                  │  - 房间状态缓存  │
                  │  - 分布式锁      │
                  └──────────────────┘
                            │
                  ┌─────────▼────────┐
                  │   MySQL 数据库   │
                  │  - 会议记录      │
                  │  - 用户信息      │
                  └──────────────────┘
```

#### 2.2 核心组件详解

**（1）信令服务器（Signaling Server）**

职责：建立 WebRTC 连接前的协商和控制

```go
// 信令消息类型
type SignalType string

const (
    JoinRoom        SignalType = "join"         // 加入房间
    LeaveRoom       SignalType = "leave"        // 离开房间
    Offer           SignalType = "offer"        // SDP Offer
    Answer          SignalType = "answer"       // SDP Answer
    IceCandidate    SignalType = "candidate"    // ICE 候选
    MuteAudio       SignalType = "mute_audio"   // 静音
    MuteVideo       SignalType = "mute_video"   // 关闭视频
)

// 信令消息结构
type SignalMessage struct {
    Type      SignalType      `json:"type"`
    RoomID    string          `json:"room_id"`
    UserID    string          `json:"user_id"`
    TargetID  string          `json:"target_id,omitempty"`
    Data      json.RawMessage `json:"data"`
    Timestamp int64           `json:"timestamp"`
}

// 房间管理器
type RoomManager struct {
    rooms sync.Map // roomID -> *Room
    redis *redis.Client
}

type Room struct {
    ID           string
    Participants map[string]*Participant
    CreatedAt    time.Time
    MaxUsers     int
    mu           sync.RWMutex
}

type Participant struct {
    UserID       string
    Conn         *websocket.Conn
    PeerID       string
    AudioEnabled bool
    VideoEnabled bool
    Role         string // host/participant
}

// WebSocket 连接处理
func (s *SignalingServer) HandleConnection(conn *websocket.Conn) {
    participant := &Participant{
        Conn:         conn,
        AudioEnabled: true,
        VideoEnabled: true,
    }

    for {
        var msg SignalMessage
        if err := conn.ReadJSON(&msg); err != nil {
            s.handleDisconnect(participant)
            return
        }

        switch msg.Type {
        case JoinRoom:
            s.handleJoinRoom(participant, &msg)
        case Offer:
            s.handleOffer(participant, &msg)
        case Answer:
            s.handleAnswer(participant, &msg)
        case IceCandidate:
            s.handleIceCandidate(participant, &msg)
        }
    }
}

// 处理加入房间
func (s *SignalingServer) handleJoinRoom(p *Participant, msg *SignalMessage) {
    room := s.getOrCreateRoom(msg.RoomID)

    room.mu.Lock()
    defer room.mu.Unlock()

    // 检查房间人数限制
    if len(room.Participants) >= room.MaxUsers {
        s.sendError(p, "room_full")
        return
    }

    // 添加参与者
    room.Participants[p.UserID] = p

    // 通知房间内其他人
    s.broadcastToRoom(room, SignalMessage{
        Type:   "user_joined",
        UserID: p.UserID,
    }, p.UserID)

    // 返回当前房间成员列表
    s.sendParticipantsList(p, room)
}
```

**（2）STUN/TURN 服务器**

用于 NAT 穿透和中继：

```bash
# 使用 coturn 部署 TURN 服务器
# turnserver.conf 配置
listening-port=3478
tls-listening-port=5349
external-ip=YOUR_PUBLIC_IP
realm=yourdomain.com
user=username:password
cert=/path/to/cert.pem
pkey=/path/to/key.pem

# WebRTC 客户端配置
const iceServers = [
    { urls: 'stun:stun.l.google.com:19302' },
    {
        urls: 'turn:your-turn-server.com:3478',
        username: 'username',
        credential: 'password'
    }
];
```

**（3）SFU 媒体服务器（Selective Forwarding Unit）**

采用 SFU 而非 MCU 或 P2P 的原因：
- **P2P**：只适合 2-4 人小会议，多人时带宽消耗呈 N² 增长
- **MCU**：服务器压力大，需要解码再编码，延迟高
- **SFU**：只转发不转码，延迟低，服务器压力小

使用开源方案：[Pion SFU](https://github.com/pion/webrtc) 或 [Mediasoup](https://mediasoup.org/)

```go
// SFU 核心逻辑（基于 Pion WebRTC）
type SFURoom struct {
    ID          string
    Publishers  map[string]*Publisher
    Subscribers map[string]*Subscriber
}

type Publisher struct {
    UserID      string
    PeerConn    *webrtc.PeerConnection
    AudioTrack  *webrtc.TrackRemote
    VideoTrack  *webrtc.TrackRemote
}

type Subscriber struct {
    UserID      string
    PeerConn    *webrtc.PeerConnection
    Subscribing map[string]bool // userID -> subscribed
}

// 订阅其他参与者的流
func (s *SFURoom) Subscribe(subscriber *Subscriber, publisherID string) error {
    publisher := s.Publishers[publisherID]
    if publisher == nil {
        return errors.New("publisher not found")
    }

    // 添加视频轨道
    if publisher.VideoTrack != nil {
        _, err := subscriber.PeerConn.AddTrack(publisher.VideoTrack)
        if err != nil {
            return err
        }
    }

    // 添加音频轨道
    if publisher.AudioTrack != nil {
        _, err := subscriber.PeerConn.AddTrack(publisher.AudioTrack)
        if err != nil {
            return err
        }
    }

    subscriber.Subscribing[publisherID] = true
    return nil
}

// 带宽自适应（模拟层）
func (s *SFURoom) AdaptBandwidth(subscriber *Subscriber) {
    stats := subscriber.PeerConn.GetStats()

    // 根据网络状况调整视频质量
    if stats.PacketLoss > 0.05 { // 丢包率 > 5%
        // 降低码率，切换到低分辨率层
        s.switchToLowerQuality(subscriber)
    } else if stats.AvailableBandwidth > 2000 { // 带宽充足
        // 提升到高清质量
        s.switchToHigherQuality(subscriber)
    }
}
```

#### 2.3 前端 WebRTC 实现

```javascript
class VideoConference {
    constructor(roomId, userId) {
        this.roomId = roomId;
        this.userId = userId;
        this.peerConnections = new Map(); // userId -> RTCPeerConnection
        this.localStream = null;
        this.signalClient = null;
    }

    // 初始化本地媒体流
    async initLocalStream() {
        try {
            this.localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });

            // 显示本地视频
            document.getElementById('localVideo').srcObject = this.localStream;
        } catch (error) {
            console.error('无法获取媒体设备:', error);
        }
    }

    // 连接信令服务器
    connectSignaling() {
        this.signalClient = new WebSocket('wss://signal.example.com');

        this.signalClient.onopen = () => {
            // 加入房间
            this.signalClient.send(JSON.stringify({
                type: 'join',
                room_id: this.roomId,
                user_id: this.userId
            }));
        };

        this.signalClient.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            this.handleSignalMessage(msg);
        };
    }

    // 处理信令消息
    async handleSignalMessage(msg) {
        switch (msg.type) {
            case 'user_joined':
                // 新用户加入，创建 Offer
                await this.createOffer(msg.user_id);
                break;

            case 'offer':
                // 收到 Offer，创建 Answer
                await this.handleOffer(msg);
                break;

            case 'answer':
                // 收到 Answer
                await this.handleAnswer(msg);
                break;

            case 'candidate':
                // 收到 ICE 候选
                await this.handleIceCandidate(msg);
                break;
        }
    }

    // 创建 PeerConnection
    createPeerConnection(userId) {
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                {
                    urls: 'turn:turn.example.com:3478',
                    username: 'user',
                    credential: 'pass'
                }
            ]
        });

        // 添加本地流
        this.localStream.getTracks().forEach(track => {
            pc.addTrack(track, this.localStream);
        });

        // 监听远程流
        pc.ontrack = (event) => {
            this.addRemoteVideo(userId, event.streams[0]);
        };

        // 监听 ICE 候选
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                this.signalClient.send(JSON.stringify({
                    type: 'candidate',
                    room_id: this.roomId,
                    user_id: this.userId,
                    target_id: userId,
                    data: event.candidate
                }));
            }
        };

        // 监听连接状态
        pc.onconnectionstatechange = () => {
            console.log(`连接状态: ${pc.connectionState}`);
            if (pc.connectionState === 'failed') {
                // 重连逻辑
                this.reconnect(userId);
            }
        };

        this.peerConnections.set(userId, pc);
        return pc;
    }

    // 创建 Offer
    async createOffer(userId) {
        const pc = this.createPeerConnection(userId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        this.signalClient.send(JSON.stringify({
            type: 'offer',
            room_id: this.roomId,
            user_id: this.userId,
            target_id: userId,
            data: offer
        }));
    }

    // 处理 Offer
    async handleOffer(msg) {
        const pc = this.createPeerConnection(msg.user_id);
        await pc.setRemoteDescription(new RTCSessionDescription(msg.data));

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        this.signalClient.send(JSON.stringify({
            type: 'answer',
            room_id: this.roomId,
            user_id: this.userId,
            target_id: msg.user_id,
            data: answer
        }));
    }

    // 处理 Answer
    async handleAnswer(msg) {
        const pc = this.peerConnections.get(msg.user_id);
        await pc.setRemoteDescription(new RTCSessionDescription(msg.data));
    }

    // 处理 ICE 候选
    async handleIceCandidate(msg) {
        const pc = this.peerConnections.get(msg.user_id);
        await pc.addIceCandidate(new RTCIceCandidate(msg.data));
    }

    // 显示远程视频
    addRemoteVideo(userId, stream) {
        let video = document.getElementById(`video-${userId}`);
        if (!video) {
            video = document.createElement('video');
            video.id = `video-${userId}`;
            video.autoplay = true;
            video.playsInline = true;
            document.getElementById('remoteVideos').appendChild(video);
        }
        video.srcObject = stream;
    }

    // 屏幕共享
    async shareScreen() {
        try {
            const screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: { cursor: 'always' },
                audio: false
            });

            const videoTrack = screenStream.getVideoTracks()[0];

            // 替换所有 PeerConnection 的视频轨道
            this.peerConnections.forEach(pc => {
                const sender = pc.getSenders().find(s => s.track?.kind === 'video');
                if (sender) {
                    sender.replaceTrack(videoTrack);
                }
            });

            // 监听停止共享
            videoTrack.onended = () => {
                this.stopScreenShare();
            };
        } catch (error) {
            console.error('屏幕共享失败:', error);
        }
    }
}

// 使用示例
const conference = new VideoConference('room123', 'user456');
await conference.initLocalStream();
conference.connectSignaling();
```

### 三、关键技术点

#### 3.1 网络穿透（NAT Traversal）

**ICE（Interactive Connectivity Establishment）流程：**

1. **收集候选地址**：
   - Host 候选：本地网卡地址
   - Server Reflexive：通过 STUN 获取的公网地址
   - Relay 候选：通过 TURN 分配的中继地址

2. **连接性检查**：
   - 尝试所有候选地址对
   - 优先级：Host > Reflexive > Relay
   - 成功后选择最优路径

```javascript
// ICE 候选收集策略
const pc = new RTCPeerConnection({
    iceServers: [...],
    iceTransportPolicy: 'all',  // all | relay（强制中继）
    iceCandidatePoolSize: 10
});
```

#### 3.2 编解码器选择

```javascript
// 设置优先编解码器（VP8/VP9/H.264）
const offer = await pc.createOffer();
offer.sdp = offer.sdp.replace(
    /m=video (\d+) UDP\/TLS\/RTP\/SAVPF (.*)/,
    (match, port, codecs) => {
        // 优先 VP9
        const vp9 = codecs.split(' ').find(c =>
            codecs.includes(`${c} VP9`)
        );
        return `m=video ${port} UDP/TLS/RTP/SAVPF ${vp9} ${codecs}`;
    }
);
```

#### 3.3 带宽管理

```go
// 服务端带宽估算
type BandwidthEstimator struct {
    sendBitrate     uint64
    receiveBitrate  uint64
    packetLoss      float64
    rtt             time.Duration
}

func (e *BandwidthEstimator) EstimateQuality() VideoQuality {
    // 根据带宽和丢包率决定视频质量
    if e.receiveBitrate < 500*1024 || e.packetLoss > 0.1 {
        return LowQuality  // 360p
    } else if e.receiveBitrate < 1500*1024 {
        return MediumQuality  // 720p
    } else {
        return HighQuality  // 1080p
    }
}
```

#### 3.4 录制服务

```go
// 使用 FFmpeg 进行云端录制
type RecordingService struct {
    ffmpegPath string
    storage    ObjectStorage
}

func (r *RecordingService) StartRecording(roomID string, streams []*MediaStream) error {
    // 合成所有流到一个视频
    cmd := exec.Command(r.ffmpegPath,
        "-f", "webm",
        "-i", "pipe:0",  // 从管道读取 WebM 流
        "-c:v", "libx264",
        "-preset", "ultrafast",
        "-tune", "zerolatency",
        "-c:a", "aac",
        "-f", "mp4",
        fmt.Sprintf("/tmp/recording_%s.mp4", roomID),
    )

    stdin, _ := cmd.StdinPipe()

    // 从 SFU 获取混流后的数据
    go func() {
        mixedStream := r.mixStreams(streams)
        io.Copy(stdin, mixedStream)
    }()

    return cmd.Start()
}

func (r *RecordingService) StopRecording(roomID string) error {
    filePath := fmt.Sprintf("/tmp/recording_%s.mp4", roomID)

    // 上传到对象存储（S3/OSS）
    file, _ := os.Open(filePath)
    defer file.Close()

    objectKey := fmt.Sprintf("recordings/%s/%s.mp4",
        time.Now().Format("2006-01-02"), roomID)

    return r.storage.Upload(objectKey, file)
}
```

### 四、性能优化

#### 4.1 大规模会议优化

**分层 SFU（Simulcast）**：
- 发送端编码 3 层：高/中/低分辨率
- 接收端根据带宽订阅不同层

```javascript
// 发送端启用 Simulcast
pc.addTransceiver('video', {
    direction: 'sendonly',
    sendEncodings: [
        { rid: 'h', maxBitrate: 1500000 },  // 1080p
        { rid: 'm', maxBitrate: 600000, scaleResolutionDownBy: 2 },  // 540p
        { rid: 'l', maxBitrate: 200000, scaleResolutionDownBy: 4 }   // 270p
    ]
});
```

**宫格布局优化**：
- 只渲染可见视频窗口
- 虚拟滚动技术

#### 4.2 弱网优化

```javascript
// 前向纠错（FEC）和重传（RTX）
const offer = await pc.createOffer();
offer.sdp = offer.sdp.replace(
    'useinbandfec=1',
    'useinbandfec=1; minptime=10; maxaveragebitrate=510000'
);
```

```go
// 服务端丢包重传
type NACKHandler struct {
    packetBuffer map[uint16]*RTPPacket  // 序列号 -> 数据包
}

func (h *NACKHandler) HandleNACK(nack *rtcp.TransportLayerNack) {
    for _, seqNum := range nack.Nacks {
        if packet, exists := h.packetBuffer[seqNum]; exists {
            // 重传丢失的包
            h.resendPacket(packet)
        }
    }
}
```

### 五、监控告警

```go
// 实时质量监控
type QualityMetrics struct {
    RoomID         string
    UserID         string
    PacketLoss     float64
    Jitter         time.Duration
    RTT            time.Duration
    Bitrate        uint64
    FrameRate      int
    Resolution     string
    Timestamp      time.Time
}

// 定时上报到监控系统（Prometheus）
func (m *MetricsCollector) Collect(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            stats := m.collectStats()

            // 推送到 Prometheus
            packetLossGauge.Set(stats.PacketLoss)
            bitrateGauge.Set(float64(stats.Bitrate))

            // 异常告警
            if stats.PacketLoss > 0.2 {
                m.alertManager.Send("high_packet_loss", stats)
            }
        case <-ctx.Done():
            return
        }
    }
}
```

### 六、扩展功能

1. **AI 能力集成**
   - 实时转写（ASR）
   - 虚拟背景（背景分割）
   - 美颜/滤镜
   - 噪音消除

2. **协作白板**
   - 基于 Canvas + WebSocket
   - OT 算法实现协同编辑

3. **多设备同步**
   - 同一账号多端加入
   - 状态同步（Redis Pub/Sub）

### 七、部署架构

```yaml
# Kubernetes 部署示例
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sfu-server
spec:
  replicas: 5
  selector:
    matchLabels:
      app: sfu
  template:
    spec:
      containers:
      - name: sfu
        image: mediasoup-server:v3
        resources:
          requests:
            cpu: "2"
            memory: "4Gi"
          limits:
            cpu: "4"
            memory: "8Gi"
        ports:
        - containerPort: 8080
        - containerPort: 40000-49999  # RTP 端口范围
          protocol: UDP
---
apiVersion: v1
kind: Service
metadata:
  name: sfu-service
spec:
  type: LoadBalancer
  ports:
  - port: 8080
    targetPort: 8080
  selector:
    app: sfu
```

## 总结

设计一个生产级别的 WebRTC 视频会议系统需要关注：
1. **架构选型**：SFU 架构适合大多数场景
2. **网络优化**：TURN 保证连通性，带宽自适应保证体验
3. **性能优化**：Simulcast、虚拟滚动、选择性转发
4. **可靠性**：弱网对抗、断线重连、降级策略
5. **监控运维**：全链路质量监控、实时告警

这是一个典型的实时通信系统设计问题，需要平衡性能、成本和用户体验。
