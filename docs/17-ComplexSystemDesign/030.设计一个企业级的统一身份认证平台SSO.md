---
title: 设计一个企业级的统一身份认证平台（SSO）
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: enterprise-sso-platform-design
ref:
---

## 核心要点

**业务分析**：多系统统一登录、跨域身份同步、权限细粒度控制、审计日志完整性
**架构设计**：OAuth2.0/OIDC标准、微服务化部署、多租户支持、高可用保障
**技术要点**：JWT/SAML令牌、LDAP集成、RBAC权限模型、零信任架构

---

## 详细回答

### 1. 业务需求分析

**核心功能需求**：
- **统一登录**：一次登录，全平台访问（SSO）
- **统一登出**：一次登出，全平台退出（SLO）
- **身份管理**：用户生命周期管理
- **权限控制**：细粒度的访问控制
- **审计合规**：完整的操作日志

**非功能需求**：
- **性能**：登录响应时间<200ms，支持10万并发
- **可用性**：99.99%可用性，秒级故障恢复
- **安全性**：多因素认证，零信任架构
- **扩展性**：支持百万用户，水平扩展

**集成需求**：
- **内部系统**：OA、CRM、ERP、财务系统
- **外部系统**：第三方SaaS，合作伙伴系统
- **移动端**：iOS、Android原生应用
- **开发工具**：CI/CD平台，开发者工具

### 2. 整体架构设计

```
                     ┌─────────────────────────────────────────┐
                     │              用户端                      │
                     │  ┌─────────┐ ┌─────────┐ ┌─────────┐    │
                     │  │ Web应用  │ │移动应用  │ │第三方App │    │
                     │  └─────────┘ └─────────┘ └─────────┘    │
                     └─────────────────────────────────────────┘
                                           │
                     ┌─────────────────────────────────────────┐
                     │              接入层                      │
                     │         API Gateway + WAF              │
                     │    (SSL终止、限流、安全防护)              │
                     └─────────────────────────────────────────┘
                                           │
                     ┌─────────────────────────────────────────┐
                     │              SSO核心服务                 │
                     │ ┌─────────┐ ┌─────────┐ ┌─────────┐    │
                     │ │认证服务  │ │授权服务  │ │用户服务  │    │
                     │ │(Auth)   │ │(Authz)  │ │(User)   │    │
                     │ └─────────┘ └─────────┘ └─────────┘    │
                     │ ┌─────────┐ ┌─────────┐ ┌─────────┐    │
                     │ │会话服务  │ │审计服务  │ │通知服务  │    │
                     │ │(Session)│ │(Audit)  │ │(Notify) │    │
                     │ └─────────┘ └─────────┘ └─────────┘    │
                     └─────────────────────────────────────────┘
                                           │
                     ┌─────────────────────────────────────────┐
                     │              集成层                      │
                     │ ┌─────────┐ ┌─────────┐ ┌─────────┐    │
                     │ │LDAP/AD  │ │邮件服务  │ │短信服务  │    │
                     │ │集成     │ │集成     │ │集成     │    │
                     │ └─────────┘ └─────────┘ └─────────┘    │
                     └─────────────────────────────────────────┘
                                           │
                     ┌─────────────────────────────────────────┐
                     │              存储层                      │
                     │ ┌─────────┐ ┌─────────┐ ┌─────────┐    │
                     │ │用户DB   │ │会话缓存  │ │日志存储  │    │
                     │ │(MySQL)  │ │(Redis)  │ │(ES)     │    │
                     │ └─────────┘ └─────────┘ └─────────┘    │
                     └─────────────────────────────────────────┘
```

### 3. 核心技术方案

#### 3.1 认证协议选型

**OAuth 2.0 + OpenID Connect**：
```go
// OAuth2授权码流程
type AuthService struct {
    userService     UserServiceInterface
    tokenService    TokenServiceInterface
    clientService   ClientServiceInterface
}

// 1. 授权端点
func (as *AuthService) Authorize(ctx context.Context, req *AuthorizeRequest) (*AuthorizeResponse, error) {
    // 验证客户端
    client, err := as.clientService.GetClient(req.ClientID)
    if err != nil {
        return nil, errors.New("invalid_client")
    }

    // 验证重定向URI
    if !client.IsValidRedirectURI(req.RedirectURI) {
        return nil, errors.New("invalid_redirect_uri")
    }

    // 检查用户登录状态
    user := as.getCurrentUser(ctx)
    if user == nil {
        // 重定向到登录页面
        loginURL := fmt.Sprintf("/login?redirect=%s", url.QueryEscape(req.RedirectURI))
        return &AuthorizeResponse{RedirectURL: loginURL}, nil
    }

    // 生成授权码
    code := as.generateAuthorizationCode(user.ID, req.ClientID, req.Scope)

    // 构建回调URL
    callbackURL := fmt.Sprintf("%s?code=%s&state=%s", req.RedirectURI, code, req.State)

    return &AuthorizeResponse{RedirectURL: callbackURL}, nil
}

// 2. 令牌端点
func (as *AuthService) Token(ctx context.Context, req *TokenRequest) (*TokenResponse, error) {
    switch req.GrantType {
    case "authorization_code":
        return as.handleAuthorizationCodeGrant(ctx, req)
    case "refresh_token":
        return as.handleRefreshTokenGrant(ctx, req)
    case "client_credentials":
        return as.handleClientCredentialsGrant(ctx, req)
    default:
        return nil, errors.New("unsupported_grant_type")
    }
}

func (as *AuthService) handleAuthorizationCodeGrant(ctx context.Context, req *TokenRequest) (*TokenResponse, error) {
    // 验证授权码
    authCode, err := as.validateAuthorizationCode(req.Code)
    if err != nil {
        return nil, errors.New("invalid_grant")
    }

    // 验证客户端
    if !as.validateClient(req.ClientID, req.ClientSecret) {
        return nil, errors.New("invalid_client")
    }

    // 生成访问令牌
    accessToken, err := as.tokenService.GenerateAccessToken(&TokenClaims{
        UserID:   authCode.UserID,
        ClientID: authCode.ClientID,
        Scope:    authCode.Scope,
        ExpireAt: time.Now().Add(time.Hour),
    })

    // 生成刷新令牌
    refreshToken, err := as.tokenService.GenerateRefreshToken(authCode.UserID, authCode.ClientID)

    return &TokenResponse{
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        TokenType:    "Bearer",
        ExpiresIn:    3600,
        Scope:        authCode.Scope,
    }, nil
}
```

**SAML 2.0支持**：
```go
// SAML断言生成
type SAMLService struct {
    privateKey  *rsa.PrivateKey
    certificate *x509.Certificate
}

func (ss *SAMLService) GenerateAssertion(user *User, request *SAMLRequest) (*SAMLAssertion, error) {
    assertion := &SAMLAssertion{
        ID:           generateID(),
        IssueInstant: time.Now().UTC(),
        Issuer:       "https://sso.company.com",
        Subject: &SAMLSubject{
            NameID: user.Email,
            SubjectConfirmation: &SAMLSubjectConfirmation{
                Method: "urn:oasis:names:tc:SAML:2.0:cm:bearer",
                SubjectConfirmationData: &SAMLSubjectConfirmationData{
                    Recipient:    request.AssertionConsumerServiceURL,
                    NotOnOrAfter: time.Now().Add(5 * time.Minute),
                    InResponseTo: request.ID,
                },
            },
        },
        Conditions: &SAMLConditions{
            NotBefore:    time.Now().Add(-5 * time.Minute),
            NotOnOrAfter: time.Now().Add(5 * time.Minute),
            AudienceRestriction: []string{request.Issuer},
        },
        AttributeStatement: &SAMLAttributeStatement{
            Attributes: []SAMLAttribute{
                {Name: "email", Value: user.Email},
                {Name: "name", Value: user.Name},
                {Name: "department", Value: user.Department},
                {Name: "role", Value: strings.Join(user.Roles, ",")},
            },
        },
    }

    // 数字签名
    signedAssertion, err := ss.signAssertion(assertion)
    return signedAssertion, err
}
```

#### 3.2 会话管理

**分布式会话存储**：
```go
type SessionManager struct {
    redis   *redis.ClusterClient
    crypto  CryptoService
}

type Session struct {
    ID          string            `json:"id"`
    UserID      int64            `json:"user_id"`
    CreatedAt   time.Time        `json:"created_at"`
    LastAccess  time.Time        `json:"last_access"`
    ExpiresAt   time.Time        `json:"expires_at"`
    IPAddress   string           `json:"ip_address"`
    UserAgent   string           `json:"user_agent"`
    Attributes  map[string]interface{} `json:"attributes"`
    Applications []SessionApp    `json:"applications"`
}

type SessionApp struct {
    AppID       string    `json:"app_id"`
    AccessTime  time.Time `json:"access_time"`
    Permissions []string  `json:"permissions"`
}

func (sm *SessionManager) CreateSession(user *User, request *http.Request) (*Session, error) {
    sessionID := sm.generateSecureSessionID()

    session := &Session{
        ID:         sessionID,
        UserID:     user.ID,
        CreatedAt:  time.Now(),
        LastAccess: time.Now(),
        ExpiresAt:  time.Now().Add(24 * time.Hour),
        IPAddress:  getClientIP(request),
        UserAgent:  request.UserAgent(),
        Attributes: make(map[string]interface{}),
        Applications: make([]SessionApp, 0),
    }

    // 加密存储
    encryptedData, err := sm.crypto.Encrypt(session)
    if err != nil {
        return nil, err
    }

    // 存储到Redis
    key := fmt.Sprintf("session:%s", sessionID)
    err = sm.redis.Set(key, encryptedData, 24*time.Hour).Err()
    if err != nil {
        return nil, err
    }

    // 用户会话索引
    userSessionKey := fmt.Sprintf("user_sessions:%d", user.ID)
    sm.redis.SAdd(userSessionKey, sessionID)
    sm.redis.Expire(userSessionKey, 24*time.Hour)

    return session, nil
}

func (sm *SessionManager) ValidateSession(sessionID string) (*Session, error) {
    key := fmt.Sprintf("session:%s", sessionID)

    encryptedData, err := sm.redis.Get(key).Result()
    if err != nil {
        if err == redis.Nil {
            return nil, errors.New("session_not_found")
        }
        return nil, err
    }

    session := &Session{}
    err = sm.crypto.Decrypt(encryptedData, session)
    if err != nil {
        return nil, err
    }

    // 检查过期时间
    if time.Now().After(session.ExpiresAt) {
        sm.InvalidateSession(sessionID)
        return nil, errors.New("session_expired")
    }

    // 更新最后访问时间
    session.LastAccess = time.Now()
    sm.updateSession(session)

    return session, nil
}

// 单点登出 (SLO)
func (sm *SessionManager) InvalidateAllUserSessions(userID int64) error {
    userSessionKey := fmt.Sprintf("user_sessions:%d", userID)

    sessionIDs, err := sm.redis.SMembers(userSessionKey).Result()
    if err != nil {
        return err
    }

    // 批量删除会话
    pipe := sm.redis.Pipeline()
    for _, sessionID := range sessionIDs {
        pipe.Del(fmt.Sprintf("session:%s", sessionID))
    }
    pipe.Del(userSessionKey)

    _, err = pipe.Exec()
    return err
}
```

#### 3.3 权限控制模型

**RBAC权限模型**：
```go
// 权限模型定义
type Permission struct {
    ID       int64  `json:"id"`
    Resource string `json:"resource"` // 资源标识
    Action   string `json:"action"`   // 操作类型
    Effect   string `json:"effect"`   // allow/deny
}

type Role struct {
    ID          int64        `json:"id"`
    Name        string       `json:"name"`
    Description string       `json:"description"`
    Permissions []Permission `json:"permissions"`
}

type User struct {
    ID           int64  `json:"id"`
    Username     string `json:"username"`
    Email        string `json:"email"`
    Department   string `json:"department"`
    Roles        []Role `json:"roles"`
    DirectPermissions []Permission `json:"direct_permissions"`
}

// 权限验证服务
type AuthorizationService struct {
    userService UserServiceInterface
    policyCache *redis.Client
}

func (as *AuthorizationService) CheckPermission(userID int64, resource, action string) (bool, error) {
    // 1. 获取用户权限（包含角色权限和直接权限）
    permissions, err := as.getUserPermissions(userID)
    if err != nil {
        return false, err
    }

    // 2. 权限匹配
    for _, perm := range permissions {
        if as.matchPermission(perm, resource, action) {
            return perm.Effect == "allow", nil
        }
    }

    // 3. 默认拒绝
    return false, nil
}

func (as *AuthorizationService) matchPermission(perm Permission, resource, action string) bool {
    // 支持通配符匹配
    resourceMatch := as.wildcardMatch(perm.Resource, resource)
    actionMatch := as.wildcardMatch(perm.Action, action)

    return resourceMatch && actionMatch
}

func (as *AuthorizationService) wildcardMatch(pattern, text string) bool {
    // 实现通配符匹配逻辑
    // 例: "user:*" 匹配 "user:create", "user:update"
    // 例: "*:read" 匹配 "user:read", "order:read"

    if pattern == "*" {
        return true
    }

    if strings.Contains(pattern, "*") {
        // 使用filepath.Match或自定义匹配逻辑
        matched, _ := filepath.Match(pattern, text)
        return matched
    }

    return pattern == text
}

// 基于属性的访问控制 (ABAC)
type ABACPolicy struct {
    ID          string                 `json:"id"`
    Description string                 `json:"description"`
    Effect      string                 `json:"effect"` // allow/deny
    Conditions  []ABACCondition        `json:"conditions"`
}

type ABACCondition struct {
    Attribute string      `json:"attribute"` // user.department, resource.owner, env.time
    Operator  string      `json:"operator"`  // eq, ne, in, not_in, gt, lt
    Value     interface{} `json:"value"`
}

func (as *AuthorizationService) EvaluateABACPolicy(policy *ABACPolicy, context *AuthContext) (bool, error) {
    for _, condition := range policy.Conditions {
        result, err := as.evaluateCondition(condition, context)
        if err != nil || !result {
            return false, err
        }
    }

    return policy.Effect == "allow", nil
}

type AuthContext struct {
    User     *User                  `json:"user"`
    Resource map[string]interface{} `json:"resource"`
    Environment map[string]interface{} `json:"environment"`
}

func (as *AuthorizationService) evaluateCondition(condition ABACCondition, context *AuthContext) (bool, error) {
    // 获取属性值
    actualValue, err := as.getAttributeValue(condition.Attribute, context)
    if err != nil {
        return false, err
    }

    // 执行比较操作
    switch condition.Operator {
    case "eq":
        return actualValue == condition.Value, nil
    case "ne":
        return actualValue != condition.Value, nil
    case "in":
        slice, ok := condition.Value.([]interface{})
        if !ok {
            return false, errors.New("invalid_value_type")
        }
        for _, v := range slice {
            if actualValue == v {
                return true, nil
            }
        }
        return false, nil
    case "gt":
        // 数值比较
        return as.compareNumbers(actualValue, condition.Value, ">")
    case "lt":
        return as.compareNumbers(actualValue, condition.Value, "<")
    default:
        return false, errors.New("unsupported_operator")
    }
}
```

#### 3.4 多因素认证 (MFA)

**TOTP时间戳算法**：
```go
type MFAService struct {
    totpGenerator TOTPGenerator
    smsService    SMSService
    emailService  EmailService
}

// TOTP验证
func (mfa *MFAService) VerifyTOTP(userID int64, code string) (bool, error) {
    // 获取用户的TOTP密钥
    secret, err := mfa.getUserTOTPSecret(userID)
    if err != nil {
        return false, err
    }

    // 验证TOTP码（考虑时间窗口偏移）
    currentTime := time.Now().Unix() / 30

    for offset := -1; offset <= 1; offset++ {
        expectedCode := mfa.totpGenerator.Generate(secret, currentTime+int64(offset))
        if expectedCode == code {
            // 防重放攻击检查
            if !mfa.isCodeAlreadyUsed(userID, code, currentTime) {
                mfa.markCodeAsUsed(userID, code, currentTime)
                return true, nil
            }
        }
    }

    return false, nil
}

// 短信验证码
func (mfa *MFAService) SendSMSCode(userID int64, phone string) error {
    // 生成6位数字验证码
    code := fmt.Sprintf("%06d", rand.Intn(1000000))

    // 存储验证码（5分钟有效期）
    key := fmt.Sprintf("sms_code:%d", userID)
    err := mfa.redis.Set(key, code, 5*time.Minute).Err()
    if err != nil {
        return err
    }

    // 发送短信
    message := fmt.Sprintf("您的验证码是：%s，5分钟内有效。", code)
    return mfa.smsService.Send(phone, message)
}

func (mfa *MFAService) VerifySMSCode(userID int64, code string) (bool, error) {
    key := fmt.Sprintf("sms_code:%d", userID)

    storedCode, err := mfa.redis.Get(key).Result()
    if err != nil {
        if err == redis.Nil {
            return false, errors.New("code_expired")
        }
        return false, err
    }

    if storedCode == code {
        // 验证成功后删除验证码
        mfa.redis.Del(key)
        return true, nil
    }

    return false, nil
}

// 生物识别（指纹、人脸）
type BiometricService struct {
    aiService AIServiceInterface
}

func (bs *BiometricService) VerifyFingerprint(userID int64, fingerprintData []byte) (bool, error) {
    // 获取用户注册的指纹模板
    template, err := bs.getUserFingerprintTemplate(userID)
    if err != nil {
        return false, err
    }

    // 调用AI服务进行比对
    similarity, err := bs.aiService.CompareBiometric("fingerprint", template, fingerprintData)
    if err != nil {
        return false, err
    }

    // 相似度阈值判断（通常>85%认为匹配）
    return similarity > 0.85, nil
}
```

#### 3.5 外部系统集成

**LDAP/AD集成**：
```go
type LDAPService struct {
    conn   *ldap.Conn
    config *LDAPConfig
}

type LDAPConfig struct {
    Host         string
    Port         int
    BaseDN       string
    BindDN       string
    BindPassword string
    UserFilter   string
    GroupFilter  string
}

func (ls *LDAPService) AuthenticateUser(username, password string) (*User, error) {
    // 1. 绑定管理员账户
    err := ls.conn.Bind(ls.config.BindDN, ls.config.BindPassword)
    if err != nil {
        return nil, err
    }

    // 2. 搜索用户
    searchFilter := fmt.Sprintf(ls.config.UserFilter, username)
    searchRequest := ldap.NewSearchRequest(
        ls.config.BaseDN,
        ldap.ScopeWholeSubtree,
        ldap.NeverDerefAliases,
        0,
        0,
        false,
        searchFilter,
        []string{"cn", "mail", "department", "memberOf"},
        nil,
    )

    searchResult, err := ls.conn.Search(searchRequest)
    if err != nil {
        return nil, err
    }

    if len(searchResult.Entries) == 0 {
        return nil, errors.New("user_not_found")
    }

    userEntry := searchResult.Entries[0]

    // 3. 验证用户密码
    err = ls.conn.Bind(userEntry.DN, password)
    if err != nil {
        return nil, errors.New("invalid_credentials")
    }

    // 4. 构建用户对象
    user := &User{
        Username:   username,
        Email:      userEntry.GetAttributeValue("mail"),
        Name:       userEntry.GetAttributeValue("cn"),
        Department: userEntry.GetAttributeValue("department"),
    }

    // 5. 获取用户组信息
    groups := userEntry.GetAttributeValues("memberOf")
    user.Roles = ls.mapGroupsToRoles(groups)

    return user, nil
}

func (ls *LDAPService) SyncUsers() error {
    // 定期同步LDAP用户到本地数据库
    searchFilter := "(&(objectClass=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"

    searchRequest := ldap.NewSearchRequest(
        ls.config.BaseDN,
        ldap.ScopeWholeSubtree,
        ldap.NeverDerefAliases,
        0,
        0,
        false,
        searchFilter,
        []string{"sAMAccountName", "cn", "mail", "department", "whenChanged"},
        nil,
    )

    searchResult, err := ls.conn.Search(searchRequest)
    if err != nil {
        return err
    }

    for _, entry := range searchResult.Entries {
        user := &User{
            Username:    entry.GetAttributeValue("sAMAccountName"),
            Email:       entry.GetAttributeValue("mail"),
            Name:        entry.GetAttributeValue("cn"),
            Department:  entry.GetAttributeValue("department"),
        }

        // 增量同步：只同步有变化的用户
        lastModified, _ := time.Parse("20060102150405.0Z", entry.GetAttributeValue("whenChanged"))

        if ls.shouldSyncUser(user.Username, lastModified) {
            err := ls.upsertUser(user)
            if err != nil {
                log.Errorf("Failed to sync user %s: %v", user.Username, err)
            }
        }
    }

    return nil
}
```

### 4. 安全加固

#### 4.1 零信任架构

**设备信任评估**：
```go
type DeviceTrustService struct {
    deviceDB    DeviceDatabase
    riskEngine  RiskEngineInterface
}

type DeviceFingerprint struct {
    UserAgent    string `json:"user_agent"`
    Screen       string `json:"screen"`
    Timezone     string `json:"timezone"`
    Language     string `json:"language"`
    Plugins      string `json:"plugins"`
    Canvas       string `json:"canvas"`
    WebGL        string `json:"webgl"`
}

func (dts *DeviceTrustService) EvaluateDeviceTrust(fingerprint *DeviceFingerprint, ipAddress string) (*TrustScore, error) {
    score := &TrustScore{
        Overall: 0.0,
        Factors: make(map[string]float64),
    }

    // 1. 设备识别
    deviceID := dts.generateDeviceID(fingerprint)
    device, err := dts.deviceDB.GetDevice(deviceID)

    if err == nil && device != nil {
        // 已知设备，提高信任分数
        score.Factors["known_device"] = 0.3

        // 检查设备行为一致性
        if dts.isDeviceBehaviorConsistent(device, fingerprint) {
            score.Factors["behavior_consistency"] = 0.2
        }
    } else {
        // 新设备，降低信任分数
        score.Factors["unknown_device"] = -0.2
    }

    // 2. IP地理位置检查
    location, err := dts.getIPLocation(ipAddress)
    if err == nil {
        if dts.isLocationSuspicious(location) {
            score.Factors["suspicious_location"] = -0.3
        } else {
            score.Factors["normal_location"] = 0.1
        }
    }

    // 3. 威胁情报检查
    if dts.isIPInThreatList(ipAddress) {
        score.Factors["threat_ip"] = -0.5
    }

    // 4. 计算总分
    for _, factor := range score.Factors {
        score.Overall += factor
    }

    // 5. 归一化到[0,1]区间
    score.Overall = math.Max(0, math.Min(1, score.Overall+0.5))

    return score, nil
}

// 自适应认证
func (as *AuthService) AdaptiveAuthentication(user *User, request *AuthRequest) (*AuthResponse, error) {
    // 评估风险
    riskScore, err := as.riskEngine.EvaluateRisk(&RiskContext{
        User:      user,
        Device:    request.DeviceFingerprint,
        Location:  request.IPAddress,
        Time:      time.Now(),
        Behavior:  request.BehaviorData,
    })

    // 根据风险等级决定认证要求
    switch {
    case riskScore < 0.3:
        // 低风险：仅需密码
        return as.passwordAuth(user, request.Password)

    case riskScore < 0.7:
        // 中风险：密码 + 短信验证码
        if !as.mfaService.VerifySMSCode(user.ID, request.SMSCode) {
            return nil, errors.New("invalid_sms_code")
        }
        return as.passwordAuth(user, request.Password)

    default:
        // 高风险：密码 + 多因素认证 + 管理员审批
        if !as.verifyMultipleFactors(user, request) {
            return nil, errors.New("insufficient_authentication")
        }

        // 触发管理员审批流程
        approval, err := as.requestAdminApproval(user, riskScore)
        if err != nil || !approval.Approved {
            return nil, errors.New("admin_approval_required")
        }

        return as.generateAuthResponse(user)
    }
}
```

#### 4.2 数据保护

**敏感数据加密**：
```go
type CryptoService struct {
    masterKey     []byte
    encryptionKey []byte
    hmacKey       []byte
}

// AES-GCM加密
func (cs *CryptoService) EncryptSensitiveData(plaintext string) (string, error) {
    block, err := aes.NewCipher(cs.encryptionKey)
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    // 生成随机nonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    // 加密
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)

    // Base64编码
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (cs *CryptoService) DecryptSensitiveData(encrypted string) (string, error) {
    // Base64解码
    ciphertext, err := base64.StdEncoding.DecodeString(encrypted)
    if err != nil {
        return "", err
    }

    block, err := aes.NewCipher(cs.encryptionKey)
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return "", errors.New("ciphertext_too_short")
    }

    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}

// 密码哈希（使用Argon2id）
func (cs *CryptoService) HashPassword(password string) (string, error) {
    salt := make([]byte, 32)
    if _, err := io.ReadFull(rand.Reader, salt); err != nil {
        return "", err
    }

    hash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)

    encoded := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
        argon2.Version, 64*1024, 1, 4,
        base64.RawStdEncoding.EncodeToString(salt),
        base64.RawStdEncoding.EncodeToString(hash))

    return encoded, nil
}
```

### 5. 审计与合规

#### 5.1 审计日志

**全链路审计**：
```go
type AuditService struct {
    logger    *logrus.Logger
    es        *elasticsearch.Client
    kafka     *kafka.Writer
}

type AuditEvent struct {
    ID          string                 `json:"id"`
    Timestamp   time.Time             `json:"timestamp"`
    EventType   string                `json:"event_type"`
    UserID      int64                 `json:"user_id,omitempty"`
    SessionID   string                `json:"session_id,omitempty"`
    ClientID    string                `json:"client_id,omitempty"`
    IPAddress   string                `json:"ip_address"`
    UserAgent   string                `json:"user_agent"`
    Resource    string                `json:"resource,omitempty"`
    Action      string                `json:"action,omitempty"`
    Result      string                `json:"result"` // success/failure
    ErrorCode   string                `json:"error_code,omitempty"`
    Details     map[string]interface{} `json:"details,omitempty"`
    RiskScore   float64               `json:"risk_score,omitempty"`
}

func (as *AuditService) LogAuthEvent(event *AuditEvent) error {
    // 1. 标准化事件数据
    event.ID = generateUUID()
    event.Timestamp = time.Now().UTC()

    // 2. 敏感数据脱敏
    as.sanitizeEvent(event)

    // 3. 实时写入Kafka（用于实时监控）
    eventData, _ := json.Marshal(event)
    err := as.kafka.WriteMessages(context.Background(), kafka.Message{
        Key:   []byte(event.EventType),
        Value: eventData,
    })
    if err != nil {
        log.Errorf("Failed to write audit event to Kafka: %v", err)
    }

    // 4. 批量写入Elasticsearch（用于历史查询）
    go func() {
        as.writeToES(event)
    }()

    // 5. 关键事件实时告警
    if as.isCriticalEvent(event) {
        as.sendAlert(event)
    }

    return nil
}

func (as *AuditService) sanitizeEvent(event *AuditEvent) {
    // 移除或掩码敏感字段
    if event.Details != nil {
        if password, exists := event.Details["password"]; exists {
            event.Details["password"] = as.maskSensitiveData(password.(string))
        }

        if token, exists := event.Details["access_token"]; exists {
            event.Details["access_token"] = as.maskSensitiveData(token.(string))
        }
    }
}

func (as *AuditService) maskSensitiveData(data string) string {
    if len(data) <= 8 {
        return "****"
    }
    return data[:4] + "****" + data[len(data)-4:]
}

// 审计查询接口
func (as *AuditService) QueryAuditLogs(query *AuditQuery) (*AuditResult, error) {
    esQuery := map[string]interface{}{
        "query": map[string]interface{}{
            "bool": map[string]interface{}{
                "must": as.buildESQuery(query),
            },
        },
        "sort": []map[string]interface{}{
            {"timestamp": map[string]string{"order": "desc"}},
        },
        "from": query.Offset,
        "size": query.Limit,
    }

    response, err := as.es.Search(
        as.es.Search.WithIndex("audit-logs-*"),
        as.es.Search.WithBody(esutil.NewJSONReader(esQuery)),
    )

    if err != nil {
        return nil, err
    }
    defer response.Body.Close()

    return as.parseESResponse(response)
}
```

#### 5.2 合规报告

**自动化合规检查**：
```go
type ComplianceService struct {
    auditService *AuditService
    policyEngine PolicyEngineInterface
}

type ComplianceReport struct {
    Period      TimePeriod            `json:"period"`
    Checks      []ComplianceCheck     `json:"checks"`
    Summary     ComplianceSummary     `json:"summary"`
    GeneratedAt time.Time            `json:"generated_at"`
}

type ComplianceCheck struct {
    Name        string  `json:"name"`
    Description string  `json:"description"`
    Standard    string  `json:"standard"` // SOX, GDPR, SOC2
    Status      string  `json:"status"`   // pass, fail, warning
    Score       float64 `json:"score"`
    Evidence    []string `json:"evidence"`
    Remediation string  `json:"remediation,omitempty"`
}

func (cs *ComplianceService) GenerateComplianceReport(period TimePeriod, standards []string) (*ComplianceReport, error) {
    report := &ComplianceReport{
        Period:      period,
        Checks:      make([]ComplianceCheck, 0),
        GeneratedAt: time.Now(),
    }

    for _, standard := range standards {
        checks, err := cs.runComplianceChecks(standard, period)
        if err != nil {
            return nil, err
        }
        report.Checks = append(report.Checks, checks...)
    }

    report.Summary = cs.calculateSummary(report.Checks)
    return report, nil
}

func (cs *ComplianceService) runComplianceChecks(standard string, period TimePeriod) ([]ComplianceCheck, error) {
    var checks []ComplianceCheck

    switch standard {
    case "SOX":
        checks = append(checks, cs.checkSOXCompliance(period)...)
    case "GDPR":
        checks = append(checks, cs.checkGDPRCompliance(period)...)
    case "SOC2":
        checks = append(checks, cs.checkSOC2Compliance(period)...)
    }

    return checks, nil
}

func (cs *ComplianceService) checkSOXCompliance(period TimePeriod) []ComplianceCheck {
    checks := []ComplianceCheck{
        {
            Name:        "User Access Review",
            Description: "Verify all user access has been reviewed within the required timeframe",
            Standard:    "SOX",
        },
        {
            Name:        "Privileged Access Monitoring",
            Description: "Ensure all privileged access is properly monitored and logged",
            Standard:    "SOX",
        },
        {
            Name:        "Access Segregation",
            Description: "Verify proper segregation of duties for critical functions",
            Standard:    "SOX",
        },
    }

    for i := range checks {
        // 执行具体的合规检查逻辑
        checks[i].Status, checks[i].Score, checks[i].Evidence = cs.performCheck(&checks[i], period)
    }

    return checks
}
```

### 6. 高可用部署

#### 6.1 容器化部署

**Kubernetes部署配置**：
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sso-auth-service
  namespace: sso-system
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: sso-auth-service
  template:
    metadata:
      labels:
        app: sso-auth-service
    spec:
      containers:
      - name: auth-service
        image: company.com/sso-auth:v1.2.3
        ports:
        - containerPort: 8080
        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: host
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: sso-config
              key: redis-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
        - name: cert-volume
          mountPath: /etc/certs
          readOnly: true
      volumes:
      - name: config-volume
        configMap:
          name: sso-config
      - name: cert-volume
        secret:
          secretName: tls-certificates
---
apiVersion: v1
kind: Service
metadata:
  name: sso-auth-service
  namespace: sso-system
spec:
  selector:
    app: sso-auth-service
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: sso-ingress
  namespace: sso-system
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  tls:
  - hosts:
    - sso.company.com
    secretName: sso-tls
  rules:
  - host: sso.company.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: sso-auth-service
            port:
              number: 80
```

#### 6.2 监控告警

**Prometheus监控配置**：
```go
// 监控指标定义
var (
    authRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "sso_auth_requests_total",
            Help: "Total number of authentication requests",
        },
        []string{"method", "status", "client_id"},
    )

    authDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "sso_auth_duration_seconds",
            Help: "Authentication request duration",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method"},
    )

    activeSessions = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "sso_active_sessions",
            Help: "Number of active user sessions",
        },
    )

    failedLoginAttempts = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "sso_failed_login_attempts_total",
            Help: "Total number of failed login attempts",
        },
        []string{"reason"},
    )
)

// 监控中间件
func PrometheusMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        // 包装ResponseWriter以捕获状态码
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}

        next.ServeHTTP(wrapped, r)

        duration := time.Since(start)

        // 记录指标
        authRequestsTotal.WithLabelValues(
            r.Method,
            fmt.Sprintf("%d", wrapped.statusCode),
            getClientID(r),
        ).Inc()

        authDuration.WithLabelValues(r.Method).Observe(duration.Seconds())
    })
}
```

### 7. 总结

企业级SSO平台的成功关键因素：

**架构设计**：
1. **标准协议**：采用OAuth2.0/OIDC/SAML标准
2. **微服务化**：服务拆分，独立扩展
3. **多租户**：支持多组织隔离
4. **高可用**：多地部署，自动故障切换

**安全保障**：
1. **零信任**：持续验证，最小权限
2. **多因素认证**：提高安全等级
3. **数据加密**：敏感数据全程保护
4. **审计合规**：满足法规要求

**用户体验**：
1. **单点登录**：一次登录，全平台通行
2. **无感知认证**：智能风险评估
3. **快速响应**：毫秒级身份验证
4. **移动友好**：支持各种终端设备

这套SSO平台架构可以支撑百万用户规模，满足企业级安全和合规要求。
