---
title: 设计一个多云管理平台
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: multi-cloud-management-platform-design
ref:
---

## 核心要点

**关键能力**: 统一资源管理 + 跨云调度编排 + 成本优化 + 安全合规

**技术难点**: 多云API适配、资源模型抽象、数据一致性、网络互通、权限统一

**核心价值**: 避免厂商锁定、成本最优化、灾备高可用、合规性管理

---

## 详细回答

### 一、系统整体架构

多云管理平台需要在不同云厂商(AWS/阿里云/腾讯云/华为云等)之上构建统一的抽象层,提供一致的管理体验。

```
┌────────────────────────────────────────────────────────────┐
│                     管理控制台层                            │
│  Web Console  │  CLI工具  │  OpenAPI  │  Terraform Provider │
└───────────────────────────┬────────────────────────────────┘
                            │
┌───────────────────────────▼────────────────────────────────┐
│                      应用服务层                             │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│ │资源管理  │ │成本分析  │ │监控告警  │ │安全审计  │      │
│ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│ │编排引擎  │ │策略引擎  │ │工单流程  │ │合规检查  │      │
│ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
└───────────────────────────┬────────────────────────────────┘
                            │
┌───────────────────────────▼────────────────────────────────┐
│                    抽象与适配层                             │
│ ┌────────────────────────────────────────────────────┐    │
│ │      统一资源模型 (CRD: Compute/Network/Storage)    │    │
│ └────────────────────────────────────────────────────┘    │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│ │AWS Adapter│ │Ali Adapter│ │Tencent  │ │Huawei   │      │
│ │          │ │          │ │Adapter  │ │Adapter  │      │
│ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
└───────────────────────────┬────────────────────────────────┘
                            │
┌───────────────────────────▼────────────────────────────────┐
│                      云厂商层                               │
│   AWS        │   阿里云    │   腾讯云    │   华为云         │
│  EC2/S3/RDS  │ ECS/OSS/RDS│ CVM/COS/TencentDB│ ECS/OBS     │
└────────────────────────────────────────────────────────────┘
```

### 二、核心模块设计

#### 1. 统一资源模型与抽象层

**资源抽象定义**

```go
// 统一资源接口
type CloudResource interface {
    GetID() string
    GetName() string
    GetType() ResourceType
    GetProvider() Provider
    GetRegion() string
    GetTags() map[string]string
    GetStatus() ResourceStatus
    GetCreatedAt() time.Time
}

// 资源类型枚举
type ResourceType string

const (
    ResourceTypeCompute  ResourceType = "compute"   // 计算实例
    ResourceTypeStorage  ResourceType = "storage"   // 存储
    ResourceTypeNetwork  ResourceType = "network"   // 网络
    ResourceTypeDatabase ResourceType = "database"  // 数据库
    ResourceTypeLoadBalancer ResourceType = "loadbalancer"
    ResourceTypeContainer ResourceType = "container"  // 容器/K8s
)

// 云厂商枚举
type Provider string

const (
    ProviderAWS     Provider = "aws"
    ProviderAliyun  Provider = "aliyun"
    ProviderTencent Provider = "tencent"
    ProviderHuawei  Provider = "huawei"
    ProviderAzure   Provider = "azure"
)

// 统一计算资源模型
type ComputeInstance struct {
    ID           string
    Name         string
    Provider     Provider
    Region       string
    Zone         string
    InstanceType string            // 实例规格
    CPU          int               // vCPU核数
    Memory       int               // 内存(MB)
    ImageID      string
    VPCID        string
    SubnetID     string
    PublicIP     string
    PrivateIP    string
    Status       ResourceStatus    // running/stopped/terminated
    Tags         map[string]string
    CreatedAt    time.Time

    // 原始厂商数据(用于透传特定字段)
    RawData      interface{}
}

type ResourceStatus string

const (
    StatusPending    ResourceStatus = "pending"
    StatusRunning    ResourceStatus = "running"
    StatusStopped    ResourceStatus = "stopped"
    StatusDeleted    ResourceStatus = "deleted"
    StatusError      ResourceStatus = "error"
)
```

**多云适配器接口**

```go
// 云厂商适配器接口
type CloudAdapter interface {
    // 认证与初始化
    Initialize(config *ProviderConfig) error
    ValidateCredentials() error

    // 计算资源操作
    ListInstances(ctx context.Context, req *ListInstancesRequest) ([]*ComputeInstance, error)
    GetInstance(ctx context.Context, instanceID string) (*ComputeInstance, error)
    CreateInstance(ctx context.Context, req *CreateInstanceRequest) (*ComputeInstance, error)
    StartInstance(ctx context.Context, instanceID string) error
    StopInstance(ctx context.Context, instanceID string) error
    DeleteInstance(ctx context.Context, instanceID string) error

    // 存储资源操作
    ListVolumes(ctx context.Context, req *ListVolumesRequest) ([]*Volume, error)
    CreateVolume(ctx context.Context, req *CreateVolumeRequest) (*Volume, error)
    AttachVolume(ctx context.Context, volumeID, instanceID string) error

    // 网络资源操作
    ListVPCs(ctx context.Context) ([]*VPC, error)
    CreateVPC(ctx context.Context, req *CreateVPCRequest) (*VPC, error)
    CreateSecurityGroup(ctx context.Context, req *CreateSGRequest) (*SecurityGroup, error)

    // 监控与日志
    GetMetrics(ctx context.Context, req *MetricsRequest) (*MetricsResponse, error)
    GetLogs(ctx context.Context, req *LogsRequest) (*LogsResponse, error)

    // 成本查询
    GetCostReport(ctx context.Context, req *CostReportRequest) (*CostReport, error)
}

// AWS适配器实现
type AWSAdapter struct {
    ec2Client *ec2.Client
    s3Client  *s3.Client
    rdsClient *rds.Client
    config    *ProviderConfig
}

func (a *AWSAdapter) ListInstances(ctx context.Context, req *ListInstancesRequest) ([]*ComputeInstance, error) {
    // 调用AWS SDK
    result, err := a.ec2Client.DescribeInstances(ctx, &ec2.DescribeInstancesInput{
        Filters: a.buildFilters(req.Filters),
    })
    if err != nil {
        return nil, fmt.Errorf("aws describe instances: %w", err)
    }

    // 转换为统一模型
    instances := []*ComputeInstance{}
    for _, reservation := range result.Reservations {
        for _, inst := range reservation.Instances {
            instances = append(instances, a.convertToComputeInstance(inst))
        }
    }

    return instances, nil
}

func (a *AWSAdapter) convertToComputeInstance(awsInst types.Instance) *ComputeInstance {
    return &ComputeInstance{
        ID:           aws.ToString(awsInst.InstanceId),
        Name:         a.getNameTag(awsInst.Tags),
        Provider:     ProviderAWS,
        Region:       a.config.Region,
        Zone:         aws.ToString(awsInst.Placement.AvailabilityZone),
        InstanceType: string(awsInst.InstanceType),
        CPU:          a.getInstanceCPU(awsInst.InstanceType),
        Memory:       a.getInstanceMemory(awsInst.InstanceType),
        ImageID:      aws.ToString(awsInst.ImageId),
        PublicIP:     aws.ToString(awsInst.PublicIpAddress),
        PrivateIP:    aws.ToString(awsInst.PrivateIpAddress),
        Status:       a.convertInstanceState(awsInst.State),
        Tags:         a.convertTags(awsInst.Tags),
        CreatedAt:    aws.ToTime(awsInst.LaunchTime),
        RawData:      awsInst,  // 保留原始数据
    }
}

// 阿里云适配器实现
type AliyunAdapter struct {
    ecsClient *ecs.Client
    ossClient *oss.Client
    config    *ProviderConfig
}

func (a *AliyunAdapter) ListInstances(ctx context.Context, req *ListInstancesRequest) ([]*ComputeInstance, error) {
    request := ecs.CreateDescribeInstancesRequest()
    request.RegionId = a.config.Region
    request.PageSize = requests.NewInteger(100)

    response, err := a.ecsClient.DescribeInstances(request)
    if err != nil {
        return nil, fmt.Errorf("aliyun describe instances: %w", err)
    }

    instances := make([]*ComputeInstance, 0, len(response.Instances.Instance))
    for _, inst := range response.Instances.Instance {
        instances = append(instances, a.convertToComputeInstance(&inst))
    }

    return instances, nil
}

func (a *AliyunAdapter) convertToComputeInstance(aliInst *ecs.Instance) *ComputeInstance {
    return &ComputeInstance{
        ID:           aliInst.InstanceId,
        Name:         aliInst.InstanceName,
        Provider:     ProviderAliyun,
        Region:       aliInst.RegionId,
        Zone:         aliInst.ZoneId,
        InstanceType: aliInst.InstanceType,
        CPU:          aliInst.Cpu,
        Memory:       aliInst.Memory,
        ImageID:      aliInst.ImageId,
        VPCID:        aliInst.VpcAttributes.VpcId,
        PublicIP:     a.getPublicIP(aliInst),
        PrivateIP:    a.getPrivateIP(aliInst),
        Status:       a.convertInstanceStatus(aliInst.Status),
        Tags:         a.convertTags(aliInst.Tags.Tag),
        CreatedAt:    a.parseTime(aliInst.CreationTime),
        RawData:      aliInst,
    }
}
```

#### 2. 资源管理服务

**统一资源管理器**

```go
type ResourceManager struct {
    adapters map[Provider]CloudAdapter
    store    ResourceStore       // 资源元数据存储
    cache    *cache.Cache        // 资源缓存
    eventBus *EventBus           // 事件总线
}

func NewResourceManager(store ResourceStore) *ResourceManager {
    return &ResourceManager{
        adapters: make(map[Provider]CloudAdapter),
        store:    store,
        cache:    cache.New(5*time.Minute, 10*time.Minute),
        eventBus: NewEventBus(),
    }
}

// 注册云厂商适配器
func (rm *ResourceManager) RegisterAdapter(provider Provider, adapter CloudAdapter) {
    rm.adapters[provider] = adapter
}

// 跨云查询资源
func (rm *ResourceManager) ListAllInstances(ctx context.Context) ([]*ComputeInstance, error) {
    var wg sync.WaitGroup
    resultChan := make(chan []*ComputeInstance, len(rm.adapters))
    errorChan := make(chan error, len(rm.adapters))

    // 并发查询所有云厂商
    for provider, adapter := range rm.adapters {
        wg.Add(1)
        go func(p Provider, a CloudAdapter) {
            defer wg.Done()

            instances, err := a.ListInstances(ctx, &ListInstancesRequest{})
            if err != nil {
                errorChan <- fmt.Errorf("%s: %w", p, err)
                return
            }
            resultChan <- instances
        }(provider, adapter)
    }

    // 等待所有查询完成
    go func() {
        wg.Wait()
        close(resultChan)
        close(errorChan)
    }()

    // 收集结果
    allInstances := []*ComputeInstance{}
    for instances := range resultChan {
        allInstances = append(allInstances, instances...)
    }

    // 检查错误
    errors := []error{}
    for err := range errorChan {
        errors = append(errors, err)
    }
    if len(errors) > 0 {
        return allInstances, fmt.Errorf("partial failure: %v", errors)
    }

    // 同步到本地存储
    rm.syncToStore(ctx, allInstances)

    return allInstances, nil
}

// 创建资源(支持云选择策略)
func (rm *ResourceManager) CreateInstance(ctx context.Context, req *CreateInstanceRequest) (*ComputeInstance, error) {
    // 1. 如果未指定云厂商,执行智能选择
    if req.Provider == "" {
        selectedProvider, err := rm.selectOptimalProvider(ctx, req)
        if err != nil {
            return nil, err
        }
        req.Provider = selectedProvider
    }

    // 2. 获取适配器
    adapter, ok := rm.adapters[req.Provider]
    if !ok {
        return nil, fmt.Errorf("unsupported provider: %s", req.Provider)
    }

    // 3. 调用云厂商API创建
    instance, err := adapter.CreateInstance(ctx, req)
    if err != nil {
        return nil, err
    }

    // 4. 记录元数据
    if err := rm.store.SaveResource(ctx, instance); err != nil {
        log.Errorf("failed to save resource metadata: %v", err)
    }

    // 5. 发布事件
    rm.eventBus.Publish(&ResourceEvent{
        Type:     EventTypeResourceCreated,
        Resource: instance,
    })

    return instance, nil
}

// 智能选择云厂商
func (rm *ResourceManager) selectOptimalProvider(ctx context.Context, req *CreateInstanceRequest) (Provider, error) {
    scores := make(map[Provider]float64)

    for provider, adapter := range rm.adapters {
        score := 0.0

        // 1. 成本评估(权重40%)
        cost, err := adapter.EstimateCost(ctx, req)
        if err == nil {
            score += (1.0 - cost/maxCost) * 0.4
        }

        // 2. 区域就近性(权重30%)
        latency := rm.getLatency(provider, req.Region)
        score += (1.0 - latency/maxLatency) * 0.3

        // 3. 资源可用性(权重20%)
        availability := rm.checkAvailability(provider, req.InstanceType)
        score += availability * 0.2

        // 4. 合规要求(权重10%)
        compliance := rm.checkCompliance(provider, req.ComplianceRequirements)
        score += compliance * 0.1

        scores[provider] = score
    }

    // 选择得分最高的厂商
    var bestProvider Provider
    maxScore := 0.0
    for provider, score := range scores {
        if score > maxScore {
            maxScore = score
            bestProvider = provider
        }
    }

    return bestProvider, nil
}
```

#### 3. 成本分析与优化

**成本采集与分析**

```go
type CostAnalyzer struct {
    adapters      map[Provider]CloudAdapter
    costStore     CostStore
    pricingCache  *PricingCache
}

// 成本报告
type CostReport struct {
    StartDate     time.Time
    EndDate       time.Time
    TotalCost     float64
    Currency      string
    ByProvider    map[Provider]float64       // 按云厂商分组
    ByService     map[string]float64         // 按服务类型分组
    ByProject     map[string]float64         // 按项目分组
    ByRegion      map[string]float64         // 按地域分组
    Recommendations []CostOptimizationAdvice  // 优化建议
}

type CostOptimizationAdvice struct {
    Type           string     // idle/rightsizing/reserved_instance/spot
    ResourceID     string
    CurrentCost    float64
    PotentialSavings float64
    Description    string
    ActionItems    []string
}

func (ca *CostAnalyzer) GenerateCostReport(ctx context.Context, startDate, endDate time.Time) (*CostReport, error) {
    report := &CostReport{
        StartDate:  startDate,
        EndDate:    endDate,
        Currency:   "USD",
        ByProvider: make(map[Provider]float64),
        ByService:  make(map[string]float64),
        ByProject:  make(map[string]float64),
        ByRegion:   make(map[string]float64),
    }

    // 并发查询各云厂商成本
    var wg sync.WaitGroup
    var mu sync.Mutex

    for provider, adapter := range ca.adapters {
        wg.Add(1)
        go func(p Provider, a CloudAdapter) {
            defer wg.Done()

            costResp, err := a.GetCostReport(ctx, &CostReportRequest{
                StartDate: startDate,
                EndDate:   endDate,
            })
            if err != nil {
                log.Errorf("failed to get cost from %s: %v", p, err)
                return
            }

            mu.Lock()
            defer mu.Unlock()

            report.TotalCost += costResp.TotalCost
            report.ByProvider[p] = costResp.TotalCost

            // 合并其他维度数据
            for service, cost := range costResp.ByService {
                report.ByService[service] += cost
            }
            for project, cost := range costResp.ByProject {
                report.ByProject[project] += cost
            }
            for region, cost := range costResp.ByRegion {
                report.ByRegion[region] += cost
            }
        }(provider, adapter)
    }

    wg.Wait()

    // 生成优化建议
    report.Recommendations = ca.generateOptimizationAdvice(ctx, report)

    return report, nil
}

// 生成优化建议
func (ca *CostAnalyzer) generateOptimizationAdvice(ctx context.Context, report *CostReport) []CostOptimizationAdvice {
    advice := []CostOptimizationAdvice{}

    // 1. 检测空闲资源
    idleResources := ca.detectIdleResources(ctx)
    for _, resource := range idleResources {
        advice = append(advice, CostOptimizationAdvice{
            Type:             "idle",
            ResourceID:       resource.ID,
            CurrentCost:      resource.MonthlyCost,
            PotentialSavings: resource.MonthlyCost * 0.9,
            Description:      fmt.Sprintf("资源 %s CPU利用率<5%% 超过7天", resource.ID),
            ActionItems:      []string{"停止或删除该资源", "迁移工作负载到其他实例"},
        })
    }

    // 2. 实例规格优化(Rightsizing)
    oversizedInstances := ca.detectOversizedInstances(ctx)
    for _, instance := range oversizedInstances {
        recommendedType := ca.recommendInstanceType(instance)
        savings := instance.CurrentCost - ca.estimateCost(recommendedType)

        advice = append(advice, CostOptimizationAdvice{
            Type:             "rightsizing",
            ResourceID:       instance.ID,
            CurrentCost:      instance.CurrentCost,
            PotentialSavings: savings,
            Description:      fmt.Sprintf("建议从 %s 降配到 %s", instance.CurrentType, recommendedType),
            ActionItems:      []string{fmt.Sprintf("修改实例规格为 %s", recommendedType)},
        })
    }

    // 3. 预留实例建议
    riOpportunities := ca.detectReservedInstanceOpportunities(ctx)
    for _, opp := range riOpportunities {
        advice = append(advice, CostOptimizationAdvice{
            Type:             "reserved_instance",
            ResourceID:       opp.InstanceID,
            CurrentCost:      opp.OnDemandCost,
            PotentialSavings: opp.OnDemandCost - opp.ReservedCost,
            Description:      "该实例运行稳定,建议购买预留实例",
            ActionItems:      []string{"购买1年期预留实例,可节省30%"},
        })
    }

    // 4. Spot实例建议
    spotOpportunities := ca.detectSpotOpportunities(ctx)
    for _, opp := range spotOpportunities {
        advice = append(advice, CostOptimizationAdvice{
            Type:             "spot",
            ResourceID:       opp.InstanceID,
            CurrentCost:      opp.OnDemandCost,
            PotentialSavings: opp.OnDemandCost * 0.7,  // Spot可节省70%
            Description:      "该工作负载可容忍中断,建议使用Spot实例",
            ActionItems:      []string{"迁移到Spot实例", "配置自动故障转移"},
        })
    }

    return advice
}
```

#### 4. 跨云网络互通

**VPN网关与专线管理**

```go
type NetworkManager struct {
    adapters   map[Provider]CloudAdapter
    tunnelMgr  *VPNTunnelManager
    routeMgr   *RouteManager
}

// VPN隧道配置
type VPNTunnel struct {
    ID          string
    Name        string
    Source      NetworkEndpoint  // 源端
    Destination NetworkEndpoint  // 目的端
    Status      TunnelStatus
    BandwidthMbps int
    Encryption  EncryptionConfig
}

type NetworkEndpoint struct {
    Provider  Provider
    Region    string
    VPCID     string
    Gateway   string
    CIDR      string
}

func (nm *NetworkManager) CreateCrossCloudVPN(ctx context.Context, req *CreateVPNRequest) (*VPNTunnel, error) {
    // 1. 在源云创建VPN网关
    sourceAdapter := nm.adapters[req.Source.Provider]
    sourceGateway, err := sourceAdapter.CreateVPNGateway(ctx, &CreateVPNGatewayRequest{
        VPCID: req.Source.VPCID,
        Name:  req.Name + "-source",
    })
    if err != nil {
        return nil, fmt.Errorf("create source gateway: %w", err)
    }

    // 2. 在目标云创建VPN网关
    destAdapter := nm.adapters[req.Destination.Provider]
    destGateway, err := destAdapter.CreateVPNGateway(ctx, &CreateVPNGatewayRequest{
        VPCID: req.Destination.VPCID,
        Name:  req.Name + "-dest",
    })
    if err != nil {
        return nil, fmt.Errorf("create dest gateway: %w", err)
    }

    // 3. 建立VPN隧道(双向)
    tunnel1, err := sourceAdapter.CreateVPNConnection(ctx, &CreateVPNConnectionRequest{
        LocalGatewayID:  sourceGateway.ID,
        RemoteGatewayIP: destGateway.PublicIP,
        RemoteCIDR:      req.Destination.CIDR,
        PSK:             generatePSK(),
    })
    if err != nil {
        return nil, err
    }

    tunnel2, err := destAdapter.CreateVPNConnection(ctx, &CreateVPNConnectionRequest{
        LocalGatewayID:  destGateway.ID,
        RemoteGatewayIP: sourceGateway.PublicIP,
        RemoteCIDR:      req.Source.CIDR,
        PSK:             tunnel1.PSK,  // 使用相同PSK
    })
    if err != nil {
        return nil, err
    }

    // 4. 配置路由
    if err := nm.configureRoutes(ctx, req.Source, req.Destination); err != nil {
        return nil, err
    }

    return &VPNTunnel{
        ID:          generateID(),
        Name:        req.Name,
        Source:      req.Source,
        Destination: req.Destination,
        Status:      TunnelStatusActive,
    }, nil
}

// 配置跨云路由
func (nm *NetworkManager) configureRoutes(ctx context.Context, source, dest NetworkEndpoint) error {
    // 在源VPC添加到目标CIDR的路由
    sourceAdapter := nm.adapters[source.Provider]
    err := sourceAdapter.CreateRoute(ctx, &CreateRouteRequest{
        VPCID:            source.VPCID,
        DestinationCIDR:  dest.CIDR,
        NextHop:          source.Gateway,
        RouteTableID:     "", // 默认路由表
    })
    if err != nil {
        return err
    }

    // 在目标VPC添加到源CIDR的路由
    destAdapter := nm.adapters[dest.Provider]
    err = destAdapter.CreateRoute(ctx, &CreateRouteRequest{
        VPCID:            dest.VPCID,
        DestinationCIDR:  source.CIDR,
        NextHop:          dest.Gateway,
        RouteTableID:     "",
    })

    return err
}
```

#### 5. 统一监控告警

**多云监控聚合**

```go
type MonitoringService struct {
    adapters     map[Provider]CloudAdapter
    metricsStore *TimeSeriesDB       // 时序数据库(Prometheus/InfluxDB)
    alertMgr     *AlertManager
}

type Metric struct {
    Name       string
    Labels     map[string]string  // resource_id, provider, region等
    Timestamp  time.Time
    Value      float64
}

func (ms *MonitoringService) CollectMetrics(ctx context.Context) error {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            for provider, adapter := range ms.adapters {
                go func(p Provider, a CloudAdapter) {
                    metrics, err := a.GetMetrics(ctx, &MetricsRequest{
                        MetricNames: []string{"CPUUtilization", "MemoryUtilization", "NetworkIn", "NetworkOut"},
                        Period:      60,  // 1分钟
                    })
                    if err != nil {
                        log.Errorf("collect metrics from %s: %v", p, err)
                        return
                    }

                    // 写入时序数据库
                    for _, m := range metrics.Metrics {
                        ms.metricsStore.Write(m)
                    }
                }(provider, adapter)
            }
        case <-ctx.Done():
            return nil
        }
    }
}

// 统一告警规则
type AlertRule struct {
    ID          string
    Name        string
    Condition   string          // PromQL表达式
    Threshold   float64
    Duration    time.Duration   // 持续时间
    Severity    string          // critical/warning/info
    Providers   []Provider      // 适用的云厂商
    NotifyChannels []string     // 通知渠道
}

func (ms *MonitoringService) EvaluateAlertRules(ctx context.Context) {
    rules := ms.alertMgr.GetRules()

    for _, rule := range rules {
        // 查询指标数据
        query := rule.Condition
        result, err := ms.metricsStore.Query(query)
        if err != nil {
            log.Errorf("query metrics: %v", err)
            continue
        }

        // 判断是否触发告警
        for _, series := range result {
            if series.Value > rule.Threshold {
                alert := &Alert{
                    RuleID:    rule.ID,
                    RuleName:  rule.Name,
                    Resource:  series.Labels["resource_id"],
                    Provider:  Provider(series.Labels["provider"]),
                    Value:     series.Value,
                    Threshold: rule.Threshold,
                    Severity:  rule.Severity,
                    FiredAt:   time.Now(),
                }

                ms.alertMgr.Fire(alert)
            }
        }
    }
}
```

### 三、高级特性

#### 1. 基于策略的自动化

```go
type PolicyEngine struct {
    policies []Policy
    executor *PolicyExecutor
}

type Policy struct {
    ID          string
    Name        string
    Type        PolicyType  // cost/security/compliance/performance
    Conditions  []Condition
    Actions     []Action
    Enabled     bool
}

type Condition struct {
    Field    string  // cost/cpu_usage/tag等
    Operator string  // gt/lt/eq/contains
    Value    interface{}
}

type Action struct {
    Type   ActionType  // stop_instance/send_alert/create_snapshot
    Params map[string]interface{}
}

// 示例:成本控制策略
func exampleCostControlPolicy() *Policy {
    return &Policy{
        Name: "每月成本超限告警",
        Type: PolicyTypeCost,
        Conditions: []Condition{
            {
                Field:    "monthly_cost",
                Operator: "gt",
                Value:    10000.0,
            },
        },
        Actions: []Action{
            {
                Type: ActionTypeSendAlert,
                Params: map[string]interface{}{
                    "channel":  "email",
                    "to":       "finance@company.com",
                    "severity": "warning",
                },
            },
        },
    }
}

// 示例:空闲资源清理策略
func exampleIdleResourcePolicy() *Policy {
    return &Policy{
        Name: "自动停止空闲实例",
        Type: PolicyTypeCost,
        Conditions: []Condition{
            {
                Field:    "cpu_usage_avg_7d",
                Operator: "lt",
                Value:    5.0,
            },
            {
                Field:    "status",
                Operator: "eq",
                Value:    "running",
            },
        },
        Actions: []Action{
            {
                Type:   ActionTypeSendAlert,
                Params: map[string]interface{}{"message": "即将停止空闲实例"},
            },
            {
                Type:   ActionTypeStopInstance,
                Params: map[string]interface{}{"delay": "24h"},  // 24小时后执行
            },
        },
    }
}
```

#### 2. 灾备与多活

```go
type DisasterRecoveryManager struct {
    resourceMgr *ResourceManager
    networkMgr  *NetworkManager
}

// 跨云容灾配置
type DRConfig struct {
    PrimaryProvider   Provider
    PrimaryRegion     string
    SecondaryProvider Provider
    SecondaryRegion   string
    RPO               time.Duration  // 恢复点目标
    RTO               time.Duration  // 恢复时间目标
    ReplicationMode   ReplicationMode  // sync/async
}

func (drm *DisasterRecoveryManager) SetupDR(ctx context.Context, config *DRConfig) error {
    // 1. 配置跨云网络
    vpn, err := drm.networkMgr.CreateCrossCloudVPN(ctx, &CreateVPNRequest{
        Source: NetworkEndpoint{
            Provider: config.PrimaryProvider,
            Region:   config.PrimaryRegion,
        },
        Destination: NetworkEndpoint{
            Provider: config.SecondaryProvider,
            Region:   config.SecondaryRegion,
        },
    })
    if err != nil {
        return err
    }

    // 2. 配置数据同步
    err = drm.setupDataReplication(ctx, config)
    if err != nil {
        return err
    }

    // 3. 定期演练
    go drm.scheduleDRDrills(ctx, config)

    return nil
}

// 灾难恢复切换
func (drm *DisasterRecoveryManager) Failover(ctx context.Context, config *DRConfig) error {
    log.Infof("initiating failover from %s to %s", config.PrimaryProvider, config.SecondaryProvider)

    // 1. 停止主站点流量
    // 2. 确认备份站点数据最新
    // 3. 更新DNS解析到备份站点
    // 4. 启动备份站点服务
    // 5. 验证服务可用性

    return nil
}
```

### 四、数据模型与存储

**元数据存储设计**

```sql
-- 资源表
CREATE TABLE resources (
    id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255),
    type VARCHAR(50),
    provider VARCHAR(50),
    region VARCHAR(100),
    status VARCHAR(50),
    spec JSONB,  -- 资源详细规格
    tags JSONB,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP,
    INDEX idx_provider_type (provider, type),
    INDEX idx_status (status)
);

-- 成本记录表(按天统计)
CREATE TABLE cost_records (
    id BIGSERIAL PRIMARY KEY,
    date DATE,
    provider VARCHAR(50),
    resource_id VARCHAR(255),
    resource_type VARCHAR(50),
    service VARCHAR(100),
    region VARCHAR(100),
    project VARCHAR(255),
    cost DECIMAL(18,6),
    currency VARCHAR(10),
    created_at TIMESTAMP,
    INDEX idx_date_provider (date, provider),
    INDEX idx_resource (resource_id, date)
);

-- 云账号表
CREATE TABLE cloud_accounts (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255),
    provider VARCHAR(50),
    credentials JSONB,  -- 加密存储
    regions JSONB,
    enabled BOOLEAN,
    created_at TIMESTAMP
);
```

### 五、安全与权限

**统一认证与权限控制**

```go
type IAMService struct {
    rbac *RBACManager
}

// 权限模型
type Permission struct {
    Resource string   // compute/storage/network/*
    Provider Provider // aws/aliyun/* (支持通配符)
    Region   string   // cn-hangzhou/*
    Actions  []string // create/delete/start/stop/*
}

type Role struct {
    ID          string
    Name        string
    Permissions []Permission
}

func (iam *IAMService) CheckPermission(ctx context.Context, user *User, action string, resource *CloudResource) bool {
    roles := iam.rbac.GetUserRoles(user.ID)

    for _, role := range roles {
        for _, perm := range role.Permissions {
            if iam.matchPermission(perm, action, resource) {
                return true
            }
        }
    }

    return false
}
```

### 六、部署架构

```
┌─────────────────────────────────────────────────────┐
│                    Kubernetes集群                    │
│                                                     │
│  ┌───────────────┐  ┌───────────────┐            │
│  │  API Service  │  │ Web Console   │            │
│  │  (3 replicas) │  │ (Nginx+React) │            │
│  └───────┬───────┘  └───────────────┘            │
│          │                                         │
│  ┌───────▼──────────────────────┐                │
│  │   Resource Manager Service    │                │
│  │   (stateless, 5 replicas)     │                │
│  └───────┬──────────────────────┘                │
│          │                                         │
│  ┌───────▼──────────────────────┐                │
│  │   Adapter Workers Pool        │                │
│  │   (按云厂商分组部署)          │                │
│  └───────┬──────────────────────┘                │
└──────────┼─────────────────────────────────────┘
           │
  ┌────────▼──────────┐
  │   PostgreSQL      │  (元数据)
  │   (主从复制)      │
  └───────────────────┘

  ┌───────────────────┐
  │   Prometheus      │  (监控数据)
  │   (with Thanos)   │
  └───────────────────┘

  ┌───────────────────┐
  │   Redis Cluster   │  (缓存/任务队列)
  └───────────────────┘
```

---

## 总结

多云管理平台的核心价值在于通过**统一抽象层**屏蔽云厂商差异,提供**一致的管理体验**。关键设计点包括:

1. **可扩展的适配器架构** - 支持快速接入新云厂商
2. **智能决策引擎** - 基于成本、性能、合规性自动选择最优云
3. **统一监控告警** - 跨云的可观测性
4. **成本优化** - 实时成本分析与优化建议
5. **安全合规** - 统一的权限管理和审计

技术挑战主要在于API差异适配、跨云网络互通、数据一致性保障等方面,需要在架构设计时充分考虑容错性和可扩展性。
