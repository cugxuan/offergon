---
title: 设计一个电商平台的订单系统(保证强一致性)
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: ecommerce-order-system-strong-consistency
ref:
---

## 核心要点

**关键词：** 分布式事务、强一致性、ACID、2PC/3PC、TCC、Saga、幂等性、防重复下单

**技术方案：** Seata分布式事务、本地消息表、状态机、分布式锁、库存预扣、超时补偿

**核心挑战：** 库存超卖、订单重复、支付一致性、分布式事务性能、高并发秒杀、数据最终一致性

---

## 详细设计方案

### 一、需求分析与业务场景

#### 1.1 功能需求

**核心流程：**
```
用户下单 → 库存扣减 → 创建订单 → 锁定优惠券 → 发起支付
         ↓
    支付成功 → 扣款 → 订单确认 → 通知仓储 → 物流发货
         ↓
    支付失败 → 回滚库存 → 释放优惠券 → 取消订单
```

**业务规则：**
1. **原子性**：下单操作要么全部成功，要么全部回滚(不能出现扣库存但订单未创建)
2. **一致性**：库存、订单、支付、优惠券状态必须保持一致
3. **隔离性**：并发下单不能导致超卖或重复扣减
4. **持久性**：订单一旦确认，数据不可丢失

#### 1.2 非功能需求

| 指标 | 要求 | 说明 |
|-----|------|------|
| 并发量 | 10万QPS | 大促峰值 |
| 响应时间 | P99 < 500ms | 下单体验 |
| 库存准确率 | 100% | 零超卖容忍度 |
| 订单一致性 | 强一致 | 金融级可靠性 |
| 可用性 | 99.99% | 年停机<53分钟 |

#### 1.3 容量估算

```
假设场景：618大促
- 日订单量：1000万单
- 峰值QPS：10万（集中在20:00-21:00）
- 平均每单：3个商品
- 日库存变动：3000万次
- 订单数据：1000万 × 2KB = 20GB/天
- 库存数据：1亿SKU × 100B = 10GB
```

---

### 二、整体架构设计

#### 2.1 微服务架构

```
                   API Gateway
                        ↓
        ┌───────────────┼───────────────┐
        ↓               ↓               ↓
   订单服务         库存服务         支付服务
   (Order)        (Inventory)       (Payment)
        ↓               ↓               ↓
   订单DB          库存DB           支付DB
        │               │               │
        └───────── 分布式事务协调器 ──────┘
              (Seata/DTM/自研TCC)
                        ↓
                   消息队列(Kafka)
                        ↓
        ┌───────────────┼───────────────┐
        ↓               ↓               ↓
   营销服务         仓储服务         通知服务
  (Promotion)      (Warehouse)    (Notification)
```

**服务职责：**

| 服务 | 职责 | 数据库表 |
|-----|------|---------|
| 订单服务 | 订单CRUD、状态流转、订单查询 | order、order_item |
| 库存服务 | 库存扣减/释放、预占管理 | inventory、inventory_log |
| 支付服务 | 支付单创建、支付回调处理 | payment、payment_transaction |
| 营销服务 | 优惠券锁定/核销、积分扣减 | coupon、promotion |
| 仓储服务 | 拣货单生成、发货管理 | warehouse_task |
| 通知服务 | 短信/邮件/Push推送 | notification_log |

#### 2.2 分层架构

```
┌─────────────────────────────────────────┐
│  接入层：负载均衡 + API网关              │
│  - 限流熔断、认证鉴权、协议转换          │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  编排层：订单编排服务 (Saga Orchestrator)│
│  - 流程编排、状态机、补偿逻辑            │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  业务层：领域服务（微服务集群）          │
│  - 订单/库存/支付/营销服务               │
└──────────────┬──────────────────────────┘
               ↓
┌─────────────────────────────────────────┐
│  数据层：分库分表 + 读写分离             │
│  - MySQL Cluster + Redis Cache           │
└─────────────────────────────────────────┘
```

---

### 三、核心模块详细设计

#### 3.1 数据模型设计

**订单表（分库分表）：**
```sql
-- 主订单表（按user_id分片）
CREATE TABLE `order` (
    order_id BIGINT PRIMARY KEY COMMENT 'Snowflake生成',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    order_no VARCHAR(32) UNIQUE NOT NULL COMMENT '业务订单号',
    total_amount DECIMAL(10,2) NOT NULL COMMENT '订单总金额',
    paid_amount DECIMAL(10,2) DEFAULT 0 COMMENT '实付金额',
    discount_amount DECIMAL(10,2) DEFAULT 0 COMMENT '优惠金额',
    status TINYINT NOT NULL COMMENT '订单状态：0待支付/1已支付/2已发货/3已完成/-1已取消',
    payment_timeout DATETIME COMMENT '支付超时时间',
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    version INT DEFAULT 0 COMMENT '乐观锁版本号',
    INDEX idx_user_time (user_id, created_at),
    INDEX idx_status (status, created_at)
) ENGINE=InnoDB PARTITION BY HASH(user_id) PARTITIONS 64;

-- 订单明细表（按order_id分片，与order同库）
CREATE TABLE order_item (
    item_id BIGINT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    sku_id BIGINT NOT NULL COMMENT '商品SKU',
    quantity INT NOT NULL COMMENT '购买数量',
    price DECIMAL(10,2) NOT NULL COMMENT '商品单价',
    total_price DECIMAL(10,2) NOT NULL COMMENT '小计',
    INDEX idx_order_id (order_id)
) ENGINE=InnoDB;

-- 订单状态流转日志
CREATE TABLE order_status_log (
    log_id BIGINT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    old_status TINYINT,
    new_status TINYINT,
    operator VARCHAR(50) COMMENT '操作人/系统',
    remark TEXT,
    created_at DATETIME NOT NULL,
    INDEX idx_order_id (order_id, created_at)
) ENGINE=InnoDB;
```

**库存表：**
```sql
-- 库存主表（按sku_id分片）
CREATE TABLE inventory (
    sku_id BIGINT PRIMARY KEY COMMENT '商品SKU',
    available_stock INT NOT NULL COMMENT '可用库存',
    locked_stock INT DEFAULT 0 COMMENT '锁定库存（预占）',
    total_stock INT NOT NULL COMMENT '总库存',
    version INT DEFAULT 0 COMMENT '乐观锁',
    updated_at DATETIME NOT NULL,
    CHECK (available_stock >= 0),
    CHECK (total_stock = available_stock + locked_stock)
) ENGINE=InnoDB;

-- 库存变动流水（用于对账）
CREATE TABLE inventory_log (
    log_id BIGINT PRIMARY KEY,
    sku_id BIGINT NOT NULL,
    order_id BIGINT COMMENT '关联订单',
    change_type TINYINT COMMENT '1扣减/2释放/3锁定/4解锁',
    quantity INT NOT NULL,
    before_stock INT,
    after_stock INT,
    created_at DATETIME NOT NULL,
    INDEX idx_sku_time (sku_id, created_at),
    INDEX idx_order_id (order_id)
) ENGINE=InnoDB;
```

**支付表：**
```sql
-- 支付单表
CREATE TABLE payment (
    payment_id BIGINT PRIMARY KEY,
    payment_no VARCHAR(32) UNIQUE NOT NULL COMMENT '支付流水号',
    order_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    payment_method TINYINT COMMENT '1支付宝/2微信/3银行卡',
    status TINYINT COMMENT '0待支付/1支付中/2成功/3失败',
    third_party_no VARCHAR(64) COMMENT '第三方支付流水号',
    callback_time DATETIME COMMENT '回调时间',
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    INDEX idx_order_id (order_id),
    INDEX idx_payment_no (payment_no)
) ENGINE=InnoDB;

-- 支付事务表（幂等性保证）
CREATE TABLE payment_transaction (
    txn_id BIGINT PRIMARY KEY,
    payment_id BIGINT NOT NULL,
    request_id VARCHAR(64) UNIQUE NOT NULL COMMENT '客户端请求ID（防重）',
    status TINYINT,
    retry_count INT DEFAULT 0,
    created_at DATETIME NOT NULL,
    INDEX idx_payment_id (payment_id)
) ENGINE=InnoDB;
```

#### 3.2 分布式事务方案选型

**方案对比：**

| 方案 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| **2PC/XA** | 强一致性、ACID保证 | 性能差、阻塞、单点故障 | 低并发、强一致要求 |
| **TCC** | 性能好、无阻塞 | 业务侵入大、补偿复杂 | 高并发、可接受最终一致性 |
| **Saga** | 长事务支持、补偿灵活 | 无隔离性、数据可见性问题 | 跨系统、长流程 |
| **本地消息表** | 简单可靠、最终一致性 | 需轮询、延迟高 | 异步场景 |
| **事务消息** | 高性能、解耦 | 依赖MQ可靠性 | 异步通知场景 |

**推荐方案：TCC + Saga 混合模式**

---

#### 3.3 TCC模式实现（核心流程）

**TCC三阶段：**
```
Try阶段：资源预留（冻结）
    ├─ 库存服务：锁定库存
    ├─ 优惠券服务：锁定优惠券
    └─ 账户服务：冻结余额
    ↓
Confirm阶段：业务确认（提交）
    ├─ 库存服务：扣减锁定库存
    ├─ 优惠券服务：核销优惠券
    ├─ 订单服务：订单状态改为已支付
    └─ 账户服务：扣减余额
    ↓
Cancel阶段：业务取消（回滚）
    ├─ 库存服务：释放锁定库存
    ├─ 优惠券服务：释放优惠券
    └─ 账户服务：解冻余额
```

**库存服务TCC接口实现：**

```go
// Try阶段：锁定库存
func (s *InventoryService) TryLockStock(ctx context.Context, req *LockStockRequest) error {
    // 1. 生成TCC事务ID（幂等性）
    tccID := req.TccTransactionID

    // 2. 幂等性检查（防止重复Try）
    if exists := s.checkTccRecord(tccID); exists {
        return nil // 已经Try过，直接返回成功
    }

    // 3. 使用乐观锁扣减库存
    sql := `
        UPDATE inventory
        SET available_stock = available_stock - ?,
            locked_stock = locked_stock + ?,
            version = version + 1
        WHERE sku_id = ?
          AND available_stock >= ?
          AND version = ?
    `
    result := s.db.Exec(sql, req.Quantity, req.Quantity, req.SkuID, req.Quantity, req.Version)

    if result.RowsAffected == 0 {
        return errors.New("库存不足或版本冲突")
    }

    // 4. 记录TCC事务（用于Confirm/Cancel）
    s.saveTccRecord(&TccRecord{
        TccID:    tccID,
        SkuID:    req.SkuID,
        Quantity: req.Quantity,
        Status:   "TRIED",
        ExpireAt: time.Now().Add(15 * time.Minute), // 15分钟超时
    })

    // 5. 记录库存变动流水
    s.logInventoryChange(req.SkuID, req.OrderID, "LOCK", req.Quantity)

    return nil
}

// Confirm阶段：确认扣减
func (s *InventoryService) ConfirmLockStock(ctx context.Context, tccID string) error {
    // 1. 查询TCC记录
    record := s.getTccRecord(tccID)
    if record == nil {
        return errors.New("TCC记录不存在")
    }

    if record.Status == "CONFIRMED" {
        return nil // 幂等性：已经Confirm过
    }

    // 2. 扣减锁定库存（locked_stock转为真实扣减）
    sql := `
        UPDATE inventory
        SET locked_stock = locked_stock - ?
        WHERE sku_id = ? AND locked_stock >= ?
    `
    s.db.Exec(sql, record.Quantity, record.SkuID, record.Quantity)

    // 3. 更新TCC状态
    s.updateTccStatus(tccID, "CONFIRMED")

    // 4. 记录流水
    s.logInventoryChange(record.SkuID, record.OrderID, "CONFIRM", record.Quantity)

    return nil
}

// Cancel阶段：回滚释放
func (s *InventoryService) CancelLockStock(ctx context.Context, tccID string) error {
    record := s.getTccRecord(tccID)
    if record == nil || record.Status == "CANCELLED" {
        return nil // 幂等性
    }

    // 释放锁定库存
    sql := `
        UPDATE inventory
        SET available_stock = available_stock + ?,
            locked_stock = locked_stock - ?
        WHERE sku_id = ?
    `
    s.db.Exec(sql, record.Quantity, record.Quantity, record.SkuID)

    s.updateTccStatus(tccID, "CANCELLED")
    s.logInventoryChange(record.SkuID, record.OrderID, "CANCEL", record.Quantity)

    return nil
}

// 超时补偿任务（定时扫描15分钟未Confirm的Try记录）
func (s *InventoryService) TimeoutCompensation() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        expiredRecords := s.db.Query(`
            SELECT tcc_id FROM tcc_inventory
            WHERE status = 'TRIED'
              AND expire_at < NOW()
        `)

        for _, record := range expiredRecords {
            // 自动Cancel
            s.CancelLockStock(context.Background(), record.TccID)
            log.Warnf("自动回滚超时TCC事务: %s", record.TccID)
        }
    }
}
```

**TCC事务记录表：**
```sql
CREATE TABLE tcc_inventory (
    tcc_id VARCHAR(64) PRIMARY KEY COMMENT 'TCC全局事务ID',
    sku_id BIGINT NOT NULL,
    order_id BIGINT,
    quantity INT NOT NULL,
    status ENUM('TRIED', 'CONFIRMED', 'CANCELLED'),
    expire_at DATETIME COMMENT '过期时间（Try后15分钟）',
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    INDEX idx_status_expire (status, expire_at)
) ENGINE=InnoDB;
```

---

#### 3.4 Saga编排模式（订单流程）

**状态机定义：**
```
[创建订单] → [锁定库存] → [锁定优惠券] → [创建支付单] → [等待支付]
                ↓               ↓               ↓
            [释放库存]      [释放优惠券]    [取消支付]
                ↓
            [取消订单]
```

**Saga编排器实现：**
```go
type SagaOrchestrator struct {
    orderService    *OrderService
    inventoryClient *InventoryClient
    couponClient    *CouponClient
    paymentClient   *PaymentClient
}

func (o *SagaOrchestrator) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 生成全局Saga事务ID
    sagaID := generateSagaID()

    // 定义Saga步骤
    saga := NewSaga(sagaID)

    // Step 1: 创建订单（待支付状态）
    saga.AddStep(
        "CreateOrder",
        func() error {
            order := o.orderService.CreateOrder(req)
            ctx = context.WithValue(ctx, "order_id", order.OrderID)
            return nil
        },
        func() error { // 补偿：删除订单
            return o.orderService.CancelOrder(ctx.Value("order_id"))
        },
    )

    // Step 2: 锁定库存（TCC Try阶段）
    saga.AddStep(
        "LockInventory",
        func() error {
            return o.inventoryClient.TryLockStock(ctx, &LockStockRequest{
                TccTransactionID: sagaID,
                SkuID:           req.SkuID,
                Quantity:        req.Quantity,
            })
        },
        func() error { // 补偿：释放库存
            return o.inventoryClient.CancelLockStock(ctx, sagaID)
        },
    )

    // Step 3: 锁定优惠券
    saga.AddStep(
        "LockCoupon",
        func() error {
            if req.CouponID == 0 {
                return nil // 无优惠券跳过
            }
            return o.couponClient.TryLockCoupon(ctx, req.CouponID)
        },
        func() error {
            return o.couponClient.CancelLockCoupon(ctx, req.CouponID)
        },
    )

    // Step 4: 创建支付单
    saga.AddStep(
        "CreatePayment",
        func() error {
            payment, err := o.paymentClient.CreatePayment(ctx, &CreatePaymentRequest{
                OrderID: ctx.Value("order_id").(int64),
                Amount:  req.TotalAmount,
            })
            ctx = context.WithValue(ctx, "payment_id", payment.PaymentID)
            return err
        },
        func() error {
            return o.paymentClient.CancelPayment(ctx, ctx.Value("payment_id").(int64))
        },
    )

    // 执行Saga事务
    if err := saga.Execute(); err != nil {
        log.Errorf("Saga事务失败，开始补偿: %v", err)
        saga.Compensate() // 自动执行补偿
        return nil, err
    }

    return order, nil
}
```

**Saga事务状态存储：**
```sql
CREATE TABLE saga_transaction (
    saga_id VARCHAR(64) PRIMARY KEY,
    business_type VARCHAR(50) COMMENT '业务类型：ORDER_CREATE',
    current_step INT DEFAULT 0 COMMENT '当前执行到第几步',
    total_steps INT NOT NULL,
    status ENUM('RUNNING', 'SUCCESS', 'COMPENSATING', 'FAILED'),
    context JSON COMMENT '上下文数据（order_id等）',
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL
) ENGINE=InnoDB;

CREATE TABLE saga_step_log (
    log_id BIGINT PRIMARY KEY,
    saga_id VARCHAR(64) NOT NULL,
    step_name VARCHAR(50) NOT NULL,
    step_index INT NOT NULL,
    action_type ENUM('FORWARD', 'COMPENSATE'),
    status ENUM('SUCCESS', 'FAILED'),
    error_msg TEXT,
    executed_at DATETIME NOT NULL,
    INDEX idx_saga_id (saga_id, step_index)
) ENGINE=InnoDB;
```

---

#### 3.5 幂等性设计

**问题场景：**
1. 用户重复点击下单按钮
2. 网络抖动导致客户端重试
3. 支付回调重复通知

**解决方案：**

**1. 前端防重（客户端）**
```javascript
// 按钮防抖
let isSubmitting = false;
function submitOrder() {
    if (isSubmitting) return;
    isSubmitting = true;

    axios.post('/api/order/create', {
        request_id: generateUUID(), // 客户端生成唯一请求ID
        ...orderData
    }).finally(() => {
        isSubmitting = false;
    });
}
```

**2. 接口幂等（服务端）**
```go
func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 1. 使用request_id作为幂等键
    requestID := req.RequestID
    if requestID == "" {
        return nil, errors.New("request_id不能为空")
    }

    // 2. 查询Redis缓存（快速判断）
    cacheKey := fmt.Sprintf("order:idempotent:%s", requestID)
    if orderID := s.redis.Get(cacheKey); orderID != "" {
        // 幂等：返回已创建的订单
        return s.getOrderByID(orderID), nil
    }

    // 3. 数据库唯一约束（最终防线）
    tx := s.db.Begin()
    defer tx.Rollback()

    // 插入幂等记录
    sql := `
        INSERT INTO order_idempotent (request_id, order_id, created_at)
        VALUES (?, ?, NOW())
    `
    if err := tx.Exec(sql, requestID, 0).Error; err != nil {
        // 违反唯一约束，说明已处理过
        existingOrder := s.getOrderByRequestID(requestID)
        return existingOrder, nil
    }

    // 4. 正常创建订单
    order := &Order{...}
    tx.Create(order)

    // 更新幂等表的order_id
    tx.Exec("UPDATE order_idempotent SET order_id = ? WHERE request_id = ?", order.OrderID, requestID)

    tx.Commit()

    // 5. 写入Redis缓存（TTL 24小时）
    s.redis.SetEX(cacheKey, order.OrderID, 24*time.Hour)

    return order, nil
}
```

**幂等表设计：**
```sql
CREATE TABLE order_idempotent (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    request_id VARCHAR(64) UNIQUE NOT NULL COMMENT '客户端请求ID',
    order_id BIGINT COMMENT '订单ID',
    created_at DATETIME NOT NULL,
    INDEX idx_request_id (request_id)
) ENGINE=InnoDB;
```

**3. 支付回调幂等**
```go
func (s *PaymentService) HandleCallback(ctx context.Context, req *CallbackRequest) error {
    // 使用第三方支付流水号作为幂等键
    thirdPartyNo := req.ThirdPartyTransactionNo

    lockKey := fmt.Sprintf("payment:callback:lock:%s", thirdPartyNo)

    // 分布式锁（防止并发回调）
    lock := s.redis.Lock(lockKey, 30*time.Second)
    if !lock.Acquire() {
        return errors.New("回调处理中，请勿重复")
    }
    defer lock.Release()

    // 查询支付单状态
    payment := s.getPaymentByThirdPartyNo(thirdPartyNo)
    if payment.Status == "SUCCESS" {
        return nil // 幂等：已经处理过
    }

    // 更新支付状态
    s.db.Model(payment).Updates(map[string]interface{}{
        "status":         "SUCCESS",
        "callback_time":  time.Now(),
        "third_party_no": thirdPartyNo,
    })

    // 触发后续流程（订单状态变更、库存确认）
    s.publishPaymentSuccessEvent(payment.OrderID)

    return nil
}
```

---

#### 3.6 库存超卖防护

**多层防护策略：**

**1. 数据库约束（最后防线）**
```sql
ALTER TABLE inventory ADD CONSTRAINT chk_stock CHECK (available_stock >= 0);
```

**2. 乐观锁（高并发场景）**
```go
func (s *InventoryService) DeductStock(skuID int64, quantity int) error {
    maxRetry := 3
    for i := 0; i < maxRetry; i++ {
        // 查询当前库存和版本号
        inventory := s.getInventory(skuID)

        if inventory.AvailableStock < quantity {
            return errors.New("库存不足")
        }

        // 乐观锁更新
        sql := `
            UPDATE inventory
            SET available_stock = available_stock - ?,
                version = version + 1
            WHERE sku_id = ? AND version = ?
        `
        result := s.db.Exec(sql, quantity, skuID, inventory.Version)

        if result.RowsAffected > 0 {
            return nil // 更新成功
        }

        // 版本冲突，重试
        time.Sleep(time.Millisecond * 10)
    }

    return errors.New("扣减库存失败，请重试")
}
```

**3. Redis预扣（秒杀场景）**
```go
// 提前将库存加载到Redis
func (s *InventoryService) WarmupStockToRedis(skuID int64) {
    inventory := s.db.GetInventory(skuID)
    key := fmt.Sprintf("stock:%d", skuID)
    s.redis.Set(key, inventory.AvailableStock)
}

// 使用Lua脚本原子扣减
func (s *InventoryService) DeductStockFromRedis(skuID int64, quantity int) error {
    key := fmt.Sprintf("stock:%d", skuID)

    // Lua脚本保证原子性
    script := `
        local stock = tonumber(redis.call('GET', KEYS[1]))
        if stock == nil then
            return -1  -- 库存未初始化
        end
        if stock < tonumber(ARGV[1]) then
            return 0  -- 库存不足
        end
        redis.call('DECRBY', KEYS[1], ARGV[1])
        return 1  -- 扣减成功
    `

    result := s.redis.Eval(script, []string{key}, quantity)

    switch result {
    case -1:
        return errors.New("商品不存在")
    case 0:
        return errors.New("库存不足")
    case 1:
        // 异步同步到MySQL
        go s.syncStockToDB(skuID, quantity)
        return nil
    }

    return errors.New("未知错误")
}

// 异步同步到数据库（批量合并）
func (s *InventoryService) syncStockToDB(skuID int64, quantity int) {
    // 聚合1秒内的扣减操作
    s.buffer.Add(skuID, quantity)

    time.AfterFunc(1*time.Second, func() {
        batches := s.buffer.Flush()
        for skuID, totalQty := range batches {
            s.db.Exec("UPDATE inventory SET available_stock = available_stock - ? WHERE sku_id = ?", totalQty, skuID)
        }
    })
}
```

**4. 分布式锁（悲观锁）**
```go
func (s *InventoryService) DeductStockWithLock(skuID int64, quantity int) error {
    lockKey := fmt.Sprintf("inventory:lock:%d", skuID)

    // 获取分布式锁（基于Redis）
    lock := s.redisLock.Obtain(lockKey, 5*time.Second, nil)
    if lock == nil {
        return errors.New("系统繁忙，请稍后重试")
    }
    defer lock.Release()

    // 加锁后执行扣减（无并发冲突）
    inventory := s.getInventory(skuID)
    if inventory.AvailableStock < quantity {
        return errors.New("库存不足")
    }

    s.db.Exec("UPDATE inventory SET available_stock = available_stock - ? WHERE sku_id = ?", quantity, skuID)
    return nil
}
```

**方案对比：**

| 方案 | 性能 | 一致性 | 适用场景 |
|-----|------|-------|---------|
| 数据库约束 | ⭐⭐ | ⭐⭐⭐⭐⭐ | 最后防线 |
| 乐观锁 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 普通下单 |
| Redis预扣 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 秒杀场景 |
| 分布式锁 | ⭐⭐ | ⭐⭐⭐⭐⭐ | 低并发、强一致 |

---

#### 3.7 订单超时处理

**场景：** 用户下单后15分钟未支付，需自动取消订单并释放库存

**方案一：延迟队列（推荐）**

```go
// 创建订单时发送延迟消息
func (s *OrderService) CreateOrder(order *Order) error {
    // ...创建订单逻辑

    // 发送15分钟延迟消息
    s.kafka.ProduceDelayed("order-timeout", DelayedMessage{
        OrderID: order.OrderID,
        Delay:   15 * time.Minute,
    })

    return nil
}

// 消费延迟消息
func (s *OrderService) HandleTimeoutMessage(msg *DelayedMessage) {
    order := s.getOrder(msg.OrderID)

    // 检查订单状态
    if order.Status != "PENDING_PAYMENT" {
        return // 已支付或已取消，无需处理
    }

    // 开启Saga补偿流程
    saga := s.loadSaga(order.SagaID)
    saga.Compensate() // 回滚：释放库存、优惠券、取消订单

    log.Infof("订单超时自动取消: %d", order.OrderID)
}
```

**方案二：时间轮（内存实现，重启丢失）**

```go
type TimingWheel struct {
    interval    time.Duration // 每格时长（1分钟）
    slots       int           // 总槽位数（60格=1小时）
    currentSlot int
    wheel       [][]Task      // 二维数组存储任务
}

func (tw *TimingWheel) Start() {
    ticker := time.NewTicker(tw.interval)
    for range ticker.C {
        tw.currentSlot = (tw.currentSlot + 1) % tw.slots

        // 执行当前槽位的任务
        for _, task := range tw.wheel[tw.currentSlot] {
            go task.Execute()
        }

        tw.wheel[tw.currentSlot] = nil // 清空槽位
    }
}

func (tw *TimingWheel) AddTask(task Task, delay time.Duration) {
    slots := int(delay / tw.interval)
    targetSlot := (tw.currentSlot + slots) % tw.slots
    tw.wheel[targetSlot] = append(tw.wheel[targetSlot], task)
}
```

**方案三：定时扫描（简单但性能差）**

```go
// 每分钟扫描一次
func (s *OrderService) ScanTimeoutOrders() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        // 查询超时订单
        orders := s.db.Query(`
            SELECT order_id FROM `order`
            WHERE status = 'PENDING_PAYMENT'
              AND payment_timeout < NOW()
            LIMIT 1000
        `)

        for _, order := range orders {
            s.cancelOrder(order.OrderID)
        }
    }
}
```

---

### 四、高可用与性能优化

#### 4.1 读写分离

```
写操作（下单、支付） → 主库（Master）
    ↓ 半同步复制（延迟<10ms）
读操作（订单查询） → 从库（Slave）
```

**注意事项：**
- 下单后立即查询订单，需从主库读（避免主从延迟）
- 使用`HINT`强制路由

```go
func (s *OrderService) GetOrder(orderID int64, forceMaster bool) *Order {
    var order Order
    db := s.db

    if forceMaster {
        db = db.Clauses(dbresolver.Write) // 强制主库
    }

    db.Where("order_id = ?", orderID).First(&order)
    return &order
}
```

#### 4.2 缓存策略

**订单缓存（Cache-Aside）：**
```go
func (s *OrderService) GetOrderWithCache(orderID int64) (*Order, error) {
    // 1. 查Redis缓存
    cacheKey := fmt.Sprintf("order:%d", orderID)
    if cached := s.redis.Get(cacheKey); cached != "" {
        var order Order
        json.Unmarshal([]byte(cached), &order)
        return &order, nil
    }

    // 2. 查数据库
    order := s.db.GetOrder(orderID)
    if order == nil {
        // 缓存空对象（防止缓存穿透）
        s.redis.SetEX(cacheKey, "null", 5*time.Minute)
        return nil, errors.New("订单不存在")
    }

    // 3. 写回缓存
    data, _ := json.Marshal(order)
    s.redis.SetEX(cacheKey, string(data), 1*time.Hour)

    return order, nil
}

// 订单状态变更时删除缓存
func (s *OrderService) UpdateOrderStatus(orderID int64, status string) error {
    s.db.Exec("UPDATE `order` SET status = ? WHERE order_id = ?", status, orderID)

    // 删除缓存
    s.redis.Del(fmt.Sprintf("order:%d", orderID))

    return nil
}
```

**库存缓存（Write-Through）：**
```go
// 扣减库存时同步更新缓存
func (s *InventoryService) DeductStock(skuID int64, quantity int) error {
    // 1. 更新数据库
    s.db.Exec("UPDATE inventory SET available_stock = available_stock - ? WHERE sku_id = ?", quantity, skuID)

    // 2. 同步更新Redis
    key := fmt.Sprintf("stock:%d", skuID)
    s.redis.DecrBy(key, quantity)

    return nil
}
```

#### 4.3 分库分表

**分片策略：**
```
订单表：按 user_id % 64 分片
    - 同一用户的订单在同一分片
    - 方便查询"我的订单"

订单明细表：与订单表同库同分片
    - 避免跨库Join

库存表：按 sku_id % 32 分片
    - 商品库存独立分片
```

**跨分片查询（订单搜索）：**
```go
// 按订单号查询（不知道user_id）
func (s *OrderService) GetOrderByOrderNo(orderNo string) (*Order, error) {
    // 方案1：在所有分片中查询（并行）
    var order *Order
    wg := sync.WaitGroup{}

    for shardID := 0; shardID < 64; shardID++ {
        wg.Add(1)
        go func(shard int) {
            defer wg.Done()
            db := s.getShardDB(shard)
            result := db.Where("order_no = ?", orderNo).First(&order)
            if result.RowsAffected > 0 {
                // 找到了
            }
        }(shardID)
    }

    wg.Wait()
    return order, nil
}

// 方案2：使用ElasticSearch索引
func (s *OrderService) SearchOrder(orderNo string) (*Order, error) {
    // ES存储 order_no -> (user_id, shard_id) 映射
    hit := s.es.Search("order_index", map[string]interface{}{
        "query": map[string]interface{}{
            "term": map[string]interface{}{"order_no": orderNo},
        },
    })

    userID := hit.Source["user_id"]
    shardID := userID % 64

    // 精确查询对应分片
    db := s.getShardDB(shardID)
    order := db.Where("order_no = ?", orderNo).First()
    return order, nil
}
```

#### 4.4 限流降级

**接口限流（令牌桶）：**
```go
import "golang.org/x/time/rate"

var orderLimiter = rate.NewLimiter(rate.Limit(10000), 10000) // 10000 QPS

func CreateOrderHandler(w http.ResponseWriter, r *http.Request) {
    if !orderLimiter.Allow() {
        http.Error(w, "系统繁忙，请稍后重试", http.StatusTooManyRequests)
        return
    }

    // 正常处理
    order := orderService.CreateOrder(...)
    json.NewEncoder(w).Encode(order)
}
```

**熔断降级（Sentinel）：**
```go
import "github.com/alibaba/sentinel-golang/core/flow"

func init() {
    // 配置熔断规则
    _, err := flow.LoadRules([]*flow.Rule{
        {
            Resource:               "create_order",
            TokenCalculateStrategy: flow.Direct,
            ControlBehavior:        flow.Reject,
            Threshold:              10000, // QPS阈值
        },
    })
}

func CreateOrder(req *Request) (*Order, error) {
    entry, err := sentinel.Entry("create_order")
    if err != nil {
        // 触发限流，返回降级响应
        return nil, errors.New("当前下单人数过多，请稍后再试")
    }
    defer entry.Exit()

    // 正常业务逻辑
    return orderService.CreateOrder(req)
}
```

---

### 五、监控与运维

#### 5.1 关键指标监控

**业务指标：**
```
1. 订单创建成功率：成功订单数 / 总请求数 > 99%
2. 支付成功率：支付成功订单 / 发起支付订单 > 95%
3. 库存准确率：实际库存 = 数据库库存（每小时对账）
4. 订单平均处理时长：P99 < 500ms
5. TCC事务成功率：Confirm数 / Try数 > 99%
```

**技术指标：**
```prometheus
# Prometheus查询
# 1. API QPS
rate(http_requests_total{api="create_order"}[1m])

# 2. 错误率
rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m])

# 3. P99延迟
histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m]))

# 4. 数据库慢查询
mysql_slow_queries_total > 100

# 5. TCC超时回滚数
tcc_cancel_total{reason="timeout"}
```

**告警规则：**
```yaml
groups:
- name: order-alerts
  rules:
  - alert: OrderCreateFailureRateHigh
    expr: rate(order_create_failed_total[5m]) / rate(order_create_total[5m]) > 0.01
    for: 5m
    annotations:
      summary: "订单创建失败率超过1%"

  - alert: InventoryInconsistency
    expr: abs(inventory_db_total - inventory_cache_total) > 100
    annotations:
      summary: "库存数据不一致，DB与缓存差异>100"

  - alert: PaymentCallbackDelay
    expr: payment_callback_delay_seconds > 60
    annotations:
      summary: "支付回调延迟超过60秒"
```

#### 5.2 分布式链路追踪

**OpenTelemetry集成：**
```go
import "go.opentelemetry.io/otel"

func CreateOrder(ctx context.Context, req *Request) (*Order, error) {
    // 创建Span
    ctx, span := otel.Tracer("order-service").Start(ctx, "CreateOrder")
    defer span.End()

    // 添加属性
    span.SetAttributes(
        attribute.Int64("user_id", req.UserID),
        attribute.Int64("sku_id", req.SkuID),
    )

    // Step 1: 锁定库存
    if err := s.inventoryClient.LockStock(ctx, req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "库存锁定失败")
        return nil, err
    }

    // Step 2: 创建订单
    order := s.createOrderInDB(ctx, req)

    span.SetStatus(codes.Ok, "订单创建成功")
    return order, nil
}
```

**Trace查看（Jaeger）：**
```
TraceID: 1a2b3c4d5e6f
├─ [order-service] CreateOrder (150ms)
│  ├─ [inventory-service] LockStock (50ms)
│  │  └─ [MySQL] UPDATE inventory (30ms)
│  ├─ [coupon-service] LockCoupon (40ms)
│  └─ [payment-service] CreatePayment (60ms)
│     └─ [Redis] SET payment:123 (5ms)
```

#### 5.3 数据一致性对账

**库存对账任务（每小时）：**
```go
func (s *ReconciliationService) ReconcileInventory() {
    // 1. 从MySQL查询所有SKU库存
    dbStocks := s.db.Query("SELECT sku_id, available_stock FROM inventory")

    // 2. 从Redis查询缓存库存
    for _, dbStock := range dbStocks {
        cacheKey := fmt.Sprintf("stock:%d", dbStock.SkuID)
        cacheStock := s.redis.Get(cacheKey)

        // 3. 对比差异
        if cacheStock != dbStock.AvailableStock {
            log.Errorf("库存不一致 SKU=%d, DB=%d, Cache=%d",
                dbStock.SkuID, dbStock.AvailableStock, cacheStock)

            // 4. 修复：以数据库为准
            s.redis.Set(cacheKey, dbStock.AvailableStock)

            // 5. 告警
            s.alert("库存不一致", dbStock.SkuID)
        }
    }
}
```

**订单状态对账：**
```go
// 扫描卡在"支付中"状态超过30分钟的订单
func (s *ReconciliationService) ReconcilePaymentStatus() {
    orders := s.db.Query(`
        SELECT order_id, payment_id FROM payment
        WHERE status = 'PROCESSING'
          AND created_at < NOW() - INTERVAL 30 MINUTE
    `)

    for _, order := range orders {
        // 主动查询第三方支付状态
        status := s.alipayClient.QueryPaymentStatus(order.PaymentID)

        if status == "SUCCESS" {
            // 补偿：手动触发支付成功逻辑
            s.paymentService.HandleCallback(&CallbackRequest{
                PaymentID: order.PaymentID,
                Status:    "SUCCESS",
            })
        } else if status == "FAILED" {
            // 取消订单
            s.orderService.CancelOrder(order.OrderID)
        }
    }
}
```

---

### 六、总结

#### 6.1 架构亮点

| 技术点 | 方案 | 收益 |
|-------|------|------|
| 分布式事务 | TCC + Saga混合 | 强一致性 + 高性能 |
| 库存防超卖 | 乐观锁 + Redis预扣 | 零超卖 + 支持10万QPS |
| 幂等性 | request_id + 分布式锁 | 防重复下单/支付 |
| 订单超时 | Kafka延迟队列 | 自动释放资源 |
| 数据分片 | user_id分片 | 单分片<500GB |
| 监控对账 | 定时对账 + 告警 | 数据一致性100% |

#### 6.2 关键指标

```
✅ 订单创建 TPS: 10万+
✅ 订单创建耗时: P99 < 500ms
✅ 库存准确率: 100%（零超卖）
✅ 数据一致性: 强一致性（TCC保证）
✅ 系统可用性: 99.99%
✅ 幂等性保证: 100%（去重成功率）
```

#### 6.3 未来优化方向

1. **异地多活**：订单数据跨Region同步，容灾能力提升
2. **智能补偿**：基于AI的异常检测和自动补偿
3. **冷热分离**：历史订单归档到对象存储，降低成本
4. **实时数仓**：Flink实时计算订单大盘，支持运营决策
5. **区块链**：关键交易上链，防篡改审计
