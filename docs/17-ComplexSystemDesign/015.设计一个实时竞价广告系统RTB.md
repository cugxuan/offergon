---
title: 设计一个实时竞价广告系统（RTB）
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: real-time-bidding-ad-system-design
ref:
---

## 核心要点

**RTB = 毫秒级竞价 + 精准定向 + 实时计费 + 反作弊**

关键特性：极低延迟（<100ms）、QPS峰值（百万级）、精准定向、实时竞价、频次控制、作弊检测、实时报表

核心挑战：超高并发、极致性能、数据一致性、预算控制、反作弊、多方利益平衡（广告主、媒体、用户）

## 详细回答

### 一、业务理解与系统架构

面试官您好，实时竞价广告系统（RTB）是程序化广告的核心，需要在100毫秒内完成用户画像匹配、竞价、创意选择等复杂流程。

#### 1. RTB 工作流程

```
用户访问媒体 → Ad Request →
竞价请求 → 多个 DSP 并发竞价 →
选择最高出价 → 返回广告创意 →
展示广告 → 曝光回调 → 点击跟踪 → 计费结算
```

**时间预算分配（总共 100ms）**：
- 媒体发送请求：10ms
- 用户画像查询：15ms
- 并发竞价（多个 DSP）：50ms
- 广告创意生成：10ms
- 响应返回：15ms

#### 2. 系统架构

```
┌─────────────────────────────────────────────────────────┐
│  媒体层（Publisher）                                      │
│  Web / App / OTT                                         │
└───────────────────┬─────────────────────────────────────┘
                    │ Ad Request
                    ↓
┌─────────────────────────────────────────────────────────┐
│  SSP（Supply-Side Platform）卖方平台                     │
│  ┌──────────┬──────────┬──────────┬──────────────┐     │
│  │流量过滤  │用户画像  │竞价引擎  │广告渲染      │     │
│  └──────────┴──────────┴──────────┴──────────────┘     │
└───────────────────┬─────────────────────────────────────┘
                    │ Bid Request (OpenRTB)
                    ↓
┌─────────────────────────────────────────────────────────┐
│  Ad Exchange（广告交易平台）                              │
│  ┌──────────┬──────────┬──────────┬──────────────┐     │
│  │流量分配  │竞价协调  │反作弊    │实时结算      │     │
│  └──────────┴──────────┴──────────┴──────────────┘     │
└───────────────────┬─────────────────────────────────────┘
                    │ 并发请求多个 DSP
                    ↓
┌─────────────────────────────────────────────────────────┐
│  DSP（Demand-Side Platform）买方平台                     │
│  ┌──────────┬──────────┬──────────┬──────────────┐     │
│  │定向匹配  │出价策略  │预算控制  │创意优选      │     │
│  └──────────┴──────────┴──────────┴──────────────┘     │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  DMP（Data Management Platform）数据管理平台             │
│  用户画像、行为数据、第三方数据                           │
└─────────────────────────────────────────────────────────┘
```

### 二、核心模块设计

#### 1. 竞价请求处理（Ad Exchange）

```go
type BidRequest struct {
    // OpenRTB 标准字段
    ID       string    `json:"id"`        // 请求唯一ID
    Imp      []Imp     `json:"imp"`       // 广告位信息
    Site     *Site     `json:"site"`      // 网站信息（PC端）
    App      *App      `json:"app"`       // 应用信息（移动端）
    Device   Device    `json:"device"`    // 设备信息
    User     User      `json:"user"`      // 用户信息
    At       int       `json:"at"`        // 竞价类型：1=一价，2=二价
    Tmax     int       `json:"tmax"`      // 超时时间（毫秒）
    Bcat     []string  `json:"bcat"`      // 禁止的广告类目
}

type Imp struct {
    ID              string        `json:"id"`
    Banner          *Banner       `json:"banner"`      // 展示广告
    Video           *Video        `json:"video"`       // 视频广告
    Native          *Native       `json:"native"`      // 原生广告
    BidFloor        float64       `json:"bidfloor"`    // 底价（CPM）
    Secure          int           `json:"secure"`      // 是否HTTPS
}

type User struct {
    ID       string   `json:"id"`        // 用户ID（Cookie/Device ID）
    Gender   string   `json:"gender"`    // 性别
    YOB      int      `json:"yob"`       // 出生年份
    Keywords string   `json:"keywords"`  // 兴趣标签
    Geo      *Geo     `json:"geo"`       // 地理位置
}

type Device struct {
    UA           string   `json:"ua"`         // User-Agent
    IP           string   `json:"ip"`         // IP地址
    DeviceType   int      `json:"devicetype"` // 1=手机，2=平板，3=PC
    Make         string   `json:"make"`       // 设备厂商（Apple/Samsung）
    Model        string   `json:"model"`      // 设备型号
    OS           string   `json:"os"`         // 操作系统
    OSV          string   `json:"osv"`        // 操作系统版本
    ConnectionType int    `json:"connectiontype"` // 网络类型
}

// 竞价请求处理器
type BidRequestHandler struct {
    userProfileService *UserProfileService
    dspClients         map[string]*DSPClient
    antifraudService   *AntifraudService
    budgetController   *BudgetController
    redis              *redis.Client
}

func (h *BidRequestHandler) HandleBidRequest(ctx context.Context, req *BidRequest) (*BidResponse, error) {
    // 设置超时（默认100ms）
    ctx, cancel := context.WithTimeout(ctx, time.Duration(req.Tmax)*time.Millisecond)
    defer cancel()

    // 1. 反作弊检测（快速过滤）
    if h.antifraudService.IsInvalidTraffic(req) {
        return nil, errors.New("invalid traffic")
    }

    // 2. 用户画像查询（并行查询多个数据源）
    userProfile := h.userProfileService.GetProfile(ctx, req.User.ID)

    // 3. 并发请求所有符合条件的 DSP
    dspResponses := h.requestDSPsConcurrently(ctx, req, userProfile)

    if len(dspResponses) == 0 {
        return nil, errors.New("no bids")
    }

    // 4. 竞价逻辑（二价竞价）
    winningBid := h.runAuction(dspResponses, req.At)

    // 5. 生成广告响应
    return h.buildBidResponse(req, winningBid), nil
}

// 并发请求多个 DSP
func (h *BidRequestHandler) requestDSPsConcurrently(
    ctx context.Context,
    req *BidRequest,
    profile *UserProfile,
) []*DSPBidResponse {
    // 过滤出符合条件的 DSP（地域、类目、预算）
    eligibleDSPs := h.filterEligibleDSPs(req)

    // 并发请求（使用 errgroup）
    var wg sync.WaitGroup
    responseChan := make(chan *DSPBidResponse, len(eligibleDSPs))

    for _, dspClient := range eligibleDSPs {
        wg.Add(1)
        go func(client *DSPClient) {
            defer wg.Done()

            // 每个 DSP 请求有独立超时（50ms）
            dspCtx, cancel := context.WithTimeout(ctx, 50*time.Millisecond)
            defer cancel()

            resp, err := client.SendBidRequest(dspCtx, req, profile)
            if err == nil && resp != nil {
                responseChan <- resp
            }
        }(dspClient)
    }

    // 等待所有请求完成或超时
    go func() {
        wg.Wait()
        close(responseChan)
    }()

    // 收集响应
    responses := make([]*DSPBidResponse, 0)
    for resp := range responseChan {
        responses = append(responses, resp)
    }

    return responses
}

// 竞价逻辑（二价竞价：胜者支付第二名价格+0.01）
func (h *BidRequestHandler) runAuction(bids []*DSPBidResponse, auctionType int) *DSPBidResponse {
    if len(bids) == 0 {
        return nil
    }

    // 按出价排序
    sort.Slice(bids, func(i, j int) bool {
        return bids[i].Price > bids[j].Price
    })

    winner := bids[0]

    if auctionType == 2 && len(bids) > 1 {
        // 二价竞价：支付第二名价格 + $0.01
        secondPrice := bids[1].Price
        winner.ClearingPrice = secondPrice + 0.01
    } else {
        // 一价竞价：支付自己的出价
        winner.ClearingPrice = winner.Price
    }

    return winner
}
```

#### 2. DSP 出价引擎

```go
type DSPBiddingEngine struct {
    targetingMatcher *TargetingMatcher
    pricingModel     *PricingModel
    budgetController *BudgetController
    creativeSelector *CreativeSelector
}

type BiddingRequest struct {
    CampaignID   string
    BidRequest   *BidRequest
    UserProfile  *UserProfile
}

// DSP 出价决策
func (engine *DSPBiddingEngine) Bid(ctx context.Context, req *BiddingRequest) (*BidResponse, error) {
    // 1. 定向匹配（快速过滤）
    campaigns := engine.targetingMatcher.Match(req.BidRequest, req.UserProfile)
    if len(campaigns) == 0 {
        return nil, errors.New("no matching campaigns")
    }

    // 2. 预算检查（Redis 原子操作）
    availableCampaigns := make([]*Campaign, 0)
    for _, campaign := range campaigns {
        if engine.budgetController.HasBudget(campaign.ID) {
            availableCampaigns = append(availableCampaigns, campaign)
        }
    }

    if len(availableCampaigns) == 0 {
        return nil, errors.New("budget exhausted")
    }

    // 3. 出价计算（多策略）
    bidPrice := engine.pricingModel.CalculateBid(availableCampaigns[0], req.UserProfile)

    // 4. 创意选择
    creative := engine.creativeSelector.Select(availableCampaigns[0], req.BidRequest)

    return &BidResponse{
        ID:    req.BidRequest.ID,
        BidID: generateBidID(),
        Price: bidPrice,
        AdMarkup: creative.HTML,
        CampaignID: availableCampaigns[0].ID,
    }, nil
}

// 定向匹配服务
type TargetingMatcher struct {
    campaignCache *cache.Cache
}

type TargetingCriteria struct {
    // 地域定向
    GeoTargeting    []string  `json:"geo_targeting"`      // ["CN", "US"]

    // 人群定向
    Gender          string    `json:"gender"`             // M/F/U
    AgeRange        [2]int    `json:"age_range"`          // [18, 35]
    Interests       []string  `json:"interests"`          // ["tech", "gaming"]

    // 设备定向
    DeviceTypes     []int     `json:"device_types"`       // [1,2] 手机/平板
    OS              []string  `json:"os"`                 // ["iOS", "Android"]

    // 行为定向
    RecentBehaviors []string  `json:"recent_behaviors"`   // ["searched_phone", "visited_ecommerce"]

    // 上下文定向
    Categories      []string  `json:"categories"`         // 允许的内容类目
    Keywords        []string  `json:"keywords"`           // 关键词
    URLWhitelist    []string  `json:"url_whitelist"`      // 域名白名单
}

func (tm *TargetingMatcher) Match(req *BidRequest, profile *UserProfile) []*Campaign {
    // 从缓存获取所有活跃广告计划
    allCampaigns := tm.campaignCache.GetActiveCampaigns()

    matched := make([]*Campaign, 0)
    for _, campaign := range allCampaigns {
        if tm.isMatch(campaign.Targeting, req, profile) {
            matched = append(matched, campaign)
        }
    }

    return matched
}

func (tm *TargetingMatcher) isMatch(
    targeting *TargetingCriteria,
    req *BidRequest,
    profile *UserProfile,
) bool {
    // 地域匹配
    if len(targeting.GeoTargeting) > 0 {
        if !contains(targeting.GeoTargeting, profile.Country) {
            return false
        }
    }

    // 性别匹配
    if targeting.Gender != "" && targeting.Gender != "U" {
        if profile.Gender != targeting.Gender {
            return false
        }
    }

    // 年龄匹配
    age := time.Now().Year() - req.User.YOB
    if age < targeting.AgeRange[0] || age > targeting.AgeRange[1] {
        return false
    }

    // 兴趣匹配（交集不为空）
    if len(targeting.Interests) > 0 {
        if !hasIntersection(targeting.Interests, profile.Interests) {
            return false
        }
    }

    // 设备匹配
    if len(targeting.DeviceTypes) > 0 {
        if !contains(targeting.DeviceTypes, req.Device.DeviceType) {
            return false
        }
    }

    return true
}

// 出价模型（基于转化预估）
type PricingModel struct {
    ctrPredictor *CTRPredictor  // 点击率预估模型
    cvrPredictor *CVRPredictor  // 转化率预估模型
}

func (pm *PricingModel) CalculateBid(campaign *Campaign, profile *UserProfile) float64 {
    // 预估点击率（CTR）
    predictedCTR := pm.ctrPredictor.Predict(campaign, profile)

    // 预估转化率（CVR）
    predictedCVR := pm.cvrPredictor.Predict(campaign, profile)

    // 计算 eCPM（期望千次曝光收益）
    // eCPM = CTR × CVR × 转化价值 × 1000
    eCPM := predictedCTR * predictedCVR * campaign.ConversionValue * 1000

    // 考虑广告主出价上限
    if eCPM > campaign.MaxBid {
        eCPM = campaign.MaxBid
    }

    // 流量质量折扣（优质媒体可以提高出价）
    qualityMultiplier := getMediaQuality(campaign.MediaID)
    finalBid := eCPM * qualityMultiplier

    return finalBid
}

// CTR 预估模型（简化版，实际使用深度学习模型）
type CTRPredictor struct {
    model *tensorflow.SavedModel
}

func (ctr *CTRPredictor) Predict(campaign *Campaign, profile *UserProfile) float64 {
    features := map[string]interface{}{
        "user_age":         profile.Age,
        "user_gender":      profile.Gender,
        "user_interests":   profile.Interests,
        "ad_category":      campaign.Category,
        "hour_of_day":      time.Now().Hour(),
        "day_of_week":      time.Now().Weekday(),
        "device_type":      profile.DeviceType,
        "historical_ctr":   campaign.HistoricalCTR,
    }

    // 调用 TensorFlow 模型预测
    prediction := ctr.model.Predict(features)
    return prediction["ctr"].(float64)
}
```

#### 3. 预算控制系统

```go
type BudgetController struct {
    redis *redis.Client
}

// 预算分配策略（平滑消耗）
type BudgetPacing struct {
    CampaignID   string
    DailyBudget  float64    // 日预算 $1000
    SpentToday   float64    // 已消耗 $450
    TargetPace   float64    // 目标进度 50%（当前时间 / 24小时）
    ActualPace   float64    // 实际进度 45%（$450 / $1000）
}

// 检查是否有预算（原子操作）
func (bc *BudgetController) HasBudget(campaignID string) bool {
    key := fmt.Sprintf("budget:%s:%s", campaignID, time.Now().Format("2006-01-02"))

    // 获取今日已消耗金额
    spent, _ := bc.redis.Get(context.Background(), key).Float64()

    // 获取日预算
    dailyBudget := bc.getDailyBudget(campaignID)

    return spent < dailyBudget
}

// 扣减预算（乐观锁 + Lua 脚本保证原子性）
func (bc *BudgetController) DeductBudget(campaignID string, amount float64) error {
    key := fmt.Sprintf("budget:%s:%s", campaignID, time.Now().Format("2006-01-02"))
    budgetKey := fmt.Sprintf("budget_limit:%s", campaignID)

    // Lua 脚本保证原子性
    luaScript := `
        local spent = tonumber(redis.call('GET', KEYS[1]) or 0)
        local budget = tonumber(redis.call('GET', KEYS[2]) or 0)
        local amount = tonumber(ARGV[1])

        if spent + amount <= budget then
            redis.call('INCRBYFLOAT', KEYS[1], amount)
            redis.call('EXPIRE', KEYS[1], 86400)
            return 1
        else
            return 0
        end
    `

    result, err := bc.redis.Eval(
        context.Background(),
        luaScript,
        []string{key, budgetKey},
        amount,
    ).Int()

    if result == 0 {
        return errors.New("budget exceeded")
    }

    return err
}

// 预算平滑（Pacing）
func (bc *BudgetController) ShouldThrottle(campaignID string) bool {
    pacing := bc.getBudgetPacing(campaignID)

    // 实际消耗速度 > 目标速度 1.2倍 → 需要节流
    if pacing.ActualPace > pacing.TargetPace*1.2 {
        return true
    }

    return false
}

func (bc *BudgetController) getBudgetPacing(campaignID string) *BudgetPacing {
    key := fmt.Sprintf("budget:%s:%s", campaignID, time.Now().Format("2006-01-02"))
    spent, _ := bc.redis.Get(context.Background(), key).Float64()

    dailyBudget := bc.getDailyBudget(campaignID)

    // 计算目标进度（基于当前时间）
    now := time.Now()
    minutesElapsed := float64(now.Hour()*60 + now.Minute())
    targetPace := minutesElapsed / 1440.0 // 1440 = 24 * 60

    actualPace := spent / dailyBudget

    return &BudgetPacing{
        CampaignID:  campaignID,
        DailyBudget: dailyBudget,
        SpentToday:  spent,
        TargetPace:  targetPace,
        ActualPace:  actualPace,
    }
}
```

### 三、关键技术挑战

#### 1. 用户画像服务（DMP）

```go
type UserProfileService struct {
    redis       *redis.Client
    hbase       *hbase.Client
    kafka       *kafka.Producer
}

type UserProfile struct {
    UserID      string     `json:"user_id"`

    // 基础属性
    Gender      string     `json:"gender"`
    Age         int        `json:"age"`
    Country     string     `json:"country"`
    City        string     `json:"city"`

    // 兴趣标签（加权）
    Interests   map[string]float64 `json:"interests"`
    // {"tech": 0.8, "gaming": 0.6, "sports": 0.3}

    // 行为标签
    RecentSearches   []string   `json:"recent_searches"`
    VisitedSites     []string   `json:"visited_sites"`
    PurchaseHistory  []Purchase `json:"purchase_history"`

    // 设备信息
    DeviceType  int        `json:"device_type"`
    OS          string     `json:"os"`

    // 实时特征
    LastActiveTime   time.Time  `json:"last_active_time"`
    SessionCount     int        `json:"session_count"`    // 今日会话次数
}

// 实时画像查询（多级缓存）
func (ups *UserProfileService) GetProfile(ctx context.Context, userID string) *UserProfile {
    // L1 缓存：本地内存（LRU，1秒TTL）
    if profile := localCache.Get(userID); profile != nil {
        return profile.(*UserProfile)
    }

    // L2 缓存：Redis（10分钟TTL）
    if cached, err := ups.redis.Get(ctx, "profile:"+userID).Result(); err == nil {
        var profile UserProfile
        json.Unmarshal([]byte(cached), &profile)
        localCache.Set(userID, &profile, 1*time.Second)
        return &profile
    }

    // L3 存储：HBase（完整画像）
    profile := ups.loadFromHBase(userID)

    // 回写缓存
    profileJSON, _ := json.Marshal(profile)
    ups.redis.Set(ctx, "profile:"+userID, profileJSON, 10*time.Minute)
    localCache.Set(userID, profile, 1*time.Second)

    return profile
}

// 实时更新用户行为（异步写入）
func (ups *UserProfileService) TrackBehavior(userID string, event *BehaviorEvent) {
    // 发送到 Kafka（异步处理）
    ups.kafka.Send("user_behavior", &kafka.Message{
        Key:   []byte(userID),
        Value: event.ToJSON(),
    })
}

type BehaviorEvent struct {
    UserID    string    `json:"user_id"`
    EventType string    `json:"event_type"` // "click", "view", "purchase"
    Timestamp time.Time `json:"timestamp"`
    Properties map[string]interface{} `json:"properties"`
}

// Kafka 消费者：实时更新画像
func (ups *UserProfileService) ConsumeEvents() {
    consumer := kafka.NewConsumer([]string{"user_behavior"})

    for msg := range consumer.Messages() {
        var event BehaviorEvent
        json.Unmarshal(msg.Value, &event)

        // 更新 HBase
        ups.updateProfile(event.UserID, &event)

        // 失效 Redis 缓存
        ups.redis.Del(context.Background(), "profile:"+event.UserID)
    }
}
```

#### 2. 反作弊系统

```go
type AntifraudService struct {
    redis        *redis.Client
    mlModel      *FraudDetectionModel
    blacklistDB  *gorm.DB
}

// 多维度作弊检测
func (afs *AntifraudService) IsInvalidTraffic(req *BidRequest) bool {
    // 1. IP 黑名单检测
    if afs.isBlacklistedIP(req.Device.IP) {
        return true
    }

    // 2. User-Agent 检测（爬虫识别）
    if afs.isBotUserAgent(req.Device.UA) {
        return true
    }

    // 3. 频率异常检测（单IP高频请求）
    if afs.detectHighFrequency(req.Device.IP) {
        return true
    }

    // 4. 点击率异常检测（历史 CTR 过高）
    if afs.detectAbnormalCTR(req.User.ID) {
        return true
    }

    // 5. 机器学习模型评分
    fraudScore := afs.mlModel.Predict(req)
    if fraudScore > 0.8 {
        return true
    }

    return false
}

// 频率检测（Redis 计数器）
func (afs *AntifraudService) detectHighFrequency(ip string) bool {
    key := fmt.Sprintf("freq:ip:%s:%d", ip, time.Now().Unix()/60)

    // 原子自增
    count, _ := afs.redis.Incr(context.Background(), key).Result()
    afs.redis.Expire(context.Background(), key, 60*time.Second)

    // 每分钟超过 1000 次请求视为异常
    return count > 1000
}

// 点击率异常检测
func (afs *AntifraudService) detectAbnormalCTR(userID string) bool {
    key := fmt.Sprintf("ctr:%s", userID)

    // 获取用户历史统计
    stats, _ := afs.redis.HGetAll(context.Background(), key).Result()
    impressions, _ := strconv.ParseInt(stats["imp"], 10, 64)
    clicks, _ := strconv.ParseInt(stats["clk"], 10, 64)

    if impressions < 100 {
        return false // 样本量不足
    }

    ctr := float64(clicks) / float64(impressions)

    // CTR > 10% 视为异常（正常 CTR 一般 < 5%）
    return ctr > 0.1
}

// 机器学习作弊检测模型
type FraudDetectionModel struct {
    model *xgboost.Booster
}

func (fdm *FraudDetectionModel) Predict(req *BidRequest) float64 {
    features := extractFraudFeatures(req)
    // 特征包括：
    // - IP 地理位置一致性
    // - 设备指纹唯一性
    // - 请求时间分布（是否集中在凌晨）
    // - User-Agent 多样性
    // - 历史点击率
    // - 广告位可见性

    prediction := fdm.model.Predict(features)
    return prediction
}
```

#### 3. 实时报表系统

```go
type RealtimeReportService struct {
    clickhouse *clickhouse.Conn
    redis      *redis.Client
}

// 实时指标（Redis 计数器 + ClickHouse 明细）
type RealtimeMetrics struct {
    CampaignID    string    `json:"campaign_id"`
    Timestamp     time.Time `json:"timestamp"`

    // 实时指标（Redis）
    Impressions   int64     `json:"impressions"`   // 曝光数
    Clicks        int64     `json:"clicks"`        // 点击数
    Conversions   int64     `json:"conversions"`   // 转化数
    Spend         float64   `json:"spend"`         // 消耗金额

    // 计算指标
    CTR           float64   `json:"ctr"`           // 点击率
    CVR           float64   `json:"cvr"`           // 转化率
    CPC           float64   `json:"cpc"`           // 单次点击成本
    CPA           float64   `json:"cpa"`           // 单次转化成本
}

// 增量更新（曝光）
func (rrs *RealtimeReportService) RecordImpression(campaignID string, bidPrice float64) {
    key := fmt.Sprintf("metrics:%s:%s", campaignID, time.Now().Format("2006-01-02:15:04"))

    pipe := rrs.redis.Pipeline()
    pipe.HIncrBy(context.Background(), key, "imp", 1)
    pipe.HIncrByFloat(context.Background(), key, "spend", bidPrice)
    pipe.Expire(context.Background(), key, 7*24*time.Hour)
    pipe.Exec(context.Background())
}

// 增量更新（点击）
func (rrs *RealtimeReportService) RecordClick(campaignID string) {
    key := fmt.Sprintf("metrics:%s:%s", campaignID, time.Now().Format("2006-01-02:15:04"))
    rrs.redis.HIncrBy(context.Background(), key, "clk", 1)
}

// 查询实时报表
func (rrs *RealtimeReportService) GetRealtimeMetrics(campaignID string, duration time.Duration) *RealtimeMetrics {
    now := time.Now()
    start := now.Add(-duration)

    var totalImp, totalClk, totalConv int64
    var totalSpend float64

    // 聚合多个时间窗口的数据
    for t := start; t.Before(now); t = t.Add(1 * time.Minute) {
        key := fmt.Sprintf("metrics:%s:%s", campaignID, t.Format("2006-01-02:15:04"))
        stats, _ := rrs.redis.HGetAll(context.Background(), key).Result()

        imp, _ := strconv.ParseInt(stats["imp"], 10, 64)
        clk, _ := strconv.ParseInt(stats["clk"], 10, 64)
        spend, _ := strconv.ParseFloat(stats["spend"], 64)

        totalImp += imp
        totalClk += clk
        totalSpend += spend
    }

    metrics := &RealtimeMetrics{
        CampaignID:  campaignID,
        Timestamp:   now,
        Impressions: totalImp,
        Clicks:      totalClk,
        Spend:       totalSpend,
    }

    // 计算衍生指标
    if totalImp > 0 {
        metrics.CTR = float64(totalClk) / float64(totalImp) * 100
        metrics.CPC = totalSpend / float64(totalClk)
    }

    return metrics
}

// 异步写入 ClickHouse（明细数据）
func (rrs *RealtimeReportService) SyncToClickHouse() {
    ticker := time.NewTicker(10 * time.Second)
    for range ticker.C {
        // 从 Kafka 消费曝光/点击事件，批量写入 ClickHouse
        batch := make([]ImpressionEvent, 0, 10000)

        for event := range kafkaConsumer.Messages() {
            var impEvent ImpressionEvent
            json.Unmarshal(event.Value, &impEvent)
            batch = append(batch, impEvent)

            if len(batch) >= 10000 {
                rrs.batchInsert(batch)
                batch = batch[:0]
            }
        }

        if len(batch) > 0 {
            rrs.batchInsert(batch)
        }
    }
}

type ImpressionEvent struct {
    Timestamp    time.Time `json:"timestamp"`
    CampaignID   string    `json:"campaign_id"`
    UserID       string    `json:"user_id"`
    IP           string    `json:"ip"`
    DeviceType   int       `json:"device_type"`
    BidPrice     float64   `json:"bid_price"`
    WinPrice     float64   `json:"win_price"`
}

func (rrs *RealtimeReportService) batchInsert(events []ImpressionEvent) error {
    tx, _ := rrs.clickhouse.Begin()
    stmt, _ := tx.Prepare(`
        INSERT INTO impressions (
            timestamp, campaign_id, user_id, ip, device_type, bid_price, win_price
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `)

    for _, event := range events {
        stmt.Exec(
            event.Timestamp,
            event.CampaignID,
            event.UserID,
            event.IP,
            event.DeviceType,
            event.BidPrice,
            event.WinPrice,
        )
    }

    return tx.Commit()
}
```

### 四、性能优化

#### 1. 架构优化

```go
// 1. 连接池管理
var httpClient = &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        1000,
        MaxIdleConnsPerHost: 100,
        IdleConnTimeout:     90 * time.Second,
    },
    Timeout: 50 * time.Millisecond,
}

// 2. 对象池（减少 GC 压力）
var bidRequestPool = sync.Pool{
    New: func() interface{} {
        return &BidRequest{}
    },
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
    req := bidRequestPool.Get().(*BidRequest)
    defer bidRequestPool.Put(req)

    // 解析请求
    json.NewDecoder(r.Body).Decode(req)

    // 处理竞价...
}

// 3. 协程池（控制并发数）
type WorkerPool struct {
    jobs    chan *Job
    workers int
}

func NewWorkerPool(workers int) *WorkerPool {
    wp := &WorkerPool{
        jobs:    make(chan *Job, 10000),
        workers: workers,
    }

    for i := 0; i < workers; i++ {
        go wp.worker()
    }

    return wp
}

func (wp *WorkerPool) worker() {
    for job := range wp.jobs {
        job.Execute()
    }
}

// 4. 批量操作
func (bc *BudgetController) BatchDeduct(deductions map[string]float64) error {
    pipe := bc.redis.Pipeline()

    for campaignID, amount := range deductions {
        key := fmt.Sprintf("budget:%s:%s", campaignID, time.Now().Format("2006-01-02"))
        pipe.IncrByFloat(context.Background(), key, amount)
    }

    _, err := pipe.Exec(context.Background())
    return err
}
```

#### 2. 缓存优化

```go
// 多级缓存架构
type CacheLayer struct {
    l1 *bigcache.BigCache  // 本地缓存（1GB）
    l2 *redis.Client       // Redis（分布式缓存）
    l3 *mysql.DB           // MySQL（持久化）
}

func (cl *CacheLayer) Get(key string) (interface{}, error) {
    // L1: 本地缓存（微秒级）
    if val, err := cl.l1.Get(key); err == nil {
        return val, nil
    }

    // L2: Redis（毫秒级）
    if val, err := cl.l2.Get(context.Background(), key).Result(); err == nil {
        cl.l1.Set(key, []byte(val))
        return val, nil
    }

    // L3: MySQL（10ms+）
    var val string
    cl.l3.QueryRow("SELECT value FROM cache WHERE key = ?", key).Scan(&val)

    // 回写缓存
    cl.l2.Set(context.Background(), key, val, 10*time.Minute)
    cl.l1.Set(key, []byte(val))

    return val, nil
}

// 缓存预热（启动时加载热数据）
func (cl *CacheLayer) Warmup() {
    // 加载活跃广告计划
    campaigns := loadActiveCampaigns()
    for _, campaign := range campaigns {
        cl.l1.Set("campaign:"+campaign.ID, campaign.ToJSON())
    }

    // 加载高频用户画像
    hotUsers := loadHotUsers()
    for _, user := range hotUsers {
        cl.l2.Set(context.Background(), "profile:"+user.ID, user.ToJSON(), 1*time.Hour)
    }
}
```

### 五、监控与告警

```go
type RTBMetrics struct {
    // QPS 监控
    BidRequestQPS    prometheus.Counter
    BidResponseQPS   prometheus.Counter

    // 延迟监控
    BidLatencyP50    prometheus.Histogram
    BidLatencyP95    prometheus.Histogram
    BidLatencyP99    prometheus.Histogram

    // 成功率监控
    BidSuccessRate   prometheus.Gauge
    DSPTimeoutRate   prometheus.GaugeVec  // 按 DSP 分组

    // 业务指标
    WinRate          prometheus.Gauge     // 竞价胜率
    FillRate         prometheus.Gauge     // 填充率
    eCPM             prometheus.Gauge     // 平均 eCPM
}

// 实时告警
func (alerter *Alerter) CheckRTBHealth() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        // 1. P99 延迟告警（> 100ms）
        if getP99Latency() > 100*time.Millisecond {
            alerter.SendAlert("P99 latency exceeded 100ms")
        }

        // 2. 胜率告警（< 5%）
        if getWinRate() < 0.05 {
            alerter.SendAlert("Win rate dropped below 5%")
        }

        // 3. DSP 超时告警（> 30%）
        for dspID, timeoutRate := range getDSPTimeoutRates() {
            if timeoutRate > 0.3 {
                alerter.SendAlert(fmt.Sprintf("DSP %s timeout rate: %.2f%%", dspID, timeoutRate*100))
            }
        }

        // 4. 预算消耗异常
        for campaignID := range getActiveCampaigns() {
            pacing := budgetController.getBudgetPacing(campaignID)
            if pacing.ActualPace > pacing.TargetPace*1.5 {
                alerter.SendAlert(fmt.Sprintf("Campaign %s budget burning too fast", campaignID))
            }
        }
    }
}
```

### 六、总结

RTB 系统的核心要点：

**性能要求**：
1. **极低延迟**：总响应时间 < 100ms，P99 < 150ms
2. **超高并发**：QPS 百万级，需要高效的并发控制
3. **资源优化**：连接池、对象池、协程池、批量操作

**核心功能**：
1. **精准定向**：多维度用户画像匹配（地域、人群、行为、上下文）
2. **智能出价**：基于 CTR/CVR 预估的动态出价
3. **预算控制**：实时扣减 + 平滑消耗（Pacing）
4. **反作弊**：IP 黑名单、频率检测、机器学习模型

**技术架构**：
1. **多级缓存**：本地缓存（L1）+ Redis（L2）+ 数据库（L3）
2. **异步处理**：Kafka 消息队列解耦实时写入
3. **分布式存储**：ClickHouse 存储海量明细数据
4. **实时计算**：Redis 计数器 + Flink 流式计算

**关键指标**：
- 竞价胜率（Win Rate）> 10%
- 填充率（Fill Rate）> 80%
- 平均 eCPM > $2.0
- 反作弊拦截率 < 5%
- 预算消耗偏差 < 10%

这就是我对实时竞价广告系统设计的完整回答,请问您还有什么想深入了解的吗?
