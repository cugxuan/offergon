---
title: 设计一个区块链钱包系统
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: blockchain-wallet-system-design
ref:
---

## 核心要点

**核心功能：** 密钥管理、多链资产管理、交易签名与广播、安全存储、助记词恢复

**技术栈：** HSM/TEE 硬件安全、分层确定性钱包(HD Wallet/BIP-32/39/44)、冷热分离架构、多签技术

**安全挑战：** 私钥防泄露、重放攻击防护、钓鱼防护、审计日志、合规 KYC/AML

## 详细回答

### 一、系统需求分析

#### 1.1 功能性需求

**基础功能：**
- **钱包创建**：生成助记词、私钥、公钥、地址
- **资产管理**：查看余额、多币种/多链支持（BTC、ETH、BSC、Polygon 等）
- **转账功能**：发起转账、签名交易、广播到区块链网络
- **收款功能**：生成收款地址、二维码
- **交易记录**：历史记录、交易状态跟踪、Gas 费估算

**高级功能：**
- **DeFi 集成**：Swap、质押、流动性挖矿
- **NFT 管理**：查看、转移、展示 NFT
- **多签钱包**：企业级多重签名管理
- **硬件钱包集成**：Ledger、Trezor 支持
- **助记词导入/导出**：跨钱包迁移

#### 1.2 非功能性需求

- **安全性**：私钥永不离开本地、加密存储、防篡改
- **可用性**：99.9% 在线率、秒级交易确认
- **合规性**：KYC/AML 合规、审计日志完整
- **性能**：支持百万级用户并发、毫秒级签名响应
- **多链兼容**：支持主流公链（EVM 兼容链、BTC、Solana 等）

### 二、技术架构设计

#### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                     客户端层                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  Web端   │  │  移动端  │  │  插件端  │              │
│  │(MetaMask)│  │(iOS/安卓)│  │(浏览器)  │              │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘              │
│       └────────────┬─────────────┘                      │
│                    │                                     │
│       ┌────────────▼─────────────────────┐              │
│       │      密钥库 (Keystore)           │              │
│       │  - 助记词加密存储                │              │
│       │  - 本地签名                      │              │
│       │  - 生物识别/密码保护             │              │
│       └────────────┬─────────────────────┘              │
└────────────────────┼─────────────────────────────────────┘
                     │ HTTPS/gRPC
        ┌────────────▼────────────┐
        │      API 网关层          │
        │  - 认证鉴权(JWT)         │
        │  - 限流防护               │
        │  - 请求路由               │
        └────────────┬────────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
┌───────▼───────┐  ┌▼────────┐  ┌▼──────────┐
│ 资产管理服务  │  │交易服务  │  │ 节点服务   │
│ - 余额查询    │  │- 交易构造│  │ - RPC调用  │
│ - 多链聚合    │  │- 签名验证│  │ - 事件监听 │
│ - 价格估值    │  │- 交易广播│  │ - 区块同步 │
└───────┬───────┘  └─┬───────┘  └─┬──────────┘
        │            │            │
        └────────────┼────────────┘
                     │
        ┌────────────▼────────────┐
        │     中间件层             │
        │  ┌──────┐  ┌──────┐     │
        │  │Redis │  │ MQ   │     │
        │  │缓存  │  │消息  │     │
        │  └──────┘  └──────┘     │
        └────────────┬────────────┘
                     │
        ┌────────────▼────────────┐
        │     存储层               │
        │  ┌──────────┐           │
        │  │  MySQL   │           │
        │  │ - 用户    │           │
        │  │ - 交易记录│           │
        │  └──────────┘           │
        │  ┌──────────┐           │
        │  │ TimeSeries│           │
        │  │(InfluxDB) │           │
        │  │ - 链上数据│           │
        │  └──────────┘           │
        └─────────────────────────┘
                     │
        ┌────────────▼────────────┐
        │    区块链网络层          │
        │  ┌────┐ ┌────┐ ┌─────┐  │
        │  │ BTC│ │ ETH│ │ BSC │  │
        │  │节点│ │节点│ │节点 │  │
        │  └────┘ └────┘ └─────┘  │
        └─────────────────────────┘
```

#### 2.2 核心模块详解

**（1）密钥管理模块（Keystore）**

这是整个系统的安全核心，负责私钥的生成、存储和使用。

```go
package keystore

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/hex"
    "github.com/tyler-smith/go-bip32"
    "github.com/tyler-smith/go-bip39"
    "golang.org/x/crypto/pbkdf2"
)

// 钱包结构
type Wallet struct {
    ID           string
    Name         string
    MnemonicHash string  // 不存储明文助记词，只存哈希
    Accounts     []*Account
    CreatedAt    time.Time
}

type Account struct {
    Address    string
    Path       string    // BIP-44 路径: m/44'/60'/0'/0/0
    PublicKey  string
    Blockchain string    // ETH/BTC/BSC
}

// HD 钱包管理器
type HDWalletManager struct {
    encryptionKey []byte
}

// 生成助记词（BIP-39）
func (m *HDWalletManager) GenerateMnemonic() (string, error) {
    // 生成 128 位熵 -> 12 个单词
    // 256 位熵 -> 24 个单词
    entropy, err := bip39.NewEntropy(256)
    if err != nil {
        return "", err
    }

    mnemonic, err := bip39.NewMnemonic(entropy)
    if err != nil {
        return "", err
    }

    return mnemonic, nil
}

// 从助记词派生密钥（BIP-32/44）
func (m *HDWalletManager) DeriveKey(mnemonic, path string) (*bip32.Key, error) {
    // 助记词 -> 种子
    seed := bip39.NewSeed(mnemonic, "") // 可选密码短语

    // 生成主密钥
    masterKey, err := bip32.NewMasterKey(seed)
    if err != nil {
        return nil, err
    }

    // BIP-44 路径派生
    // m/44'/coin_type'/account'/change/index
    // 以太坊: m/44'/60'/0'/0/0
    // 比特币: m/44'/0'/0'/0/0
    key, err := derivePath(masterKey, path)
    return key, err
}

// 路径派生实现
func derivePath(masterKey *bip32.Key, path string) (*bip32.Key, error) {
    // 解析路径: m/44'/60'/0'/0/0
    // 44' 表示强化派生
    segments := parsePath(path)

    key := masterKey
    for _, segment := range segments {
        if segment.Hardened {
            key, _ = key.NewChildKey(bip32.FirstHardenedChild + segment.Index)
        } else {
            key, _ = key.NewChildKey(segment.Index)
        }
    }
    return key, nil
}

// 加密存储助记词（AES-256-GCM）
func (m *HDWalletManager) EncryptMnemonic(mnemonic, password string) (string, error) {
    // 使用 PBKDF2 派生加密密钥
    salt := make([]byte, 32)
    rand.Read(salt)

    key := pbkdf2.Key([]byte(password), salt, 100000, 32, sha256.New)

    // AES-GCM 加密
    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    nonce := make([]byte, gcm.NonceSize())
    rand.Read(nonce)

    ciphertext := gcm.Seal(nonce, nonce, []byte(mnemonic), nil)

    // 返回: salt + ciphertext（hex 编码）
    encrypted := append(salt, ciphertext...)
    return hex.EncodeToString(encrypted), nil
}

// 解密助记词
func (m *HDWalletManager) DecryptMnemonic(encrypted, password string) (string, error) {
    data, _ := hex.DecodeString(encrypted)

    // 提取 salt 和 ciphertext
    salt := data[:32]
    ciphertext := data[32:]

    // 派生密钥
    key := pbkdf2.Key([]byte(password), salt, 100000, 32, sha256.New)

    block, _ := aes.NewCipher(key)
    gcm, _ := cipher.NewGCM(block)

    nonceSize := gcm.NonceSize()
    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}

// 生成以太坊地址
func GenerateEthereumAddress(publicKey []byte) string {
    // 公钥 Keccak256 哈希，取后 20 字节
    hash := crypto.Keccak256(publicKey[1:]) // 去掉 0x04 前缀
    address := hash[12:]
    return "0x" + hex.EncodeToString(address)
}
```

**（2）交易服务**

```go
package transaction

import (
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/crypto"
    "math/big"
)

// 交易构造器
type TransactionBuilder struct {
    client *ethclient.Client
}

// 以太坊交易结构
type ETHTransaction struct {
    From     string
    To       string
    Value    *big.Int  // Wei
    GasLimit uint64
    GasPrice *big.Int
    Nonce    uint64
    Data     []byte    // 合约调用数据
}

// 构造以太坊转账交易
func (b *TransactionBuilder) BuildETHTransfer(
    from, to string,
    amount *big.Float, // ETH 数量
) (*types.Transaction, error) {
    // 查询 nonce
    nonce, err := b.client.PendingNonceAt(
        context.Background(),
        common.HexToAddress(from),
    )
    if err != nil {
        return nil, err
    }

    // 转换金额（ETH -> Wei）
    value := new(big.Int)
    amount.Mul(amount, big.NewFloat(1e18)).Int(value)

    // 估算 Gas
    gasLimit := uint64(21000) // 普通转账

    // 查询 Gas Price（支持 EIP-1559）
    gasPrice, err := b.client.SuggestGasPrice(context.Background())
    if err != nil {
        return nil, err
    }

    // 构造交易
    tx := types.NewTransaction(
        nonce,
        common.HexToAddress(to),
        value,
        gasLimit,
        gasPrice,
        nil, // data
    )

    return tx, nil
}

// 签名交易
func SignTransaction(tx *types.Transaction, privateKeyHex string, chainID *big.Int) ([]byte, error) {
    // 解析私钥
    privateKey, err := crypto.HexToECDSA(privateKeyHex)
    if err != nil {
        return nil, err
    }

    // EIP-155 签名（防重放攻击）
    signer := types.NewEIP155Signer(chainID)
    signedTx, err := types.SignTx(tx, signer, privateKey)
    if err != nil {
        return nil, err
    }

    // 序列化交易
    rawTxBytes, err := signedTx.MarshalBinary()
    return rawTxBytes, err
}

// 广播交易
func (b *TransactionBuilder) BroadcastTransaction(signedTxHex string) (string, error) {
    rawTxBytes, _ := hex.DecodeString(signedTxHex)

    tx := new(types.Transaction)
    tx.UnmarshalBinary(rawTxBytes)

    err := b.client.SendTransaction(context.Background(), tx)
    if err != nil {
        return "", err
    }

    return tx.Hash().Hex(), nil
}

// ERC-20 代币转账
func (b *TransactionBuilder) BuildERC20Transfer(
    tokenAddress, from, to string,
    amount *big.Int,
) (*types.Transaction, error) {
    // ERC-20 transfer 方法签名
    // transfer(address,uint256)
    methodID := crypto.Keccak256([]byte("transfer(address,uint256)"))[:4]

    // 编码参数
    toAddress := common.HexToAddress(to)
    paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
    paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)

    data := append(methodID, paddedAddress...)
    data = append(data, paddedAmount...)

    // 查询 nonce 和 gas
    nonce, _ := b.client.PendingNonceAt(
        context.Background(),
        common.HexToAddress(from),
    )

    gasPrice, _ := b.client.SuggestGasPrice(context.Background())

    // 估算 Gas Limit（调用合约）
    gasLimit := uint64(60000)

    tx := types.NewTransaction(
        nonce,
        common.HexToAddress(tokenAddress),
        big.NewInt(0), // value = 0
        gasLimit,
        gasPrice,
        data,
    )

    return tx, nil
}
```

**（3）资产管理服务**

```go
package asset

import (
    "context"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
    "math/big"
)

type AssetService struct {
    ethClient *ethclient.Client
    // 其他链的客户端...
}

// 查询 ETH 余额
func (s *AssetService) GetETHBalance(address string) (*big.Float, error) {
    account := common.HexToAddress(address)

    balance, err := s.ethClient.BalanceAt(
        context.Background(),
        account,
        nil, // 最新区块
    )
    if err != nil {
        return nil, err
    }

    // Wei -> ETH
    ethBalance := new(big.Float)
    ethBalance.SetString(balance.String())
    return ethBalance.Quo(ethBalance, big.NewFloat(1e18)), nil
}

// 查询 ERC-20 代币余额
func (s *AssetService) GetERC20Balance(
    tokenAddress, userAddress string,
) (*big.Int, error) {
    // 调用合约 balanceOf 方法
    methodID := crypto.Keccak256([]byte("balanceOf(address)"))[:4]

    userAddr := common.HexToAddress(userAddress)
    paddedAddress := common.LeftPadBytes(userAddr.Bytes(), 32)
    data := append(methodID, paddedAddress...)

    // 以太坊 call（不消耗 gas）
    msg := ethereum.CallMsg{
        To:   &common.HexToAddress(tokenAddress),
        Data: data,
    }

    result, err := s.ethClient.CallContract(context.Background(), msg, nil)
    if err != nil {
        return nil, err
    }

    balance := new(big.Int).SetBytes(result)
    return balance, nil
}

// 多链资产聚合
func (s *AssetService) GetUserAssets(userID string) (*UserAssets, error) {
    // 从数据库获取用户所有地址
    addresses, _ := s.db.GetUserAddresses(userID)

    assets := &UserAssets{
        TotalValueUSD: 0,
        Balances:      make(map[string][]*AssetBalance),
    }

    // 并发查询所有链的余额
    var wg sync.WaitGroup
    resultChan := make(chan *AssetBalance, len(addresses)*3)

    for _, addr := range addresses {
        wg.Add(1)
        go func(address *Address) {
            defer wg.Done()

            switch address.Blockchain {
            case "ETH":
                balance, _ := s.GetETHBalance(address.Address)
                // 获取价格
                price, _ := s.priceService.GetPrice("ETH", "USD")
                valueUSD := new(big.Float).Mul(balance, big.NewFloat(price))

                resultChan <- &AssetBalance{
                    Blockchain: "ETH",
                    Symbol:     "ETH",
                    Balance:    balance.String(),
                    ValueUSD:   valueUSD.String(),
                }

            case "BTC":
                // 类似处理...
            }
        }(addr)
    }

    go func() {
        wg.Wait()
        close(resultChan)
    }()

    // 收集结果
    for asset := range resultChan {
        assets.Balances[asset.Blockchain] = append(
            assets.Balances[asset.Blockchain],
            asset,
        )
    }

    return assets, nil
}
```

#### 2.3 安全架构

**（1）冷热钱包分离**

```go
// 热钱包：用于日常小额交易，部署在线上服务器
type HotWallet struct {
    privateKey string  // 加密存储在 HSM 中
    address    string
    balance    *big.Int
    dailyLimit *big.Int  // 每日转账限额
}

// 冷钱包：大额资金存储，离线保存
type ColdWallet struct {
    address       string
    publicKey     string
    // 私钥离线存储（硬件钱包/纸钱包）
    multiSigConfig *MultiSigConfig  // 多签配置
}

// 自动资金调度
func (s *WalletService) AutoBalancing() {
    // 监控热钱包余额
    hotBalance := s.getHotWalletBalance()

    // 余额过低时，从冷钱包补充
    if hotBalance.Cmp(s.minHotBalance) < 0 {
        s.requestColdWalletTransfer(s.targetHotBalance)
    }

    // 余额过高时，转入冷钱包
    if hotBalance.Cmp(s.maxHotBalance) > 0 {
        excess := new(big.Int).Sub(hotBalance, s.targetHotBalance)
        s.transferToColdWallet(excess)
    }
}
```

**（2）多签钱包实现**

```solidity
// 以太坊多签合约（2/3 签名）
pragma solidity ^0.8.0;

contract MultiSigWallet {
    address[] public owners;
    uint public required; // 所需签名数

    struct Transaction {
        address to;
        uint value;
        bytes data;
        bool executed;
    }

    Transaction[] public transactions;
    mapping(uint => mapping(address => bool)) public confirmations;

    modifier onlyOwner() {
        require(isOwner(msg.sender), "Not owner");
        _;
    }

    constructor(address[] memory _owners, uint _required) {
        require(_owners.length >= _required, "Invalid required");
        owners = _owners;
        required = _required;
    }

    function submitTransaction(
        address _to,
        uint _value,
        bytes memory _data
    ) public onlyOwner returns (uint) {
        uint txId = transactions.length;
        transactions.push(Transaction({
            to: _to,
            value: _value,
            data: _data,
            executed: false
        }));
        return txId;
    }

    function confirmTransaction(uint _txId) public onlyOwner {
        require(!confirmations[_txId][msg.sender], "Already confirmed");

        confirmations[_txId][msg.sender] = true;

        // 检查是否达到所需签名数
        if (isConfirmed(_txId)) {
            executeTransaction(_txId);
        }
    }

    function executeTransaction(uint _txId) internal {
        Transaction storage txn = transactions[_txId];
        require(!txn.executed, "Already executed");

        txn.executed = true;
        (bool success, ) = txn.to.call{value: txn.value}(txn.data);
        require(success, "Transaction failed");
    }

    function isConfirmed(uint _txId) public view returns (bool) {
        uint count = 0;
        for (uint i = 0; i < owners.length; i++) {
            if (confirmations[_txId][owners[i]]) {
                count++;
            }
        }
        return count >= required;
    }

    function isOwner(address _addr) public view returns (bool) {
        for (uint i = 0; i < owners.length; i++) {
            if (owners[i] == _addr) return true;
        }
        return false;
    }
}
```

**（3）交易风控系统**

```go
type RiskControlService struct {
    db           *gorm.DB
    redis        *redis.Client
    alertService *AlertService
}

// 风险检查
func (r *RiskControlService) CheckTransaction(tx *Transaction) error {
    // 1. 地址黑名单检查
    if r.isBlacklisted(tx.To) {
        return errors.New("blacklisted address")
    }

    // 2. 单笔限额检查
    if tx.Value.Cmp(r.singleTxLimit) > 0 {
        return errors.New("exceeds single transaction limit")
    }

    // 3. 日累计限额检查
    dailyTotal := r.getDailyTotal(tx.From)
    if new(big.Int).Add(dailyTotal, tx.Value).Cmp(r.dailyLimit) > 0 {
        return errors.New("exceeds daily limit")
    }

    // 4. 异常行为检测
    if r.detectAnomalous(tx) {
        r.alertService.Send("suspicious_transaction", tx)
        return errors.New("suspicious activity detected")
    }

    // 5. Gas 价格检查（防止过高 Gas 攻击）
    if tx.GasPrice.Cmp(r.maxGasPrice) > 0 {
        return errors.New("gas price too high")
    }

    return nil
}

// 异常检测
func (r *RiskControlService) detectAnomalous(tx *Transaction) bool {
    // 检查短时间内大量交易
    recentTxCount := r.redis.Get(
        fmt.Sprintf("tx_count:%s:5m", tx.From),
    ).Val()

    if count, _ := strconv.Atoi(recentTxCount); count > 10 {
        return true
    }

    // 检查首次交互地址
    if !r.hasInteractedBefore(tx.From, tx.To) {
        // 首次大额转账可疑
        if tx.Value.Cmp(big.NewInt(1e18)) > 0 {
            return true
        }
    }

    return false
}
```

### 三、关键技术实现

#### 3.1 BIP 协议实现

**BIP-39（助记词）→ BIP-32（HD 钱包）→ BIP-44（多币种）**

```
助记词: abandon abandon abandon ... (12/24 个单词)
    ↓
种子 (Seed): 512 位熵
    ↓
主密钥 (Master Key): m
    ↓
BIP-44 路径:
  - 以太坊: m/44'/60'/0'/0/0
  - 比特币: m/44'/0'/0'/0/0
  - BSC:    m/44'/60'/0'/0/0 (兼容 ETH)
    ↓
派生私钥 → 公钥 → 地址
```

#### 3.2 交易监听与确认

```go
// 监听链上交易状态
type TransactionMonitor struct {
    client *ethclient.Client
}

func (m *TransactionMonitor) WatchTransaction(txHash string) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        <-ticker.C

        // 查询交易回执
        receipt, err := m.client.TransactionReceipt(
            context.Background(),
            common.HexToHash(txHash),
        )

        if err != nil {
            continue // 交易未打包
        }

        // 检查交易状态
        if receipt.Status == 1 {
            log.Infof("交易成功: %s, Gas Used: %d", txHash, receipt.GasUsed)
            m.updateTxStatus(txHash, "success")
            return
        } else {
            log.Errorf("交易失败: %s", txHash)
            m.updateTxStatus(txHash, "failed")
            return
        }
    }
}

// 区块确认数检查
func (m *TransactionMonitor) WaitForConfirmations(txHash string, confirmations int) {
    receipt, _ := m.client.TransactionReceipt(context.Background(), common.HexToHash(txHash))

    currentBlock, _ := m.client.BlockNumber(context.Background())

    confirmedBlocks := currentBlock - receipt.BlockNumber.Uint64()

    if confirmedBlocks >= uint64(confirmations) {
        log.Infof("交易已确认 %d 个区块", confirmedBlocks)
    }
}
```

#### 3.3 Gas 费优化

```go
// EIP-1559 Gas 费估算
type GasEstimator struct {
    client *ethclient.Client
}

func (g *GasEstimator) EstimateGas() (*GasFee, error) {
    // 查询基础费用
    header, _ := g.client.HeaderByNumber(context.Background(), nil)
    baseFee := header.BaseFee

    // 查询优先费用
    tipCap, _ := g.client.SuggestGasTipCap(context.Background())

    // 计算 maxFeePerGas
    maxFeePerGas := new(big.Int).Add(
        new(big.Int).Mul(baseFee, big.NewInt(2)), // baseFee * 2
        tipCap,
    )

    return &GasFee{
        MaxFeePerGas:         maxFeePerGas,
        MaxPriorityFeePerGas: tipCap,
    }, nil
}

// 提供三档 Gas 费选项
func (g *GasEstimator) GetGasOptions() map[string]*GasFee {
    baseFee := g.getBaseFee()

    return map[string]*GasFee{
        "slow": {
            MaxFeePerGas:         new(big.Int).Mul(baseFee, big.NewInt(110)).Div(baseFee, big.NewInt(100)), // +10%
            MaxPriorityFeePerGas: big.NewInt(1e9), // 1 Gwei
        },
        "standard": {
            MaxFeePerGas:         new(big.Int).Mul(baseFee, big.NewInt(125)).Div(baseFee, big.NewInt(100)), // +25%
            MaxPriorityFeePerGas: big.NewInt(2e9), // 2 Gwei
        },
        "fast": {
            MaxFeePerGas:         new(big.Int).Mul(baseFee, big.NewInt(150)).Div(baseFee, big.NewInt(100)), // +50%
            MaxPriorityFeePerGas: big.NewInt(3e9), // 3 Gwei
        },
    }
}
```

### 四、安全措施

#### 4.1 客户端安全

```javascript
// 移动端使用系统 Keychain/Keystore
import * as SecureStore from 'expo-secure-store';

async function savePrivateKey(privateKey) {
    // iOS: 存储到 Keychain
    // Android: 存储到 Keystore（硬件支持）
    await SecureStore.setItemAsync('wallet_key', privateKey, {
        keychainAccessible: SecureStore.WHEN_UNLOCKED,
    });
}

// 生物识别验证
import * as LocalAuthentication from 'expo-local-authentication';

async function authenticateBeforeSign() {
    const result = await LocalAuthentication.authenticateAsync({
        promptMessage: '请验证身份以签名交易',
        fallbackLabel: '使用密码',
    });

    if (result.success) {
        const privateKey = await SecureStore.getItemAsync('wallet_key');
        return privateKey;
    }
    return null;
}
```

#### 4.2 防钓鱼措施

```go
// 地址簿白名单
type AddressBook struct {
    UserID   string
    Name     string
    Address  string
    Verified bool  // 是否已验证
}

// 交易前警告
func (s *TransactionService) ValidateRecipient(to string) *Warning {
    // 检查是否在地址簿中
    if !s.isInAddressBook(to) {
        return &Warning{
            Level:   "high",
            Message: "首次向此地址转账，请仔细核对",
        }
    }

    // 检查是否为已知诈骗地址
    if s.isKnownScam(to) {
        return &Warning{
            Level:   "critical",
            Message: "警告：该地址已被标记为诈骗地址",
        }
    }

    return nil
}
```

### 五、监控与运维

```go
// 钱包系统监控指标
type WalletMetrics struct {
    // 交易指标
    TxSuccessRate   float64  // 交易成功率
    TxPendingCount  int      // 待处理交易数
    AvgConfirmTime  time.Duration  // 平均确认时间

    // 安全指标
    FailedSignAttempts int   // 签名失败次数
    AnomalousActivity  int   // 异常活动次数

    // 性能指标
    APIResponseTime time.Duration
    NodeSyncStatus  bool    // 节点同步状态
}

// Prometheus 监控
func (m *MetricsCollector) Collect() {
    prometheus.MustRegister(
        prometheus.NewGaugeFunc(
            prometheus.GaugeOpts{
                Name: "wallet_balance_total",
                Help: "Total wallet balance in USD",
            },
            func() float64 {
                return m.getTotalBalance()
            },
        ),
    )
}
```

### 六、合规与审计

```go
// KYC/AML 合规
type ComplianceService struct {
    kycProvider KYCProvider
}

func (c *ComplianceService) VerifyUser(userID string) error {
    // 身份验证（KYC）
    kycResult, _ := c.kycProvider.Verify(userID)
    if !kycResult.Passed {
        return errors.New("KYC verification failed")
    }

    // 制裁名单检查
    if c.isOnSanctionsList(userID) {
        return errors.New("user on sanctions list")
    }

    return nil
}

// 大额交易报告
func (c *ComplianceService) ReportLargeTransaction(tx *Transaction) {
    if tx.Value.Cmp(big.NewInt(10000e18)) > 0 { // > $10,000
        c.fileSARReport(tx) // Suspicious Activity Report
    }
}

// 审计日志
type AuditLog struct {
    Timestamp   time.Time
    UserID      string
    Action      string  // create_wallet/send_tx/export_key
    Details     string
    IPAddress   string
    DeviceInfo  string
}
```

### 七、部署架构

```yaml
# Kubernetes 部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wallet-api
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: wallet-api
        image: wallet-api:v1.0
        env:
        - name: ETH_NODE_URL
          value: "https://mainnet.infura.io/v3/YOUR_KEY"
        - name: HSM_ENDPOINT
          valueFrom:
            secretKeyRef:
              name: hsm-config
              key: endpoint
        resources:
          limits:
            cpu: "2"
            memory: "4Gi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
---
# Redis 缓存
apiVersion: v1
kind: Service
metadata:
  name: redis
spec:
  ports:
  - port: 6379
  selector:
    app: redis
```

## 总结

设计一个安全可靠的区块链钱包系统需要：

1. **密钥管理**：HD 钱包 + 加密存储 + 生物识别
2. **安全架构**：冷热分离 + 多签 + HSM 硬件加密
3. **交易处理**：离线签名 + Gas 优化 + 风控系统
4. **多链支持**：统一接口 + 适配器模式
5. **合规审计**：KYC/AML + 完整日志 + 大额报告

这是一个典型的高安全性系统设计问题，私钥的安全是整个系统的生命线。
