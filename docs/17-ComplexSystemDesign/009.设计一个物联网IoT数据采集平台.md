---
title: 设计一个物联网（IoT）数据采集平台
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: iot-data-collection-platform-design
ref:
---

## 核心要点

**平台功能：** 海量设备接入、实时数据采集、边缘计算、数据存储分析、设备管理、告警规则

**技术架构：** MQTT/CoAP 协议 + 时序数据库(InfluxDB/TimescaleDB) + 流式计算(Flink/Kafka) + 边缘网关

**核心挑战：** 百万设备并发接入、TB/天级数据写入、低功耗协议、弱网环境、数据安全、实时性保证

## 详细回答

### 一、系统需求分析

#### 1.1 功能性需求

**设备层需求：**
- **设备接入**：支持多种协议（MQTT、CoAP、HTTP、WebSocket）
- **设备注册**：设备身份认证、密钥管理、批量注册
- **OTA 升级**：固件远程更新、版本管理、灰度发布
- **设备影子**：记录设备期望状态和实际状态

**数据层需求：**
- **数据采集**：传感器数据、日志、事件、告警
- **数据处理**：清洗、聚合、降采样、异常检测
- **数据存储**：时序数据、元数据、告警记录
- **数据查询**：历史查询、实时查询、聚合统计

**应用层需求：**
- **可视化大屏**：实时监控、设备分布、数据趋势
- **规则引擎**：条件触发、告警通知、自动控制
- **数据分析**：预测性维护、能耗分析、故障诊断
- **API 开放**：REST API、WebSocket 实时推送

#### 1.2 非功能性需求

- **高并发**：支持 100 万+ 设备同时在线
- **高吞吐**：处理 10 万条/秒的数据写入
- **低延迟**：端到端延迟 < 500ms
- **高可用**：99.95% SLA，故障自动切换
- **安全性**：设备认证、数据加密、访问控制
- **可扩展**：水平扩展支持设备数量增长

### 二、技术架构设计

#### 2.1 整体架构

```
┌──────────────────────────────────────────────────────────────┐
│                        设备层                                  │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │传感器    │  │ 工业网关│  │ 摄像头  │  │ 智能设备│         │
│  │(温湿度)  │  │(Modbus) │  │        │  │        │         │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘         │
│       │ MQTT       │ CoAP       │ RTSP       │ HTTP         │
└───────┼────────────┼────────────┼────────────┼──────────────┘
        │            │            │            │
        └────────────┼────────────┼────────────┘
                     │
        ┌────────────▼────────────┐
        │     边缘网关层            │
        │  - 协议转换              │
        │  - 数据预处理            │
        │  - 边缘计算              │
        │  - 本地缓存              │
        └────────────┬────────────┘
                     │ TLS/mTLS
        ┌────────────▼────────────┐
        │   IoT 接入层 (Hub)       │
        │  ┌──────────────────┐   │
        │  │ MQTT Broker集群  │   │
        │  │(EMQX/VerneMQ)    │   │
        │  └──────────────────┘   │
        │  ┌──────────────────┐   │
        │  │ 设备认证服务      │   │
        │  │(TLS/JWT/证书)    │   │
        │  └──────────────────┘   │
        └────────────┬────────────┘
                     │
        ┌────────────▼────────────┐
        │   消息队列层             │
        │  ┌──────┐  ┌──────┐     │
        │  │Kafka │  │Redis │     │
        │  │集群  │  │ Pub/Sub│   │
        │  └──────┘  └──────┘     │
        └────────────┬────────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
   ┌────▼─────┐ ┌───▼──────┐ ┌──▼────────┐
   │流式计算  │ │规则引擎  │ │ 数据存储  │
   │(Flink)   │ │(Drools)  │ │(多存储)   │
   │- 实时聚合│ │- 条件判断│ │           │
   │- 异常检测│ │- 告警触发│ │           │
   └────┬─────┘ └───┬──────┘ └──┬────────┘
        │           │           │
        └───────────┼───────────┘
                    │
        ┌───────────▼───────────┐
        │      存储层            │
        │ ┌─────────────────┐   │
        │ │ InfluxDB        │   │
        │ │(时序数据)        │   │
        │ └─────────────────┘   │
        │ ┌─────────────────┐   │
        │ │ PostgreSQL      │   │
        │ │(元数据/设备信息)│   │
        │ └─────────────────┘   │
        │ ┌─────────────────┐   │
        │ │ Elasticsearch   │   │
        │ │(日志/事件搜索)  │   │
        │ └─────────────────┘   │
        │ ┌─────────────────┐   │
        │ │ HDFS/S3         │   │
        │ │(冷数据归档)      │   │
        │ └─────────────────┘   │
        └───────────┬───────────┘
                    │
        ┌───────────▼───────────┐
        │     应用服务层         │
        │ ┌────────┐ ┌────────┐ │
        │ │设备管理│ │数据API │ │
        │ └────────┘ └────────┘ │
        │ ┌────────┐ ┌────────┐ │
        │ │告警服务│ │OTA升级 │ │
        │ └────────┘ └────────┘ │
        └───────────┬───────────┘
                    │
        ┌───────────▼───────────┐
        │     展示层             │
        │ ┌────────┐ ┌────────┐ │
        │ │管理后台│ │数据大屏│ │
        │ └────────┘ └────────┘ │
        │ ┌────────┐ ┌────────┐ │
        │ │移动App │ │开放API │ │
        │ └────────┘ └────────┘ │
        └───────────────────────┘
```

#### 2.2 核心组件详解

**（1）设备接入层（IoT Hub）**

基于 MQTT 协议实现高并发设备连接：

```go
package iothub

import (
    mqtt "github.com/eclipse/paho.mqtt.golang"
    "crypto/tls"
    "crypto/x509"
)

// IoT Hub 配置
type HubConfig struct {
    BrokerURL   string
    Port        int
    MaxClients  int
    TLSConfig   *tls.Config
}

// 设备连接管理器
type DeviceConnectionManager struct {
    broker     *EMQXBroker
    authSvc    *DeviceAuthService
    sessions   sync.Map // deviceID -> *Session
    metrics    *MetricsCollector
}

// 设备认证
type DeviceAuthService struct {
    db    *gorm.DB
    redis *redis.Client
}

// 设备凭证
type DeviceCredential struct {
    DeviceID     string
    ProductKey   string
    DeviceSecret string
    Certificate  []byte    // X.509 证书
    ExpireAt     time.Time
}

// 认证方式 1: 基于证书的双向 TLS
func (d *DeviceAuthService) AuthByClientCert(cert *x509.Certificate) error {
    // 从证书 CN 提取设备 ID
    deviceID := cert.Subject.CommonName

    // 验证设备是否注册
    device, err := d.db.GetDevice(deviceID)
    if err != nil {
        return errors.New("device not found")
    }

    // 验证证书是否匹配
    if !bytes.Equal(cert.Raw, device.Certificate) {
        return errors.New("certificate mismatch")
    }

    // 检查证书有效期
    if time.Now().After(cert.NotAfter) {
        return errors.New("certificate expired")
    }

    return nil
}

// 认证方式 2: 基于签名的一机一密
func (d *DeviceAuthService) AuthBySignature(deviceID, productKey, sign string) error {
    // 从数据库获取 DeviceSecret
    secret, err := d.redis.Get(fmt.Sprintf("device:secret:%s", deviceID)).Result()
    if err != nil {
        secret, _ = d.db.GetDeviceSecret(deviceID)
        d.redis.Set(fmt.Sprintf("device:secret:%s", deviceID), secret, 24*time.Hour)
    }

    // 计算签名: HMAC-SHA256(productKey + deviceID, secret)
    expectedSign := hmacSHA256(productKey+deviceID, secret)

    if sign != expectedSign {
        return errors.New("signature verification failed")
    }

    return nil
}

// MQTT 连接处理
func (m *DeviceConnectionManager) HandleConnect(client mqtt.Client) {
    opts := client.OptionsReader()
    deviceID := opts.ClientID()

    log.Infof("设备连接: %s", deviceID)

    // 创建会话
    session := &Session{
        DeviceID:    deviceID,
        ConnectedAt: time.Now(),
        Client:      client,
    }
    m.sessions.Store(deviceID, session)

    // 订阅下行主题
    // Topic: /sys/{productKey}/{deviceID}/thing/service/property/set
    downlinkTopic := fmt.Sprintf("/sys/%s/thing/service/property/set", deviceID)
    client.Subscribe(downlinkTopic, 1, m.handleDownlinkMessage)

    // 更新设备在线状态
    m.updateDeviceStatus(deviceID, "online")

    // 上报指标
    m.metrics.OnlineDevices.Inc()
}

// 处理设备上报数据
func (m *DeviceConnectionManager) HandleMessage(client mqtt.Client, msg mqtt.Message) {
    // Topic: /sys/{productKey}/{deviceID}/thing/event/property/post
    deviceID := extractDeviceID(msg.Topic())

    // 解析数据
    var payload DeviceData
    json.Unmarshal(msg.Payload(), &payload)

    // 数据校验
    if err := m.validateData(&payload); err != nil {
        log.Errorf("数据校验失败: %v", err)
        return
    }

    // 发送到 Kafka
    m.publishToKafka(deviceID, &payload)

    // 触发规则引擎
    m.triggerRuleEngine(deviceID, &payload)
}

// 设备数据模型
type DeviceData struct {
    DeviceID  string                 `json:"device_id"`
    Timestamp int64                  `json:"timestamp"`
    Data      map[string]interface{} `json:"data"`
}

// 示例数据：
// {
//   "device_id": "sensor001",
//   "timestamp": 1704067200000,
//   "data": {
//     "temperature": 25.6,
//     "humidity": 60.2,
//     "battery": 85
//   }
// }
```

**（2）边缘网关**

在设备端附近部署边缘计算节点，减少云端压力：

```go
package edge

// 边缘网关
type EdgeGateway struct {
    gatewayID   string
    cloudClient mqtt.Client
    localCache  *LocalStorage
    rules       []*EdgeRule
}

// 边缘规则
type EdgeRule struct {
    ID        string
    Condition string  // 条件表达式
    Action    string  // 动作: alert/control/aggregate
}

// 数据预处理
func (g *EdgeGateway) ProcessData(data *SensorData) {
    // 1. 数据清洗
    cleaned := g.cleanData(data)

    // 2. 异常值过滤
    if g.isAnomaly(cleaned) {
        log.Warnf("异常数据: %v", cleaned)
        // 直接上报异常
        g.uploadToCloud(cleaned)
        return
    }

    // 3. 本地聚合（降低上报频率）
    g.localCache.Add(cleaned)

    // 每 10 条或每 60 秒上报一次
    if g.shouldUpload() {
        aggregated := g.aggregate(g.localCache.GetAll())
        g.uploadToCloud(aggregated)
        g.localCache.Clear()
    }

    // 4. 边缘规则执行
    for _, rule := range g.rules {
        if g.evaluateRule(rule, cleaned) {
            g.executeAction(rule, cleaned)
        }
    }
}

// 数据聚合示例
func (g *EdgeGateway) aggregate(dataList []*SensorData) *AggregatedData {
    result := &AggregatedData{
        DeviceID:  g.gatewayID,
        StartTime: dataList[0].Timestamp,
        EndTime:   dataList[len(dataList)-1].Timestamp,
        Count:     len(dataList),
    }

    // 计算平均值、最大值、最小值
    var tempSum, humSum float64
    tempMax, humMax := -999.0, -999.0
    tempMin, humMin := 999.0, 999.0

    for _, data := range dataList {
        tempSum += data.Temperature
        humSum += data.Humidity

        if data.Temperature > tempMax {
            tempMax = data.Temperature
        }
        if data.Temperature < tempMin {
            tempMin = data.Temperature
        }
    }

    result.AvgTemperature = tempSum / float64(len(dataList))
    result.MaxTemperature = tempMax
    result.MinTemperature = tempMin

    return result
}

// 边缘 AI 推理（示例：异常检测）
func (g *EdgeGateway) detectAnomaly(data *SensorData) bool {
    // 加载 TensorFlow Lite 模型
    model := g.loadModel("anomaly_detection.tflite")

    // 特征提取
    features := []float32{
        float32(data.Temperature),
        float32(data.Humidity),
        float32(data.Pressure),
    }

    // 推理
    result := model.Predict(features)

    // 判断是否异常（阈值 0.8）
    return result > 0.8
}
```

**（3）流式计算引擎（Flink）**

```java
// Flink 实时数据处理任务
public class IoTDataProcessingJob {

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // 1. 从 Kafka 读取数据
        FlinkKafkaConsumer<DeviceData> kafkaSource = new FlinkKafkaConsumer<>(
            "iot-data-topic",
            new DeviceDataSchema(),
            kafkaProperties
        );

        DataStream<DeviceData> dataStream = env
            .addSource(kafkaSource)
            .assignTimestampsAndWatermarks(
                WatermarkStrategy
                    .<DeviceData>forBoundedOutOfOrderness(Duration.ofSeconds(5))
                    .withTimestampAssigner((event, timestamp) -> event.getTimestamp())
            );

        // 2. 数据清洗和转换
        DataStream<CleanedData> cleanedStream = dataStream
            .filter(data -> data.getTemperature() != null)
            .map(new DataCleanFunction());

        // 3. 按设备分组，计算 5 分钟滑动窗口的聚合指标
        DataStream<AggregatedMetrics> aggregated = cleanedStream
            .keyBy(DeviceData::getDeviceId)
            .window(TumblingEventTimeWindows.of(Time.minutes(5)))
            .aggregate(new TemperatureAggregateFunction());

        // 4. 异常检测
        DataStream<Alert> alerts = cleanedStream
            .keyBy(DeviceData::getDeviceId)
            .flatMap(new AnomalyDetectionFunction());

        // 5. 输出到不同目标
        aggregated.addSink(new InfluxDBSink());  // 时序数据库
        alerts.addSink(new AlertKafkaSink());    // 告警队列

        env.execute("IoT Data Processing Job");
    }

    // 聚合函数：计算平均温度
    public static class TemperatureAggregateFunction
            implements AggregateFunction<DeviceData, TemperatureAccumulator, AggregatedMetrics> {

        @Override
        public TemperatureAccumulator createAccumulator() {
            return new TemperatureAccumulator(0.0, 0);
        }

        @Override
        public TemperatureAccumulator add(DeviceData value, TemperatureAccumulator acc) {
            return new TemperatureAccumulator(
                acc.sum + value.getTemperature(),
                acc.count + 1
            );
        }

        @Override
        public AggregatedMetrics getResult(TemperatureAccumulator acc) {
            return new AggregatedMetrics(
                acc.sum / acc.count,  // 平均值
                acc.count
            );
        }

        @Override
        public TemperatureAccumulator merge(TemperatureAccumulator a, TemperatureAccumulator b) {
            return new TemperatureAccumulator(a.sum + b.sum, a.count + b.count);
        }
    }

    // 异常检测函数
    public static class AnomalyDetectionFunction extends RichFlatMapFunction<DeviceData, Alert> {
        private transient ValueState<Double> lastTemperature;

        @Override
        public void open(Configuration config) {
            ValueStateDescriptor<Double> descriptor = new ValueStateDescriptor<>(
                "lastTemperature",
                Types.DOUBLE
            );
            lastTemperature = getRuntimeContext().getState(descriptor);
        }

        @Override
        public void flatMap(DeviceData value, Collector<Alert> out) throws Exception {
            Double last = lastTemperature.value();

            // 温度突变检测（> 10°C）
            if (last != null && Math.abs(value.getTemperature() - last) > 10) {
                out.collect(new Alert(
                    value.getDeviceId(),
                    "TEMPERATURE_SPIKE",
                    String.format("温度突变: %.1f -> %.1f", last, value.getTemperature()),
                    System.currentTimeMillis()
                ));
            }

            // 阈值告警（> 80°C）
            if (value.getTemperature() > 80) {
                out.collect(new Alert(
                    value.getDeviceId(),
                    "HIGH_TEMPERATURE",
                    String.format("温度过高: %.1f°C", value.getTemperature()),
                    System.currentTimeMillis()
                ));
            }

            lastTemperature.update(value.getTemperature());
        }
    }
}
```

**（4）规则引擎**

```go
package ruleengine

// 规则引擎
type RuleEngine struct {
    rules   []*Rule
    actions map[string]ActionHandler
}

// 规则定义
type Rule struct {
    ID          string
    Name        string
    Description string
    Condition   string  // 条件表达式（支持复杂逻辑）
    Actions     []Action
    Enabled     bool
}

// 条件示例：
// "temperature > 80 && humidity < 30"
// "battery < 20"
// "vibration > avg(vibration, 1h) * 1.5"

type Action struct {
    Type   string  // alert/webhook/control/email
    Config map[string]interface{}
}

// 规则执行
func (e *RuleEngine) Evaluate(deviceID string, data *DeviceData) {
    for _, rule := range e.rules {
        if !rule.Enabled {
            continue
        }

        // 计算条件表达式
        if e.evaluateCondition(rule.Condition, data) {
            log.Infof("规则触发: %s, 设备: %s", rule.Name, deviceID)

            // 执行动作
            for _, action := range rule.Actions {
                handler := e.actions[action.Type]
                if handler != nil {
                    handler.Execute(deviceID, data, action.Config)
                }
            }
        }
    }
}

// 条件表达式计算（使用 govaluate）
func (e *RuleEngine) evaluateCondition(condition string, data *DeviceData) bool {
    expression, err := govaluate.NewEvaluableExpression(condition)
    if err != nil {
        return false
    }

    // 构建参数
    parameters := map[string]interface{}{
        "temperature": data.Data["temperature"],
        "humidity":    data.Data["humidity"],
        "battery":     data.Data["battery"],
    }

    result, err := expression.Evaluate(parameters)
    if err != nil {
        return false
    }

    return result.(bool)
}

// 告警动作处理器
type AlertActionHandler struct {
    notifier *AlertNotifier
}

func (h *AlertActionHandler) Execute(deviceID string, data *DeviceData, config map[string]interface{}) {
    alert := &Alert{
        DeviceID:  deviceID,
        Level:     config["level"].(string),
        Message:   config["message"].(string),
        Timestamp: time.Now(),
        Data:      data,
    }

    // 发送告警
    h.notifier.Send(alert)
}

// 控制动作处理器（下发指令）
type ControlActionHandler struct {
    mqtt mqtt.Client
}

func (h *ControlActionHandler) Execute(deviceID string, data *DeviceData, config map[string]interface{}) {
    // 构造控制指令
    command := map[string]interface{}{
        "action": config["action"],
        "params": config["params"],
    }

    payload, _ := json.Marshal(command)

    // 下发到设备
    topic := fmt.Sprintf("/sys/%s/thing/service/control", deviceID)
    h.mqtt.Publish(topic, 1, false, payload)

    log.Infof("下发控制指令到设备 %s: %v", deviceID, command)
}
```

**（5）时序数据存储（InfluxDB）**

```go
package storage

import (
    influxdb2 "github.com/influxdata/influxdb-client-go/v2"
)

// 时序数据写入器
type TimeSeriesWriter struct {
    client   influxdb2.Client
    writeAPI api.WriteAPIBlocking
}

// 批量写入设备数据
func (w *TimeSeriesWriter) WriteDeviceData(dataList []*DeviceData) error {
    points := make([]*write.Point, 0, len(dataList))

    for _, data := range dataList {
        // 创建数据点
        p := influxdb2.NewPoint(
            "device_metrics",  // measurement
            map[string]string{  // tags（索引字段）
                "device_id":  data.DeviceID,
                "product_key": data.ProductKey,
                "location":   data.Location,
            },
            map[string]interface{}{  // fields（值字段）
                "temperature": data.Data["temperature"],
                "humidity":    data.Data["humidity"],
                "battery":     data.Data["battery"],
            },
            time.Unix(data.Timestamp/1000, 0),
        )
        points = append(points, p)
    }

    // 批量写入
    return w.writeAPI.WritePoint(context.Background(), points...)
}

// 查询历史数据
func (w *TimeSeriesWriter) QueryDeviceHistory(
    deviceID string,
    start, end time.Time,
) ([]*DeviceData, error) {
    query := fmt.Sprintf(`
        from(bucket: "iot-data")
        |> range(start: %s, stop: %s)
        |> filter(fn: (r) => r["_measurement"] == "device_metrics")
        |> filter(fn: (r) => r["device_id"] == "%s")
    `, start.Format(time.RFC3339), end.Format(time.RFC3339), deviceID)

    result, err := w.client.QueryAPI("my-org").Query(context.Background(), query)
    if err != nil {
        return nil, err
    }

    dataList := make([]*DeviceData, 0)
    for result.Next() {
        record := result.Record()
        dataList = append(dataList, &DeviceData{
            DeviceID:  record.ValueByKey("device_id").(string),
            Timestamp: record.Time().Unix() * 1000,
            Data: map[string]interface{}{
                record.Field(): record.Value(),
            },
        })
    }

    return dataList, nil
}

// 聚合查询（平均温度）
func (w *TimeSeriesWriter) QueryAvgTemperature(
    deviceID string,
    window time.Duration,
) ([]TimeValue, error) {
    query := fmt.Sprintf(`
        from(bucket: "iot-data")
        |> range(start: -24h)
        |> filter(fn: (r) => r["device_id"] == "%s")
        |> filter(fn: (r) => r["_field"] == "temperature")
        |> aggregateWindow(every: %s, fn: mean)
    `, deviceID, window.String())

    // 执行查询...
}
```

### 三、关键技术实现

#### 3.1 设备协议适配

**MQTT vs CoAP 选择：**

| 特性 | MQTT | CoAP |
|------|------|------|
| 传输层 | TCP | UDP |
| 开销 | 较小（2字节头） | 极小（4字节头） |
| QoS | 0/1/2三级 | 确认/非确认 |
| 适用场景 | 稳定网络 | 弱网/低功耗 |

```go
// CoAP 服务器实现
package coap

import (
    "github.com/plgd-dev/go-coap/v2/udp"
)

type CoapServer struct {
    server *udp.Server
}

func (s *CoapServer) Start() error {
    mux := coap.NewRouter()

    // 数据上报端点: coap://server/data
    mux.Handle("/data", coap.HandlerFunc(s.handleDataPost))

    // 设备注册端点
    mux.Handle("/register", coap.HandlerFunc(s.handleRegister))

    return udp.ListenAndServe("udp", ":5683", mux)
}

func (s *CoapServer) handleDataPost(w coap.ResponseWriter, r *coap.Request) {
    // 解析设备上报的数据
    var data DeviceData
    json.Unmarshal(r.Msg.Payload(), &data)

    // 处理数据
    s.processData(&data)

    // 返回 ACK
    w.SetCode(coap.Changed)
}
```

#### 3.2 设备影子（Device Shadow）

```go
// 设备影子：记录设备期望状态和实际状态
type DeviceShadow struct {
    DeviceID  string                 `json:"device_id"`
    Reported  map[string]interface{} `json:"reported"`  // 设备上报的实际状态
    Desired   map[string]interface{} `json:"desired"`   // 云端期望的状态
    Delta     map[string]interface{} `json:"delta"`     // 差异
    Version   int64                  `json:"version"`
    UpdatedAt time.Time              `json:"updated_at"`
}

// 示例：
// {
//   "device_id": "light001",
//   "reported": {"power": "off", "brightness": 0},
//   "desired": {"power": "on", "brightness": 80},
//   "delta": {"power": "on", "brightness": 80}
// }

type ShadowService struct {
    redis *redis.Client
}

// 更新期望状态
func (s *ShadowService) UpdateDesiredState(deviceID string, desired map[string]interface{}) error {
    shadow, _ := s.GetShadow(deviceID)

    shadow.Desired = desired
    shadow.Version++

    // 计算差异
    shadow.Delta = s.calculateDelta(shadow.Reported, shadow.Desired)

    // 保存到 Redis
    key := fmt.Sprintf("shadow:%s", deviceID)
    data, _ := json.Marshal(shadow)
    s.redis.Set(key, data, 0)

    // 如果有差异，下发到设备
    if len(shadow.Delta) > 0 {
        s.publishToDevice(deviceID, shadow.Delta)
    }

    return nil
}

// 设备上报实际状态
func (s *ShadowService) UpdateReportedState(deviceID string, reported map[string]interface{}) error {
    shadow, _ := s.GetShadow(deviceID)

    shadow.Reported = reported
    shadow.Version++

    // 重新计算差异
    shadow.Delta = s.calculateDelta(shadow.Reported, shadow.Desired)

    // 保存
    key := fmt.Sprintf("shadow:%s", deviceID)
    data, _ := json.Marshal(shadow)
    s.redis.Set(key, data, 0)

    return nil
}
```

#### 3.3 OTA 固件升级

```go
type OTAService struct {
    storage ObjectStorage
    mqtt    mqtt.Client
}

// 固件版本
type FirmwareVersion struct {
    Version     string
    URL         string
    MD5         string
    Size        int64
    Description string
    CreatedAt   time.Time
}

// 推送固件升级
func (o *OTAService) PushUpgrade(deviceIDs []string, version string) error {
    firmware, _ := o.db.GetFirmware(version)

    for _, deviceID := range deviceIDs {
        // 构造升级消息
        upgradeMsg := map[string]interface{}{
            "version": firmware.Version,
            "url":     firmware.URL,
            "md5":     firmware.MD5,
            "size":    firmware.Size,
        }

        payload, _ := json.Marshal(upgradeMsg)

        // 下发到设备
        topic := fmt.Sprintf("/ota/%s/upgrade", deviceID)
        o.mqtt.Publish(topic, 1, false, payload)

        log.Infof("推送固件升级到设备 %s: %s", deviceID, version)
    }

    return nil
}

// 灰度升级
func (o *OTAService) GrayRelease(version string, percentage int) error {
    // 获取所有在线设备
    devices, _ := o.db.GetOnlineDevices()

    // 随机选择指定比例的设备
    total := len(devices)
    count := total * percentage / 100

    rand.Shuffle(len(devices), func(i, j int) {
        devices[i], devices[j] = devices[j], devices[i]
    })

    selectedDevices := devices[:count]

    return o.PushUpgrade(selectedDevices, version)
}
```

### 四、性能优化

#### 4.1 数据降采样

```go
// 降采样策略：减少存储成本
func (s *DataProcessor) Downsample(data []*DeviceData, interval time.Duration) []*DeviceData {
    if len(data) == 0 {
        return data
    }

    result := make([]*DeviceData, 0)
    bucket := make([]*DeviceData, 0)
    bucketStart := data[0].Timestamp

    for _, d := range data {
        // 如果超出时间窗口，聚合当前 bucket
        if d.Timestamp-bucketStart > interval.Milliseconds() {
            aggregated := s.aggregateBucket(bucket)
            result = append(result, aggregated)

            bucket = make([]*DeviceData, 0)
            bucketStart = d.Timestamp
        }

        bucket = append(bucket, d)
    }

    // 最后一个 bucket
    if len(bucket) > 0 {
        result = append(result, s.aggregateBucket(bucket))
    }

    return result
}
```

#### 4.2 数据压缩

```go
// 使用 Snappy 压缩数据
func compressData(data []byte) []byte {
    return snappy.Encode(nil, data)
}

// 批量上传时压缩
func (g *EdgeGateway) uploadCompressed(dataList []*DeviceData) {
    // 序列化
    raw, _ := json.Marshal(dataList)

    // 压缩（减少 60-80% 流量）
    compressed := snappy.Encode(nil, raw)

    // 上传
    g.cloudClient.Publish("data/compressed", 1, false, compressed)
}
```

### 五、安全设计

#### 5.1 设备认证

```go
// 一机一密方案
func (a *AuthService) RegisterDevice(productKey, deviceName string) (*DeviceCredential, error) {
    // 生成 DeviceSecret
    secret := generateRandomString(32)

    // 生成设备 ID
    deviceID := fmt.Sprintf("%s.%s", productKey, deviceName)

    // 保存到数据库
    cred := &DeviceCredential{
        DeviceID:     deviceID,
        ProductKey:   productKey,
        DeviceSecret: secret,
        ExpireAt:     time.Now().AddDate(10, 0, 0), // 10 年
    }

    a.db.Create(cred)

    return cred, nil
}

// 设备端签名连接
func connectToIoTHub(deviceID, productKey, secret string) {
    // 计算签名
    timestamp := time.Now().Unix()
    signContent := fmt.Sprintf("%s%s%d", productKey, deviceID, timestamp)
    sign := hmacSHA256(signContent, secret)

    // MQTT 连接参数
    opts := mqtt.NewClientOptions()
    opts.AddBroker("tls://iot-hub.example.com:8883")
    opts.SetClientID(deviceID)
    opts.SetUsername(deviceID)
    opts.SetPassword(fmt.Sprintf("sign=%s&timestamp=%d", sign, timestamp))

    client := mqtt.NewClient(opts)
    client.Connect()
}
```

#### 5.2 数据加密

```go
// 端到端加密（AES-128）
func (e *EdgeGateway) encryptData(data []byte, key []byte) []byte {
    block, _ := aes.NewCipher(key)
    gcm, _ := cipher.NewGCM(block)

    nonce := make([]byte, gcm.NonceSize())
    rand.Read(nonce)

    return gcm.Seal(nonce, nonce, data, nil)
}
```

### 六、监控告警

```go
// 系统监控指标
type IoTMetrics struct {
    // 设备指标
    OnlineDevices   int
    TotalDevices    int
    MessageRate     float64  // 消息/秒

    // 数据指标
    DataWriteRate   float64  // 写入/秒
    DataStorageSize int64    // 存储大小

    // 性能指标
    AvgLatency      time.Duration
    P99Latency      time.Duration

    // 异常指标
    OfflineDevices  int
    AlertCount      int
}

// Prometheus 集成
func (m *MetricsCollector) Export() {
    prometheus.NewGaugeFunc(
        prometheus.GaugeOpts{
            Name: "iot_online_devices",
            Help: "Number of online devices",
        },
        func() float64 {
            return float64(m.getOnlineDevices())
        },
    )
}
```

### 七、部署方案

```yaml
# Kubernetes 部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iot-hub
spec:
  replicas: 5
  template:
    spec:
      containers:
      - name: emqx
        image: emqx/emqx:5.0
        resources:
          limits:
            cpu: "4"
            memory: "8Gi"
        env:
        - name: EMQX_NODE__PROCESS_LIMIT
          value: "2097152"
        - name: EMQX_LISTENER__TCP__EXTERNAL__MAX_CONNECTIONS
          value: "1024000"
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: influxdb
spec:
  serviceName: influxdb
  replicas: 3
  template:
    spec:
      containers:
      - name: influxdb
        image: influxdb:2.7
        volumeMounts:
        - name: data
          mountPath: /var/lib/influxdb2
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Ti
```

## 总结

设计一个生产级 IoT 数据采集平台需要考虑：

1. **协议选择**：MQTT/CoAP 根据场景选择，支持海量设备接入
2. **边缘计算**：数据预处理、本地决策，降低云端压力
3. **流式处理**：Flink 实时计算，毫秒级响应
4. **时序存储**：InfluxDB 高效存储和查询时序数据
5. **安全认证**：一机一密 + TLS 加密 + 设备影子
6. **弹性扩展**：微服务架构 + Kubernetes 部署

这是一个典型的高并发、低延迟、大数据量的系统设计问题，核心在于分层架构和边缘计算。
