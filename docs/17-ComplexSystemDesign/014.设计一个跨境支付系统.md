---
title: 设计一个跨境支付系统
tags:
  - 复杂系统设计
status: robot
class: 复杂系统设计
slug: cross-border-payment-system-design
ref:
---

## 核心要点

**跨境支付 = 多币种结算 + 合规风控 + 汇率管理 + 渠道路由**

关键特性：多币种支持、实时汇率、资金清算、KYC/AML、外汇风险对冲、支付路由、对账系统

核心挑战：强一致性保证、合规性要求、汇率波动风险、跨时区处理、手续费优化、资金安全

## 详细回答

### 一、业务理解与架构设计

面试官您好，设计一个跨境支付系统需要考虑金融合规、多币种结算、风险控制等复杂场景。

#### 1. 核心业务流程

```
用户发起支付 → KYC/AML 检查 → 汇率锁定 → 支付路由选择 →
本地货币扣款 → 换汇 → 跨境清算 → 目标货币到账 → 对账
```

#### 2. 系统架构分层

```
┌─────────────────────────────────────────────────┐
│  接入层：Web/App/OpenAPI                         │
├─────────────────────────────────────────────────┤
│  业务层                                          │
│  ┌──────────┬─────────┬──────────┬──────────┐  │
│  │订单服务  │风控服务 │汇率服务  │路由服务  │  │
│  └──────────┴─────────┴──────────┴──────────┘  │
├─────────────────────────────────────────────────┤
│  核心层                                          │
│  ┌──────────┬─────────┬──────────┬──────────┐  │
│  │账务系统  │清算系统 │对账系统  │资金池    │  │
│  └──────────┴─────────┴──────────┴──────────┘  │
├─────────────────────────────────────────────────┤
│  通道层：SWIFT / 本地清算网络 / 第三方支付      │
└─────────────────────────────────────────────────┘
```

### 二、核心模块设计

#### 1. 订单服务 - 状态机设计

```go
// 订单状态流转
type OrderStatus int

const (
    StatusCreated      OrderStatus = 1  // 已创建
    StatusRiskChecked  OrderStatus = 2  // 风控通过
    StatusRateLocked   OrderStatus = 3  // 汇率锁定
    StatusDebited      OrderStatus = 4  // 已扣款
    StatusExchanging   OrderStatus = 5  // 换汇中
    StatusClearing     OrderStatus = 6  // 清算中
    StatusCompleted    OrderStatus = 7  // 已完成
    StatusFailed       OrderStatus = 99 // 失败
)

// 订单数据模型
type CrossBorderOrder struct {
    OrderID         string          `json:"order_id"`
    UserID          string          `json:"user_id"`

    // 源货币信息
    SourceCurrency  string          `json:"source_currency"`  // USD
    SourceAmount    decimal.Decimal `json:"source_amount"`    // 1000.00

    // 目标货币信息
    TargetCurrency  string          `json:"target_currency"`  // CNY
    TargetAmount    decimal.Decimal `json:"target_amount"`    // 7200.00

    // 汇率信息
    ExchangeRate    decimal.Decimal `json:"exchange_rate"`    // 7.2
    RateLockedAt    time.Time       `json:"rate_locked_at"`
    RateExpireAt    time.Time       `json:"rate_expire_at"`   // 汇率有效期30秒

    // 费用明细
    PlatformFee     decimal.Decimal `json:"platform_fee"`     // 平台手续费
    ChannelFee      decimal.Decimal `json:"channel_fee"`      // 通道费用
    FxMarkup        decimal.Decimal `json:"fx_markup"`        // 汇率加价

    // 收款人信息
    BeneficiaryName string          `json:"beneficiary_name"`
    BeneficiaryBank string          `json:"beneficiary_bank"`
    BeneficiaryAcct string          `json:"beneficiary_account"`
    SwiftCode       string          `json:"swift_code"`

    // 状态跟踪
    Status          OrderStatus     `json:"status"`
    ChannelOrderID  string          `json:"channel_order_id"` // 通道订单号
    CreatedAt       time.Time       `json:"created_at"`
    CompletedAt     *time.Time      `json:"completed_at"`
}

// 状态流转逻辑（有限状态机）
type OrderStateMachine struct {
    order *CrossBorderOrder
    db    *gorm.DB
}

func (sm *OrderStateMachine) TransitionTo(newStatus OrderStatus) error {
    // 检查状态转换是否合法
    if !sm.isValidTransition(sm.order.Status, newStatus) {
        return fmt.Errorf("invalid transition: %d -> %d", sm.order.Status, newStatus)
    }

    // 数据库事务更新状态
    tx := sm.db.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // 乐观锁更新（防止并发修改）
    result := tx.Model(&CrossBorderOrder{}).
        Where("order_id = ? AND status = ?", sm.order.OrderID, sm.order.Status).
        Update("status", newStatus)

    if result.RowsAffected == 0 {
        tx.Rollback()
        return errors.New("concurrent modification detected")
    }

    // 记录状态变更日志
    tx.Create(&OrderStatusLog{
        OrderID:    sm.order.OrderID,
        OldStatus:  sm.order.Status,
        NewStatus:  newStatus,
        ChangedAt:  time.Now(),
    })

    tx.Commit()
    sm.order.Status = newStatus
    return nil
}

func (sm *OrderStateMachine) isValidTransition(from, to OrderStatus) bool {
    validTransitions := map[OrderStatus][]OrderStatus{
        StatusCreated:     {StatusRiskChecked, StatusFailed},
        StatusRiskChecked: {StatusRateLocked, StatusFailed},
        StatusRateLocked:  {StatusDebited, StatusFailed},
        StatusDebited:     {StatusExchanging, StatusFailed},
        StatusExchanging:  {StatusClearing, StatusFailed},
        StatusClearing:    {StatusCompleted, StatusFailed},
    }

    allowedStates := validTransitions[from]
    for _, allowed := range allowedStates {
        if allowed == to {
            return true
        }
    }
    return false
}
```

#### 2. 风控服务 - 多维度检查

```go
type RiskCheckService struct {
    kycService  *KYCService
    amlService  *AMLService
    ruleEngine  *RuleEngine
    redisClient *redis.Client
}

// 风控检查入口
func (rcs *RiskCheckService) CheckOrder(ctx context.Context, order *CrossBorderOrder) error {
    // 1. KYC 检查（身份验证）
    if err := rcs.kycService.Verify(ctx, order.UserID); err != nil {
        return fmt.Errorf("KYC failed: %w", err)
    }

    // 2. AML 检查（反洗钱）
    if err := rcs.amlService.ScreenTransaction(ctx, order); err != nil {
        return fmt.Errorf("AML screening failed: %w", err)
    }

    // 3. 限额检查
    if err := rcs.checkLimits(ctx, order); err != nil {
        return err
    }

    // 4. 频率控制
    if err := rcs.checkFrequency(ctx, order); err != nil {
        return err
    }

    // 5. 规则引擎评分
    riskScore := rcs.ruleEngine.Evaluate(order)
    if riskScore > 80 {
        // 高风险订单，人工审核
        rcs.sendToManualReview(order)
        return errors.New("high risk, manual review required")
    }

    return nil
}

// 限额检查（单笔/单日/单月）
func (rcs *RiskCheckService) checkLimits(ctx context.Context, order *CrossBorderOrder) error {
    // 单笔限额
    if order.SourceAmount.GreaterThan(decimal.NewFromInt(50000)) {
        return errors.New("exceeds single transaction limit")
    }

    // 单日限额（使用 Redis 统计）
    dailyKey := fmt.Sprintf("limit:daily:%s:%s", order.UserID, time.Now().Format("2006-01-02"))
    dailyAmount, _ := rcs.redisClient.Get(ctx, dailyKey).Result()

    currentDaily := decimal.NewFromFloat(parseFloat(dailyAmount))
    newDaily := currentDaily.Add(order.SourceAmount)

    if newDaily.GreaterThan(decimal.NewFromInt(100000)) {
        return errors.New("exceeds daily limit")
    }

    // 更新当日累计金额
    pipe := rcs.redisClient.Pipeline()
    pipe.IncrByFloat(ctx, dailyKey, order.SourceAmount.InexactFloat64())
    pipe.Expire(ctx, dailyKey, 24*time.Hour)
    pipe.Exec(ctx)

    return nil
}

// AML 反洗钱筛查
type AMLService struct {
    sanctionListCache *cache.Cache
}

func (aml *AMLService) ScreenTransaction(ctx context.Context, order *CrossBorderOrder) error {
    // 1. 检查制裁名单（OFAC/UN/EU）
    if aml.isOnSanctionList(order.BeneficiaryName) {
        return errors.New("beneficiary on sanction list")
    }

    // 2. 高风险国家检查
    beneficiaryCountry := aml.extractCountryFromSwift(order.SwiftCode)
    if aml.isHighRiskCountry(beneficiaryCountry) {
        // 需要额外尽职调查
        return errors.New("high risk country")
    }

    // 3. 结构化交易检测（拆分大额交易规避监管）
    if aml.detectStructuring(ctx, order.UserID, order.SourceAmount) {
        return errors.New("potential structuring detected")
    }

    return nil
}

func (aml *AMLService) detectStructuring(ctx context.Context, userID string, amount decimal.Decimal) bool {
    // 检查最近24小时内的交易是否存在可疑拆分
    // 例如：10笔 9000 美元的交易（规避 10000 美元申报门槛）
    recentOrders := aml.getRecentOrders(userID, 24*time.Hour)

    var total decimal.Decimal
    count := 0
    for _, order := range recentOrders {
        if order.SourceAmount.GreaterThan(decimal.NewFromInt(8000)) &&
           order.SourceAmount.LessThan(decimal.NewFromInt(10000)) {
            total = total.Add(order.SourceAmount)
            count++
        }
    }

    // 如果有多笔接近但低于监管门槛的交易，标记为可疑
    return count >= 3 && total.GreaterThan(decimal.NewFromInt(25000))
}
```

#### 3. 汇率服务 - 多源聚合与对冲

```go
type ExchangeRateService struct {
    providers  []RateProvider  // 多个汇率数据源
    cache      *redis.Client
    rateEngine *HedgingEngine
}

// 汇率数据源接口
type RateProvider interface {
    GetRate(from, to string) (decimal.Decimal, error)
    GetProviderName() string
}

// 获取实时汇率（多源聚合）
func (ers *ExchangeRateService) GetRealTimeRate(from, to string) (decimal.Decimal, error) {
    cacheKey := fmt.Sprintf("fx:%s:%s", from, to)

    // 1. 优先从缓存获取（1秒缓存）
    if cached, err := ers.cache.Get(context.Background(), cacheKey).Result(); err == nil {
        return decimal.NewFromString(cached)
    }

    // 2. 从多个数据源获取汇率
    rates := make([]decimal.Decimal, 0)
    for _, provider := range ers.providers {
        rate, err := provider.GetRate(from, to)
        if err == nil {
            rates = append(rates, rate)
        }
    }

    if len(rates) == 0 {
        return decimal.Zero, errors.New("no rate available")
    }

    // 3. 计算中位数汇率（防止单一数据源异常）
    sort.Slice(rates, func(i, j int) bool {
        return rates[i].LessThan(rates[j])
    })
    medianRate := rates[len(rates)/2]

    // 4. 加上汇率加价（平台利润来源）
    markup := decimal.NewFromFloat(0.005) // 0.5% 加价
    finalRate := medianRate.Mul(decimal.NewFromInt(1).Add(markup))

    // 5. 缓存1秒
    ers.cache.Set(context.Background(), cacheKey, finalRate.String(), 1*time.Second)

    return finalRate, nil
}

// 汇率锁定（防止用户支付期间汇率波动）
func (ers *ExchangeRateService) LockRate(order *CrossBorderOrder) error {
    rate, err := ers.GetRealTimeRate(order.SourceCurrency, order.TargetCurrency)
    if err != nil {
        return err
    }

    order.ExchangeRate = rate
    order.RateLockedAt = time.Now()
    order.RateExpireAt = time.Now().Add(30 * time.Second) // 汇率锁定30秒
    order.TargetAmount = order.SourceAmount.Mul(rate)

    // 计算手续费
    order.FxMarkup = order.TargetAmount.Mul(decimal.NewFromFloat(0.005))

    return nil
}

// 外汇对冲引擎（降低汇率风险）
type HedgingEngine struct {
    positionTracker *PositionTracker
    hedgingAPI      *ForexBrokerAPI
}

// 实时监控外汇敞口
func (he *HedgingEngine) MonitorExposure() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        positions := he.positionTracker.GetAllPositions()

        for currencyPair, netPosition := range positions {
            // 如果净敞口超过阈值，执行对冲
            threshold := decimal.NewFromInt(100000) // 10万美元

            if netPosition.Abs().GreaterThan(threshold) {
                he.executeHedge(currencyPair, netPosition)
            }
        }
    }
}

func (he *HedgingEngine) executeHedge(pair string, position decimal.Decimal) error {
    // 通过外汇经纪商 API 执行对冲交易
    // 例如：净多头 USD/CNY 150,000 → 在市场上卖出 150,000 USD

    order := &HedgeOrder{
        CurrencyPair: pair,
        Amount:       position.Abs(),
        Side:         getHedgeSide(position), // position > 0 → Sell, position < 0 → Buy
    }

    return he.hedgingAPI.PlaceOrder(order)
}
```

#### 4. 支付路由 - 最优通道选择

```go
type PaymentRouter struct {
    channels []PaymentChannel
    scorer   *ChannelScorer
}

type PaymentChannel interface {
    GetChannelID() string
    GetSupportedCurrencies() []string
    GetFee(amount decimal.Decimal) decimal.Decimal
    GetEstimatedArrivalTime() time.Duration
    GetSuccessRate() float64
    Execute(order *CrossBorderOrder) error
}

// 通道评分模型
type ChannelScorer struct{}

func (cs *ChannelScorer) Score(channel PaymentChannel, order *CrossBorderOrder) float64 {
    // 综合评分 = 费用(40%) + 速度(30%) + 成功率(20%) + 可用性(10%)

    fee := channel.GetFee(order.SourceAmount)
    feeScore := 100 - (fee.Div(order.SourceAmount).Mul(decimal.NewFromInt(100)).InexactFloat64())

    arrivalTime := channel.GetEstimatedArrivalTime()
    speedScore := 100 - (float64(arrivalTime.Minutes()) / 1440 * 100) // 归一化到0-100

    successRate := channel.GetSuccessRate()
    successScore := successRate * 100

    availabilityScore := 100.0 // 简化处理

    totalScore := feeScore*0.4 + speedScore*0.3 + successScore*0.2 + availabilityScore*0.1
    return totalScore
}

// 路由决策
func (pr *PaymentRouter) Route(order *CrossBorderOrder) (PaymentChannel, error) {
    // 1. 过滤支持该币种对的通道
    candidates := make([]PaymentChannel, 0)
    for _, channel := range pr.channels {
        if pr.supportsCurrencyPair(channel, order.SourceCurrency, order.TargetCurrency) {
            candidates = append(candidates, channel)
        }
    }

    if len(candidates) == 0 {
        return nil, errors.New("no available channel")
    }

    // 2. 计算每个通道的评分
    type scoredChannel struct {
        channel PaymentChannel
        score   float64
    }

    scored := make([]scoredChannel, 0)
    for _, channel := range candidates {
        score := pr.scorer.Score(channel, order)
        scored = append(scored, scoredChannel{channel, score})
    }

    // 3. 选择评分最高的通道
    sort.Slice(scored, func(i, j int) bool {
        return scored[i].score > scored[j].score
    })

    return scored[0].channel, nil
}

// 示例：SWIFT 通道实现
type SwiftChannel struct {
    swiftClient *SwiftClient
}

func (sc *SwiftChannel) Execute(order *CrossBorderOrder) error {
    // 构造 SWIFT MT103 报文
    mt103 := &MT103Message{
        TransactionRef:  order.OrderID,
        ValueDate:       time.Now().Format("060102"),
        Currency:        order.TargetCurrency,
        Amount:          order.TargetAmount.String(),
        OrderingCustomer: CustomerInfo{
            Account: order.UserID,
        },
        BeneficiaryCustomer: CustomerInfo{
            Name:    order.BeneficiaryName,
            Account: order.BeneficiaryAcct,
        },
        BeneficiaryBank: BankInfo{
            SwiftCode: order.SwiftCode,
            Name:      order.BeneficiaryBank,
        },
        RemittanceInfo: "Cross-border payment",
    }

    // 发送 SWIFT 报文
    return sc.swiftClient.SendMT103(mt103)
}
```

### 三、关键技术挑战

#### 1. 分布式事务 - Saga 模式

跨境支付涉及多个步骤（扣款、换汇、清算），使用 Saga 模式保证最终一致性：

```go
type PaymentSaga struct {
    order        *CrossBorderOrder
    compensators []Compensator // 补偿操作列表
}

type Compensator func() error

// 执行 Saga 流程
func (saga *PaymentSaga) Execute() error {
    // Step 1: 扣款
    if err := saga.debitSourceAccount(); err != nil {
        return err
    }
    saga.compensators = append(saga.compensators, saga.refundSourceAccount)

    // Step 2: 换汇
    if err := saga.exchangeCurrency(); err != nil {
        saga.rollback()
        return err
    }
    saga.compensators = append(saga.compensators, saga.reverseExchange)

    // Step 3: 跨境清算
    if err := saga.crossBorderClearing(); err != nil {
        saga.rollback()
        return err
    }

    // Step 4: 入账
    if err := saga.creditBeneficiaryAccount(); err != nil {
        saga.rollback()
        return err
    }

    return nil
}

// 回滚操作
func (saga *PaymentSaga) rollback() {
    // 逆序执行补偿操作
    for i := len(saga.compensators) - 1; i >= 0; i-- {
        if err := saga.compensators[i](); err != nil {
            // 补偿失败，记录日志，人工介入
            log.Errorf("compensation failed: %v", err)
        }
    }
}

func (saga *PaymentSaga) debitSourceAccount() error {
    // 调用账务系统扣款
    return accountingService.Debit(saga.order.UserID, saga.order.SourceAmount)
}

func (saga *PaymentSaga) refundSourceAccount() error {
    // 补偿：退款
    return accountingService.Credit(saga.order.UserID, saga.order.SourceAmount)
}
```

#### 2. 对账系统 - 三方对账

```go
type ReconciliationService struct {
    db              *gorm.DB
    channelClients  map[string]ChannelClient
}

// 每日对账任务
func (rs *ReconciliationService) DailyReconciliation(date time.Time) error {
    // 1. 获取内部订单数据
    internalOrders := rs.getInternalOrders(date)

    // 2. 从各通道获取对账文件
    channelOrders := make(map[string][]ChannelOrder)
    for channelID, client := range rs.channelClients {
        orders, err := client.DownloadReconciliationFile(date)
        if err != nil {
            log.Errorf("failed to download recon file from %s: %v", channelID, err)
            continue
        }
        channelOrders[channelID] = orders
    }

    // 3. 三方对账：内部订单 vs 通道订单 vs 银行流水
    diff := rs.compareOrders(internalOrders, channelOrders)

    // 4. 处理差异
    for _, discrepancy := range diff {
        switch discrepancy.Type {
        case "missing_in_channel":
            // 内部有记录，通道无记录 → 可能是通道未处理，需重推
            rs.handleMissingInChannel(discrepancy.Order)
        case "missing_internally":
            // 通道有记录，内部无记录 → 可能是回调丢失，需补单
            rs.handleMissingInternally(discrepancy.ChannelOrder)
        case "amount_mismatch":
            // 金额不一致 → 人工核查
            rs.reportDiscrepancy(discrepancy)
        }
    }

    return nil
}

type Discrepancy struct {
    Type         string
    Order        *CrossBorderOrder
    ChannelOrder *ChannelOrder
    Reason       string
}

func (rs *ReconciliationService) compareOrders(
    internal []*CrossBorderOrder,
    channel map[string][]ChannelOrder,
) []Discrepancy {
    diffs := make([]Discrepancy, 0)

    // 构建通道订单索引
    channelMap := make(map[string]*ChannelOrder)
    for _, orders := range channel {
        for _, order := range orders {
            channelMap[order.OrderID] = &order
        }
    }

    // 比对内部订单
    for _, order := range internal {
        channelOrder, exists := channelMap[order.OrderID]

        if !exists {
            diffs = append(diffs, Discrepancy{
                Type:  "missing_in_channel",
                Order: order,
            })
            continue
        }

        // 比对金额
        if !order.TargetAmount.Equal(channelOrder.Amount) {
            diffs = append(diffs, Discrepancy{
                Type:         "amount_mismatch",
                Order:        order,
                ChannelOrder: channelOrder,
                Reason:       fmt.Sprintf("amount diff: %s vs %s",
                    order.TargetAmount, channelOrder.Amount),
            })
        }

        delete(channelMap, order.OrderID)
    }

    // 剩余的通道订单是内部缺失的
    for _, channelOrder := range channelMap {
        diffs = append(diffs, Discrepancy{
            Type:         "missing_internally",
            ChannelOrder: channelOrder,
        })
    }

    return diffs
}
```

#### 3. 幂等性保证

```go
type IdempotencyMiddleware struct {
    redis *redis.Client
}

func (im *IdempotencyMiddleware) Handle(c *gin.Context) {
    idempotencyKey := c.GetHeader("Idempotency-Key")
    if idempotencyKey == "" {
        c.Next()
        return
    }

    // 检查是否已处理过
    cacheKey := fmt.Sprintf("idempotency:%s", idempotencyKey)
    cached, err := im.redis.Get(c, cacheKey).Result()

    if err == nil {
        // 已处理过，直接返回缓存的响应
        var response map[string]interface{}
        json.Unmarshal([]byte(cached), &response)
        c.JSON(200, response)
        c.Abort()
        return
    }

    // 使用 SET NX 原子操作防止并发
    acquired, _ := im.redis.SetNX(c, cacheKey+":lock", "1", 10*time.Second).Result()
    if !acquired {
        c.JSON(409, gin.H{"error": "duplicate request in progress"})
        c.Abort()
        return
    }

    // 执行业务逻辑
    c.Next()

    // 缓存响应结果（24小时）
    if c.Writer.Status() < 300 {
        responseData := c.Keys["response"]
        responseJSON, _ := json.Marshal(responseData)
        im.redis.Set(c, cacheKey, responseJSON, 24*time.Hour)
    }
}
```

### 四、性能优化

#### 1. 数据库分片

```go
// 按用户ID哈希分片
func getShardID(userID string) int {
    hash := crc32.ChecksumIEEE([]byte(userID))
    return int(hash % 16) // 16个分片
}

// 路由到对应分片
func (db *ShardedDB) GetConnection(userID string) *gorm.DB {
    shardID := getShardID(userID)
    return db.shards[shardID]
}

// 订单表分表策略
// orders_0, orders_1, ..., orders_15
// order_logs_0, order_logs_1, ..., order_logs_15
```

#### 2. 异步处理 + 消息队列

```go
// 将耗时操作异步化
func (s *PaymentService) CreateOrder(req *CreateOrderRequest) (*CrossBorderOrder, error) {
    // 1. 快速创建订单（同步）
    order := &CrossBorderOrder{
        OrderID: generateOrderID(),
        Status:  StatusCreated,
        // ... 其他字段
    }
    s.db.Create(order)

    // 2. 发送消息到队列（异步处理）
    s.mqProducer.Send("payment.created", order)

    return order, nil
}

// 消费者处理订单
func (consumer *PaymentConsumer) HandlePaymentCreated(msg *Message) error {
    order := msg.Payload.(*CrossBorderOrder)

    // 风控检查
    if err := riskService.CheckOrder(order); err != nil {
        order.Status = StatusFailed
        db.Save(order)
        return err
    }

    // 汇率锁定
    rateService.LockRate(order)

    // 路由选择
    channel, _ := routerService.Route(order)

    // 执行支付
    saga := NewPaymentSaga(order, channel)
    return saga.Execute()
}
```

### 五、监控与告警

```go
// 关键指标监控
type Metrics struct {
    // 业务指标
    OrderCount          prometheus.Counter
    OrderAmount         prometheus.Gauge
    SuccessRate         prometheus.Gauge
    AverageProcessTime  prometheus.Histogram

    // 风控指标
    RiskBlockedCount    prometheus.Counter
    AMLAlertCount       prometheus.Counter

    // 财务指标
    FxExposure          prometheus.GaugeVec  // 按币种对分组
    DailyPnL            prometheus.Gauge

    // 技术指标
    APILatency          prometheus.Histogram
    DBQueryTime         prometheus.Histogram
    CacheHitRate        prometheus.Gauge
}

// 实时告警规则
func (alerter *Alerter) CheckAlerts() {
    // 1. 成功率告警（5分钟成功率 < 95%）
    if successRate := calculateSuccessRate(5 * time.Minute); successRate < 0.95 {
        alerter.Send(Alert{
            Level:   "critical",
            Message: fmt.Sprintf("Success rate dropped to %.2f%%", successRate*100),
        })
    }

    // 2. 外汇敞口告警（单一货币对敞口 > 50万美元）
    for pair, exposure := range getExposureByPair() {
        if exposure.Abs().GreaterThan(decimal.NewFromInt(500000)) {
            alerter.Send(Alert{
                Level:   "warning",
                Message: fmt.Sprintf("FX exposure for %s: $%.2f", pair, exposure),
            })
        }
    }

    // 3. 对账差异告警
    if discrepancyCount := getDiscrepancyCount(today()); discrepancyCount > 10 {
        alerter.Send(Alert{
            Level:   "high",
            Message: fmt.Sprintf("%d reconciliation discrepancies found", discrepancyCount),
        })
    }
}
```

### 六、合规性设计

#### 1. 交易报告

```go
// 大额交易报告（美国银行保密法要求）
func (reporter *ComplianceReporter) GenerateCTR(order *CrossBorderOrder) error {
    if order.SourceAmount.LessThan(decimal.NewFromInt(10000)) {
        return nil // 不需要报告
    }

    ctr := &CurrencyTransactionReport{
        FilingDate:        time.Now(),
        TransactionAmount: order.SourceAmount,
        TransactionType:   "Cross-border payment",
        ConductorInfo: PersonInfo{
            Name:    order.UserID, // 实际应该是真实姓名
            IDType:  "Passport",
            IDNumber: getUserIDNumber(order.UserID),
        },
        // ... 其他必填字段
    }

    return reporter.SubmitToFINCEN(ctr)
}

// 可疑交易报告（SAR）
func (reporter *ComplianceReporter) FileSAR(order *CrossBorderOrder, reason string) error {
    sar := &SuspiciousActivityReport{
        ReportDate:      time.Now(),
        TransactionDate: order.CreatedAt,
        Amount:          order.SourceAmount,
        SuspiciousActivity: SuspiciousActivity{
            Type:        "Structuring",
            Description: reason,
        },
        // ... 其他字段
    }

    return reporter.SubmitSAR(sar)
}
```

#### 2. 数据留存

```go
// 交易记录至少保留7年（符合金融合规要求）
type OrderArchiver struct {
    coldStorage *S3Client
}

func (archiver *OrderArchiver) ArchiveOldOrders() error {
    // 查询7天前的已完成订单
    cutoffDate := time.Now().AddDate(0, 0, -7)
    orders := db.Where("status = ? AND completed_at < ?", StatusCompleted, cutoffDate).
        Find(&CrossBorderOrder{})

    // 导出为 JSON 并压缩
    jsonData, _ := json.Marshal(orders)
    compressed := gzip.Compress(jsonData)

    // 上传到冷存储（S3 Glacier）
    archiver.coldStorage.Upload("orders/archive/"+cutoffDate.Format("2006-01-02")+".json.gz", compressed)

    return nil
}
```

### 七、全球化部署

```
┌─────────────────────────────────────────────────┐
│  用户请求 → CDN → 就近接入点                      │
├─────────────────────────────────────────────────┤
│  北美区域                                        │
│  - 订单服务（us-east-1）                         │
│  - 风控服务（本地）                               │
│  - 数据库主库（Aurora Global）                   │
├─────────────────────────────────────────────────┤
│  欧洲区域                                        │
│  - 订单服务（eu-west-1）                         │
│  - 风控服务（本地）                               │
│  - 数据库只读副本                                │
├─────────────────────────────────────────────────┤
│  亚太区域                                        │
│  - 订单服务（ap-southeast-1）                   │
│  - 风控服务（本地）                               │
│  - 数据库只读副本                                │
└─────────────────────────────────────────────────┘

跨区域数据同步：
- 订单数据：强一致性（同步复制到所有区域）
- 用户数据：最终一致性（异步复制）
- 汇率数据：全局缓存（1秒刷新）
```

### 八、总结

跨境支付系统的核心要点：

**技术架构**：
1. **状态机管理**：订单生命周期严格控制
2. **Saga 模式**：分布式事务最终一致性
3. **多路由策略**：通道智能选择降低成本
4. **实时对账**：确保资金安全

**业务保障**：
1. **风控体系**：KYC/AML/限额/频控多维度防护
2. **汇率管理**：多源聚合 + 加价 + 对冲降低风险
3. **合规性**：交易报告、数据留存、审计日志
4. **幂等性**：防止重复扣款

**性能优化**：
1. **数据库分片**：按用户ID水平拆分
2. **异步处理**：消息队列解耦耗时操作
3. **全球部署**：就近接入降低延迟

**关键指标**：
- 订单成功率 > 99%
- P99 延迟 < 3秒
- 对账准确率 100%
- 汇率风险敞口 < 总交易量 5%

这就是我对跨境支付系统设计的完整回答，请问您还有什么想深入了解的吗?
