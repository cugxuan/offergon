---
title: sync.Cond 条件变量的使用场景和实现原理
tags:
  - Go并发
  - 同步原语
status: robot
class: Go并发
slug: sync-cond-usage-and-implementation
ref:
---

## 核心要点

**sync.Cond 是基于 Mutex 实现的条件变量，用于在多 goroutine 间等待/通知特定条件。通过 Wait() 原子地释放锁并阻塞，Signal()/Broadcast() 唤醒等待者。适用于生产者-消费者、读写协调等需要"等待条件满足"的场景，比 channel 更节省资源但使用复杂度更高。**

---

## 详细解答

### 一、sync.Cond 基础

#### 结构定义

```go
type Cond struct {
    L Locker        // 关联的锁（通常是*sync.Mutex）
    notify  notifyList  // 等待队列
    checker copyChecker  // 防拷贝检查
}
```

#### 核心方法

```go
// 创建条件变量
cond := sync.NewCond(&mu)

// Wait: 原子地释放锁并阻塞，被唤醒后重新获取锁
cond.Wait()

// Signal: 唤醒一个等待者
cond.Signal()

// Broadcast: 唤醒所有等待者
cond.Broadcast()
```

### 二、典型使用场景

#### 场景 1：生产者-消费者（有界队列）

```go
type Queue struct {
    mu    sync.Mutex
    cond  *sync.Cond
    items []int
    cap   int
}

func NewQueue(cap int) *Queue {
    q := &Queue{items: make([]int, 0, cap), cap: cap}
    q.cond = sync.NewCond(&q.mu)
    return q
}

// 生产者：队列满时等待
func (q *Queue) Enqueue(item int) {
    q.mu.Lock()
    defer q.mu.Unlock()

    // 等待队列非满
    for len(q.items) == q.cap {
        q.cond.Wait()  // 释放锁并阻塞
    }

    q.items = append(q.items, item)
    q.cond.Signal()  // 唤醒消费者
}

// 消费者：队列空时等待
func (q *Queue) Dequeue() int {
    q.mu.Lock()
    defer q.mu.Unlock()

    // 等待队列非空
    for len(q.items) == 0 {
        q.cond.Wait()
    }

    item := q.items[0]
    q.items = q.items[1:]
    q.cond.Signal()  // 唤醒生产者
    return item
}
```

**关键点**：

1. **必须在循环中调用 Wait()**：防止虚假唤醒（spurious wakeup）
2. **Wait() 前必须持有锁**：Wait() 会自动释放锁
3. **Signal() 通知对方角色**：生产者唤醒消费者，反之亦然

#### 场景 2：多读者单写者协调

```go
type DataStore struct {
    mu      sync.Mutex
    cond    *sync.Cond
    data    string
    readers int
}

func NewDataStore() *DataStore {
    ds := &DataStore{}
    ds.cond = sync.NewCond(&ds.mu)
    return ds
}

// 写入：等待所有读者完成
func (ds *DataStore) Write(data string) {
    ds.mu.Lock()
    defer ds.mu.Unlock()

    // 等待读者为0
    for ds.readers > 0 {
        ds.cond.Wait()
    }

    ds.data = data
    ds.cond.Broadcast()  // 通知所有等待的读者
}

// 读取：读取期间增加计数
func (ds *DataStore) Read() string {
    ds.mu.Lock()
    defer ds.mu.Unlock()

    ds.readers++
    data := ds.data
    ds.readers--

    if ds.readers == 0 {
        ds.cond.Signal()  // 最后一个读者通知写者
    }

    return data
}
```

#### 场景 3：任务批量处理

```go
type BatchProcessor struct {
    mu       sync.Mutex
    cond     *sync.Cond
    tasks    []Task
    batchSize int
}

func (bp *BatchProcessor) AddTask(task Task) {
    bp.mu.Lock()
    defer bp.mu.Unlock()

    bp.tasks = append(bp.tasks, task)

    // 达到批量大小，唤醒处理器
    if len(bp.tasks) >= bp.batchSize {
        bp.cond.Signal()
    }
}

func (bp *BatchProcessor) ProcessBatch() {
    bp.mu.Lock()
    defer bp.mu.Unlock()

    // 等待任务数达到阈值
    for len(bp.tasks) < bp.batchSize {
        bp.cond.Wait()
    }

    batch := bp.tasks[:bp.batchSize]
    bp.tasks = bp.tasks[bp.batchSize:]

    bp.mu.Unlock()  // 处理期间释放锁
    processTasks(batch)
    bp.mu.Lock()
}
```

### 三、实现原理

#### Wait() 的底层实现

```go
func (c *Cond) Wait() {
    // 检查是否复制了Cond（panic）
    c.checker.check()

    // 将当前goroutine加入等待队列
    t := runtime_notifyListAdd(&c.notify)

    // 释放关联的锁
    c.L.Unlock()

    // 阻塞等待被唤醒
    runtime_notifyListWait(&c.notify, t)

    // 被唤醒后重新获取锁
    c.L.Lock()
}
```

**关键步骤**：

1. 将 goroutine 加入 `notifyList`（类似 channel 的 waitq）
2. **原子地**释放锁并阻塞（避免死锁）
3. 被唤醒后自动重新获取锁

#### Signal() 的实现

```go
func (c *Cond) Signal() {
    c.checker.check()
    runtime_notifyListNotifyOne(&c.notify)  // 唤醒一个等待者
}
```

- 从等待队列取出一个 goroutine 并调用 `goready()` 唤醒
- **不需要持有锁**（但实践中通常在锁内调用）

#### Broadcast() 的实现

```go
func (c *Cond) Broadcast() {
    c.checker.check()
    runtime_notifyListNotifyAll(&c.notify)  // 唤醒所有等待者
}
```

- 唤醒队列中所有 goroutine
- 适用于条件改变会影响多个等待者的场景

### 四、常见陷阱

#### 陷阱 1：忘记在循环中调用 Wait()

```go
// 错误示例
if len(items) == 0 {
    cond.Wait()  // 可能虚假唤醒
}
item := items[0]

// 正确示例
for len(items) == 0 {
    cond.Wait()  // 重新检查条件
}
item := items[0]
```

**虚假唤醒原因**：

- 操作系统信号
- Broadcast() 唤醒多个等待者，但只有一个能处理
- 条件在 Wait() 返回到检查之间被其他 goroutine 改变

#### 陷阱 2：Signal/Broadcast 前未持有锁

```go
// 错误但常见的模式
mu.Lock()
data = newData
mu.Unlock()
cond.Signal()  // 可能导致信号丢失

// 推荐模式
mu.Lock()
data = newData
cond.Signal()
mu.Unlock()
```

**虽然 Signal() 不需要锁**，但在锁外调用可能导致时序问题。

#### 陷阱 3：复制 Cond 结构体

```go
cond1 := sync.NewCond(&mu)
cond2 := *cond1  // panic: sync.Cond is copied
```

**原因**：Cond 包含 `copyChecker`，运行时检测到复制会 panic。

### 五、Cond vs Channel

| 特性 | sync.Cond | channel |
|------|-----------|---------|
| **使用复杂度** | 高（需手动管理锁） | 低（语言级支持） |
| **内存开销** | 低（只有等待队列） | 高（缓冲区 + hchan） |
| **唤醒机制** | Signal/Broadcast | 发送数据 |
| **适用场景** | 复杂条件等待 | 简单通知/数据传递 |
| **性能** | 略高（无数据拷贝） | 略低（channel 开销） |

**选择建议**：

- **优先用 channel**：代码清晰，Go 习惯用法
- **使用 Cond 的情况**：
  - 需要 Broadcast 语义（channel 只能通知一个接收者）
  - 极致性能优化（避免 channel 开销）
  - 已有复杂锁逻辑，Cond 可自然融入

### 六、完整示例：线程池

```go
type WorkerPool struct {
    mu       sync.Mutex
    cond     *sync.Cond
    tasks    []func()
    workers  int
    shutdown bool
}

func NewWorkerPool(n int) *WorkerPool {
    wp := &WorkerPool{workers: n}
    wp.cond = sync.NewCond(&wp.mu)

    for i := 0; i < n; i++ {
        go wp.worker()
    }
    return wp
}

func (wp *WorkerPool) worker() {
    for {
        wp.mu.Lock()

        // 等待任务或关闭信号
        for len(wp.tasks) == 0 && !wp.shutdown {
            wp.cond.Wait()
        }

        if wp.shutdown && len(wp.tasks) == 0 {
            wp.mu.Unlock()
            return
        }

        task := wp.tasks[0]
        wp.tasks = wp.tasks[1:]
        wp.mu.Unlock()

        task()  // 执行任务（锁外）
    }
}

func (wp *WorkerPool) Submit(task func()) {
    wp.mu.Lock()
    defer wp.mu.Unlock()

    wp.tasks = append(wp.tasks, task)
    wp.cond.Signal()  // 唤醒一个worker
}

func (wp *WorkerPool) Shutdown() {
    wp.mu.Lock()
    defer wp.mu.Unlock()

    wp.shutdown = true
    wp.cond.Broadcast()  // 唤醒所有worker退出
}
```

### 七、性能测试

```go
func BenchmarkCond(b *testing.B) {
    mu := sync.Mutex{}
    cond := sync.NewCond(&mu)
    done := make(chan struct{})

    go func() {
        for i := 0; i < b.N; i++ {
            mu.Lock()
            cond.Signal()
            mu.Unlock()
        }
        close(done)
    }()

    for i := 0; i < b.N; i++ {
        mu.Lock()
        cond.Wait()
        mu.Unlock()
    }
    <-done
}

func BenchmarkChannel(b *testing.B) {
    ch := make(chan struct{})
    done := make(chan struct{})

    go func() {
        for i := 0; i < b.N; i++ {
            ch <- struct{}{}
        }
        close(done)
    }()

    for i := 0; i < b.N; i++ {
        <-ch
    }
    <-done
}
```

**典型结果**：Cond 比 channel 快约 20-30%（小数据量场景）。

### 八、总结

**sync.Cond 的核心价值**：

1. **精确的条件等待**：等待特定条件而非盲目阻塞
2. **Broadcast 能力**：一次唤醒多个等待者
3. **低开销**：无需数据传递，只需通知

**面试金句**：

> "sync.Cond 是 Go 中最接近传统条件变量的同步原语。它通过原子地'释放锁-阻塞-重新获取锁'的三段式操作，避免了竞态条件。虽然使用复杂度高于 channel，但在需要 Broadcast 或极致性能的场景下是不可替代的工具。理解 Cond 的关键是掌握'必须在循环中 Wait()'这一模式，以应对虚假唤醒。"
