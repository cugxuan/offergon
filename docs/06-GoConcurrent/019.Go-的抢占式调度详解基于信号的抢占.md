---
title: Go 的抢占式调度详解（基于信号的抢占）
tags:
  - Go并发
status: robot
class: Go并发
slug: go-preemptive-scheduling-signal-based
ref:
---

## 核心要点

- **协作式 → 异步抢占**:Go 1.14 之前依赖函数序言检查,1.14+ 引入基于信号的异步抢占
- **SIGURG 信号**:调度器向目标线程发送 SIGURG,触发信号处理器抢占 goroutine
- **抢占时机**:系统调用返回、sysmon 检测到长时间运行的 G、GC 需要 STW 时触发
- **保存上下文**:信号处理器修改 G 的 PC/SP,使其返回到 runtime.asyncPreempt 保存现场

---

## 详细回答

### 一、Go 调度器的演进历史

#### 1. 协作式调度(Go 1.13 及之前)

**机制**: 在函数序言(prologue)插入栈增长检查,顺便检查抢占标志。

```go
// 编译器生成的函数序言伪代码
func myFunction() {
    if stackguard0 == stackPreempt {
        runtime.morestack_noctxt()  // 触发抢占
    }
    // 实际函数逻辑...
}
```

**问题**:
- **无函数调用的循环无法抢占**:
  ```go
  for {
      i++  // 无函数调用,永远不会检查抢占
  }
  ```
- **垃圾回收延迟**:GC 需要 STW(Stop-The-World),等待所有 goroutine 进入安全点
- **调度不公平**:长时间运行的 goroutine 霸占 CPU

#### 2. 基于信号的异步抢占(Go 1.14+)

**核心思想**: 通过操作系统信号强制中断 goroutine 执行,无需等待函数调用。

**优势**:
- 可以抢占任意执行点(包括紧密循环)
- GC 的 STW 延迟大幅降低
- 调度更公平

### 二、异步抢占的完整流程

#### 阶段1: 触发抢占(谁决定抢占?)

**场景1: sysmon 监控线程检测超时**

```go
// runtime/proc.go
func sysmon() {
    for {
        // ...
        // 遍历所有 P,检查运行时间
        for _, pp := range allp {
            if pp.status == _Prunning {
                pd := &pp.sysmontick
                s := pp.schedtick
                if s != pd.schedtick {
                    pd.schedtick = s
                    pd.schedwhen = now
                } else if pd.schedwhen+forcePreemptNS <= now {
                    // 运行超过 10ms,标记抢占
                    preemptone(pp)
                }
            }
        }
        usleep(delay)
    }
}
```

**场景2: GC 需要 STW**

```go
// runtime/mgc.go
func stopTheWorldWithSema() {
    // 标记所有 P 为需要抢占
    for _, pp := range allp {
        pp.preempt = true
    }
    preemptall()  // 向所有 P 发送抢占信号
}
```

#### 阶段2: 发送抢占信号(preemptM)

```go
// runtime/signal_unix.go
func preemptM(mp *m) {
    if atomic.Cas(&mp.signalPending, 0, 1) {
        // 向 M 绑定的线程发送 SIGURG 信号
        signalM(mp, sigPreempt)  // sigPreempt = SIGURG
    }
}
```

**为什么选择 SIGURG?**
- SIGURG 是紧急数据信号,默认被忽略,不会终止进程
- Go 运行时独占使用,不会与用户代码冲突
- 在所有 Unix 系统中可用

#### 阶段3: 信号处理器捕获信号(sighandler)

```go
// runtime/signal_unix.go
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
    if sig == _SIGURG && gp != nil && gp.m != nil && gp.m.preemptGen.Load() != 0 {
        // 这是一个异步抢占信号
        doSigPreempt(gp, ctxt)
    }
}

func doSigPreempt(gp *g, ctxt unsafe.Pointer) {
    c := &sigctxt{info: nil, ctxt: ctxt}

    // 保存原始 PC 和 SP
    pc := c.rip()  // x86-64 的 PC 寄存器
    sp := c.rsp()  // 栈指针

    // 修改信号上下文,让 goroutine"返回"到 asyncPreempt
    c.set_rip(uint64(abi.FuncPCABIInternal(asyncPreempt)))
    c.set_rsp(sp - 8)  // 预留返回地址空间

    // 将原始 PC 压栈(作为返回地址)
    *(*uint64)(unsafe.Pointer(sp - 8)) = pc
}
```

**关键操作**:
1. 修改 RIP(指令指针)指向 `asyncPreempt` 函数
2. 调整 RSP(栈指针)为原 PC 预留空间
3. 信号返回后,goroutine 会"认为"自己调用了 asyncPreempt

#### 阶段4: 保存现场(asyncPreempt)

```go
// runtime/preempt.go
// 用汇编实现,保存所有寄存器
TEXT runtime·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0
    // 1. 保存调用者保存的寄存器(caller-saved)
    PUSHQ AX
    PUSHQ CX
    PUSHQ DX
    PUSHQ BX
    PUSHQ SI
    PUSHQ DI
    PUSHQ R8
    PUSHQ R9
    PUSHQ R10
    PUSHQ R11
    PUSHQ R12
    PUSHQ R13
    PUSHQ R14
    PUSHQ R15

    // 2. 保存浮点寄存器
    MOVUPS X0, 0(SP)
    MOVUPS X1, 16(SP)
    // ...

    // 3. 调用 asyncPreempt2 进行实际的调度
    CALL runtime·asyncPreempt2(SB)

    // 4. 恢复寄存器
    POPQ R15
    POPQ R14
    // ...
    RET
```

#### 阶段5: 触发调度(asyncPreempt2 → gopreempt_m)

```go
// runtime/preempt.go
func asyncPreempt2() {
    gp := getg()
    gp.asyncSafePoint = true  // 标记为异步安全点

    // 调用实际的抢占处理
    gopreempt_m(gp)
}

func gopreempt_m(gp *g) {
    goschedImpl(gp)  // 将 G 放回全局队列,触发调度
}
```

### 三、关键技术细节

#### 1. 信号安全性(Signal Safety)

**问题**: 信号处理器可能在任意时刻中断 goroutine,包括:
- 持有锁时
- 操作堆内存时
- 执行系统调用时

**解决方案**: 只在"异步安全点"(async-safe point)执行抢占。

```go
// runtime/preempt.go
func canPreemptM(mp *m) bool {
    return mp.locks == 0 &&  // 未持有调度器锁
           mp.mallocing == 0 &&  // 未在 malloc 中
           mp.preemptoff == "" &&  // 未禁用抢占
           mp.p.ptr().status == _Prunning  // P 在运行中
}
```

#### 2. 寄存器状态保存

抢占点必须保存所有活跃寄存器,包括:
- 通用寄存器(RAX, RBX, RCX, ...)
- 浮点寄存器(XMM0-XMM15)
- 栈指针(RSP)和程序计数器(RIP)

**为什么必须在汇编中实现?**
- Go 编译器假设函数调用遵守调用约定
- `asyncPreempt` 需要保存**所有**寄存器,包括被调用者保存的寄存器
- 只有汇编能完全控制寄存器状态

#### 3. 信号上下文修改(Signal Context Hijacking)

```c
// 简化的 C 伪代码,展示原理
void signal_handler(int sig, siginfo_t *info, void *ucontext) {
    ucontext_t *uc = (ucontext_t *)ucontext;

    // 保存原始 PC
    uint64_t original_pc = uc->uc_mcontext.gregs[REG_RIP];

    // 修改 PC 指向 asyncPreempt
    uc->uc_mcontext.gregs[REG_RIP] = (uint64_t)asyncPreempt;

    // 调整栈指针,压入返回地址
    uint64_t *sp = (uint64_t *)uc->uc_mcontext.gregs[REG_RSP];
    sp--;
    *sp = original_pc;
    uc->uc_mcontext.gregs[REG_RSP] = (uint64_t)sp;
}
```

**效果**: 信号返回后,CPU 会"跳转"到 asyncPreempt,就像 goroutine 主动调用了该函数。

### 四、与协作式调度的对比

| 维度 | 协作式调度 | 异步抢占 |
|-----|-----------|---------|
| 抢占点 | 仅函数调用处 | 任意指令 |
| 无限循环 | 无法抢占 | 可以抢占 |
| GC STW 延迟 | 可能很长 | <10ms |
| 实现复杂度 | 简单(编译器插桩) | 复杂(信号处理) |
| 平台依赖 | 无 | 依赖 Unix 信号 |

### 五、实际案例分析

#### 案例1: 紧密循环被抢占

```go
// Go 1.13: 永远无法抢占
func busyLoop() {
    for {
        sum := 0
        for i := 0; i < 1e9; i++ {
            sum += i
        }
    }
}

// Go 1.14+: sysmon 检测到超时(10ms)后发送 SIGURG 抢占
```

**抢占时间线**:
```
T=0ms    goroutine 开始执行 busyLoop
T=10ms   sysmon 检测到超时,调用 preemptone()
T=10ms   发送 SIGURG 信号到线程
T=10ms   信号处理器修改 PC 指向 asyncPreempt
T=10ms   asyncPreempt 保存寄存器,调用 gopreempt_m
T=10ms   goroutine 被放回队列,调度器切换到其他 G
```

#### 案例2: GC 触发 STW

```go
// 垃圾回收需要 STW
runtime.GC()

// 内部流程:
// 1. stopTheWorldWithSema() 标记所有 P 需要抢占
// 2. preemptall() 向所有 M 发送 SIGURG
// 3. 所有 goroutine 在信号处理器中被中断
// 4. 进入 STW 阶段,执行 GC 的标记清理
// 5. startTheWorldWithSema() 恢复执行
```

**性能对比**:
- Go 1.13: STW 可能 >100ms(等待紧密循环的 G)
- Go 1.14+: STW <10ms(强制抢占)

### 六、平台差异

#### Unix/Linux: SIGURG 信号
```go
const sigPreempt = _SIGURG
```

#### Windows: 使用 SuspendThread
```go
// runtime/os_windows.go
func preemptM(mp *m) {
    SuspendThread(mp.thread)
    // 修改线程上下文
    GetThreadContext(mp.thread, &context)
    context.Rip = asyncPreempt
    SetThreadContext(mp.thread, &context)
    ResumeThread(mp.thread)
}
```

**区别**:
- Unix 通过信号"建议"抢占
- Windows 直接暂停线程并修改上下文

### 七、局限性与未来改进

#### 1. 仍然存在无法抢占的场景

```go
// 系统调用期间无法抢占
syscall.Read(fd, buf)

// 持有调度器锁时无法抢占
runtime.LockOSThread()
defer runtime.UnlockOSThread()
```

**原因**: 这些场景下抢占可能导致死锁或状态不一致。

#### 2. 信号延迟

从发送 SIGURG 到实际抢占,可能有几微秒的延迟:
- 操作系统调度延迟
- 信号队列排队
- 内核态到用户态切换

#### 3. 未来方向

- **用户态抢占**: 无需依赖操作系统信号(如 WASM 运行时)
- **更精细的安全点检测**: 减少不必要的寄存器保存开销
- **基于硬件的抢占**: 使用 CPU 性能计数器触发中断

### 八、面试要点总结

1. **演进历史**: 协作式(函数序言检查)→ 异步抢占(信号中断)
2. **信号选择**: SIGURG 不会终止进程,且 Go 独占使用
3. **核心流程**: sysmon 检测超时 → 发送 SIGURG → 信号处理器修改 PC → asyncPreempt 保存现场 → 触发调度
4. **技术难点**: 信号安全性、寄存器保存、上下文修改
5. **性能提升**: GC 的 STW 延迟从 >100ms 降至 <10ms
