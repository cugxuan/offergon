---
title: singleflight 模式如何防止缓存击穿？
tags:
  - Go并发
  - 缓存策略
status: robot
class: Go并发
slug: singleflight-cache-breakdown-prevention
ref:
---

## 核心要点

**singleflight 通过请求合并机制防止缓存击穿:多个并发请求同一个 key 时,只让第一个请求执行,其他请求等待并共享结果,避免大量请求同时击穿缓存到数据库。**

---

## 什么是缓存击穿

缓存击穿是指一个热点 key 在缓存中过期的瞬间,有大量并发请求同时访问这个 key,导致所有请求都击穿缓存直接访问数据库,造成数据库瞬时压力暴增。

典型场景:
- 热门商品详情页缓存过期
- 热点用户信息缓存失效
- 热门文章数据缓存过期

## singleflight 工作原理

singleflight 是 Go 官方提供的扩展库(`golang.org/x/sync/singleflight`),核心思想是**请求合并**。

### 核心机制

```go
type Group struct {
    mu sync.Mutex                // 保护 m
    m  map[string]*call          // 正在执行的调用
}

type call struct {
    wg  sync.WaitGroup           // 等待组
    val interface{}              // 返回值
    err error                    // 错误
    dups int                     // 重复调用次数
}
```

### 执行流程

1. **第一个请求到达**:创建 call 对象,执行实际的数据加载函数
2. **后续并发请求**:发现已有相同 key 的 call 正在执行,直接等待
3. **第一个请求完成**:唤醒所有等待的 goroutine,共享结果

```go
func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]*call)
    }
    if c, ok := g.m[key]; ok {
        // 已有请求在执行,等待结果
        c.dups++
        g.mu.Unlock()
        c.wg.Wait()  // 阻塞等待
        return c.val, c.err, true
    }
    // 第一个请求,创建 call 并执行
    c := new(call)
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()

    // 执行实际函数
    c.val, c.err = fn()
    c.wg.Done()

    g.mu.Lock()
    delete(g.m, key)  // 执行完成,删除 call
    g.mu.Unlock()

    return c.val, c.err, c.dups > 0
}
```

## 实际应用示例

### 缓存加载场景

```go
package main

import (
    "fmt"
    "sync"
    "time"
    "golang.org/x/sync/singleflight"
)

type Cache struct {
    data sync.Map
    sf   singleflight.Group
}

// 获取数据:先查缓存,缓存未命中则从数据库加载
func (c *Cache) Get(key string) (interface{}, error) {
    // 先查缓存
    if val, ok := c.data.Load(key); ok {
        return val, nil
    }

    // 缓存未命中,使用 singleflight 加载
    val, err, shared := c.sf.Do(key, func() (interface{}, error) {
        fmt.Printf("从数据库加载 key: %s\n", key)
        time.Sleep(100 * time.Millisecond) // 模拟数据库查询
        data := fmt.Sprintf("data-%s", key)

        // 加载成功后写入缓存
        c.data.Store(key, data)
        return data, nil
    })

    if shared {
        fmt.Printf("请求被合并,共享结果\n")
    }

    return val, err
}

func main() {
    cache := &Cache{}
    var wg sync.WaitGroup

    // 模拟 100 个并发请求同一个 key
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            val, err := cache.Get("user:1001")
            if err != nil {
                fmt.Printf("goroutine %d 获取失败: %v\n", id, err)
            } else {
                fmt.Printf("goroutine %d 获取成功: %v\n", id, val)
            }
        }(i)
    }

    wg.Wait()
}
```

**输出结果**:
```
从数据库加载 key: user:1001
请求被合并,共享结果
请求被合并,共享结果
...
```

可以看到,100 个并发请求只执行了 1 次数据库查询,其他 99 个请求都共享了结果。

### 防止缓存击穿的完整方案

```go
type UserCache struct {
    cache sync.Map
    sf    singleflight.Group
}

func (uc *UserCache) GetUser(userID int64) (*User, error) {
    key := fmt.Sprintf("user:%d", userID)

    // 先查缓存
    if val, ok := uc.cache.Load(key); ok {
        if user, ok := val.(*User); ok {
            return user, nil
        }
    }

    // singleflight 保证只有一个请求去数据库
    val, err, _ := uc.sf.Do(key, func() (interface{}, error) {
        // 从数据库加载用户信息
        user, err := loadUserFromDB(userID)
        if err != nil {
            return nil, err
        }

        // 写入缓存,设置 5 分钟过期
        uc.cache.Store(key, user)
        time.AfterFunc(5*time.Minute, func() {
            uc.cache.Delete(key)
        })

        return user, nil
    })

    if err != nil {
        return nil, err
    }

    return val.(*User), nil
}
```

## 三种调用方法对比

singleflight 提供了三种调用方法:

### 1. Do - 等待结果

```go
val, err, shared := sf.Do(key, fn)
```
- 阻塞等待第一个请求完成
- 所有请求共享相同结果
- **适用场景**:必须获取到数据才能继续

### 2. DoChan - 异步等待

```go
ch := sf.DoChan(key, fn)
result := <-ch  // 异步接收结果
```
- 返回 channel,可以配合 select 使用
- 支持超时控制
- **适用场景**:需要超时控制或异步处理

```go
ch := sf.DoChan(key, fn)
select {
case result := <-ch:
    return result.Val, result.Err
case <-time.After(1 * time.Second):
    return nil, errors.New("timeout")
}
```

### 3. Forget - 主动遗忘

```go
sf.Forget(key)
```
- 主动删除正在执行的 key
- 下次请求会重新执行函数
- **适用场景**:需要取消正在进行的调用

## 使用注意事项

### 1. 错误传播问题

如果第一个请求失败,所有等待的请求都会收到相同的错误:

```go
val, err, _ := sf.Do(key, func() (interface{}, error) {
    // 如果这里返回错误,所有请求都会失败
    return nil, errors.New("database error")
})
// 100 个请求都会得到 "database error"
```

**解决方案**:发生错误时不要缓存,让后续请求重试

```go
val, err, _ := sf.Do(key, func() (interface{}, error) {
    data, err := loadFromDB(key)
    if err != nil {
        // 不缓存错误,直接返回
        return nil, err
    }
    // 只缓存成功的结果
    cache.Store(key, data)
    return data, nil
})
```

### 2. 缓存雪崩风险

大量 key 同时过期时,singleflight 只能保证单个 key 的请求合并,不同 key 仍会并发访问数据库。

**解决方案**:缓存过期时间加随机偏移

```go
expireTime := 5*time.Minute + time.Duration(rand.Intn(60))*time.Second
```

### 3. 内存占用

正在执行的 call 会占用内存,如果函数执行时间很长,可能导致大量 goroutine 阻塞。

**解决方案**:配合超时控制使用 DoChan

```go
ch := sf.DoChan(key, slowFunc)
select {
case result := <-ch:
    return result.Val, result.Err
case <-time.After(3 * time.Second):
    sf.Forget(key)  // 主动遗忘,避免后续请求继续等待
    return nil, errors.New("timeout")
}
```

### 4. 热点 key 性能

对于极高并发的热点 key,虽然只有一个请求访问数据库,但大量 goroutine 仍会阻塞等待。

**解决方案**:配合本地缓存 + 布隆过滤器

```go
// 1. 本地缓存热点数据
if val, ok := localCache.Get(key); ok {
    return val, nil
}

// 2. singleflight 请求
val, err, _ := sf.Do(key, func() (interface{}, error) {
    return loadFromRedis(key)
})

// 3. 写入本地缓存
if err == nil {
    localCache.Set(key, val, 10*time.Second)
}
```

## singleflight 与其他缓存策略对比

| 策略 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| **singleflight** | 请求合并 | 实现简单,无额外依赖 | 只能防击穿,不能防雪崩 |
| **互斥锁** | 加锁重建缓存 | 可控性强 | 实现复杂,性能较差 |
| **永不过期** | 逻辑过期 | 完全避免击穿 | 需要后台线程维护 |
| **预热** | 提前加载 | 服务稳定 | 需要预测热点数据 |

## 总结

singleflight 是一个轻量级但非常实用的库,通过**请求合并**机制有效防止缓存击穿:

1. **核心原理**:多个并发请求同一个 key 时,只执行一次函数,其他请求等待并共享结果
2. **适用场景**:缓存加载、防止缓存击穿、降低数据库压力
3. **最佳实践**:
   - 配合缓存使用,减少数据库访问
   - 错误不要缓存,允许重试
   - 使用 DoChan 配合超时控制
   - 对极热点 key 配合本地缓存
4. **注意事项**:错误传播、缓存雪崩、内存占用

在高并发系统中,singleflight 是防止缓存击穿的标准解决方案,配合 Redis 缓存可以显著降低数据库压力。
