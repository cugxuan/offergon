---
title: errgroup 的实现原理和最佳实践
tags:
  - Go并发
status: robot
class: Go并发
slug: errgroup-implementation-best-practices
ref:
---

## 核心要点

**errgroup 是 golang.org/x/sync 提供的并发控制库，基于 WaitGroup + context + error收集实现。核心功能：并发执行多个任务、第一个错误立即取消其他任务、等待所有goroutine完成。适用于需要错误传播的并发场景，如批量HTTP请求、并行数据处理等。**

---

## 详细解答

### 一、基本用法

```go
import (
    "context"
    "fmt"
    "golang.org/x/sync/errgroup"
    "net/http"
)

func fetchURLs(urls []string) error {
    g, ctx := errgroup.WithContext(context.Background())

    results := make([]string, len(urls))

    for i, url := range urls {
        i, url := i, url  // 捕获循环变量

        g.Go(func() error {
            req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
            if err != nil {
                return err
            }

            resp, err := http.DefaultClient.Do(req)
            if err != nil {
                return err  // 返回错误会取消其他请求
            }
            defer resp.Body.Close()

            results[i] = resp.Status
            return nil
        })
    }

    // 等待所有goroutine完成，返回第一个错误
    if err := g.Wait(); err != nil {
        return err
    }

    fmt.Println(results)
    return nil
}
```

### 二、实现原理

#### 源码剖析（简化版）

```go
package errgroup

import (
    "context"
    "sync"
)

type Group struct {
    cancel func()  // context取消函数

    wg sync.WaitGroup

    errOnce sync.Once
    err     error  // 保存第一个错误
}

// 创建带context的Group
func WithContext(ctx context.Context) (*Group, context.Context) {
    ctx, cancel := context.WithCancel(ctx)
    return &Group{cancel: cancel}, ctx
}

// 启动goroutine
func (g *Group) Go(f func() error) {
    g.wg.Add(1)

    go func() {
        defer g.wg.Done()

        if err := f(); err != nil {
            g.errOnce.Do(func() {
                g.err = err  // 保存第一个错误
                if g.cancel != nil {
                    g.cancel()  // 取消context
                }
            })
        }
    }()
}

// 等待所有goroutine完成
func (g *Group) Wait() error {
    g.wg.Wait()
    if g.cancel != nil {
        g.cancel()  // 确保context被取消
    }
    return g.err
}
```

**关键设计**：

1. **WaitGroup**：等待所有goroutine
2. **sync.Once**：确保只保存第一个错误
3. **context取消**：错误发生时通知其他goroutine退出

### 三、使用场景

#### 场景1：并行HTTP请求

```go
func fetchMultipleAPIs() (map[string]interface{}, error) {
    g, ctx := errgroup.WithContext(context.Background())

    var mu sync.Mutex
    results := make(map[string]interface{})

    apis := map[string]string{
        "users":    "https://api.example.com/users",
        "posts":    "https://api.example.com/posts",
        "comments": "https://api.example.com/comments",
    }

    for name, url := range apis {
        name, url := name, url

        g.Go(func() error {
            data, err := fetchJSON(ctx, url)
            if err != nil {
                return fmt.Errorf("fetch %s failed: %w", name, err)
            }

            mu.Lock()
            results[name] = data
            mu.Unlock()

            return nil
        })
    }

    if err := g.Wait(); err != nil {
        return nil, err
    }

    return results, nil
}
```

#### 场景2：并行数据处理

```go
func processFiles(files []string) error {
    g, ctx := errgroup.WithContext(context.Background())

    // 限制并发数为10
    g.SetLimit(10)

    for _, file := range files {
        file := file

        g.Go(func() error {
            select {
            case <-ctx.Done():
                return ctx.Err()  // 提前退出
            default:
            }

            return processFile(file)
        })
    }

    return g.Wait()
}
```

#### 场景3：管道模式

```go
func pipeline() error {
    g, ctx := errgroup.WithContext(context.Background())

    // Stage 1: 生成数据
    in := make(chan int)
    g.Go(func() error {
        defer close(in)
        for i := 0; i < 100; i++ {
            select {
            case in <- i:
            case <-ctx.Done():
                return ctx.Err()
            }
        }
        return nil
    })

    // Stage 2: 处理数据
    out := make(chan int)
    g.Go(func() error {
        defer close(out)
        for v := range in {
            select {
            case out <- v * 2:
            case <-ctx.Done():
                return ctx.Err()
            }
        }
        return nil
    })

    // Stage 3: 消费数据
    g.Go(func() error {
        for v := range out {
            fmt.Println(v)
        }
        return nil
    })

    return g.Wait()
}
```

### 四、限制并发数（Go 1.20+）

```go
func fetchWithLimit(urls []string, limit int) error {
    g, ctx := errgroup.WithContext(context.Background())
    g.SetLimit(limit)  // 限制并发goroutine数量

    for _, url := range urls {
        url := url

        g.Go(func() error {
            return fetch(ctx, url)
        })
    }

    return g.Wait()
}
```

**旧版本替代方案**（使用semaphore）：

```go
import "golang.org/x/sync/semaphore"

func fetchWithSemaphore(urls []string, limit int) error {
    g, ctx := errgroup.WithContext(context.Background())
    sem := semaphore.NewWeighted(int64(limit))

    for _, url := range urls {
        url := url

        g.Go(func() error {
            if err := sem.Acquire(ctx, 1); err != nil {
                return err
            }
            defer sem.Release(1)

            return fetch(ctx, url)
        })
    }

    return g.Wait()
}
```

### 五、常见陷阱

#### 陷阱1：循环变量捕获

```go
// 错误
for _, url := range urls {
    g.Go(func() error {
        return fetch(url)  // url被共享
    })
}

// 正确
for _, url := range urls {
    url := url  // 捕获变量
    g.Go(func() error {
        return fetch(url)
    })
}
```

#### 陷阱2：忘记检查ctx取消

```go
g.Go(func() error {
    // 长时间操作
    for i := 0; i < 1000000; i++ {
        // 错误：未检查ctx
        heavyWork()
    }
    return nil
})

// 正确
g.Go(func() error {
    for i := 0; i < 1000000; i++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            heavyWork()
        }
    }
    return nil
})
```

#### 陷阱3：共享状态未加锁

```go
var counter int  // 错误：竞态条件

for i := 0; i < 100; i++ {
    g.Go(func() error {
        counter++  // 竞态
        return nil
    })
}

// 正确：使用锁或atomic
var counter int64
for i := 0; i < 100; i++ {
    g.Go(func() error {
        atomic.AddInt64(&counter, 1)
        return nil
    })
}
```

### 六、与其他方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **errgroup** | 错误传播、context取消 | 只返回第一个错误 | 并行任务，需错误控制 |
| **WaitGroup** | 简单、轻量 | 无错误处理、无取消 | 简单并发等待 |
| **channel** | 灵活、可收集所有错误 | 代码复杂 | 需要所有错误或结果 |

### 七、最佳实践

#### 1. 始终检查context

```go
g.Go(func() error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }

    // 业务逻辑
    return doWork(ctx)
})
```

#### 2. 合理设置并发限制

```go
// 根据资源类型设置限制
cpuBound := 10         // CPU密集型
ioBound := 100         // IO密集型
networkBound := 1000   // 网络请求

g.SetLimit(networkBound)
```

#### 3. 包装错误信息

```go
g.Go(func() error {
    if err := processItem(item); err != nil {
        return fmt.Errorf("process item %s failed: %w", item.ID, err)
    }
    return nil
})
```

#### 4. 超时控制

```go
func fetchWithTimeout(urls []string, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()

    g, ctx := errgroup.WithContext(ctx)

    for _, url := range urls {
        url := url
        g.Go(func() error {
            return fetch(ctx, url)
        })
    }

    return g.Wait()
}
```

### 八、自定义扩展

#### 收集所有错误

```go
type MultiError []error

func (m MultiError) Error() string {
    var errs []string
    for _, err := range m {
        errs = append(errs, err.Error())
    }
    return strings.Join(errs, "; ")
}

type ErrorGroup struct {
    g    *errgroup.Group
    mu   sync.Mutex
    errs []error
}

func (eg *ErrorGroup) Go(f func() error) {
    eg.g.Go(func() error {
        if err := f(); err != nil {
            eg.mu.Lock()
            eg.errs = append(eg.errs, err)
            eg.mu.Unlock()
        }
        return nil  // 不返回错误，继续执行
    })
}

func (eg *ErrorGroup) Wait() error {
    eg.g.Wait()
    if len(eg.errs) > 0 {
        return MultiError(eg.errs)
    }
    return nil
}
```

### 九、性能考虑

```go
func BenchmarkErrGroup(b *testing.B) {
    urls := make([]string, 100)
    for i := range urls {
        urls[i] = "https://example.com"
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        g, ctx := errgroup.WithContext(context.Background())
        for _, url := range urls {
            url := url
            g.Go(func() error {
                return fetch(ctx, url)
            })
        }
        g.Wait()
    }
}
```

**优化建议**：

- 复用Group对象（避免频繁创建）
- 使用对象池缓存临时对象
- 合理设置并发限制

### 十、总结

**errgroup核心价值**：

1. **简化并发错误处理**：自动收集第一个错误
2. **自动取消机制**：错误发生时取消其他任务
3. **结合context**：优雅传播取消信号

**面试金句**：

> "errgroup通过WaitGroup + sync.Once + context实现了优雅的并发错误控制。它的核心设计是'快速失败'：任一goroutine返回错误时立即取消其他任务，避免资源浪费。实践中需注意循环变量捕获、context检查、共享状态保护等细节。对于需要收集所有错误的场景，可自行扩展或使用channel模式。"
