---
title: 如何实现一个无锁的并发队列？
tags:
  - Go并发
status: robot
class: Go并发
slug: lock-free-concurrent-queue
ref:
---

## 核心要点

- **CAS 操作核心**:通过 atomic.CompareAndSwap 实现无锁的入队和出队操作
- **链表结构**:使用单链表存储节点,头尾指针通过原子操作更新
- **ABA 问题**:需要版本号或标记位防止 CAS 误判
- **内存回收**:避免过早释放节点内存,可使用延迟回收或 epoch-based 机制

---

## 详细回答

### 一、无锁队列的基本原理

#### 1. 为什么需要无锁队列?

**有锁队列的问题**:
```go
type LockedQueue struct {
    mu    sync.Mutex
    items []interface{}
}

func (q *LockedQueue) Enqueue(item interface{}) {
    q.mu.Lock()
    defer q.mu.Unlock()
    q.items = append(q.items, item)  // 持锁期间可能触发扩容,阻塞其他goroutine
}
```

**缺点**:
- 锁竞争导致线程阻塞
- 优先级反转(低优先级持锁阻塞高优先级)
- 单点瓶颈(所有操作串行化)

**无锁队列的优势**:
- 无阻塞操作,goroutine 永不挂起
- 高并发下性能更好
- 避免死锁问题

#### 2. CAS 的核心作用

```go
// CompareAndSwap 伪代码
func CAS(addr *int, old, new int) bool {
    if *addr == old {
        *addr = new
        return true
    }
    return false
}
```

**特点**:
- 原子操作,硬件支持(x86 的 CMPXCHG 指令)
- 失败后可重试,不会阻塞
- 是无锁算法的基础

### 二、经典无锁队列实现(Michael-Scott 队列)

#### 1. 数据结构定义

```go
package lockfree

import (
    "sync/atomic"
    "unsafe"
)

// 队列节点
type node struct {
    value interface{}
    next  unsafe.Pointer  // 指向下一个节点(*node)
}

// 无锁队列
type LockFreeQueue struct {
    head unsafe.Pointer  // 指向头节点(*node)
    tail unsafe.Pointer  // 指向尾节点(*node)
}

// 初始化队列
func NewLockFreeQueue() *LockFreeQueue {
    dummy := &node{}  // 哨兵节点
    q := &LockFreeQueue{
        head: unsafe.Pointer(dummy),
        tail: unsafe.Pointer(dummy),
    }
    return q
}
```

**设计要点**:
- **哨兵节点**:简化边界条件处理,head 永远指向哨兵
- **unsafe.Pointer**:允许原子操作指针

#### 2. 入队操作(Enqueue)

```go
func (q *LockFreeQueue) Enqueue(value interface{}) {
    newNode := &node{value: value}

    for {
        // 1. 读取当前的 tail 和 tail.next
        tail := atomic.LoadPointer(&q.tail)
        tailNode := (*node)(tail)
        next := atomic.LoadPointer(&tailNode.next)

        // 2. 验证 tail 未被其他线程修改
        if tail != atomic.LoadPointer(&q.tail) {
            continue  // tail 已变化,重新读取
        }

        if next == nil {
            // 3. tail 确实是最后一个节点,尝试插入
            if atomic.CompareAndSwapPointer(&tailNode.next, nil, unsafe.Pointer(newNode)) {
                // 4. 插入成功,尝试更新 tail(可以失败,留给其他线程)
                atomic.CompareAndSwapPointer(&q.tail, tail, unsafe.Pointer(newNode))
                return
            }
        } else {
            // 5. tail 落后了,帮助推进 tail
            atomic.CompareAndSwapPointer(&q.tail, tail, next)
        }
    }
}
```

**关键步骤解析**:

**步骤1-2: 读取并验证 tail**
```
初始状态:
head → [dummy] → [A] → [B]
                        ↑
                       tail
```

**步骤3: CAS 插入新节点**
```
尝试: tailNode.next: nil → newNode
成功后:
head → [dummy] → [A] → [B] → [C(new)]
                        ↑
                       tail (待更新)
```

**步骤4: 更新 tail(可以延迟)**
- 即使 CAS 失败也没关系
- 其他线程会通过步骤5帮助推进

**步骤5: 协作推进 tail**
```
发现 tail.next != nil,说明 tail 落后:
head → [dummy] → [A] → [B] → [C]
                        ↑      ↑
                      tail   实际尾部

协作推进:
atomic.CAS(&q.tail, [B], [C])
```

#### 3. 出队操作(Dequeue)

```go
func (q *LockFreeQueue) Dequeue() (interface{}, bool) {
    for {
        // 1. 读取 head, tail, head.next
        head := atomic.LoadPointer(&q.head)
        headNode := (*node)(head)
        tail := atomic.LoadPointer(&q.tail)
        next := atomic.LoadPointer(&headNode.next)

        // 2. 验证 head 未被修改
        if head != atomic.LoadPointer(&q.head) {
            continue
        }

        if next == nil {
            // 3. 队列为空
            return nil, false
        }

        if head == tail {
            // 4. head 和 tail 指向同一个节点,但 next != nil
            // 说明 tail 落后,帮助推进
            atomic.CompareAndSwapPointer(&q.tail, tail, next)
            continue  // 重试
        }

        // 5. 正常情况:读取 next 的值
        nextNode := (*node)(next)
        value := nextNode.value

        // 6. 尝试将 head 移动到 next
        if atomic.CompareAndSwapPointer(&q.head, head, next) {
            return value, true
        }
    }
}
```

**关键步骤解析**:

**步骤3: 空队列检测**
```
head → [dummy] → nil
       ↑
      tail

next == nil → 队列为空
```

**步骤4: tail 落后的情况**
```
head → [dummy] → [A]
       ↑
      tail

head == tail 但 next != nil → tail 需要推进
```

**步骤6: 移动 head**
```
出队前:
head → [dummy] → [A] → [B]
                        ↑
                       tail

出队后:
        [dummy]   [A] → [B]
                  ↑     ↑
                head  tail

注意:[dummy] 成为垃圾,需要 GC 回收
```

### 三、ABA 问题与解决方案

#### 1. ABA 问题示例

```
时刻T1: 线程1读取 tail = A
时刻T2: 线程2将 A 出队
时刻T3: 线程2回收 A 的内存
时刻T4: 线程3分配新节点,恰好也在地址 A
时刻T5: 线程1 执行 CAS(tail, A, B)
        → 成功!(但实际上 A 已经不是原来的 A)
```

**后果**: 可能导致队列结构损坏。

#### 2. 解决方案1:延迟内存回收

```go
type nodeWithVersion struct {
    value   interface{}
    next    unsafe.Pointer
    version uint64  // 版本号
}

type LockFreeQueueV2 struct {
    head    unsafe.Pointer
    tail    unsafe.Pointer
    version uint64  // 全局版本号
}

func (q *LockFreeQueueV2) Enqueue(value interface{}) {
    ver := atomic.AddUint64(&q.version, 1)
    newNode := &nodeWithVersion{value: value, version: ver}
    // ... CAS 时同时比较版本号
}
```

#### 3. 解决方案2:Go 的 GC 天然优势

Go 的垃圾回收器保证:
- 只要有指针引用,内存不会被回收
- 即使节点从队列中移除,只要还有 goroutine 持有指针就安全
- **ABA 问题在 Go 中影响较小**(相比 C/C++ 的手动内存管理)

### 四、性能优化技巧

#### 1. 减少 false sharing(伪共享)

```go
type LockFreeQueue struct {
    head unsafe.Pointer
    _    [56]byte  // 缓存行填充(64字节 - 8字节指针)
    tail unsafe.Pointer
    _    [56]byte
}
```

**原理**:
- CPU 缓存行通常 64 字节
- 如果 head 和 tail 在同一缓存行,不同 CPU 修改时会互相失效缓存
- 填充确保它们在不同缓存行

#### 2. 批量操作

```go
func (q *LockFreeQueue) EnqueueBatch(values []interface{}) {
    // 先串行构建子链表
    var first, last *node
    for _, v := range values {
        n := &node{value: v}
        if first == nil {
            first = n
        } else {
            last.next = unsafe.Pointer(n)
        }
        last = n
    }

    // 一次性 CAS 接入队列
    for {
        tail := atomic.LoadPointer(&q.tail)
        tailNode := (*node)(tail)
        if atomic.CompareAndSwapPointer(&tailNode.next, nil, unsafe.Pointer(first)) {
            atomic.CompareAndSwapPointer(&q.tail, tail, unsafe.Pointer(last))
            return
        }
    }
}
```

#### 3. 使用 Go 的 atomic.Value(类型安全)

```go
type typedNode struct {
    value int  // 固定类型,避免 interface{} 开销
    next  atomic.Value  // 存储 *typedNode
}

type TypedQueue struct {
    head atomic.Value  // 存储 *typedNode
    tail atomic.Value
}
```

### 五、完整的生产级实现

```go
package lockfree

import (
    "sync/atomic"
    "unsafe"
)

type node struct {
    value interface{}
    next  unsafe.Pointer
}

type Queue struct {
    head unsafe.Pointer
    _    [56]byte  // 防止伪共享
    tail unsafe.Pointer
    _    [56]byte
}

func NewQueue() *Queue {
    dummy := &node{}
    return &Queue{
        head: unsafe.Pointer(dummy),
        tail: unsafe.Pointer(dummy),
    }
}

func (q *Queue) Enqueue(v interface{}) {
    n := &node{value: v}
    for {
        tail := atomic.LoadPointer(&q.tail)
        next := atomic.LoadPointer(&(*node)(tail).next)

        if tail == atomic.LoadPointer(&q.tail) {
            if next == nil {
                if atomic.CompareAndSwapPointer(&(*node)(tail).next, next, unsafe.Pointer(n)) {
                    atomic.CompareAndSwapPointer(&q.tail, tail, unsafe.Pointer(n))
                    return
                }
            } else {
                atomic.CompareAndSwapPointer(&q.tail, tail, next)
            }
        }
    }
}

func (q *Queue) Dequeue() (interface{}, bool) {
    for {
        head := atomic.LoadPointer(&q.head)
        tail := atomic.LoadPointer(&q.tail)
        next := atomic.LoadPointer(&(*node)(head).next)

        if head == atomic.LoadPointer(&q.head) {
            if head == tail {
                if next == nil {
                    return nil, false  // 队列为空
                }
                atomic.CompareAndSwapPointer(&q.tail, tail, next)
            } else {
                v := (*node)(next).value
                if atomic.CompareAndSwapPointer(&q.head, head, next) {
                    return v, true
                }
            }
        }
    }
}

// 判断队列是否为空
func (q *Queue) IsEmpty() bool {
    head := atomic.LoadPointer(&q.head)
    next := atomic.LoadPointer(&(*node)(head).next)
    return next == nil
}
```

### 六、性能对比测试

```go
func BenchmarkLockedQueue(b *testing.B) {
    q := &LockedQueue{}
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            q.Enqueue(1)
            q.Dequeue()
        }
    })
}

func BenchmarkLockFreeQueue(b *testing.B) {
    q := NewQueue()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            q.Enqueue(1)
            q.Dequeue()
        }
    })
}
```

**典型结果**(8核 CPU):
```
BenchmarkLockedQueue-8       10000000    150 ns/op
BenchmarkLockFreeQueue-8     50000000     30 ns/op
```

**无锁队列快 5 倍**!

### 七、使用场景与局限

#### 适用场景
1. **高并发生产者-消费者**:多个 goroutine 同时读写
2. **实时系统**:不能容忍锁阻塞的场景
3. **性能敏感路径**:热点队列操作

#### 不适用场景
1. **低并发场景**:有锁队列更简单,性能差异小
2. **需要阻塞等待**:无锁队列天然非阻塞,需要配合 sleep 或信号量
3. **复杂逻辑**:无锁算法调试困难

#### 替代方案
- **channel**:Go 推荐的并发通信方式,内置阻塞支持
- **sync.Pool**:对象池场景
- **buffered channel + select**:简单且可靠

### 八、面试要点总结

1. **核心机制**:基于 CAS 的原子操作,避免锁竞争
2. **数据结构**:链表 + 哨兵节点 + 双指针(head/tail)
3. **协作机制**:tail 落后时其他线程帮助推进
4. **ABA 问题**:版本号或依赖 GC(Go 的优势)
5. **性能优化**:缓存行对齐、批量操作、类型安全优化
6. **实战权衡**:多数场景下 channel 更好,无锁队列适用于极端性能需求

**面试扩展问题**:
- 如何在无锁队列中实现阻塞等待?(答:结合 condition variable 或 futex)
- 如何实现无锁栈?(答:单指针 + CAS 更新栈顶)
- Go 的 channel 底层是否无锁?(答:否,使用 mutex + 环形缓冲区)
