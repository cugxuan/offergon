---
title: Go 的协程泄漏检测工具 goleak 原理
tags:
  - Go并发
status: robot
class: Go并发
slug: goleak-goroutine-leak-detection-principle
ref:
---

## 要点提炼

**核心原理**：通过 **`runtime.Stack()`** 获取所有 goroutine 的堆栈信息,对比测试前后的差异,识别泄漏的 goroutine。

**检测机制**：在测试开始前记录 goroutine 快照,测试结束后再次快照,过滤掉已知的系统 goroutine,剩余未关闭的即为泄漏。

**关键特性**：非侵入式检测、支持白名单过滤、与 `testing` 包无缝集成,适用于单元测试和集成测试。

---

## 详细回答

### 一、什么是 goroutine 泄漏?

**定义**：启动的 goroutine 未能正确退出,持续占用内存和调度资源,导致资源耗尽。

**常见原因**:
1. **Channel 死锁**：goroutine 永久阻塞在 channel 读写操作
2. **忘记关闭**：未通过 context/channel 通知 goroutine 退出
3. **无限循环**：goroutine 中存在无退出条件的死循环
4. **锁未释放**：goroutine 等待永远不会释放的锁

**危害**:
- 内存泄漏(每个 goroutine 约 2KB 栈空间)
- CPU 资源浪费(死循环的 goroutine)
- 程序最终崩溃(goroutine 数量超过限制)

---

### 二、goleak 的基本使用

#### 2.1 安装

```bash
go get -u go.uber.org/goleak
```

#### 2.2 简单示例

```go
package main

import (
    "testing"
    "time"

    "go.uber.org/goleak"
)

// TestWithLeak 会检测到泄漏
func TestWithLeak(t *testing.T) {
    defer goleak.VerifyNone(t) // 测试结束时检查是否有 goroutine 泄漏

    // 启动一个永不退出的 goroutine
    go func() {
        for {
            time.Sleep(1 * time.Second)
        }
    }()

    // 测试逻辑
    time.Sleep(100 * time.Millisecond)
}

// TestWithoutLeak 不会检测到泄漏
func TestWithoutLeak(t *testing.T) {
    defer goleak.VerifyNone(t)

    done := make(chan struct{})
    go func() {
        defer close(done)
        time.Sleep(100 * time.Millisecond)
    }()

    <-done // 等待 goroutine 完成
}
```

**运行测试**:
```bash
go test -v

# 输出
=== RUN   TestWithLeak
    leaks.go:78: found unexpected goroutines:
    [Goroutine 19 in state sleep, with time.Sleep on top of the stack:
    goroutine 19 [sleep]:
    time.Sleep(0x3b9aca00)
        /usr/local/go/src/runtime/time.go:195 +0x135
    main.TestWithLeak.func1()
        /path/to/test.go:13 +0x2d
    created by main.TestWithLeak
        /path/to/test.go:11 +0x56
    ]
--- FAIL: TestWithLeak (0.46s)
=== RUN   TestWithoutLeak
--- PASS: TestWithoutLeak (0.10s)
```

---

### 三、goleak 的工作原理

#### 3.1 核心流程

```
1. 测试开始前:
   ├─ 调用 runtime.Stack() 获取所有 goroutine 的堆栈信息
   ├─ 解析堆栈,记录 goroutine ID、状态、调用栈
   └─ 过滤掉已知的系统 goroutine (如 testing、runtime 的后台任务)

2. 测试执行:
   └─ 运行业务代码

3. 测试结束后 (defer goleak.VerifyNone(t)):
   ├─ 再次获取 goroutine 快照
   ├─ 对比前后差异,找出新增的 goroutine
   ├─ 应用用户自定义的过滤规则
   └─ 如果存在未关闭的 goroutine,报告泄漏
```

#### 3.2 源码解析(简化版)

```go
// goleak 的核心实现(简化版)
package goleak

import (
    "bytes"
    "fmt"
    "runtime"
    "strings"
)

// goroutine 信息结构
type goroutineInfo struct {
    id    int    // goroutine ID
    state string // 状态(running, sleep, chan send 等)
    stack string // 堆栈跟踪
}

// VerifyNone 检查是否有 goroutine 泄漏
func VerifyNone(t TestingT, options ...Option) {
    // 1. 应用选项(过滤规则等)
    opts := buildOpts(options...)

    // 2. 获取当前所有 goroutine
    current := getGoroutines()

    // 3. 过滤掉已知的系统 goroutine
    leaked := filterGoroutines(current, opts.filters)

    // 4. 如果有泄漏,报告错误
    if len(leaked) > 0 {
        t.Errorf("found unexpected goroutines:\n%s", formatStacks(leaked))
    }
}

// getGoroutines 获取所有 goroutine 的堆栈信息
func getGoroutines() []goroutineInfo {
    // 1. 分配足够大的缓冲区
    buf := make([]byte, 1<<20) // 1MB

    // 2. 获取所有 goroutine 的堆栈跟踪
    n := runtime.Stack(buf, true) // true 表示获取所有 goroutine
    buf = buf[:n]

    // 3. 解析堆栈信息
    return parseGoroutines(buf)
}

// parseGoroutines 解析 runtime.Stack 的输出
func parseGoroutines(stacksBuf []byte) []goroutineInfo {
    var goroutines []goroutineInfo

    // runtime.Stack 的输出格式:
    // goroutine 1 [running]:
    // main.main()
    //     /path/to/main.go:10 +0x123

    lines := strings.Split(string(stacksBuf), "\n")
    var current *goroutineInfo

    for _, line := range lines {
        // 解析 goroutine 头部: "goroutine 1 [running]:"
        if strings.HasPrefix(line, "goroutine ") {
            if current != nil {
                goroutines = append(goroutines, *current)
            }
            current = &goroutineInfo{}
            fmt.Sscanf(line, "goroutine %d [%s]:", &current.id, &current.state)
        } else if current != nil {
            current.stack += line + "\n"
        }
    }

    if current != nil {
        goroutines = append(goroutines, *current)
    }

    return goroutines
}

// filterGoroutines 过滤掉已知的系统 goroutine
func filterGoroutines(goroutines []goroutineInfo, filters []func(*goroutineInfo) bool) []goroutineInfo {
    var leaked []goroutineInfo

    for _, g := range goroutines {
        // 应用所有过滤规则
        shouldIgnore := false
        for _, filter := range filters {
            if filter(&g) {
                shouldIgnore = true
                break
            }
        }

        if !shouldIgnore {
            leaked = append(leaked, g)
        }
    }

    return leaked
}
```

---

### 四、goleak 的高级用法

#### 4.1 忽略特定的 goroutine

```go
func TestWithIgnore(t *testing.T) {
    defer goleak.VerifyNone(t,
        // 忽略包含特定函数的 goroutine
        goleak.IgnoreTopFunction("main.backgroundWorker"),
    )

    // 启动后台任务(会被忽略)
    go backgroundWorker()

    // 测试逻辑
    time.Sleep(100 * time.Millisecond)
}

func backgroundWorker() {
    for {
        time.Sleep(1 * time.Second)
    }
}
```

#### 4.2 TestMain 中全局检测

```go
func TestMain(m *testing.M) {
    // 在所有测试运行前后检查 goroutine 泄漏
    goleak.VerifyTestMain(m,
        goleak.IgnoreTopFunction("internal/poll.runtime_pollWait"),
    )
}

func TestSomething(t *testing.T) {
    // 无需在每个测试中调用 goleak.VerifyNone
    go func() {
        time.Sleep(10 * time.Second)
    }() // 这个泄漏会在 TestMain 中被检测到
}
```

#### 4.3 自定义过滤规则

```go
func TestCustomFilter(t *testing.T) {
    defer goleak.VerifyNone(t,
        goleak.IgnoreCurrent(), // 忽略当前 goroutine

        // 自定义过滤函数
        goleak.IgnoreFunc(func(g goleak.Goroutine) bool {
            // 忽略状态为 "sleep" 且栈中包含 "time.Sleep" 的 goroutine
            return g.State() == "sleep" && strings.Contains(g.Stack(), "time.Sleep")
        }),
    )

    // 测试逻辑
}
```

---

### 五、常见 goroutine 泄漏模式及修复

#### 5.1 Channel 死锁

```go
// ❌ 错误: goroutine 永久阻塞
func badChannelUsage() {
    ch := make(chan int) // 无缓冲 channel
    go func() {
        ch <- 42 // 如果没有接收者,永久阻塞
    }()
}

// ✅ 正确: 确保 channel 有接收者或使用 context 超时
func goodChannelUsage(ctx context.Context) {
    ch := make(chan int)
    go func() {
        select {
        case ch <- 42:
        case <-ctx.Done():
            return // 超时退出
        }
    }()

    select {
    case val := <-ch:
        fmt.Println(val)
    case <-time.After(1 * time.Second):
        fmt.Println("timeout")
    }
}
```

#### 5.2 忘记关闭 goroutine

```go
// ❌ 错误: 没有退出机制
func badWorker() {
    go func() {
        for {
            // 永不退出
            doWork()
        }
    }()
}

// ✅ 正确: 使用 done channel 或 context
func goodWorker(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                return
            default:
                doWork()
            }
        }
    }()
}
```

#### 5.3 HTTP 请求未取消

```go
// ❌ 错误: 请求未关联 context
func badHTTPRequest() {
    go func() {
        resp, _ := http.Get("http://slow-api.com")
        defer resp.Body.Close()
        // 如果请求永不返回,goroutine 泄漏
    }()
}

// ✅ 正确: 使用带超时的 context
func goodHTTPRequest(ctx context.Context) {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    go func() {
        req, _ := http.NewRequestWithContext(ctx, "GET", "http://slow-api.com", nil)
        client := &http.Client{}
        resp, err := client.Do(req)
        if err != nil {
            return // 超时或取消时退出
        }
        defer resp.Body.Close()
    }()
}
```

---

### 六、goleak 的局限性

#### 6.1 无法检测活锁

```go
// goleak 检测不到这种"活着"但无用的 goroutine
func TestActiveLeak(t *testing.T) {
    defer goleak.VerifyNone(t)

    go func() {
        for {
            // 空循环,不阻塞但浪费 CPU
            runtime.Gosched()
        }
    }()

    time.Sleep(100 * time.Millisecond)
    // goleak 认为这个 goroutine "活着",但实际是泄漏
}
```

#### 6.2 时序问题

```go
// 测试可能在 goroutine 退出前结束
func TestTimingIssue(t *testing.T) {
    defer goleak.VerifyNone(t)

    go func() {
        time.Sleep(200 * time.Millisecond) // 较长的清理时间
    }()

    time.Sleep(100 * time.Millisecond)
    // goleak 检查时,goroutine 还未完成
    // 解决方法: 使用 sync.WaitGroup 等待
}

// ✅ 正确写法
func TestWithWaitGroup(t *testing.T) {
    defer goleak.VerifyNone(t)

    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        time.Sleep(200 * time.Millisecond)
    }()

    wg.Wait() // 确保 goroutine 完成
}
```

#### 6.3 性能开销

```go
// goleak 需要解析所有 goroutine 的堆栈,有一定性能开销
// 建议:
// 1. 只在单元测试中使用,不要在 benchmark 中使用
// 2. 使用 TestMain 全局检测,而不是每个测试都调用
```

---

### 七、与其他工具对比

| 工具           | 检测方式       | 优势                       | 劣势                     |
| -------------- | -------------- | -------------------------- | ------------------------ |
| **goleak**     | 快照对比       | 精确、易用、与 testing 集成 | 无法检测活锁、有性能开销 |
| **pprof**      | 运行时分析     | 可视化、检测活锁           | 手动分析、无自动化       |
| **race detector** | 动态分析    | 检测数据竞争               | 不检测泄漏               |
| **静态分析**   | 代码扫描       | 无运行时开销               | 误报多、覆盖面有限       |

---

### 八、生产环境监控 goroutine 泄漏

#### 8.1 使用 pprof 监控

```go
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    // 应用逻辑
}
```

**查看 goroutine 数量**:
```bash
# 浏览器访问
http://localhost:6060/debug/pprof/goroutine?debug=1

# 命令行
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

#### 8.2 自定义监控指标

```go
package main

import (
    "runtime"
    "time"
)

func monitorGoroutines() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    baseline := runtime.NumGoroutine()

    for range ticker.C {
        current := runtime.NumGoroutine()
        growth := current - baseline

        if growth > 100 {
            // 报警: goroutine 数量异常增长
            log.Warnf("Goroutine leak detected: baseline=%d, current=%d, growth=%d",
                baseline, current, growth)
        }

        baseline = current
    }
}

func main() {
    go monitorGoroutines()
    // 应用逻辑
}
```

---

### 九、完整测试示例

```go
package service

import (
    "context"
    "sync"
    "testing"
    "time"

    "go.uber.org/goleak"
)

// TestMain 全局检测 goroutine 泄漏
func TestMain(m *testing.M) {
    goleak.VerifyTestMain(m,
        // 忽略已知的系统 goroutine
        goleak.IgnoreTopFunction("internal/poll.runtime_pollWait"),
        goleak.IgnoreTopFunction("net/http.(*persistConn).writeLoop"),
    )
}

// Service 示例服务
type Service struct {
    workers []*Worker
    wg      sync.WaitGroup
    ctx     context.Context
    cancel  context.CancelFunc
}

type Worker struct {
    id int
}

func (w *Worker) Run(ctx context.Context, wg *sync.WaitGroup) {
    defer wg.Done()

    for {
        select {
        case <-ctx.Done():
            return
        case <-time.After(100 * time.Millisecond):
            // 模拟工作
        }
    }
}

func NewService() *Service {
    ctx, cancel := context.WithCancel(context.Background())
    return &Service{
        ctx:    ctx,
        cancel: cancel,
    }
}

func (s *Service) Start() {
    for i := 0; i < 3; i++ {
        worker := &Worker{id: i}
        s.workers = append(s.workers, worker)
        s.wg.Add(1)
        go worker.Run(s.ctx, &s.wg)
    }
}

func (s *Service) Stop() {
    s.cancel()
    s.wg.Wait()
}

// TestService_NoLeak 验证服务没有 goroutine 泄漏
func TestService_NoLeak(t *testing.T) {
    defer goleak.VerifyNone(t)

    svc := NewService()
    svc.Start()

    time.Sleep(200 * time.Millisecond)

    svc.Stop() // 确保所有 worker 正确退出
}

// TestService_WithLeak 演示泄漏检测
func TestService_WithLeak(t *testing.T) {
    defer goleak.VerifyNone(t)

    svc := NewService()
    svc.Start()

    time.Sleep(200 * time.Millisecond)

    // 忘记调用 Stop(),导致 3 个 worker goroutine 泄漏
    // goleak 会检测到并报告错误
}
```

**运行测试**:
```bash
go test -v

# 输出
=== RUN   TestService_NoLeak
--- PASS: TestService_NoLeak (0.20s)
=== RUN   TestService_WithLeak
    service_test.go:75: found unexpected goroutines:
    [Goroutine 21 in state select, with service.(*Worker).Run on top of the stack:
    goroutine 21 [select]:
    service.(*Worker).Run(...)
        /path/to/service.go:25
    created by service.(*Service).Start
        /path/to/service.go:42 +0x123
    ]
--- FAIL: TestService_WithLeak (0.46s)
```

---

## 总结

**goleak 的核心原理**:
1. **快照机制**: 通过 `runtime.Stack()` 获取 goroutine 信息
2. **差异对比**: 对比测试前后的 goroutine 列表
3. **过滤系统 goroutine**: 使用白名单避免误报
4. **集成测试框架**: 与 `testing.T` 无缝集成

**最佳实践**:
1. ✅ 在 `TestMain` 中全局启用 goleak
2. ✅ 确保测试中的 goroutine 正确退出(使用 WaitGroup)
3. ✅ 合理使用 `IgnoreTopFunction` 过滤已知的后台任务
4. ✅ 结合 pprof 在生产环境监控 goroutine 数量
5. ❌ 不要在 benchmark 中使用 goleak(性能开销大)

**面试回答框架**:
1. 解释 goroutine 泄漏的危害(内存泄漏、资源耗尽)
2. 说明 goleak 基于 `runtime.Stack()` 实现快照对比
3. 展示基本用法(`VerifyNone`)和高级用法(`IgnoreTopFunction`)
4. 列举常见泄漏模式(channel 死锁、忘记关闭)
5. 强调生产环境需要结合 pprof 监控

**相关工具**:
- `go.uber.org/goleak`: 单元测试中检测泄漏
- `net/http/pprof`: 生产环境运行时分析
- `runtime/debug.SetTraceback("all")`: 崩溃时打印所有 goroutine
- `github.com/google/gops`: 进程诊断工具

---

**进一步学习**:
- [Uber goleak 源码](https://github.com/uber-go/goleak)
- [Go runtime.Stack 文档](https://pkg.go.dev/runtime#Stack)
- [Dave Cheney: Goroutine Leaks](https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop)
