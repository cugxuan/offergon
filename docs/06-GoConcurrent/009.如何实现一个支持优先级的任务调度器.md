---
title: 如何实现一个支持优先级的任务调度器？
tags:
  - Go并发
status: robot
class: Go并发
slug: priority-task-scheduler-implementation
ref:
---

## 核心要点

**优先级调度器使用堆(container/heap)管理任务队列,高优先级任务优先执行。核心组件：优先级队列、worker池、任务分发器。实现难点包括：饥饿问题(低优先级任务永不执行)、动态优先级、抢占式调度。可结合时间片轮转、优先级老化等算法优化公平性。**

---

## 实现

```go
package scheduler

import (
    "container/heap"
    "context"
    "sync"
    "time"
)

// 优先级级别
const (
    PriorityHigh   = 3
    PriorityNormal = 2
    PriorityLow    = 1
)

type Task struct {
    ID       string
    Priority int
    Fn       func(context.Context) error
    Timeout  time.Duration

    // 用于防止饥饿
    SubmitTime time.Time
    WaitTime   time.Duration
}

// 优先级队列(最大堆)
type PriorityQueue []*Task

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    // 优先级高的排前面
    if pq[i].Priority != pq[j].Priority {
        return pq[i].Priority > pq[j].Priority
    }
    // 同优先级按提交时间排序(防止饥饿)
    return pq[i].SubmitTime.Before(pq[j].SubmitTime)
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(*Task))
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}

// 调度器
type Scheduler struct {
    pq      PriorityQueue
    mu      sync.Mutex
    cond    *sync.Cond
    workers int
    wg      sync.WaitGroup
    ctx     context.Context
    cancel  context.CancelFunc

    // 统计
    completed int64
    failed    int64
}

func New(workers int) *Scheduler {
    ctx, cancel := context.WithCancel(context.Background())
    s := &Scheduler{
        pq:      make(PriorityQueue, 0),
        workers: workers,
        ctx:     ctx,
        cancel:  cancel,
    }
    s.cond = sync.NewCond(&s.mu)

    heap.Init(&s.pq)

    // 启动workers
    for i := 0; i < workers; i++ {
        s.wg.Add(1)
        go s.worker()
    }

    // 启动优先级老化goroutine
    go s.priorityAging()

    return s
}

func (s *Scheduler) worker() {
    defer s.wg.Done()

    for {
        s.mu.Lock()

        // 等待任务或关闭信号
        for s.pq.Len() == 0 {
            select {
            case <-s.ctx.Done():
                s.mu.Unlock()
                return
            default:
                s.cond.Wait()
            }

            // 重新检查ctx
            select {
            case <-s.ctx.Done():
                s.mu.Unlock()
                return
            default:
            }
        }

        task := heap.Pop(&s.pq).(*Task)
        s.mu.Unlock()

        // 执行任务
        s.executeTask(task)
    }
}

func (s *Scheduler) executeTask(task *Task) {
    defer func() {
        if r := recover(); r != nil {
            atomic.AddInt64(&s.failed, 1)
            log.Printf("Task %s panic: %v", task.ID, r)
        }
    }()

    ctx, cancel := context.WithTimeout(s.ctx, task.Timeout)
    defer cancel()

    err := task.Fn(ctx)
    if err != nil {
        atomic.AddInt64(&s.failed, 1)
        log.Printf("Task %s failed: %v", task.ID, err)
    } else {
        atomic.AddInt64(&s.completed, 1)
    }
}

// 提交任务
func (s *Scheduler) Submit(task *Task) error {
    select {
    case <-s.ctx.Done():
        return errors.New("scheduler closed")
    default:
    }

    task.SubmitTime = time.Now()

    s.mu.Lock()
    heap.Push(&s.pq, task)
    s.mu.Unlock()

    s.cond.Signal()  // 唤醒一个worker
    return nil
}

// 优先级老化：防止低优先级任务饥饿
func (s *Scheduler) priorityAging() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            s.mu.Lock()
            now := time.Now()

            for _, task := range s.pq {
                waitTime := now.Sub(task.SubmitTime)
                // 等待超过30秒,提升优先级
                if waitTime > 30*time.Second && task.Priority < PriorityHigh {
                    task.Priority++
                }
            }

            // 重新堆化
            heap.Init(&s.pq)
            s.mu.Unlock()

        case <-s.ctx.Done():
            return
        }
    }
}

func (s *Scheduler) Shutdown(timeout time.Duration) error {
    done := make(chan struct{})

    go func() {
        s.mu.Lock()
        s.cond.Broadcast()  // 唤醒所有等待的worker
        s.mu.Unlock()

        s.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        s.cancel()
        return nil
    case <-time.After(timeout):
        s.cancel()
        return errors.New("shutdown timeout")
    }
}
```

## 使用示例

```go
func main() {
    scheduler := New(5)
    defer scheduler.Shutdown(10 * time.Second)

    // 提交不同优先级任务
    for i := 0; i < 20; i++ {
        id := i
        priority := PriorityLow
        if i%5 == 0 {
            priority = PriorityHigh
        } else if i%3 == 0 {
            priority = PriorityNormal
        }

        scheduler.Submit(&Task{
            ID:       fmt.Sprintf("task-%d", id),
            Priority: priority,
            Timeout:  5 * time.Second,
            Fn: func(ctx context.Context) error {
                time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
                fmt.Printf("[Priority %d] Task %d completed\n", priority, id)
                return nil
            },
        })
    }

    time.Sleep(30 * time.Second)
}
```

## 高级特性

### 1. 动态优先级调整

```go
func (s *Scheduler) UpdatePriority(taskID string, newPriority int) bool {
    s.mu.Lock()
    defer s.mu.Unlock()

    for _, task := range s.pq {
        if task.ID == taskID {
            task.Priority = newPriority
            heap.Init(&s.pq)
            return true
        }
    }
    return false
}
```

### 2. 时间片轮转（避免长任务阻塞）

```go
func (s *Scheduler) executeTaskWithTimeSlice(task *Task) {
    timeSlice := 100 * time.Millisecond
    ctx, cancel := context.WithTimeout(s.ctx, timeSlice)
    defer cancel()

    err := task.Fn(ctx)
    if err == context.DeadlineExceeded {
        // 时间片用完，重新入队
        task.Priority -= 1  // 降低优先级
        s.Submit(task)
    }
}
```

### 3. 抢占式调度

```go
func (s *Scheduler) SubmitUrgent(task *Task) error {
    task.Priority = 999  // 超高优先级
    task.SubmitTime = time.Now()

    s.mu.Lock()
    heap.Push(&s.pq, task)
    s.mu.Unlock()

    s.cond.Broadcast()  // 唤醒所有worker
    return nil
}
```

## 总结

**面试金句**：

> "优先级调度器通过堆结构实现O(logN)的任务插入和提取。关键设计点是防止饥饿：通过优先级老化、同优先级FIFO、最大等待时间保障低优先级任务最终被执行。生产环境还需考虑任务取消、重试、监控等功能。"
