---
title: 如何优雅地关闭多个 goroutine？
tags:
  - Go并发
  - 并发
status: robot
class: Go并发
slug: gracefully-shutdown-multiple-goroutines
ref:
---

## 要点提炼

**核心策略**：通过 **Context + WaitGroup + Channel** 组合实现优雅关闭，确保资源清理和超时控制。

**关键模式**：
1. **信号传播**：使用 `context.WithCancel()` 广播关闭信号
2. **完成等待**：`sync.WaitGroup` 确保所有 goroutine 完成清理
3. **超时保护**：`context.WithTimeout()` 防止无限等待
4. **错误收集**：`errgroup.Group` 统一管理错误

---

## 详细回答

### 一、为什么需要优雅关闭？

**常见问题**：
1. **资源泄漏**：goroutine 未正确退出，导致内存泄漏
2. **数据丢失**：强制终止导致未完成的任务数据丢失
3. **连接未关闭**：数据库连接、文件句柄等资源未释放
4. **日志缺失**：无法记录关闭时的状态信息

**优雅关闭的目标**：
- 通知所有 goroutine 停止接收新任务
- 等待正在执行的任务完成
- 清理资源（关闭连接、刷新缓冲等）
- 超时保护（避免无限等待）

---

### 二、基础模式：Context + WaitGroup

#### 2.1 使用 done channel

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, done <-chan struct{}, wg *sync.WaitGroup) {
    defer wg.Done()

    for {
        select {
        case <-done:
            fmt.Printf("Worker %d: shutting down\n", id)
            // 清理资源
            time.Sleep(100 * time.Millisecond) // 模拟清理工作
            fmt.Printf("Worker %d: cleanup completed\n", id)
            return
        default:
            // 执行正常工作
            fmt.Printf("Worker %d: working...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    var wg sync.WaitGroup
    done := make(chan struct{})

    // 启动 5 个 worker
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, done, &wg)
    }

    // 运行 2 秒后关闭
    time.Sleep(2 * time.Second)
    fmt.Println("Initiating shutdown...")

    close(done) // 广播关闭信号
    wg.Wait()   // 等待所有 worker 完成

    fmt.Println("All workers stopped")
}
```

**关键点**：
- `close(done)` 会通知所有监听该 channel 的 goroutine
- `wg.Wait()` 阻塞直到所有 goroutine 调用 `Done()`
- 每个 worker 负责自己的资源清理

---

#### 2.2 使用 Context（推荐）

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func worker(ctx context.Context, id int, wg *sync.WaitGroup) {
    defer wg.Done()

    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d: received shutdown signal (%v)\n", id, ctx.Err())
            // 执行清理逻辑
            cleanupResources(id)
            return
        default:
            // 执行正常工作
            if err := doWork(ctx, id); err != nil {
                fmt.Printf("Worker %d: error - %v\n", id, err)
                return
            }
        }
    }
}

func doWork(ctx context.Context, id int) error {
    select {
    case <-time.After(500 * time.Millisecond):
        fmt.Printf("Worker %d: task completed\n", id)
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

func cleanupResources(id int) {
    fmt.Printf("Worker %d: cleaning up...\n", id)
    time.Sleep(100 * time.Millisecond)
    fmt.Printf("Worker %d: cleanup done\n", id)
}

func main() {
    var wg sync.WaitGroup
    ctx, cancel := context.WithCancel(context.Background())

    // 启动 5 个 worker
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(ctx, i, &wg)
    }

    // 运行 2 秒后关闭
    time.Sleep(2 * time.Second)
    fmt.Println("Initiating graceful shutdown...")

    cancel()  // 取消 context
    wg.Wait() // 等待所有 worker 完成

    fmt.Println("All workers stopped gracefully")
}
```

**Context 的优势**：
1. 支持超时和截止时间
2. 可以传递取消原因（Go 1.20+）
3. 标准化的取消机制
4. 方便在函数调用链中传递

---

### 三、进阶模式：带超时的优雅关闭

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type Server struct {
    workers   []*Worker
    wg        sync.WaitGroup
    ctx       context.Context
    cancel    context.CancelFunc
    isRunning bool
    mu        sync.Mutex
}

type Worker struct {
    id   int
    name string
}

func (w *Worker) Run(ctx context.Context, wg *sync.WaitGroup) {
    defer wg.Done()

    ticker := time.NewTicker(500 * time.Millisecond)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            fmt.Printf("[%s] Shutting down: %v\n", w.name, ctx.Err())
            w.cleanup()
            return
        case <-ticker.C:
            fmt.Printf("[%s] Processing task\n", w.name)
        }
    }
}

func (w *Worker) cleanup() {
    fmt.Printf("[%s] Cleaning up resources...\n", w.name)
    time.Sleep(200 * time.Millisecond) // 模拟清理工作
    fmt.Printf("[%s] Cleanup completed\n", w.name)
}

func NewServer() *Server {
    ctx, cancel := context.WithCancel(context.Background())
    return &Server{
        workers: make([]*Worker, 0),
        ctx:     ctx,
        cancel:  cancel,
    }
}

func (s *Server) Start() {
    s.mu.Lock()
    defer s.mu.Unlock()

    if s.isRunning {
        return
    }

    // 创建 5 个 worker
    for i := 1; i <= 5; i++ {
        worker := &Worker{
            id:   i,
            name: fmt.Sprintf("Worker-%d", i),
        }
        s.workers = append(s.workers, worker)
        s.wg.Add(1)
        go worker.Run(s.ctx, &s.wg)
    }

    s.isRunning = true
    fmt.Println("Server started")
}

// Shutdown 优雅关闭服务器（带超时）
func (s *Server) Shutdown(timeout time.Duration) error {
    s.mu.Lock()
    if !s.isRunning {
        s.mu.Unlock()
        return nil
    }
    s.mu.Unlock()

    fmt.Printf("Initiating shutdown (timeout: %v)...\n", timeout)

    // 发送关闭信号
    s.cancel()

    // 创建超时 channel
    done := make(chan struct{})
    go func() {
        s.wg.Wait()
        close(done)
    }()

    // 等待完成或超时
    select {
    case <-done:
        fmt.Println("All workers stopped gracefully")
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("shutdown timeout after %v", timeout)
    }
}

func main() {
    server := NewServer()
    server.Start()

    // 运行 2 秒
    time.Sleep(2 * time.Second)

    // 优雅关闭（5 秒超时）
    if err := server.Shutdown(5 * time.Second); err != nil {
        fmt.Printf("Error during shutdown: %v\n", err)
    }
}
```

**关键改进**：
1. **超时保护**：避免某个 goroutine 卡住导致无法关闭
2. **状态管理**：使用 `isRunning` 标志防止重复启动/关闭
3. **封装**：将关闭逻辑封装到 `Shutdown()` 方法

---

### 四、生产级实现：errgroup + 错误处理

```go
package main

import (
    "context"
    "fmt"
    "time"

    "golang.org/x/sync/errgroup"
)

type Task struct {
    id       int
    duration time.Duration
    willFail bool
}

func (t *Task) Execute(ctx context.Context) error {
    fmt.Printf("Task %d: started\n", t.id)

    select {
    case <-time.After(t.duration):
        if t.willFail {
            err := fmt.Errorf("task %d failed", t.id)
            fmt.Printf("Task %d: %v\n", t.id, err)
            return err
        }
        fmt.Printf("Task %d: completed successfully\n", t.id)
        return nil
    case <-ctx.Done():
        fmt.Printf("Task %d: cancelled (%v)\n", t.id, ctx.Err())
        return ctx.Err()
    }
}

func main() {
    // 使用 errgroup 管理多个 goroutine
    g, ctx := errgroup.WithContext(context.Background())

    tasks := []*Task{
        {id: 1, duration: 1 * time.Second, willFail: false},
        {id: 2, duration: 2 * time.Second, willFail: false},
        {id: 3, duration: 500 * time.Millisecond, willFail: true}, // 这个会失败
        {id: 4, duration: 3 * time.Second, willFail: false},
        {id: 5, duration: 1500 * time.Millisecond, willFail: false},
    }

    // 启动所有任务
    for _, task := range tasks {
        task := task // 避免闭包陷阱
        g.Go(func() error {
            return task.Execute(ctx)
        })
    }

    // 等待所有任务完成或某个任务失败
    if err := g.Wait(); err != nil {
        fmt.Printf("\nShutdown triggered by error: %v\n", err)
    } else {
        fmt.Println("\nAll tasks completed successfully")
    }
}
```

**errgroup 的优势**：
1. **自动取消**：任一 goroutine 返回错误，自动取消 context
2. **错误收集**：`Wait()` 返回第一个非 nil 错误
3. **简化代码**：不需要手动管理 WaitGroup 和 Context

**输出示例**：
```
Task 1: started
Task 2: started
Task 3: started
Task 4: started
Task 5: started
Task 3: task 3 failed
Task 5: cancelled (context canceled)
Task 1: cancelled (context canceled)
Task 2: cancelled (context canceled)
Task 4: cancelled (context canceled)

Shutdown triggered by error: task 3 failed
```

---

### 五、HTTP 服务器优雅关闭

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // 创建 HTTP 服务器
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        // 模拟长时间运行的请求
        time.Sleep(2 * time.Second)
        fmt.Fprintf(w, "Request completed at %v\n", time.Now())
    })

    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }

    // 在 goroutine 中启动服务器
    go func() {
        fmt.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            fmt.Printf("Server error: %v\n", err)
        }
    }()

    // 监听系统信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

    // 阻塞直到收到信号
    sig := <-quit
    fmt.Printf("\nReceived signal: %v\n", sig)

    // 创建关闭 context（30 秒超时）
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    fmt.Println("Shutting down server...")

    // 优雅关闭（等待现有连接完成）
    if err := server.Shutdown(ctx); err != nil {
        fmt.Printf("Server forced to shutdown: %v\n", err)
    } else {
        fmt.Println("Server exited gracefully")
    }
}
```

**测试方法**：
```bash
# 终端 1：启动服务器
go run main.go

# 终端 2：发起请求
curl http://localhost:8080

# 终端 1：按 Ctrl+C 关闭
# 观察：服务器会等待请求完成后才退出
```

---

### 六、工作池模式的优雅关闭

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type WorkerPool struct {
    workerCount int
    jobs        chan Job
    wg          sync.WaitGroup
    ctx         context.Context
    cancel      context.CancelFunc
}

type Job struct {
    ID   int
    Data string
}

func NewWorkerPool(workerCount int, bufferSize int) *WorkerPool {
    ctx, cancel := context.WithCancel(context.Background())
    return &WorkerPool{
        workerCount: workerCount,
        jobs:        make(chan Job, bufferSize),
        ctx:         ctx,
        cancel:      cancel,
    }
}

func (wp *WorkerPool) Start() {
    for i := 1; i <= wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
    fmt.Printf("Worker pool started with %d workers\n", wp.workerCount)
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()

    for {
        select {
        case job, ok := <-wp.jobs:
            if !ok {
                // Channel 已关闭，退出
                fmt.Printf("Worker %d: jobs channel closed, exiting\n", id)
                return
            }
            wp.processJob(id, job)
        case <-wp.ctx.Done():
            // 收到取消信号，处理完当前任务后退出
            fmt.Printf("Worker %d: context cancelled, draining remaining jobs\n", id)
            // 处理剩余任务
            for job := range wp.jobs {
                wp.processJob(id, job)
            }
            return
        }
    }
}

func (wp *WorkerPool) processJob(workerID int, job Job) {
    fmt.Printf("Worker %d: processing job %d (%s)\n", workerID, job.ID, job.Data)
    time.Sleep(500 * time.Millisecond) // 模拟工作
    fmt.Printf("Worker %d: completed job %d\n", workerID, job.ID)
}

func (wp *WorkerPool) Submit(job Job) bool {
    select {
    case wp.jobs <- job:
        return true
    case <-wp.ctx.Done():
        return false
    }
}

func (wp *WorkerPool) Shutdown(timeout time.Duration) error {
    fmt.Println("Initiating worker pool shutdown...")

    // 1. 停止接收新任务
    wp.cancel()

    // 2. 关闭 jobs channel（通知 worker 处理完剩余任务后退出）
    close(wp.jobs)

    // 3. 等待所有 worker 完成（带超时）
    done := make(chan struct{})
    go func() {
        wp.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("All workers stopped gracefully")
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("shutdown timeout after %v", timeout)
    }
}

func main() {
    pool := NewWorkerPool(3, 10)
    pool.Start()

    // 提交任务
    for i := 1; i <= 10; i++ {
        job := Job{
            ID:   i,
            Data: fmt.Sprintf("task-%d", i),
        }
        if !pool.Submit(job) {
            fmt.Printf("Failed to submit job %d\n", i)
        }
    }

    // 等待一段时间后关闭
    time.Sleep(2 * time.Second)

    if err := pool.Shutdown(5 * time.Second); err != nil {
        fmt.Printf("Shutdown error: %v\n", err)
    }
}
```

**关键设计**：
1. **双重信号**：
   - `ctx.Done()` 表示不再接收新任务
   - `close(jobs)` 表示处理完现有任务后退出
2. **任务排空**：worker 会处理完 channel 中的剩余任务
3. **超时保护**：避免某些任务卡住导致无法关闭

---

### 七、最佳实践总结

#### 7.1 选择合适的模式

| 场景                     | 推荐方案                          | 示例                     |
| ------------------------ | --------------------------------- | ------------------------ |
| 简单并发任务             | Context + WaitGroup               | 多个独立的后台任务       |
| 需要错误处理             | errgroup.Group                    | 多个可能失败的任务       |
| HTTP 服务器              | http.Server.Shutdown()            | Web 应用                 |
| 工作池                   | Context + Channel + WaitGroup     | 任务队列处理             |
| 复杂服务（多组件）       | 分层关闭 + 超时控制               | 微服务架构               |

#### 7.2 关闭流程检查清单

```go
// ✅ 标准优雅关闭流程
func GracefulShutdown() {
    // 1. 停止接收新请求/任务
    cancel() // 或 close(inputChannel)

    // 2. 等待正在执行的任务完成
    wg.Wait() // 或 errgroup.Wait()

    // 3. 清理资源
    db.Close()
    cache.Flush()

    // 4. 记录日志
    log.Info("Shutdown completed")
}
```

#### 7.3 常见陷阱

**❌ 陷阱 1：忘记等待 goroutine 完成**
```go
// 错误
func main() {
    go worker()
    cancel()
    // 主进程直接退出，worker 可能未完成清理
}

// 正确
func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(&wg)
    cancel()
    wg.Wait() // 等待 worker 完成
}
```

**❌ 陷阱 2：没有超时保护**
```go
// 危险
wg.Wait() // 如果某个 goroutine 卡住，永远等待

// 安全
done := make(chan struct{})
go func() {
    wg.Wait()
    close(done)
}()

select {
case <-done:
    fmt.Println("All done")
case <-time.After(30 * time.Second):
    fmt.Println("Timeout!")
}
```

**❌ 陷阱 3：忽略 context 取消**
```go
// 错误：不检查 context
func worker(ctx context.Context) {
    for {
        doWork() // 即使 context 取消也继续执行
    }
}

// 正确
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            doWork()
        }
    }
}
```

---

### 八、完整示例：生产级服务

```go
package main

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"
)

type Service struct {
    name      string
    startFunc func(context.Context) error
    stopFunc  func() error
}

type Application struct {
    services []*Service
    wg       sync.WaitGroup
    ctx      context.Context
    cancel   context.CancelFunc
}

func NewApplication() *Application {
    ctx, cancel := context.WithCancel(context.Background())
    return &Application{
        services: make([]*Service, 0),
        ctx:      ctx,
        cancel:   cancel,
    }
}

func (app *Application) RegisterService(svc *Service) {
    app.services = append(app.services, svc)
}

func (app *Application) Start() error {
    for _, svc := range app.services {
        svc := svc
        app.wg.Add(1)
        go func() {
            defer app.wg.Done()
            if err := svc.startFunc(app.ctx); err != nil {
                fmt.Printf("[%s] Error: %v\n", svc.name, err)
            }
        }()
    }

    fmt.Println("All services started")
    return nil
}

func (app *Application) Shutdown(timeout time.Duration) error {
    fmt.Println("\n=== Starting graceful shutdown ===")

    // 1. 广播取消信号
    app.cancel()

    // 2. 调用各服务的停止函数
    for _, svc := range app.services {
        if svc.stopFunc != nil {
            if err := svc.stopFunc(); err != nil {
                fmt.Printf("[%s] Stop error: %v\n", svc.name, err)
            }
        }
    }

    // 3. 等待所有服务完成（带超时）
    done := make(chan struct{})
    go func() {
        app.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("=== Shutdown completed successfully ===")
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("shutdown timeout after %v", timeout)
    }
}

func main() {
    app := NewApplication()

    // 注册服务 1：定时任务
    app.RegisterService(&Service{
        name: "scheduler",
        startFunc: func(ctx context.Context) error {
            ticker := time.NewTicker(1 * time.Second)
            defer ticker.Stop()

            for {
                select {
                case <-ctx.Done():
                    fmt.Println("[scheduler] Stopping...")
                    return nil
                case <-ticker.C:
                    fmt.Println("[scheduler] Tick")
                }
            }
        },
    })

    // 注册服务 2：数据处理
    app.RegisterService(&Service{
        name: "processor",
        startFunc: func(ctx context.Context) error {
            for {
                select {
                case <-ctx.Done():
                    fmt.Println("[processor] Flushing buffer...")
                    time.Sleep(500 * time.Millisecond)
                    fmt.Println("[processor] Stopped")
                    return nil
                case <-time.After(2 * time.Second):
                    fmt.Println("[processor] Processing batch")
                }
            }
        },
    })

    // 启动应用
    if err := app.Start(); err != nil {
        fmt.Printf("Failed to start: %v\n", err)
        os.Exit(1)
    }

    // 监听系统信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    // 优雅关闭（10 秒超时）
    if err := app.Shutdown(10 * time.Second); err != nil {
        fmt.Printf("Shutdown error: %v\n", err)
        os.Exit(1)
    }
}
```

---

## 总结

**优雅关闭的核心要素**：
1. **信号传播**：Context 或 done channel 广播关闭信号
2. **完成等待**：WaitGroup 确保所有 goroutine 完成
3. **超时保护**：避免无限等待
4. **资源清理**：关闭连接、刷新缓冲、持久化状态

**面试回答框架**：
1. 说明为什么需要优雅关闭（资源泄漏、数据丢失）
2. 介绍基础模式（Context + WaitGroup）
3. 展示进阶技巧（超时控制、errgroup、HTTP 服务器）
4. 强调生产环境最佳实践（分层关闭、监控信号）

**推荐工具**：
- `golang.org/x/sync/errgroup`：管理多个 goroutine 和错误
- `github.com/oklog/run`：优雅管理多个服务的生命周期
- `github.com/uber-go/fx`：依赖注入 + 生命周期管理
