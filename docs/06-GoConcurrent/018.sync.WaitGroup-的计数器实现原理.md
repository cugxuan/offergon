---
title: sync.WaitGroup 的计数器实现原理
tags:
  - Go并发
  - 同步原语
status: robot
class: Go并发
slug: waitgroup-counter-implementation
ref:
---

## 核心要点

- **64位状态机**:使用一个 uint64 同时存储计数器(高32位)和等待者数量(低32位)
- **原子操作**:Add/Done/Wait 都通过 atomic.AddUint64 和 CompareAndSwap 实现无锁操作
- **信号量唤醒**:当计数器归零时,通过 runtime_Semrelease 唤醒所有等待的 goroutine
- **复用检测**:使用额外的状态位防止 WaitGroup 被错误复用

---

## 详细回答

### 一、WaitGroup 的数据结构

#### 源码实现(sync/waitgroup.go)

```go
type WaitGroup struct {
    noCopy noCopy  // 防止拷贝检测器

    state atomic.Uint64  // 高32位:计数器, 低32位:等待者数量
    sema  uint32          // 信号量,用于阻塞和唤醒 goroutine
}
```

**状态字段布局**:
```
|<--- 32位计数器 --->|<--- 32位等待者数量 --->|
| counter (高32位)   | waiter count (低32位)  |
```

**为什么使用一个 64 位整数?**
- **原子操作要求**:可以通过一次 atomic 操作同时读取/修改两个值
- **避免竞态**:防止 Add 和 Wait 之间的时序问题

### 二、核心方法实现

#### 1. Add(delta int) - 增加计数

```go
func (wg *WaitGroup) Add(delta int) {
    // 1. 原子地将 delta 加到高32位计数器
    state := wg.state.Add(uint64(delta) << 32)

    v := int32(state >> 32)  // 提取计数器值
    w := uint32(state)       // 提取等待者数量

    // 2. 校验:计数器不能为负
    if v < 0 {
        panic("sync: negative WaitGroup counter")
    }

    // 3. 校验:Add 和 Wait 不能并发调用
    if w != 0 && delta > 0 && v == int32(delta) {
        panic("sync: WaitGroup misuse: Add called concurrently with Wait")
    }

    // 4. 如果计数器 > 0 或者没有等待者,直接返回
    if v > 0 || w == 0 {
        return
    }

    // 5. 计数器归零且有等待者 → 唤醒所有等待者
    // 此时必须保证没有新的 Add/Wait 并发进行
    if wg.state.Load() != state {
        panic("sync: WaitGroup misuse: Add/Wait concurrency")
    }

    // 重置状态为 0
    wg.state.Store(0)

    // 唤醒所有 w 个等待的 goroutine
    for ; w != 0; w-- {
        runtime_Semrelease(&wg.sema, false, 0)
    }
}
```

**关键点**:
- `delta << 32`:将增量左移 32 位,操作高位计数器
- 归零检测:当 `v == 0 && w > 0` 时触发唤醒
- 原子性:整个检查和唤醒过程通过状态字的原子性保证

#### 2. Done() - 减少计数

```go
func (wg *WaitGroup) Done() {
    wg.Add(-1)  // 简单包装,计数器 -1
}
```

**设计精妙之处**:
- Done 复用 Add 的逻辑,减少代码重复
- 当最后一个 Done 调用使计数器归零时,自动触发唤醒

#### 3. Wait() - 等待计数器归零

```go
func (wg *WaitGroup) Wait() {
    for {
        state := wg.state.Load()
        v := int32(state >> 32)  // 提取计数器
        w := uint32(state)       // 提取等待者数量

        // 1. 快速路径:如果计数器已归零,直接返回
        if v == 0 {
            return
        }

        // 2. 慢速路径:增加等待者计数
        // CAS 原子地将等待者数量 +1
        if wg.state.CompareAndSwap(state, state+1) {
            // 3. 阻塞当前 goroutine
            runtime_Semacquire(&wg.sema)

            // 4. 被唤醒后检查状态是否被正确重置
            if wg.state.Load() != 0 {
                panic("sync: WaitGroup is reused before previous Wait has returned")
            }
            return
        }
    }
}
```

**关键点**:
- CAS 循环:处理并发 Wait 的竞争
- Semacquire:阻塞当前 goroutine,直到被 Semrelease 唤醒
- 复用检测:确保上一轮 Wait 完成后才能复用 WaitGroup

### 三、原子操作的细节

#### 1. 状态字操作

```go
// Add(2) 的原子操作
old_state = 0x0000000000000005  // counter=0, waiter=5
new_state = old_state + (2 << 32)
         = 0x0000000000000005 + 0x0000000200000000
         = 0x0000000200000005  // counter=2, waiter=5
```

**优势**:
- 单次原子操作完成计数器修改和等待者数量读取
- 避免 TOCTOU(Time-Of-Check-Time-Of-Use)问题

#### 2. 并发场景示例

**场景1: 正常使用**
```go
var wg sync.WaitGroup

// Goroutine 1
wg.Add(2)        // state: 0x0000000200000000 (counter=2, waiter=0)
go task1()
go task2()
wg.Wait()        // state: 0x0000000200000001 (counter=2, waiter=1)

// Goroutine 2 (task1)
wg.Done()        // state: 0x0000000100000001 (counter=1, waiter=1)

// Goroutine 3 (task2)
wg.Done()        // state: 0x0000000000000001 (counter=0, waiter=1)
                 // 触发唤醒 → state: 0x0000000000000000
```

**场景2: 错误用法(并发 Add 和 Wait)**
```go
var wg sync.WaitGroup
wg.Add(1)

// Goroutine 1
go func() {
    wg.Wait()    // 阻塞,等待者 +1
}()

// Goroutine 2
wg.Add(1)        // panic: Add called concurrently with Wait
```

**检测逻辑**:
```go
if w != 0 && delta > 0 && v == int32(delta) {
    // w != 0: 有等待者
    // delta > 0: 正在增加计数
    // v == delta: 说明 Add 前计数器是 0
    // → 证明 Add 和 Wait 并发了!
    panic(...)
}
```

### 四、信号量机制

#### 1. runtime_Semacquire (阻塞)

```go
// 内部调用 runtime.semacquire
func runtime_Semacquire(s *uint32)
```

**行为**:
- 如果 `*s > 0`,则 `*s--` 并立即返回
- 否则,将当前 goroutine 加入等待队列并挂起

#### 2. runtime_Semrelease (唤醒)

```go
// 内部调用 runtime.semrelease
func runtime_Semrelease(s *uint32, handoff bool, skipframes int)
```

**行为**:
- `*s++`,并唤醒一个等待的 goroutine
- WaitGroup 中循环调用 w 次,唤醒所有等待者

#### 3. 信号量与互斥锁的区别

| 特性 | 信号量 | 互斥锁 |
|-----|--------|--------|
| 计数 | 可以 > 1 | 只有 0/1 |
| 释放者 | 任意 goroutine | 必须是持锁者 |
| 用途 | 资源计数/事件通知 | 临界区保护 |

WaitGroup 使用信号量作为**事件通知机制**,而非资源保护。

### 五、内存对齐与性能优化

#### 1. 32位系统的特殊处理

在 32 位系统上,64 位原子操作要求地址 8 字节对齐:

```go
func (wg *WaitGroup) state1() (statep *uint64, semap *uint32) {
    if unsafe.Alignof(wg.state) == 8 {
        // 64位系统或已对齐,直接使用
        return &wg.state, &wg.sema
    } else {
        // 32位系统,可能未对齐
        // 使用 sema 字段的地址空间存储 state
        return (*uint64)(unsafe.Pointer(&wg.sema)), &wg.state
    }
}
```

**原因**: ARM32 等架构对未对齐的 64 位原子操作会 panic。

#### 2. noCopy 防止拷贝

```go
type noCopy struct{}

func (*noCopy) Lock()   {}
func (*noCopy) Unlock() {}
```

**作用**:
- `go vet` 检测到实现了 Lock/Unlock 的类型会警告拷贝
- 防止 `wg2 := wg1` 导致状态不一致

### 六、常见陷阱与最佳实践

#### 1. 计数器为负

```go
var wg sync.WaitGroup
wg.Done()  // panic: negative WaitGroup counter
```

**原因**: Done 比 Add 多调用。

#### 2. 并发 Add 和 Wait

```go
var wg sync.WaitGroup
wg.Add(1)
go func() {
    time.Sleep(10 * time.Millisecond)
    wg.Add(1)  // 可能 panic
}()
wg.Wait()
```

**正确做法**: 所有 Add 必须在 Wait 之前调用。

#### 3. 过早复用

```go
var wg sync.WaitGroup
wg.Add(1)
go func() {
    wg.Done()
    wg.Add(1)  // 错误!上一轮 Wait 可能还未返回
}()
wg.Wait()
```

**正确做法**: 等待 Wait 返回后再复用。

#### 4. 最佳实践

```go
// ✅ 正确:在启动 goroutine 前调用 Add
var wg sync.WaitGroup
wg.Add(2)
go func() { defer wg.Done(); task1() }()
go func() { defer wg.Done(); task2() }()
wg.Wait()

// ❌ 错误:在 goroutine 内调用 Add(竞态)
var wg sync.WaitGroup
go func() {
    wg.Add(1)  // 可能在 Wait 之后执行
    defer wg.Done()
    task()
}()
wg.Wait()
```

### 七、性能分析

#### 1. 时间复杂度

| 操作 | 复杂度 | 说明 |
|-----|--------|------|
| Add/Done | O(1) | 一次原子加法 |
| Wait (无阻塞) | O(1) | 一次原子读 |
| Wait (阻塞) | O(1) | 信号量挂起 |
| 唤醒所有等待者 | O(w) | w = 等待者数量 |

#### 2. 与 Channel 对比

**方案1: 使用 Channel**
```go
done := make(chan struct{}, n)
for i := 0; i < n; i++ {
    go func() {
        task()
        done <- struct{}{}
    }()
}
for i := 0; i < n; i++ {
    <-done
}
```

**方案2: 使用 WaitGroup**
```go
var wg sync.WaitGroup
wg.Add(n)
for i := 0; i < n; i++ {
    go func() {
        defer wg.Done()
        task()
    }()
}
wg.Wait()
```

**性能对比**:
- **WaitGroup 更快**:无需 channel 的内存分配和同步开销
- **Channel 更灵活**:可以传递数据,支持 select

### 八、面试要点总结

1. **数据结构**:64位状态字 = 高32位计数器 + 低32位等待者数量
2. **原子操作**:通过 atomic.AddUint64 和 CAS 实现无锁并发
3. **信号量机制**:使用 runtime 信号量实现阻塞和唤醒
4. **错误检测**:编译时禁止拷贝,运行时检测并发 Add/Wait
5. **性能优化**:单次原子操作同时修改计数器和读取等待者,O(1) 时间复杂度
