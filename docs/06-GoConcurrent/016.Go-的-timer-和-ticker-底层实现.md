---
title: Go 的 timer 和 ticker 底层实现
tags:
  - Go并发
status: robot
class: Go并发
slug: go-timer-ticker-implementation
ref:
---

## 核心要点

- **四叉堆管理**:Go 1.14+ 使用 per-P 的四叉堆存储定时器,每个 P 维护独立的 timer 堆
- **timer 状态机**:定时器有 10 种状态(timerWaiting、timerRunning 等),状态转换控制生命周期
- **触发机制**:调度循环中检查堆顶最近到期的 timer,到期后执行回调并更新状态
- **Ticker 复用**:Ticker 通过 timer 实现周期性触发,每次触发后重新设置 when 时间并调整堆位置

---

## 详细回答

### 一、Timer 和 Ticker 的关系

在 Go 的 time 包中,`Timer` 和 `Ticker` 都是基于底层的 **runtime timer** 机制实现的:

- **Timer**:一次性定时器,到期后触发一次事件
- **Ticker**:周期性定时器,本质是 Timer 的周期性封装,每次触发后自动重置下次触发时间

### 二、底层数据结构

#### 1. timer 结构体(runtime/time.go)

```go
type timer struct {
    pp      uintptr  // 所属的 P
    when    int64    // 触发时间(纳秒时间戳)
    period  int64    // 周期(0表示一次性timer,>0表示ticker)
    f       func(interface{}, uintptr)  // 回调函数
    arg     interface{}  // 回调参数
    seq     uintptr      // 序列号
    nextwhen int64       // 下次触发时间(用于ticker)
    status  uint32       // 状态标记
}
```

**关键字段说明**:
- `when`:绝对触发时间,用于堆排序
- `period`:区分 Timer(period=0) 和 Ticker(period>0)
- `status`:状态机控制,确保并发安全

#### 2. 四叉堆存储(Go 1.14+优化)

Go 1.14 之前使用全局锁的四叉堆,性能瓶颈严重。**1.14 版本改为 per-P 的四叉堆**:

```go
type p struct {
    // ...
    timers []*timer  // 当前P的timer堆(四叉堆)
    numTimers uint32 // timer数量
    // ...
}
```

**四叉堆特点**:
- 每个节点最多 4 个子节点,相比二叉堆减少比较次数
- 堆顶永远是最近要触发的 timer
- 插入/删除复杂度 O(log₄N)

### 三、Timer 状态机

定时器有 **10 种状态**,状态转换通过原子操作保证并发安全:

| 状态 | 含义 |
|-----|------|
| timerNoStatus | 未初始化 |
| timerWaiting | 在堆中等待触发 |
| timerRunning | 正在执行回调 |
| timerDeleted | 已标记删除 |
| timerRemoving | 正在从堆移除 |
| timerRemoved | 已从堆移除 |
| timerModifying | 正在修改时间 |
| timerModifiedEarlier | 修改为更早时间 |
| timerModifiedLater | 修改为更晚时间 |
| timerMoving | 正在P间迁移 |

**状态转换示例**:
```
创建: timerNoStatus → timerWaiting
触发: timerWaiting → timerRunning → timerWaiting(ticker) / timerRemoved(timer)
停止: timerWaiting → timerDeleted → timerRemoving → timerRemoved
```

### 四、触发流程

#### 1. 调度循环检查(schedule → findrunnable → checkTimers)

```go
// runtime/proc.go
func schedule() {
    // 每次调度时检查当前P的timers
    now := nanotime()
    pollUntil := int64(0)

    if pp.numTimers > 0 {
        // 检查堆顶timer是否到期
        pollUntil = pp.timers[0].when
        if pollUntil <= now {
            // 有到期的timer,执行之
            runtimer(pp, now)
        }
    }
    // ...
}
```

#### 2. 执行 timer 回调(runtimer)

```go
func runtimer(pp *p, now int64) {
    for {
        t := pp.timers[0]  // 堆顶timer

        if t.when > now {
            break  // 未到期,退出
        }

        // 状态转换: timerWaiting → timerRunning
        atomic.Cas(&t.status, timerWaiting, timerRunning)

        // 执行回调(非阻塞)
        runOneTimer(pp, t, now)

        // 如果是ticker(period>0),重新入堆
        if t.period > 0 {
            t.when += t.period * int64(...)
            siftdownTimer(pp.timers, 0)  // 调整堆
        } else {
            // 一次性timer,标记删除
            atomic.Store(&t.status, timerRemoved)
            dodeltimer(pp, 0)
        }
    }
}
```

#### 3. Ticker 的周期性触发

Ticker 的关键在于 **period 字段**:
- 每次触发后,`when += period`
- 调用 `siftdownTimer` 重新调整堆位置
- 循环往复,直到 Stop() 被调用

### 五、性能优化要点

#### 1. per-P 设计避免全局锁

**旧版本问题**(Go 1.13):
```go
var timers struct {
    lock mutex
    t    []*timer  // 全局堆
}
```
所有 P 共享一个堆,高并发下锁竞争严重。

**新版本优化**(Go 1.14+):
- 每个 P 独立维护 timer 堆
- 只有 timer 迁移时需要跨 P 操作
- 大幅降低锁竞争

#### 2. 四叉堆减少比较

相比二叉堆,四叉堆高度更低:
- 1000 个 timer:二叉堆高度 10,四叉堆高度 5
- 插入/删除减少约 50% 比较次数

#### 3. 状态机避免并发冲突

通过原子状态转换,避免多个 goroutine 同时操作 timer 导致数据竞争。

### 六、使用示例对比

#### Timer(一次性)
```go
timer := time.NewTimer(2 * time.Second)
<-timer.C  // 阻塞直到到期
fmt.Println("Timer fired!")
```

底层行为:
1. 创建 timer,`period=0`,`when=now+2s`
2. 入堆,状态 → timerWaiting
3. 2 秒后触发,发送信号到 `timer.C`
4. 状态 → timerRemoved,从堆删除

#### Ticker(周期性)
```go
ticker := time.NewTicker(1 * time.Second)
defer ticker.Stop()

for t := range ticker.C {
    fmt.Println("Tick at", t)
}
```

底层行为:
1. 创建 timer,`period=1s`,`when=now+1s`
2. 每次触发后:`when += 1s`,重新入堆
3. Stop() 时状态 → timerDeleted → timerRemoved

### 七、面试要点总结

1. **数据结构**:per-P 的四叉堆,避免全局锁
2. **状态机**:10 种状态通过原子操作转换,保证并发安全
3. **触发机制**:调度循环检查堆顶,到期执行回调
4. **Ticker 实现**:复用 timer,通过 period 字段实现周期触发
5. **性能优化**:1.14 版本的 per-P 设计是关键里程碑
