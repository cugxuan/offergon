---
title: 如何实现一个支持取消的 context 链？
tags:
  - Go并发
  - 上下文
status: robot
class: Go并发
slug: implement-cancelable-context-chain
ref:
---

## 要点提炼

**核心概念**：Context 通过树形结构传播取消信号,父 context 取消时,所有子 context 自动取消。

**关键机制**：
1. **取消传播**：`context.WithCancel()` 创建可取消的子 context
2. **超时控制**：`context.WithTimeout()` 和 `WithDeadline()` 自动取消
3. **值传递**：`context.WithValue()` 传递请求级别的元数据
4. **链式组合**：多层 context 形成取消链,任一父节点取消则全部子节点取消

---

## 详细回答

### 一、Context 的设计理念

**为什么需要 Context?**

在 Go 的并发编程中,常见的问题包括:
1. **如何优雅地停止 goroutine?** → Context 提供统一的取消机制
2. **如何传递请求超时时间?** → Context 支持 deadline 和 timeout
3. **如何传递请求级别的值?** → Context 携带 key-value 对

**Context 接口**:

```go
type Context interface {
    // Deadline 返回 context 的截止时间
    Deadline() (deadline time.Time, ok bool)

    // Done 返回一个 channel,当 context 取消时关闭
    Done() <-chan struct{}

    // Err 返回 context 取消的原因
    Err() error // 可能是 Canceled 或 DeadlineExceeded

    // Value 返回与 key 关联的值
    Value(key interface{}) interface{}
}
```

---

### 二、基础 Context 类型

#### 2.1 Background 和 TODO

```go
// Background 是所有 context 的根节点,永不取消
ctx := context.Background()

// TODO 用于还不确定使用什么 context 的场景
ctx := context.TODO()
```

**使用场景**:
- `Background()`：main 函数、初始化、测试的顶层 context
- `TODO()`：代码重构中的临时占位符

---

#### 2.2 WithCancel - 手动取消

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d: stopped (%v)\n", id, ctx.Err())
            return
        default:
            fmt.Printf("Worker %d: working...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    // 创建可取消的 context
    ctx, cancel := context.WithCancel(context.Background())

    // 启动 3 个 worker
    for i := 1; i <= 3; i++ {
        go worker(ctx, i)
    }

    // 运行 2 秒后取消
    time.Sleep(2 * time.Second)
    fmt.Println("Canceling context...")
    cancel() // 通知所有 worker 停止

    // 等待 worker 退出
    time.Sleep(1 * time.Second)
}
```

**输出**:
```
Worker 1: working...
Worker 2: working...
Worker 3: working...
...
Canceling context...
Worker 1: stopped (context canceled)
Worker 2: stopped (context canceled)
Worker 3: stopped (context canceled)
```

---

#### 2.3 WithTimeout - 超时自动取消

```go
func fetchData(ctx context.Context, url string) error {
    // 创建 5 秒超时的 context
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel() // 确保资源释放

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        // 如果超时, err 是 context.DeadlineExceeded
        return err
    }
    defer resp.Body.Close()

    fmt.Printf("Status: %s\n", resp.Status)
    return nil
}

func main() {
    ctx := context.Background()

    // 快速的 API
    if err := fetchData(ctx, "https://www.google.com"); err != nil {
        fmt.Printf("Error: %v\n", err)
    }

    // 慢速的 API (会超时)
    if err := fetchData(ctx, "https://httpbin.org/delay/10"); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
}
```

---

#### 2.4 WithDeadline - 指定截止时间

```go
func processUntilDeadline() {
    // 设置截止时间为 3 秒后
    deadline := time.Now().Add(3 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()

    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Deadline reached: %v\n", ctx.Err())
            return
        default:
            fmt.Println("Processing...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```

---

#### 2.5 WithValue - 传递请求元数据

```go
type contextKey string

const (
    requestIDKey contextKey = "request-id"
    userIDKey    contextKey = "user-id"
)

func handleRequest(ctx context.Context) {
    // 从 context 中读取值
    requestID := ctx.Value(requestIDKey)
    userID := ctx.Value(userIDKey)

    fmt.Printf("Request ID: %v, User ID: %v\n", requestID, userID)

    // 传递给下游函数
    processData(ctx)
}

func processData(ctx context.Context) {
    // 继承上游的 context 值
    requestID := ctx.Value(requestIDKey)
    fmt.Printf("Processing data for request: %v\n", requestID)
}

func main() {
    ctx := context.Background()

    // 添加请求 ID
    ctx = context.WithValue(ctx, requestIDKey, "req-12345")

    // 添加用户 ID
    ctx = context.WithValue(ctx, userIDKey, "user-67890")

    handleRequest(ctx)
}
```

**注意事项**:
- ⚠️ 不要用 Context 传递可选参数,只传递请求级别的元数据
- ⚠️ Key 应该是自定义类型(避免冲突)
- ⚠️ Value 应该是只读的,不要修改

---

### 三、Context 链的实现原理

#### 3.1 Context 树形结构

```
context.Background() (root)
    ├─ WithCancel() → ctx1
    │   ├─ WithTimeout(3s) → ctx2
    │   │   └─ WithValue("user", "alice") → ctx3
    │   └─ WithValue("request-id", "123") → ctx4
    └─ WithDeadline(t) → ctx5

取消传播:
- cancel ctx1 → ctx2, ctx3, ctx4 全部取消
- cancel ctx2 → ctx3 取消, ctx4 不受影响
```

#### 3.2 简化的 Context 实现

```go
package context

import (
    "sync"
    "time"
)

// cancelCtx 可取消的 context
type cancelCtx struct {
    Context                    // 父 context
    mu       sync.Mutex        // 保护以下字段
    done     chan struct{}     // 关闭时通知取消
    children map[canceler]struct{} // 子 context 列表
    err      error             // 取消原因
}

type canceler interface {
    cancel(removeFromParent bool, err error)
    Done() <-chan struct{}
}

// WithCancel 创建可取消的 context
func WithCancel(parent Context) (Context, CancelFunc) {
    c := &cancelCtx{
        Context: parent,
        done:    make(chan struct{}),
    }

    // 将自己注册到父 context
    propagateCancel(parent, c)

    return c, func() { c.cancel(true, Canceled) }
}

// Done 返回取消通知 channel
func (c *cancelCtx) Done() <-chan struct{} {
    return c.done
}

// Err 返回取消原因
func (c *cancelCtx) Err() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.err
}

// cancel 取消 context
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    c.mu.Lock()

    if c.err != nil {
        c.mu.Unlock()
        return // 已取消
    }

    c.err = err
    close(c.done) // 关闭 channel,通知所有监听者

    // 递归取消所有子 context
    for child := range c.children {
        child.cancel(false, err)
    }
    c.children = nil

    c.mu.Unlock()

    if removeFromParent {
        removeChild(c.Context, c) // 从父节点移除自己
    }
}

// propagateCancel 监听父 context 的取消信号
func propagateCancel(parent Context, child canceler) {
    if parent.Done() == nil {
        return // 父 context 永不取消
    }

    // 找到最近的可取消父 context
    if p, ok := parentCancelCtx(parent); ok {
        p.mu.Lock()
        if p.err != nil {
            // 父 context 已取消,立即取消子 context
            child.cancel(false, p.err)
        } else {
            // 注册到父 context 的 children 列表
            if p.children == nil {
                p.children = make(map[canceler]struct{})
            }
            p.children[child] = struct{}{}
        }
        p.mu.Unlock()
    } else {
        // 父 context 不是 cancelCtx,启动 goroutine 监听
        go func() {
            select {
            case <-parent.Done():
                child.cancel(false, parent.Err())
            case <-child.Done():
            }
        }()
    }
}
```

**关键点**:
1. **链式取消**: 父 context 取消时,递归取消所有子 context
2. **懒惰监听**: 只有需要时才启动 goroutine 监听父 context
3. **线程安全**: 使用 mutex 保护共享状态

---

### 四、实战案例：HTTP 服务器请求处理

```go
package main

import (
    "context"
    "fmt"
    "math/rand"
    "net/http"
    "time"
)

type contextKey string

const requestIDKey contextKey = "request-id"

// Middleware: 为每个请求生成 request ID
func requestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := fmt.Sprintf("req-%d", rand.Int63())
        ctx := context.WithValue(r.Context(), requestIDKey, requestID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// Middleware: 设置请求超时
func timeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), timeout)
            defer cancel()
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

// Handler: 处理业务逻辑
func handleAPI(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    requestID := ctx.Value(requestIDKey)

    fmt.Printf("[%v] Request started\n", requestID)

    // 模拟数据库查询
    if err := queryDatabase(ctx, requestID); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // 模拟外部 API 调用
    if err := callExternalAPI(ctx, requestID); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    fmt.Fprintf(w, "Success! Request ID: %v\n", requestID)
}

func queryDatabase(ctx context.Context, requestID interface{}) error {
    // 创建子 context (2 秒超时)
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()

    // 模拟查询
    select {
    case <-time.After(1 * time.Second):
        fmt.Printf("[%v] Database query completed\n", requestID)
        return nil
    case <-ctx.Done():
        fmt.Printf("[%v] Database query canceled: %v\n", requestID, ctx.Err())
        return ctx.Err()
    }
}

func callExternalAPI(ctx context.Context, requestID interface{}) error {
    // 创建子 context (3 秒超时)
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    // 模拟 API 调用
    select {
    case <-time.After(2 * time.Second):
        fmt.Printf("[%v] External API call completed\n", requestID)
        return nil
    case <-ctx.Done():
        fmt.Printf("[%v] External API call canceled: %v\n", requestID, ctx.Err())
        return ctx.Err()
    }
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/api", handleAPI)

    // 应用中间件
    handler := requestIDMiddleware(mux)
    handler = timeoutMiddleware(5 * time.Second)(handler)

    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }

    fmt.Println("Server listening on :8080")
    server.ListenAndServe()
}
```

**Context 链路**:
```
http.Server (根 context)
  ├─ requestIDMiddleware (添加 request-id)
  └─ timeoutMiddleware (5 秒总超时)
      ├─ queryDatabase (2 秒子超时)
      └─ callExternalAPI (3 秒子超时)
```

**测试**:
```bash
# 正常请求 (3 秒内完成)
curl http://localhost:8080/api

# 模拟慢请求 (修改 queryDatabase sleep 为 6 秒, 会触发超时)
```

---

### 五、Context 最佳实践

#### 5.1 函数签名规范

```go
// ✅ 正确: context 作为第一个参数
func DoSomething(ctx context.Context, arg1 string, arg2 int) error {
    // ...
}

// ❌ 错误: context 不应该放在 struct 中
type Server struct {
    ctx context.Context // 不推荐
}

// ✅ 正确: 每个请求创建独立的 context
func (s *Server) HandleRequest(ctx context.Context) {
    // ...
}
```

#### 5.2 避免在循环中创建 context

```go
// ❌ 错误: 每次循环创建新 context
for _, item := range items {
    ctx, cancel := context.WithTimeout(parentCtx, 1*time.Second)
    defer cancel() // defer 在函数退出时才执行,导致 context 泄漏
    process(ctx, item)
}

// ✅ 正确: 在循环内立即 cancel
for _, item := range items {
    func() {
        ctx, cancel := context.WithTimeout(parentCtx, 1*time.Second)
        defer cancel()
        process(ctx, item)
    }()
}

// ✅ 更好: 使用固定超时的 context
ctx, cancel := context.WithTimeout(parentCtx, 10*time.Second)
defer cancel()
for _, item := range items {
    if err := process(ctx, item); err != nil {
        return err
    }
}
```

#### 5.3 Context 值的使用规范

```go
// ✅ 正确: 使用自定义类型作为 key
type contextKey string
const userIDKey contextKey = "user-id"

ctx = context.WithValue(ctx, userIDKey, "alice")

// ❌ 错误: 使用 string 作为 key (容易冲突)
ctx = context.WithValue(ctx, "user-id", "alice")

// ❌ 错误: 传递可选参数 (应该用函数参数)
ctx = context.WithValue(ctx, "pageSize", 20)

// ✅ 正确: 只传递请求级别的元数据
// - 请求 ID
// - 用户认证信息
// - 链路追踪 ID
// - 请求来源 IP
```

#### 5.4 Context 取消检查模式

```go
// 模式 1: 定期检查 (适合长时间运行的任务)
func longRunningTask(ctx context.Context) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            // 执行一小段工作
            doWork()
        }
    }
}

// 模式 2: 在阻塞操作中检查 (适合 I/O 密集型任务)
func ioTask(ctx context.Context) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    case data := <-dataChan:
        process(data)
    case <-time.After(1 * time.Second):
        timeout()
    }
}

// 模式 3: 使用 context-aware 的库函数
func httpRequest(ctx context.Context) error {
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    // http.Client 会自动响应 ctx 的取消
    resp, err := client.Do(req)
    // ...
}
```

---

### 六、常见陷阱

#### 6.1 Context 泄漏

```go
// ❌ 错误: 忘记调用 cancel 导致 goroutine 泄漏
func badExample() {
    ctx, _ := context.WithCancel(context.Background())
    go worker(ctx) // 永远不会停止
}

// ✅ 正确: 必须调用 cancel
func goodExample() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // 确保释放资源
    go worker(ctx)
}
```

#### 6.2 忽略 context 取消

```go
// ❌ 错误: 不检查 context 状态
func badWorker(ctx context.Context) {
    for {
        doWork() // 即使 context 取消也继续运行
    }
}

// ✅ 正确: 响应 context 取消
func goodWorker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            doWork()
        }
    }
}
```

#### 6.3 在 select 中重复监听 Done()

```go
// ❌ 低效: 每次循环都调用 Done()
for {
    select {
    case <-ctx.Done(): // 每次都创建新的 channel 引用
        return
    case data := <-dataChan:
        process(data)
    }
}

// ✅ 高效: 缓存 Done() 的结果
done := ctx.Done()
for {
    select {
    case <-done:
        return
    case data := <-dataChan:
        process(data)
    }
}
```

---

### 七、Context 与 errgroup 结合

```go
package main

import (
    "context"
    "fmt"
    "time"

    "golang.org/x/sync/errgroup"
)

func fetchData(ctx context.Context, id int) error {
    select {
    case <-time.After(time.Duration(id) * time.Second):
        if id == 3 {
            return fmt.Errorf("task %d failed", id)
        }
        fmt.Printf("Task %d completed\n", id)
        return nil
    case <-ctx.Done():
        fmt.Printf("Task %d canceled\n", id)
        return ctx.Err()
    }
}

func main() {
    // errgroup 会自动创建带 cancel 的 context
    g, ctx := errgroup.WithContext(context.Background())

    for i := 1; i <= 5; i++ {
        i := i
        g.Go(func() error {
            return fetchData(ctx, i)
        })
    }

    // 等待所有任务完成或某个任务失败
    if err := g.Wait(); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
}
```

**输出**:
```
Task 1 completed
Task 2 completed
Task 4 canceled
Task 5 canceled
Error: task 3 failed
```

**说明**: Task 3 失败后, errgroup 自动取消 context,导致 Task 4 和 5 被取消。

---

### 八、自定义 Context 实现

```go
package customctx

import (
    "context"
    "sync"
    "time"
)

// CascadeCancelCtx 支持级联取消的 context
type CascadeCancelCtx struct {
    parent   context.Context
    mu       sync.Mutex
    done     chan struct{}
    err      error
    children []context.CancelFunc
}

func WithCascadeCancel(parent context.Context) (context.Context, context.CancelFunc) {
    ctx := &CascadeCancelCtx{
        parent: parent,
        done:   make(chan struct{}),
    }

    go func() {
        select {
        case <-parent.Done():
            ctx.cancel(parent.Err())
        case <-ctx.done:
        }
    }()

    return ctx, func() { ctx.cancel(context.Canceled) }
}

func (c *CascadeCancelCtx) Done() <-chan struct{} {
    return c.done
}

func (c *CascadeCancelCtx) Err() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.err
}

func (c *CascadeCancelCtx) Deadline() (time.Time, bool) {
    return c.parent.Deadline()
}

func (c *CascadeCancelCtx) Value(key interface{}) interface{} {
    return c.parent.Value(key)
}

// AddChild 注册子 context 的 cancel 函数
func (c *CascadeCancelCtx) AddChild(cancel context.CancelFunc) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.children = append(c.children, cancel)
}

func (c *CascadeCancelCtx) cancel(err error) {
    c.mu.Lock()
    defer c.mu.Unlock()

    if c.err != nil {
        return // 已取消
    }

    c.err = err
    close(c.done)

    // 级联取消所有子 context
    for _, cancel := range c.children {
        cancel()
    }
    c.children = nil
}
```

---

## 总结

**Context 链的核心机制**:
1. **树形结构**: 父子关系形成取消传播链
2. **自动取消**: 父 context 取消时递归取消所有子节点
3. **资源管理**: 必须调用 cancel() 释放资源
4. **类型组合**: WithCancel、WithTimeout、WithValue 可嵌套使用

**最佳实践**:
1. ✅ Context 作为第一个参数传递
2. ✅ 不要将 Context 存储在 struct 中
3. ✅ 必须调用 cancel() (使用 defer)
4. ✅ Context.Value 仅用于请求级别的元数据
5. ❌ 不要传递 nil context (使用 context.TODO())
6. ❌ 不要在循环中创建 context 而不 cancel

**面试回答框架**:
1. 解释 Context 的作用(取消传播、超时控制、值传递)
2. 说明 Context 的树形结构和取消机制
3. 展示 WithCancel、WithTimeout 的使用
4. 强调 cancel() 的重要性(资源泄漏)
5. 列举常见陷阱(忘记 cancel、不检查 Done())

**相关工具**:
- `golang.org/x/sync/errgroup`: Context + 错误处理
- `go.opentelemetry.io/otel/trace`: 链路追踪 context
- `github.com/grpc/grpc-go`: gRPC 的 context 传播

---

**进一步学习**:
- [Go Blog: Context](https://go.dev/blog/context)
- [Go Context 源码](https://github.com/golang/go/blob/master/src/context/context.go)
- [Uber Go Style Guide: Context](https://github.com/uber-go/guide/blob/master/style.md#context)
