---
title: 如何检测和解决 goroutine 死锁？
tags:
  - Go并发
  - 并发
  - 死锁
status: robot
class: Go并发
slug: detect-resolve-goroutine-deadlock
ref:
---

## 核心要点

**Go 运行时能自动检测全局死锁(所有 goroutine 都阻塞),并抛出 fatal error。开发者可通过规范加锁顺序、使用超时机制、context 取消、死锁检测工具来预防和诊断死锁问题。**

---

## 什么是 goroutine 死锁

死锁是指两个或多个 goroutine 互相等待对方持有的资源,导致所有 goroutine 永久阻塞无法继续执行的状态。

### 死锁的四个必要条件

1. **互斥条件**:资源不能被多个 goroutine 同时使用
2. **持有并等待**:goroutine 持有资源的同时等待其他资源
3. **不可抢占**:资源不能被强制剥夺,只能主动释放
4. **循环等待**:存在 goroutine 循环等待资源的链条

破坏任何一个条件都能避免死锁。

## Go 运行时的死锁检测

### 全局死锁检测

Go 运行时会检测**全局死锁**(所有 goroutine 都阻塞),并自动 panic:

```go
package main

import "sync"

func main() {
    var mu sync.Mutex
    mu.Lock()
    mu.Lock()  // 尝试再次获取已持有的锁,死锁
}
```

**运行结果**:
```
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [semacquire]:
sync.runtime_SemacquireMutex(0xc000010088, 0x0, 0x1)
    /usr/local/go/src/runtime/sema.go:71 +0x47
sync.(*Mutex).lockSlow(0xc000010080)
    /usr/local/go/src/sync/mutex.go:138 +0x105
sync.(*Mutex).Lock(...)
    /usr/local/go/src/sync/mutex.go:81
main.main()
    /path/to/main.go:8 +0x85
```

Go 运行时能检测到所有 goroutine 都在等待,没有可运行的 goroutine,触发 panic。

### 局部死锁无法检测

如果有其他 goroutine 仍在运行,Go 无法检测局部死锁:

```go
func main() {
    var mu1, mu2 sync.Mutex

    // goroutine 1
    go func() {
        mu1.Lock()
        time.Sleep(100 * time.Millisecond)
        mu2.Lock()  // 等待 mu2
        mu2.Unlock()
        mu1.Unlock()
    }()

    // goroutine 2
    go func() {
        mu2.Lock()
        time.Sleep(100 * time.Millisecond)
        mu1.Lock()  // 等待 mu1
        mu1.Unlock()
        mu2.Unlock()
    }()

    // main goroutine 继续运行,不会触发死锁检测
    select {}
}
```

这种情况下,两个 goroutine 互相等待,但 main goroutine 还在运行,Go 运行时不会报错。

## 常见死锁场景和解决方案

### 1. 重复加锁(自死锁)

**问题代码**:
```go
var mu sync.Mutex

func process() {
    mu.Lock()
    defer mu.Unlock()
    // ... 业务逻辑
    process()  // 递归调用,尝试再次获取锁
}
```

**解决方案**:使用 `sync.RWMutex` 的递归读锁,或重构代码避免递归中加锁

```go
var mu sync.RWMutex

func process() {
    mu.RLock()
    defer mu.RUnlock()
    // 只读操作可以递归
    readData()
}

// 或者分离锁和逻辑
func processWithLock() {
    mu.Lock()
    defer mu.Unlock()
    processWithoutLock()
}

func processWithoutLock() {
    // 实际逻辑,不加锁
}
```

### 2. 循环等待(相互死锁)

**问题代码**:
```go
var mu1, mu2 sync.Mutex

// goroutine A
func transferA2B() {
    mu1.Lock()
    mu2.Lock()
    // 转账操作
    mu2.Unlock()
    mu1.Unlock()
}

// goroutine B
func transferB2A() {
    mu2.Lock()  // 加锁顺序相反
    mu1.Lock()
    // 转账操作
    mu1.Unlock()
    mu2.Unlock()
}
```

**解决方案**:统一加锁顺序

```go
// 始终按照固定顺序加锁(如按内存地址或 ID 排序)
func transfer(from, to *Account) {
    // 按地址排序,保证全局统一的加锁顺序
    if uintptr(unsafe.Pointer(from)) < uintptr(unsafe.Pointer(to)) {
        from.mu.Lock()
        to.mu.Lock()
    } else {
        to.mu.Lock()
        from.mu.Lock()
    }
    defer from.mu.Unlock()
    defer to.mu.Unlock()

    // 转账逻辑
}
```

### 3. channel 死锁

**问题代码**:
```go
func main() {
    ch := make(chan int)
    ch <- 1  // 阻塞,没有接收者
    fmt.Println(<-ch)
}
```

**解决方案**:使用带缓冲 channel 或在另一个 goroutine 中接收

```go
// 方案1:使用缓冲 channel
func main() {
    ch := make(chan int, 1)
    ch <- 1
    fmt.Println(<-ch)
}

// 方案2:异步接收
func main() {
    ch := make(chan int)
    go func() {
        fmt.Println(<-ch)
    }()
    ch <- 1
}
```

### 4. WaitGroup 使用错误

**问题代码**:
```go
func main() {
    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        // 忘记调用 Done,或 panic 导致 Done 未执行
        panic("something wrong")
    }()

    wg.Wait()  // 永远等待
}
```

**解决方案**:确保 Done 一定执行

```go
func main() {
    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()  // defer 保证一定执行
        defer func() {
            if r := recover(); r != nil {
                fmt.Println("recovered:", r)
            }
        }()
        // 业务逻辑
    }()

    wg.Wait()
}
```

## 死锁检测工具

### 1. Go 内置 race detector

虽然主要用于检测数据竞争,但也能帮助发现潜在死锁:

```bash
go run -race main.go
go test -race ./...
```

### 2. go-deadlock 库

`github.com/sasha-s/go-deadlock` 是 `sync.Mutex` 的替代品,能检测潜在死锁:

```go
import (
    deadlock "github.com/sasha-s/go-deadlock"
)

var mu deadlock.Mutex  // 替代 sync.Mutex

func process() {
    mu.Lock()
    defer mu.Unlock()
    // 如果持锁时间过长,会打印警告
}
```

配置检测参数:
```go
deadlock.Opts.DeadlockTimeout = 30 * time.Second  // 持锁超过 30 秒报警
deadlock.Opts.LogBuf = os.Stderr
```

### 3. pprof goroutine 分析

使用 pprof 查看 goroutine 阻塞状态:

```go
import _ "net/http/pprof"

func main() {
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()
    // ... 业务代码
}
```

访问 `http://localhost:6060/debug/pprof/goroutine?debug=2` 查看所有 goroutine 堆栈,找出阻塞的 goroutine。

### 4. 自定义超时检测

使用 `context.WithTimeout` 为操作设置超时:

```go
func processWithTimeout(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    done := make(chan struct{})
    go func() {
        // 可能死锁的操作
        heavyWork()
        close(done)
    }()

    select {
    case <-done:
        return nil
    case <-ctx.Done():
        return fmt.Errorf("operation timeout: %w", ctx.Err())
    }
}
```

## 死锁预防最佳实践

### 1. 加锁顺序规范

为所有锁定义全局顺序(如按内存地址、ID 等),始终按相同顺序加锁:

```go
type Account struct {
    ID int64
    mu sync.Mutex
    balance int
}

func transfer(from, to *Account, amount int) {
    // 总是先锁 ID 小的账户
    first, second := from, to
    if first.ID > second.ID {
        first, second = second, first
    }

    first.mu.Lock()
    defer first.mu.Unlock()
    second.mu.Lock()
    defer second.mu.Unlock()

    from.balance -= amount
    to.balance += amount
}
```

### 2. 使用 tryLock 机制

虽然 Go 标准库的 `sync.Mutex` 不支持 tryLock,但可以自己实现:

```go
type TryMutex struct {
    ch chan struct{}
}

func NewTryMutex() *TryMutex {
    return &TryMutex{ch: make(chan struct{}, 1)}
}

func (m *TryMutex) Lock() {
    m.ch <- struct{}{}
}

func (m *TryMutex) Unlock() {
    <-m.ch
}

func (m *TryMutex) TryLock() bool {
    select {
    case m.ch <- struct{}{}:
        return true
    default:
        return false
    }
}

// 使用示例
func transferWithRetry(from, to *Account) error {
    for i := 0; i < 3; i++ {
        if from.mu.TryLock() {
            if to.mu.TryLock() {
                // 成功获取两个锁
                defer to.mu.Unlock()
                defer from.mu.Unlock()
                // 执行转账
                return nil
            }
            from.mu.Unlock()
        }
        time.Sleep(10 * time.Millisecond)  // 退避重试
    }
    return errors.New("failed to acquire locks")
}
```

### 3. 缩小锁的范围

减少持锁时间,降低死锁概率:

```go
// 不好的做法:持锁时间长
func process() {
    mu.Lock()
    defer mu.Unlock()

    data := loadData()      // IO 操作
    result := compute(data)  // 计算密集
    saveResult(result)       // IO 操作
}

// 好的做法:只在必要时持锁
func process() {
    mu.Lock()
    data := loadDataFromCache()
    mu.Unlock()

    result := compute(data)  // 不持锁计算

    mu.Lock()
    saveToCache(result)
    mu.Unlock()
}
```

### 4. 使用无锁数据结构

优先使用 channel 和 `sync/atomic` 等无锁机制:

```go
// 使用 channel 替代 mutex + condition variable
type Queue struct {
    ch chan interface{}
}

func (q *Queue) Push(item interface{}) {
    q.ch <- item
}

func (q *Queue) Pop() interface{} {
    return <-q.ch
}
```

### 5. Context 超时控制

为所有阻塞操作设置超时:

```go
func fetch(ctx context.Context, url string) ([]byte, error) {
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    return io.ReadAll(resp.Body)
}
```

## 死锁调试流程

1. **复现问题**:在测试环境中稳定复现死锁
2. **收集 goroutine dump**:
   ```bash
   # 发送 SIGQUIT 信号打印所有 goroutine 堆栈
   kill -QUIT <pid>

   # 或使用 pprof
   curl http://localhost:6060/debug/pprof/goroutine?debug=2
   ```
3. **分析阻塞链**:查找处于 `chan receive`、`semacquire`、`sync.Mutex.Lock` 状态的 goroutine
4. **绘制资源依赖图**:找出循环等待的环
5. **修复代码**:统一加锁顺序或使用超时机制

## 总结

死锁检测和预防的关键要点:

1. **Go 运行时检测**:只能检测全局死锁,局部死锁需手动排查
2. **预防策略**:
   - 统一加锁顺序
   - 使用超时机制
   - 缩小锁范围
   - 优先使用无锁数据结构
3. **检测工具**:
   - `go-deadlock` 库检测潜在死锁
   - pprof 分析 goroutine 阻塞
   - race detector 辅助发现问题
4. **最佳实践**:
   - 为阻塞操作设置 context 超时
   - 使用 defer 确保锁释放
   - 编写单元测试覆盖并发场景
   - 生产环境启用 goroutine 监控

死锁是并发编程中最难调试的问题之一,预防永远优于检测和修复。
