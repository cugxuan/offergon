---
title: atomic 包的 CAS 操作原理和应用
tags:
  - Go并发
status: robot
class: Go并发
slug: cas-operation-principle-and-application
ref:
---

## 核心要点

**CAS（Compare-And-Swap）是 CPU 提供的原子指令，通过一条指令完成"比较-交换"操作。Go 的 sync/atomic 包封装了 CAS 指令，可实现无锁数据结构。CAS 基于乐观锁思想，适用于低竞争场景，高竞争下会产生大量自旋导致性能下降。典型应用包括无锁计数器、自旋锁、ABA 问题需注意版本号解决。**

---

## 详细解答

### 一、CAS 原理

#### 定义

CAS 操作接受三个参数：内存地址 V、期望值 A、新值 B

```
if *V == A:
    *V = B
    return true
else:
    return false
```

**关键特性**：整个操作是**原子的**（不可被中断）

#### CPU 指令

- **x86**: `CMPXCHG` 指令（配合 `LOCK` 前缀）
- **ARM**: `LDREX/STREX` 指令对
- **RISC-V**: `LR/SC` (Load-Reserved/Store-Conditional)

**示例**（x86 汇编伪代码）：

```asm
LOCK CMPXCHG [addr], new_value
; 原子地比较 [addr] 与 EAX，相等则写入 new_value
```

### 二、Go 中的 CAS 使用

#### 基本 API

```go
import "sync/atomic"

var value int32 = 10

// CAS: 期望 old=10，交换为 new=20
swapped := atomic.CompareAndSwapInt32(&value, 10, 20)
if swapped {
    fmt.Println("交换成功")
} else {
    fmt.Println("交换失败，值已被其他goroutine修改")
}
```

#### 所有 CAS 函数

```go
func CompareAndSwapInt32(addr *int32, old, new int32) bool
func CompareAndSwapInt64(addr *int64, old, new int64) bool
func CompareAndSwapUint32(addr *uint32, old, new uint32) bool
func CompareAndSwapUint64(addr *uint64, old, new uint64) bool
func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) bool
func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) bool
```

### 三、典型应用

#### 应用 1：无锁计数器

```go
type Counter struct {
    value int64
}

func (c *Counter) Inc() {
    for {
        old := atomic.LoadInt64(&c.value)
        new := old + 1
        if atomic.CompareAndSwapInt64(&c.value, old, new) {
            return  // CAS成功
        }
        // CAS失败，自旋重试
    }
}

func (c *Counter) Get() int64 {
    return atomic.LoadInt64(&c.value)
}
```

**性能对比**（100万次递增）：

| 方法 | 耗时 | 说明 |
|------|------|------|
| `sync.Mutex` | ~50ms | 有锁 |
| `atomic.AddInt64` | ~10ms | 原子加法 |
| CAS 自旋 | ~15ms | 低竞争下接近 Add |

#### 应用 2：自旋锁

```go
type SpinLock struct {
    state int32  // 0=未锁定, 1=已锁定
}

func (s *SpinLock) Lock() {
    for !atomic.CompareAndSwapInt32(&s.state, 0, 1) {
        runtime.Gosched()  // 让出CPU
    }
}

func (s *SpinLock) Unlock() {
    atomic.StoreInt32(&s.state, 0)
}
```

**适用场景**：

- ✅ 临界区极短（微秒级）
- ❌ 临界区较长（会浪费 CPU 自旋）

#### 应用 3：单例模式（双重检查锁优化版）

```go
type Singleton struct {
    data string
}

var (
    instance unsafe.Pointer  // *Singleton
    mu       sync.Mutex
)

func GetInstance() *Singleton {
    // 第一次检查（无锁）
    ptr := atomic.LoadPointer(&instance)
    if ptr != nil {
        return (*Singleton)(ptr)
    }

    mu.Lock()
    defer mu.Unlock()

    // 第二次检查（有锁）
    ptr = atomic.LoadPointer(&instance)
    if ptr != nil {
        return (*Singleton)(ptr)
    }

    // 初始化
    newInstance := &Singleton{data: "initialized"}
    atomic.StorePointer(&instance, unsafe.Pointer(newInstance))
    return newInstance
}
```

**关键**：使用 `atomic.LoadPointer` 和 `StorePointer` 保证内存可见性。

#### 应用 4：无锁栈（Treiber Stack）

```go
type Node struct {
    value int
    next  unsafe.Pointer  // *Node
}

type Stack struct {
    head unsafe.Pointer  // *Node
}

func (s *Stack) Push(v int) {
    node := &Node{value: v}
    for {
        old := atomic.LoadPointer(&s.head)
        node.next = old
        if atomic.CompareAndSwapPointer(&s.head, old, unsafe.Pointer(node)) {
            return
        }
    }
}

func (s *Stack) Pop() (int, bool) {
    for {
        old := atomic.LoadPointer(&s.head)
        if old == nil {
            return 0, false
        }
        node := (*Node)(old)
        next := atomic.LoadPointer(&node.next)
        if atomic.CompareAndSwapPointer(&s.head, old, next) {
            return node.value, true
        }
    }
}
```

### 四、ABA 问题

#### 问题场景

```go
// 线程1: 读取 V=A, 准备CAS(A -> C)
old := atomic.LoadPointer(&head)  // old = A

// 线程2: V=A -> V=B -> V=A (回到A)
atomic.StorePointer(&head, B)
atomic.StorePointer(&head, A)

// 线程1: CAS成功！但中间状态已丢失
atomic.CompareAndSwapPointer(&head, old, C)  // 成功，但A已不是原来的A
```

**问题**：CAS 只比较值，无法检测中间变化。

#### 解决方案：版本号（Version Stamp）

```go
type VersionedPointer struct {
    ptr     unsafe.Pointer
    version uint64
}

type Stack struct {
    head atomic.Value  // VersionedPointer
}

func (s *Stack) Push(v int) {
    node := &Node{value: v}
    for {
        vp := s.head.Load().(VersionedPointer)
        node.next = vp.ptr
        newVP := VersionedPointer{
            ptr:     unsafe.Pointer(node),
            version: vp.version + 1,  // 版本号递增
        }
        if s.head.CompareAndSwap(vp, newVP) {
            return
        }
    }
}
```

**Java 的解决方案**：`AtomicStampedReference`

### 五、CAS vs 互斥锁

#### 性能测试

```go
func BenchmarkMutex(b *testing.B) {
    var mu sync.Mutex
    var counter int
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            mu.Lock()
            counter++
            mu.Unlock()
        }
    })
}

func BenchmarkCAS(b *testing.B) {
    var counter int64
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            for {
                old := atomic.LoadInt64(&counter)
                if atomic.CompareAndSwapInt64(&counter, old, old+1) {
                    break
                }
            }
        }
    })
}
```

**结果**（8核）：

| 并发数 | Mutex | CAS | 胜者 |
|--------|-------|-----|------|
| 1 | 20 ns/op | 15 ns/op | CAS |
| 4 | 80 ns/op | 60 ns/op | CAS |
| 16 | 300 ns/op | 500 ns/op | Mutex |

**结论**：

- 低竞争（并发数少）：CAS 胜
- 高竞争（并发数多）：Mutex 胜（避免自旋浪费）

### 六、Go 1.19+ 的 atomic 类型

```go
var counter atomic.Int64  // 新类型，无需指针

counter.Add(1)
counter.Store(10)
old := counter.Load()
swapped := counter.CompareAndSwap(10, 20)
```

**优点**：

- 类型安全（编译时检查）
- 无需手动取地址
- API 更简洁

### 七、底层实现（Go runtime）

#### AMD64 实现（src/runtime/internal/atomic/atomic_amd64.s）

```asm
TEXT ·Cas64(SB), NOSPLIT, $0-25
    MOVQ    ptr+0(FP), BX
    MOVQ    old+8(FP), AX
    MOVQ    new+16(FP), CX
    LOCK
    CMPXCHGQ    CX, 0(BX)
    SETEQ   ret+24(FP)
    RET
```

**解释**：

1. `MOVQ`: 加载参数
2. `LOCK CMPXCHGQ`: 原子比较交换（64位）
3. `SETEQ`: 设置返回值（ZF 标志位）

#### ARM64 实现

```asm
TEXT ·Cas64(SB), NOSPLIT, $0-25
    MOVD    ptr+0(FP), R0
    MOVD    old+8(FP), R1
    MOVD    new+16(FP), R2
loop:
    LDAXR   (R0), R3        // Load-Acquire Exclusive
    CMP     R1, R3
    BNE     fail
    STLXR   R2, (R0), R4    // Store-Release Exclusive
    CBNZ    R4, loop        // 失败则重试
    MOVD    $1, R0
    MOVB    R0, ret+24(FP)
    RET
fail:
    MOVD    $0, R0
    MOVB    R0, ret+24(FP)
    RET
```

### 八、常见陷阱

#### 陷阱 1：忘记循环重试

```go
// 错误：CAS 失败后未重试
old := atomic.LoadInt64(&counter)
atomic.CompareAndSwapInt64(&counter, old, old+1)  // 可能失败

// 正确：自旋直到成功
for {
    old := atomic.LoadInt64(&counter)
    if atomic.CompareAndSwapInt64(&counter, old, old+1) {
        break
    }
}
```

#### 陷阱 2：高竞争下盲目使用 CAS

```go
// 8个goroutine并发递增100万次
// CAS自旋: 耗时 5秒（大量重试）
// Mutex:   耗时 1秒
```

**教训**：高竞争选 Mutex。

#### 陷阱 3：对齐问题

```go
type BadStruct struct {
    a int32
    b int64  // 可能未8字节对齐！
}

var s BadStruct
atomic.AddInt64(&s.b, 1)  // 可能 panic
```

**解决**：

```go
type GoodStruct struct {
    b int64  // 放在前面，保证对齐
    a int32
}
```

### 九、总结

| 特性 | CAS | Mutex |
|------|-----|-------|
| **实现方式** | CPU指令 | OS系统调用 |
| **低竞争性能** | 优秀 | 良好 |
| **高竞争性能** | 差（自旋） | 优秀 |
| **公平性** | 无保证 | FIFO |
| **使用复杂度** | 高 | 低 |

**选择建议**：

- **优先 atomic.AddXxx**：比手写 CAS 循环快
- **次选 Mutex**：简单可靠
- **手写 CAS**：仅用于实现无锁数据结构

**面试金句**：

> "CAS 是现代并发编程的基石，Go 的 sync.Mutex 和 channel 底层都用到了 CAS。它通过乐观锁避免了系统调用开销，但高竞争下会因自旋导致性能下降。理解 CAS 的关键是认识到它只是一个原子的'条件写入'原语，正确使用需要配合循环重试，并注意 ABA 问题。"
