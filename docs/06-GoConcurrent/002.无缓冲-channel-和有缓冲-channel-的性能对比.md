---
title: 无缓冲 channel 和有缓冲 channel 的性能对比
tags:
  - Go并发
  - 并发
status: robot
class: Go并发
slug: buffered-vs-unbuffered-channel-performance
ref:
---

## 核心要点

**有缓冲 channel 性能优于无缓冲 channel：无缓冲每次操作都需要 goroutine 同步和调度切换（gopark/goready），有缓冲在容量范围内可快速读写缓冲区。但有缓冲会增加内存开销和 GC 压力，容量设计不当可能导致死锁或资源浪费。**

---

## 详细解答

### 一、性能对比基准测试

以下是一个典型的性能测试：

```go
package main

import (
    "testing"
)

// 无缓冲channel测试
func BenchmarkUnbuffered(b *testing.B) {
    ch := make(chan int)

    go func() {
        for i := 0; i < b.N; i++ {
            <-ch
        }
    }()

    for i := 0; i < b.N; i++ {
        ch <- i
    }
}

// 有缓冲channel测试（容量为1）
func BenchmarkBuffered1(b *testing.B) {
    ch := make(chan int, 1)

    go func() {
        for i := 0; i < b.N; i++ {
            <-ch
        }
    }()

    for i := 0; i < b.N; i++ {
        ch <- i
    }
}

// 有缓冲channel测试（容量为100）
func BenchmarkBuffered100(b *testing.B) {
    ch := make(chan int, 100)

    go func() {
        for i := 0; i < b.N; i++ {
            <-ch
        }
    }()

    for i := 0; i < b.N; i++ {
        ch <- i
    }
}
```

**测试结果**（实际数据会因硬件而异）：

```
BenchmarkUnbuffered-8       5000000    350 ns/op
BenchmarkBuffered1-8       10000000    180 ns/op
BenchmarkBuffered100-8     20000000     95 ns/op
```

**结论**：

- 有缓冲 channel 性能可提升 **2-4 倍**
- 缓冲容量越大，性能越好（到一定阈值后收益递减）

### 二、性能差异的底层原因

#### 1. **无缓冲 channel 的开销**

无缓冲 channel（`make(chan T)`）的 `dataqsiz = 0`，每次操作流程：

```
发送方执行 ch <- v：
1. 加锁
2. 检查recvq，如果为空：
   - 创建sudog，加入sendq
   - 调用 gopark() 挂起当前goroutine
   - 触发调度器切换到其他goroutine
3. 等待接收方唤醒
4. 解锁
```

**关键开销点**：

- **goroutine 调度切换**：`gopark()` 和 `goready()` 涉及保存/恢复上下文、调度器查找可运行 goroutine
- **强制同步**：发送和接收必须配对出现，任意一方缺失都会阻塞

#### 2. **有缓冲 channel 的优化**

有缓冲 channel（`make(chan T, n)`）在 `qcount < dataqsiz` 时：

```
发送方执行 ch <- v：
1. 加锁
2. 检查缓冲区未满：
   - 直接写入 buf[sendx]
   - sendx++, qcount++
   - 解锁，立即返回（不阻塞）
3. 发送方继续执行，无需等待
```

**性能优势**：

- **无需调度切换**：缓冲区未满时，发送方写入后立即返回
- **批量处理能力**：生产者可连续发送多个值，消费者可批量消费
- **减少锁竞争**：发送和接收不再强制同步，降低并发冲突

#### 3. **内存拷贝对比**

**无缓冲**：数据直接从发送方栈拷贝到接收方栈（通过 `sudog.elem`）

```go
// 运行时伪代码
send(c, sg, ep, ...) {
    // 直接内存拷贝：发送方 -> 接收方
    typedmemmove(c.elemtype, sg.elem, ep)
    goready(sg.g)  // 唤醒接收方
}
```

**有缓冲**：数据需要两次拷贝（发送方 -> 缓冲区 -> 接收方）

```go
// 发送时
qp := chanbuf(c, c.sendx)
typedmemmove(c.elemtype, qp, ep)  // 拷贝到缓冲区

// 接收时
qp := chanbuf(c, c.recvx)
typedmemmove(c.elemtype, ep, qp)  // 从缓冲区拷贝
```

**看似矛盾**：有缓冲多一次拷贝，为何性能更好？

- 内存拷贝成本（纳秒级）远低于 goroutine 调度（微秒级）
- 缓冲区命中时避免了调度，整体性能提升

### 三、不同场景的性能表现

#### 场景 1：高频小数据传输

```go
// 无缓冲：每次都阻塞等待
ch := make(chan int)
for i := 0; i < 100000; i++ {
    ch <- i  // 每次都需要goroutine切换
}

// 有缓冲：批量发送
ch := make(chan int, 100)
for i := 0; i < 100000; i++ {
    ch <- i  // 缓冲未满时无阻塞
}
```

**性能差异**：有缓冲减少 99% 的调度切换（100 个元素只需切换 1 次）

#### 场景 2：生产者-消费者速率不匹配

```go
// 生产快消费慢
producer := func() {
    for i := 0; i < 1000; i++ {
        ch <- process(i)  // 每次 10ms
    }
}

consumer := func() {
    for v := range ch {
        heavyWork(v)  // 每次 50ms
    }
}
```

**无缓冲**：生产者频繁阻塞，吞吐量被消费者限制

**有缓冲**：生产者可持续生产，缓冲区削峰填谷，提高吞吐

#### 场景 3：多发送者多接收者

```go
// 10个goroutine并发发送
for i := 0; i < 10; i++ {
    go func() {
        for v := range input {
            ch <- v
        }
    }()
}
```

**无缓冲**：高并发下锁竞争激烈，频繁唤醒导致调度抖动

**有缓冲**：缓冲区起到蓄水池作用，降低竞争

### 四、内存和 GC 影响

#### 内存开销对比

```go
// 无缓冲
ch1 := make(chan [1024]byte)
// 内存占用：hchan结构体（约96字节）+ 元素类型信息

// 有缓冲（容量100）
ch2 := make(chan [1024]byte, 100)
// 内存占用：96字节 + 100*1024字节 = 约102KB
```

**大容量缓冲的代价**：

- 预分配内存可能造成浪费（容量未充分利用）
- GC 需要扫描缓冲区中的指针（如果元素包含指针）
- 对于大对象，建议传递指针而非值以减少拷贝

#### GC 压力测试

```go
type LargeStruct struct {
    Data [10000]int
}

// 传值：每次拷贝80KB
ch1 := make(chan LargeStruct, 100)

// 传指针：每次拷贝8字节
ch2 := make(chan *LargeStruct, 100)
```

传指针可显著降低内存拷贝和 GC 扫描开销。

### 五、死锁风险对比

#### 无缓冲的死锁

```go
// 经典错误：单goroutine发送
func main() {
    ch := make(chan int)
    ch <- 1  // 阻塞：无接收方
    fmt.Println(<-ch)  // 永远不会执行
}
// fatal error: all goroutines are asleep - deadlock!
```

#### 有缓冲的隐蔽死锁

```go
// 缓冲满后仍会死锁
func main() {
    ch := make(chan int, 2)
    ch <- 1
    ch <- 2
    ch <- 3  // 阻塞：缓冲已满，无接收方
}
// 同样死锁，但更难发现
```

**教训**：缓冲不是银弹，只是推迟了阻塞的发生。

### 六、最佳实践建议

#### 1. **何时使用无缓冲 channel**

- 需要严格的同步语义（如事件通知、握手协议）
- 内存受限场景
- 强调代码清晰性而非极致性能

**示例**：协程完成信号

```go
done := make(chan struct{})
go func() {
    work()
    done <- struct{}{}  // 发送完成信号
}()
<-done  // 等待完成
```

#### 2. **何时使用有缓冲 channel**

- 生产者消费者模型，需要解耦速率
- 高并发场景，需要降低调度开销
- 批量处理场景

**容量设计原则**：

```go
// 公式：capacity = 并发数 × 平均处理时间 / 平均生产时间
// 例如：10个生产者，每个生产耗时1ms，消费耗时10ms
capacity := 10 * 10 / 1  // 建议100

ch := make(chan Task, capacity)
```

#### 3. **性能优化技巧**

**批量发送减少 channel 操作次数**：

```go
// 低效：每个元素单独发送
for _, item := range items {
    ch <- item
}

// 高效：批量发送
const batchSize = 100
batch := make([]Item, 0, batchSize)
for _, item := range items {
    batch = append(batch, item)
    if len(batch) == batchSize {
        ch <- batch
        batch = batch[:0]
    }
}
if len(batch) > 0 {
    ch <- batch
}
```

### 七、性能分析工具

使用 pprof 分析 channel 热点：

```bash
# CPU分析
go test -bench=. -cpuprofile=cpu.prof
go tool pprof cpu.prof

# 查看channel相关调用
(pprof) list chansend
(pprof) list chanrecv
```

### 八、总结

| 维度 | 无缓冲 channel | 有缓冲 channel |
|------|---------------|----------------|
| **性能** | 较低（需频繁调度） | 较高（减少调度） |
| **内存** | 低 | 高（预分配缓冲区） |
| **同步语义** | 强（强制配对） | 弱（异步解耦） |
| **死锁风险** | 明显（立即阻塞） | 隐蔽（延迟阻塞） |
| **适用场景** | 事件通知、严格同步 | 生产消费、批量处理 |

**面试核心观点**：性能优化不能脱离场景，有缓冲 channel 并非总是最优解。理解底层原理（调度成本 vs 内存成本）是做出正确选择的关键。
