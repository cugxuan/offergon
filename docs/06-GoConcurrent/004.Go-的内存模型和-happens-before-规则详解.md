---
title: Go 的内存模型和 happens-before 规则详解
tags:
  - Go并发
  - 内存管理
status: robot
class: Go并发
slug: go-memory-model-happens-before-rules
ref:
---

## 核心要点

**Go 内存模型定义了在并发场景下，一个 goroutine 对变量的写入何时能被另一个 goroutine 观察到。happens-before 关系通过同步原语（channel、锁、sync.Once 等）建立偏序关系，保证内存操作的可见性。违反 happens-before 规则会导致数据竞争和未定义行为。**

---

## 详细解答

### 一、内存模型的必要性

#### 问题场景：数据竞争

```go
var a string
var done bool

func setup() {
    a = "hello, world"  // (1)
    done = true         // (2)
}

func main() {
    go setup()
    for !done {         // (3)
    }
    fmt.Println(a)      // (4) 可能输出空字符串！
}
```

**为什么会出错？**

1. **编译器重排序**：编译器可能将 (1) 和 (2) 的执行顺序对调
2. **CPU 重排序**：现代 CPU 为优化性能会乱序执行指令
3. **缓存不一致**：main goroutine 可能从缓存读到旧值

**内存模型的作用**：定义哪些情况下必须保证顺序和可见性。

### 二、happens-before 关系详解

#### 定义

**事件 A happens-before 事件 B** 意味着：

1. A 的执行结果对 B 可见
2. A 在程序顺序上必须先于 B 发生

**记作**：A ≺ B

#### 传递性

```
如果 A ≺ B 且 B ≺ C，则 A ≺ C
```

#### 单 goroutine 规则

**Within a single goroutine**, happens-before 顺序就是程序代码顺序：

```go
func example() {
    x := 1     // (1)
    y := 2     // (2)
    fmt.Println(x, y)  // (3)
    // (1) ≺ (2) ≺ (3)
}
```

**注意**：编译器可以重排序 (1) 和 (2)，只要不影响单线程内的观察结果（as-if-serial 语义）。

### 三、Go 的 happens-before 保证

#### 1. **程序初始化**

**规则**：包的 `init()` 函数 happens-before `main.main()`

```go
package main

import "fmt"

var a string

func init() {
    a = "hello"  // (1)
}

func main() {
    fmt.Println(a)  // (2) 保证能看到 "hello"
    // (1) ≺ (2)
}
```

**初始化顺序**：

1. 所有包的全局变量初始化
2. 所有包的 `init()` 函数（按依赖顺序）
3. `main.main()`

#### 2. **goroutine 创建**

**规则**：`go` 语句 happens-before 新 goroutine 的执行

```go
var a string

func f() {
    fmt.Println(a)  // (2) 保证能看到 "hello"
}

func main() {
    a = "hello"  // (1)
    go f()       // (1) ≺ (2)
}
```

**注意**：goroutine 的退出不保证 happens-before 任何事件！

```go
var a string

func main() {
    go func() {
        a = "hello"  // (1)
    }()
    fmt.Println(a)  // (2) 可能输出空字符串
    // 无法保证 (1) ≺ (2)
}
```

#### 3. **channel 通信**

**规则 3.1**：对 channel 的发送 happens-before 对应的接收完成

```go
var c = make(chan int, 10)
var a string

func sender() {
    a = "hello"  // (1)
    c <- 1       // (2)
}

func receiver() {
    <-c          // (3)
    fmt.Println(a)  // (4) 保证输出 "hello"
    // (1) ≺ (2) ≺ (3) ≺ (4)
}
```

**规则 3.2**：关闭 channel happens-before 从该 channel 接收到零值

```go
var c = make(chan int, 10)
var a string

func main() {
    go func() {
        a = "hello"  // (1)
        close(c)     // (2)
    }()
    <-c              // (3) 接收到零值
    fmt.Println(a)   // (4) 保证输出 "hello"
    // (1) ≺ (2) ≺ (3) ≺ (4)
}
```

**规则 3.3**（无缓冲 channel）：从无缓冲 channel 接收 happens-before 对应的发送完成

```go
var c = make(chan int)  // 无缓冲
var a string

func main() {
    go func() {
        a = "hello"  // (1)
        <-c          // (2) 接收
    }()
    c <- 1           // (3) 发送（阻塞直到(2)开始）
    fmt.Println(a)   // (4) 保证输出 "hello"
    // (1) ≺ (2) ≺ (3) ≺ (4)
}
```

**关键差异**：

| channel 类型 | happens-before 关系 |
|-------------|---------------------|
| 有缓冲 | 发送 ≺ 接收完成 |
| 无缓冲 | 接收 ≺ 发送完成 |

#### 4. **锁（sync.Mutex / sync.RWMutex）**

**规则 4.1**：第 n 次 `Unlock()` happens-before 第 n+1 次 `Lock()` 返回

```go
var mu sync.Mutex
var a string

func writer() {
    mu.Lock()
    a = "hello"  // (1)
    mu.Unlock()  // (2)
}

func reader() {
    mu.Lock()    // (3)
    fmt.Println(a)  // (4) 保证输出 "hello"
    mu.Unlock()
    // (1) ≺ (2) ≺ (3) ≺ (4)
}
```

**规则 4.2**（RWMutex）：`RLock()` happens-before 对应的 `RUnlock()`

**规则 4.3**：任何 `RUnlock()` happens-before 下一次 `Lock()`

```go
var rwmu sync.RWMutex
var a string

func writer() {
    rwmu.Lock()
    a = "hello"  // (1)
    rwmu.Unlock()  // (2)
}

func reader() {
    rwmu.RLock()   // (3)
    fmt.Println(a)  // (4)
    rwmu.RUnlock()
    // (1) ≺ (2) ≺ (3) ≺ (4)
}
```

#### 5. **sync.Once**

**规则**：`once.Do(f)` 中的 f() 执行完成 happens-before 任何 `once.Do(f)` 返回

```go
var once sync.Once
var a string

func setup() {
    a = "hello"  // (1)
}

func doSomething() {
    once.Do(setup)  // (2)
    fmt.Println(a)  // (3) 保证输出 "hello"
    // (1) ≺ (2) ≺ (3)
}
```

**多个 goroutine 并发调用**：

```go
go doSomething()  // goroutine 1
go doSomething()  // goroutine 2

// setup() 只执行一次，但两个goroutine都能看到结果
```

#### 6. **sync.WaitGroup**

**规则**：`wg.Done()` happens-before `wg.Wait()` 返回

```go
var wg sync.WaitGroup
var a string

func worker() {
    a = "hello"  // (1)
    wg.Done()    // (2)
}

func main() {
    wg.Add(1)
    go worker()
    wg.Wait()    // (3)
    fmt.Println(a)  // (4) 保证输出 "hello"
    // (1) ≺ (2) ≺ (3) ≺ (4)
}
```

### 四、违反 happens-before 的错误示例

#### 示例 1：双重检查锁（错误实现）

```go
type Singleton struct {
    data string
}

var instance *Singleton
var mu sync.Mutex

func GetInstance() *Singleton {
    if instance == nil {  // (1) 无锁读取
        mu.Lock()
        if instance == nil {
            instance = &Singleton{data: "hello"}  // (2)
        }
        mu.Unlock()
    }
    return instance  // (3) 可能看到未初始化的对象！
}
```

**问题**：

- goroutine A 执行 (2) 时，可能先写入 `instance` 指针，后初始化 `data`
- goroutine B 在 (1) 看到非空指针，但 `data` 可能还未初始化

**修复**：使用 `sync.Once`

```go
var instance *Singleton
var once sync.Once

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{data: "hello"}
    })
    return instance
}
```

#### 示例 2：忽略 channel 关闭顺序

```go
var c = make(chan bool)
var a string

func main() {
    go func() {
        a = "hello"  // (1)
    }()
    close(c)         // (2)
    <-c              // (3)
    fmt.Println(a)   // (4) 可能输出空字符串
    // 无法保证 (1) ≺ (4)
}
```

**问题**：close(c) 和 goroutine 的写入无同步关系。

#### 示例 3：错误使用 atomic

```go
var flag int32
var a string

func writer() {
    a = "hello"                      // (1)
    atomic.StoreInt32(&flag, 1)      // (2)
}

func reader() {
    for atomic.LoadInt32(&flag) == 0 {  // (3)
    }
    fmt.Println(a)  // (4) 仍然可能输出空字符串！
}
```

**问题**：atomic 只保证 flag 本身的原子性，不保证 (1) 对 (4) 可见。

**修复**：使用 channel 或锁

```go
var c = make(chan struct{})
var a string

func writer() {
    a = "hello"  // (1)
    close(c)     // (2)
}

func reader() {
    <-c          // (3)
    fmt.Println(a)  // (4) 保证输出 "hello"
}
```

### 五、happens-before 与内存屏障

#### 内存屏障（Memory Barrier）

内存屏障是 CPU 指令级别的同步机制，分为：

1. **Load Barrier**（读屏障）：阻止屏障前的读操作与屏障后的读/写重排序
2. **Store Barrier**（写屏障）：阻止屏障前的写操作与屏障后的读/写重排序
3. **Full Barrier**（全屏障）：阻止所有重排序

**Go 中的应用**：

- channel 发送/接收操作包含内存屏障
- `sync.Mutex.Lock/Unlock` 包含内存屏障
- atomic 操作包含必要的屏障（但不是全屏障）

**示例**：channel 发送的伪代码

```go
func chansend(c *hchan, elem unsafe.Pointer) {
    // ... 前置逻辑

    // 写屏障：确保elem的所有写入对接收方可见
    typedmemmove(c.elemtype, qp, elem)

    // 全屏障
    atomic.Store(&c.qcount, qcount+1)

    // ... 唤醒接收方
}
```

### 六、数据竞争检测

#### 使用 race detector

```bash
go run -race main.go
go test -race ./...
```

**示例**：检测数据竞争

```go
var a int

func main() {
    go func() {
        a = 1  // 写
    }()
    fmt.Println(a)  // 读
}
```

运行 `go run -race main.go` 输出：

```
WARNING: DATA RACE
Write at 0x... by goroutine 6:
  main.func1()
      main.go:6 +0x3c

Previous read at 0x... by main goroutine:
  main.main()
      main.go:8 +0x88
```

### 七、实践建议

#### 1. **优先使用高级同步原语**

```go
// 不推荐：使用atomic + 忙等待
for atomic.LoadInt32(&ready) == 0 {
    runtime.Gosched()
}

// 推荐：使用channel
<-readyChan
```

#### 2. **避免共享内存，使用通信**

```go
// 不推荐：共享变量
var sharedData Data
mu.Lock()
sharedData = newData
mu.Unlock()

// 推荐：通过channel传递
dataChan <- newData
```

#### 3. **正确使用 sync.Once**

```go
var config *Config
var once sync.Once

func GetConfig() *Config {
    once.Do(func() {
        config = loadConfig()  // 保证只执行一次且对所有goroutine可见
    })
    return config
}
```

### 八、Go 内存模型版本变更

#### Go 1.19 之前

- 原子操作不保证 happens-before
- 需要手动配合 channel/锁使用

#### Go 1.19+ (引入 atomic 类型)

```go
var x atomic.Int32
var a string

func writer() {
    a = "hello"  // (1)
    x.Store(1)   // (2) 包含 release 语义
}

func reader() {
    if x.Load() == 1 {  // (3) 包含 acquire 语义
        fmt.Println(a)  // (4) 保证输出 "hello"
        // (1) ≺ (2) ≺ (3) ≺ (4)
    }
}
```

**新增保证**：

- `atomic.Store` 有 release 语义（写屏障）
- `atomic.Load` 有 acquire 语义（读屏障）

### 九、面试扩展问题

#### Q1：为什么 Go 不默认保证所有变量的可见性？

**A**：性能考虑。强制所有内存访问都串行化会严重降低性能。Go 通过显式同步（channel/锁）在性能和正确性之间取得平衡。

#### Q2：happens-before 和时间顺序的关系？

**A**：happens-before 是逻辑顺序，不是物理时间顺序。即使 A 在时钟上晚于 B，只要存在 happens-before 关系 A ≺ B，就保证 A 的结果对 B 可见。

#### Q3：如何在不使用锁的情况下保证可见性？

**A**：使用 channel 或 Go 1.19+ 的 atomic 类型。

### 十、总结

| 同步原语 | happens-before 保证 | 适用场景 |
|---------|---------------------|---------|
| channel 发送/接收 | 发送 ≺ 接收完成 | 事件通知、数据传递 |
| 无缓冲 channel | 接收 ≺ 发送完成 | 严格同步 |
| Mutex Lock/Unlock | Unlock ≺ 下一次 Lock | 临界区保护 |
| sync.Once | Do(f) 完成 ≺ 所有 Do 返回 | 单例初始化 |
| sync.WaitGroup | Done ≺ Wait 返回 | 等待多任务 |
| atomic (1.19+) | Store ≺ Load | 无锁计数器 |

**面试核心观点**：

> "Go 内存模型通过 happens-before 关系定义了并发程序的行为边界。理解 happens-before 是写正确并发代码的前提。实践中应优先使用 channel 和标准库提供的同步原语，它们已内置了必要的内存屏障，而不是手动拼装 atomic 操作，后者极易出错。"
