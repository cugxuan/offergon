---
title: sync.Once 为什么能保证只执行一次？
tags:
  - Go并发
  - 同步原语
status: robot
class: Go并发
slug: sync-once-guarantee-single-execution
ref:
---

## 核心要点

- **双检查锁定**:先用原子操作快速检查 done 标志,再用互斥锁保护函数执行
- **原子标记**:done 字段使用 atomic.Uint32 保证内存可见性和顺序性
- **happens-before 保证**:通过 Mutex 和 atomic.Store 确保函数执行完成后 done=1 对所有 goroutine 可见
- **性能优化**:已执行后的调用仅需一次原子读操作,无锁竞争

---

## 详细回答

### 一、sync.Once 的源码实现

#### 完整源码(Go 1.21+)

```go
// sync/once.go
type Once struct {
    done atomic.Uint32  // 标记是否已执行(0=未执行,1=已执行)
    m    Mutex           // 保护函数执行的互斥锁
}

func (o *Once) Do(f func()) {
    // 快速路径:如果已执行,直接返回(无锁)
    if o.done.Load() == 0 {
        // 慢速路径:需要执行函数
        o.doSlow(f)
    }
}

func (o *Once) doSlow(f func()) {
    o.m.Lock()
    defer o.m.Unlock()

    // 双重检查:可能其他 goroutine 已在 Lock 前执行完
    if o.done.Load() == 0 {
        defer o.done.Store(1)  // 确保 panic 时也标记为已执行
        f()
    }
}
```

### 二、为什么能保证只执行一次?

#### 1. 双检查锁定(Double-Checked Locking)

sync.Once 采用经典的双检查锁定模式:

```
第一次检查(无锁)
    ↓
  done == 0?
    ↓ 是
  获取锁
    ↓
第二次检查(有锁)
    ↓
  done == 0?
    ↓ 是
  执行函数 f()
    ↓
  done = 1
    ↓
  释放锁
```

**为什么需要两次检查?**

- **第一次检查(fast path)**:已执行的情况下,避免锁竞争
- **第二次检查(double check)**:防止多个 goroutine 同时通过第一次检查

**示例场景**:
```go
// 假设 3 个 goroutine 同时调用 Do()

Goroutine 1: if done.Load() == 0 { ... }  // 通过
Goroutine 2: if done.Load() == 0 { ... }  // 通过(G1 还未 Store(1))
Goroutine 3: if done.Load() == 0 { ... }  // 通过

// 三者都进入 doSlow(),但只有一个能获得锁
Goroutine 1: Lock() → 成功 → 执行 f() → Store(1) → Unlock()
Goroutine 2: Lock() → 阻塞...
Goroutine 3: Lock() → 阻塞...

// G1 释放锁后,G2 获取锁
Goroutine 2: Lock() → 成功 → if done.Load() == 0 { ... } → 不通过 → Unlock()
Goroutine 3: Lock() → 成功 → if done.Load() == 0 { ... } → 不通过 → Unlock()
```

#### 2. 原子操作保证内存可见性

**为什么使用 atomic.Uint32 而不是普通 uint32?**

```go
// 错误示例:使用普通变量(无法保证可见性)
type BrokenOnce struct {
    done uint32  // 没有原子操作
    m    Mutex
}

func (o *BrokenOnce) Do(f func()) {
    if o.done == 0 {  // 可能读取到过期值!
        o.m.Lock()
        if o.done == 0 {
            f()
            o.done = 1  // 可能未及时同步到其他 CPU 缓存
        }
        o.m.Unlock()
    }
}
```

**问题**: CPU 缓存一致性协议不保证跨核心的即时可见性,可能导致:
- Goroutine A 已将 done 设为 1
- Goroutine B 在另一个 CPU 核心读到旧值 0
- 函数被执行两次!

**正确做法**: 使用 `atomic.Load()` 和 `atomic.Store()`
- `Load()`:强制从主内存读取最新值
- `Store()`:立即刷新到主内存并通知其他核心

#### 3. defer 确保 panic 安全

```go
defer o.done.Store(1)  // 放在 f() 之前
f()
```

**设计意图**:即使 `f()` panic,也标记为已执行,避免二次执行。

**争议点**: 这种设计可能导致初始化失败后无法重试,例如:

```go
var config *Config
var once sync.Once

once.Do(func() {
    config = loadConfig()  // 如果 panic,config 仍为 nil
})

// 后续调用 once.Do() 不会重试,config 永远是 nil
```

**解决方案**: 业务代码需自行处理 panic 和重试逻辑。

### 三、内存模型与 happens-before 保证

sync.Once 保证 **happens-before 关系**:

```
f() 中的所有操作  happens-before  done.Store(1)
     ↓                                   ↓
done.Store(1)    happens-before  done.Load() == 1
     ↓                                   ↓
其他 goroutine 看到 done=1 时,必定能看到 f() 的所有副作用
```

**示例**:
```go
var data int
var once sync.Once

// Goroutine 1
once.Do(func() {
    data = 42  // 写操作
})

// Goroutine 2
once.Do(func() { ... })  // 不会执行
fmt.Println(data)  // 保证能读到 42(而不是 0)
```

**保证机制**:
1. `Mutex.Lock()` 建立 happens-before
2. `atomic.Store(1)` 的 release 语义同步到 `atomic.Load()`

### 四、性能分析

#### 1. 时间复杂度

| 场景 | 操作 | 复杂度 |
|-----|-----|--------|
| 首次调用 | 1次原子读 + 1次加锁 + 函数执行 + 1次原子写 | O(n) |
| 后续调用 | 1次原子读 | O(1) |

**关键优化**: 已执行后的调用只需一次无锁的原子读,性能极高。

#### 2. 与其他方案对比

**方案1: 每次都加锁**
```go
type SlowOnce struct {
    done bool
    m    Mutex
}

func (o *SlowOnce) Do(f func()) {
    o.m.Lock()  // 每次都加锁,性能差
    defer o.m.Unlock()
    if !o.done {
        f()
        o.done = true
    }
}
```
问题:即使已执行,每次调用仍需加锁,高并发下性能差。

**方案2: 仅用原子操作(无法保证唯一性)**
```go
type BrokenOnce struct {
    done atomic.Uint32
}

func (o *BrokenOnce) Do(f func()) {
    if o.done.CompareAndSwap(0, 1) {  // 有竞态!
        f()
    }
}
```
问题:CAS 成功后,多个 goroutine 可能同时进入执行块(在 Store 之前)。

**sync.Once 的优势**:
- 结合原子操作和互斥锁
- 快速路径无锁,慢速路径保证唯一性
- 最优性能与正确性平衡

### 五、常见使用场景

#### 1. 单例初始化
```go
type Singleton struct { /* ... */ }

var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{ /* 初始化 */ }
    })
    return instance
}
```

#### 2. 延迟初始化资源
```go
var (
    db   *sql.DB
    once sync.Once
)

func GetDB() *sql.DB {
    once.Do(func() {
        db, _ = sql.Open("mysql", dsn)
    })
    return db
}
```

#### 3. 测试清理(Go 1.21+)
```go
func TestCleanup(t *testing.T) {
    var once sync.Once
    cleanup := func() {
        once.Do(func() {
            // 清理资源,保证只执行一次
        })
    }
    t.Cleanup(cleanup)
    t.Cleanup(cleanup)  // 重复注册,但只执行一次
}
```

### 六、注意事项与陷阱

#### 1. 闭包捕获变量
```go
// 错误示例
for i := 0; i < 3; i++ {
    once.Do(func() {
        fmt.Println(i)  // 可能输出 3(而非 0)
    })
}

// 正确做法
for i := 0; i < 3; i++ {
    i := i  // 捕获循环变量
    once.Do(func() {
        fmt.Println(i)
    })
}
```

#### 2. panic 后无法重试
```go
once.Do(func() {
    panic("init failed")
})
// once 已标记为 done,后续调用不会重试
```

**解决方案**: 自定义可重试的 Once:
```go
type RetryOnce struct {
    done atomic.Bool
    m    sync.Mutex
}

func (o *RetryOnce) Do(f func()) (err error) {
    if o.done.Load() {
        return nil
    }
    o.m.Lock()
    defer o.m.Unlock()
    if o.done.Load() {
        return nil
    }
    defer func() {
        if recover() == nil {  // 仅在成功时标记
            o.done.Store(true)
        }
    }()
    f()
    return nil
}
```

#### 3. 不要在 Do 内再次调用 Do
```go
// 死锁示例
var once sync.Once
once.Do(func() {
    once.Do(func() {  // 死锁!
        fmt.Println("nested")
    })
})
```

### 七、面试要点总结

1. **核心机制**: 双检查锁定 + 原子操作
2. **性能保证**: 已执行后的调用仅需 O(1) 无锁原子读
3. **内存模型**: atomic.Store 的 release 语义保证 happens-before
4. **panic 处理**: defer 确保异常时也标记为已执行(不可重试)
5. **典型场景**: 单例模式、资源延迟初始化
