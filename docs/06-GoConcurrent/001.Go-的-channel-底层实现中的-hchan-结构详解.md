---
title: Go 的 channel 底层实现中的 hchan 结构详解
tags:
  - Go并发
  - 并发
status: robot
class: Go并发
slug: go-channel-hchan-structure
ref:
---

## 核心要点

**hchan 是 Go channel 的底层结构体，包含：环形缓冲区、发送接收等待队列、互斥锁、元素类型信息等。发送接收通过 sudog 链表实现 goroutine 阻塞唤醒，缓冲区通过循环队列实现高效读写。**

---

## 详细解答

### 一、hchan 结构体定义

在 Go 运行时源码 `runtime/chan.go` 中，channel 的底层结构体 `hchan` 定义如下：

```go
type hchan struct {
    qcount   uint           // 当前队列中剩余元素个数
    dataqsiz uint           // 环形队列长度（容量）
    buf      unsafe.Pointer // 环形队列指针
    elemsize uint16         // 每个元素的大小
    closed   uint32         // 标识channel是否关闭
    elemtype *_type         // 元素类型
    sendx    uint           // 发送操作处理到的位置（循环队列索引）
    recvx    uint           // 接收操作处理到的位置（循环队列索引）
    recvq    waitq          // 等待接收的goroutine队列
    sendq    waitq          // 等待发送的goroutine队列
    lock     mutex          // 互斥锁，保护所有字段
}
```

### 二、核心字段详解

#### 1. **环形缓冲区（buf + sendx + recvx）**

`buf` 指向一个循环队列，用于缓冲数据：

- **dataqsiz**：缓冲区容量，对于无缓冲 channel 为 0
- **qcount**：当前缓冲区中的元素数量
- **sendx**：下一个发送数据的位置索引
- **recvx**：下一个接收数据的位置索引

**循环队列实现原理**：

```
初始状态：buf = [_, _, _, _]  sendx=0, recvx=0, qcount=0

发送一个元素：
buf = [a, _, _, _]  sendx=1, recvx=0, qcount=1

再发送两个：
buf = [a, b, c, _]  sendx=3, recvx=0, qcount=3

接收一个：
buf = [a, b, c, _]  sendx=3, recvx=1, qcount=2

发送到满再发送会循环：
buf = [e, b, c, d]  sendx=1, recvx=1, qcount=4 （循环覆盖）
```

通过 `sendx` 和 `recvx` 实现 O(1) 的入队出队操作。

#### 2. **等待队列（sendq + recvq）**

```go
type waitq struct {
    first *sudog  // 队列头部
    last  *sudog  // 队列尾部
}

type sudog struct {
    g          *g           // goroutine
    elem       unsafe.Pointer // 数据元素
    next       *sudog
    prev       *sudog
    c          *hchan       // channel
    // ... 其他字段
}
```

- **recvq（接收等待队列）**：当 channel 为空或无缓冲区时，接收操作会阻塞，goroutine 被包装成 `sudog` 放入此队列
- **sendq（发送等待队列）**：当 channel 已满或无缓冲区时，发送操作会阻塞，goroutine 被包装成 `sudog` 放入此队列

**阻塞与唤醒机制**：

1. 当接收方从空 channel 读取时，会创建 `sudog` 加入 `recvq`，goroutine 进入阻塞状态
2. 当发送方往该 channel 发送数据时，会从 `recvq` 取出第一个 `sudog`，直接将数据拷贝到等待接收的 goroutine 的栈空间，然后唤醒该 goroutine
3. 发送方阻塞同理，会加入 `sendq`，被接收方唤醒

#### 3. **互斥锁（lock）**

channel 的所有操作都需要加锁，保证并发安全：

- 发送和接收操作开始时会调用 `lock(&c.lock)`
- 操作完成后调用 `unlock(&c.lock)`

这意味着 channel 操作本身就是线程安全的，但频繁的锁竞争也是 channel 性能瓶颈之一。

#### 4. **类型信息（elemtype + elemsize）**

- **elemtype**：元素的类型元数据，用于 GC 扫描和内存管理
- **elemsize**：每个元素的字节大小，用于计算内存拷贝偏移量

### 三、发送和接收操作流程

#### 发送操作（ch <- v）底层调用 `chansend`：

```go
func chansend(c *hchan, ep unsafe.Pointer, block bool) bool {
    lock(&c.lock)

    // 1. 如果recvq不为空，说明有goroutine在等待接收
    if sg := c.recvq.dequeue(); sg != nil {
        // 直接将数据拷贝给等待的接收者
        send(c, sg, ep, func() { unlock(&c.lock) })
        return true
    }

    // 2. 如果缓冲区未满
    if c.qcount < c.dataqsiz {
        // 将数据放入缓冲区
        qp := chanbuf(c, c.sendx)
        typedmemmove(c.elemtype, qp, ep)
        c.sendx++
        if c.sendx == c.dataqsiz {
            c.sendx = 0  // 循环
        }
        c.qcount++
        unlock(&c.lock)
        return true
    }

    // 3. 缓冲区已满，阻塞
    gp := getg()
    mysg := acquiresudog()
    mysg.elem = ep
    mysg.g = gp
    c.sendq.enqueue(mysg)
    gopark()  // 挂起当前goroutine

    unlock(&c.lock)
    return true
}
```

#### 接收操作（<-ch）底层调用 `chanrecv`：

流程与发送类似：

1. 先检查 `sendq` 是否有等待发送的 goroutine，有则直接拷贝并唤醒
2. 再检查缓冲区是否有数据，有则从 `recvx` 位置读取
3. 否则阻塞，加入 `recvq`

### 四、关键设计优化

1. **无锁优化的缺失**：channel 使用全局互斥锁而非无锁算法，优先保证正确性和简洁性
2. **直接内存拷贝**：当发送和接收同时发生时，数据直接从发送方拷贝到接收方，跳过缓冲区
3. **循环队列高效利用内存**：避免频繁的内存分配和 GC 压力
4. **公平性不保证**：等待队列是 FIFO，但多个 goroutine 竞争时不保证公平唤醒

### 五、面试扩展

**面试官可能追问**：

1. **为什么无缓冲 channel 仍然需要 hchan 结构？**
   - 需要 `sendq` 和 `recvq` 来管理阻塞的 goroutine
   - 需要 `lock` 保证并发安全
   - 需要 `elemtype` 用于类型安全的内存操作

2. **关闭的 channel 为什么可以读取但不能写入？**
   - 写入已关闭 channel 会导致 panic（设计哲学：避免数据丢失）
   - 读取已关闭 channel 返回零值（允许优雅关闭模式）

3. **channel 比互斥锁性能差的原因？**
   - channel 内部本身就用了互斥锁
   - channel 涉及 goroutine 调度（gopark/goready）
   - channel 需要内存拷贝操作

### 六、总结

hchan 通过**环形缓冲区 + 等待队列 + 互斥锁**的设计，实现了 Go 的 CSP 并发模型。理解 hchan 结构是掌握 channel 特性（阻塞行为、关闭语义、nil channel 处理）的基础，也是面试中展示底层理解能力的关键。
