---
title: Linux 的内存回收机制（kswapd、oom-killer）
tags:
  - 内存管理
  - 操作系统
status: robot
class: 操作系统
slug: linux-memory-reclaim-kswapd-oom-killer
ref:
---

## 核心要点

**Linux内存回收机制**通过kswapd内核线程进行主动回收和OOM Killer进行被动释放，确保系统在内存紧张时的稳定运行；**kswapd**基于水位标记进行分层回收，**OOM Killer**通过badness评分算法选择性终止进程，两者配合实现从优雅降级到强制释放的完整内存管理策略。

## 详细解答

### 1. Linux内存管理基础

#### 1.1 内存分区和水位标记

**内存区域（Zone）分类：**
```c
// Linux内存区域定义
enum zone_type {
    ZONE_DMA,           // DMA区域 (0-16MB)
    ZONE_DMA32,         // 32位DMA区域 (0-4GB)
    ZONE_NORMAL,        // 正常区域 (直接映射)
    ZONE_HIGHMEM,       // 高端内存区域 (32位系统)
    ZONE_MOVABLE,       // 可移动区域
    __MAX_NR_ZONES
};

struct zone {
    unsigned long watermark[NR_WMARK];  // 水位标记
    unsigned long lowmem_reserve[MAX_NR_ZONES];
    struct per_cpu_pageset pageset[NR_CPUS];
    // ...
};
```

**水位标记系统：**
```c
enum zone_watermarks {
    WMARK_MIN,      // 最低水位：触发直接回收
    WMARK_LOW,      // 低水位：唤醒kswapd
    WMARK_HIGH,     // 高水位：kswapd停止工作
    NR_WMARK
};

// 水位计算
static void setup_per_zone_wmarks(void) {
    for_each_zone(zone) {
        unsigned long min_pages = zone->managed_pages / 1024;

        zone->watermark[WMARK_MIN] = min_pages;
        zone->watermark[WMARK_LOW] = min_pages * 5/4;   // 125%
        zone->watermark[WMARK_HIGH] = min_pages * 3/2;  // 150%
    }
}
```

#### 1.2 页面回收算法基础

**LRU链表管理：**
```c
enum lru_list {
    LRU_INACTIVE_ANON = LRU_BASE,      // 非活跃匿名页
    LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,    // 活跃匿名页
    LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,    // 非活跃文件页
    LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,  // 活跃文件页
    LRU_UNEVICTABLE,                   // 不可回收页
    NR_LRU_LISTS
};

struct lruvec {
    struct list_head lists[NR_LRU_LISTS];  // LRU链表数组
    struct zone_reclaim_stat reclaim_stat;   // 回收统计
    // ...
};
```

### 2. kswapd内核线程详解

#### 2.1 kswapd工作原理

**kswapd线程主循环：**
```c
static int kswapd(void *p) {
    pg_data_t *pgdat = (pg_data_t*)p;
    struct task_struct *tsk = current;

    tsk->flags |= PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD;
    set_freezable();

    for (;;) {
        bool ret;

        // 等待唤醒信号
        wait_event_freezable(pgdat->kswapd_wait,
            kswapd_try_to_sleep(pgdat, order, classzone_idx));

        // 执行内存回收
        ret = try_to_free_pages(pgdat, order, GFP_KERNEL, classzone_idx);

        // 检查是否需要继续工作
        if (!ret) {
            count_vm_event(KSWAPD_LOW_WMARK_HIT_QUICKLY);
        }
    }

    return 0;
}
```

**kswapd唤醒条件：**
```c
void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx) {
    pg_data_t *pgdat;

    if (!populated_zone(zone))
        return;

    pgdat = zone->zone_pgdat;

    // 检查水位标记
    if (zone_watermark_ok_safe(zone, order, low_wmark_pages(zone),
                              classzone_idx, 0))
        return;

    // 唤醒kswapd
    if (!waitqueue_active(&pgdat->kswapd_wait))
        return;

    wake_up_interruptible(&pgdat->kswapd_wait);
}
```

#### 2.2 页面回收策略

**回收优先级算法：**
```c
// 回收优先级定义
#define DEF_PRIORITY 12
#define MAX_SWAPPINESS 100

static unsigned long shrink_lruvec(struct lruvec *lruvec,
                                  struct scan_control *sc) {
    unsigned long nr[NR_LRU_LISTS];
    unsigned long targets[NR_LRU_LISTS];
    unsigned long nr_to_scan;
    unsigned long nr_reclaimed = 0;

    // 计算各LRU链表的扫描数量
    get_scan_count(lruvec, sc, nr);

    // 按优先级回收页面
    while (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||
           nr[LRU_INACTIVE_FILE]) {

        // 优先回收文件页（clean pages）
        if (nr[LRU_INACTIVE_FILE]) {
            nr_to_scan = min(nr[LRU_INACTIVE_FILE], SWAP_CLUSTER_MAX);
            nr[LRU_INACTIVE_FILE] -= nr_to_scan;
            nr_reclaimed += shrink_page_list(&page_list, sc);
        }

        // 回收匿名页（需要swap）
        if (nr[LRU_INACTIVE_ANON] && should_reclaim_anon(sc)) {
            nr_to_scan = min(nr[LRU_INACTIVE_ANON], SWAP_CLUSTER_MAX);
            nr[LRU_INACTIVE_ANON] -= nr_to_scan;
            nr_reclaimed += shrink_page_list(&page_list, sc);
        }
    }

    return nr_reclaimed;
}
```

**swappiness参数控制：**
```c
// swappiness影响匿名页和文件页的回收比例
static void get_scan_count(struct lruvec *lruvec, struct scan_control *sc,
                          unsigned long *nr) {
    unsigned long anon_prio, file_prio;
    unsigned long ap, fp;
    unsigned long anon = get_lru_size(lruvec, LRU_ACTIVE_ANON) +
                        get_lru_size(lruvec, LRU_INACTIVE_ANON);
    unsigned long file = get_lru_size(lruvec, LRU_ACTIVE_FILE) +
                        get_lru_size(lruvec, LRU_INACTIVE_FILE);

    // swappiness=0: 尽量不swap
    // swappiness=100: 匿名页和文件页同等对待
    anon_prio = sc->swappiness;
    file_prio = 200 - anon_prio;

    // 计算扫描比例
    fraction[0] = anon_prio * (anon + 1);
    fraction[1] = file_prio * (file + 1);

    // 分配扫描数量到各LRU链表
    denominator = anon_prio + file_prio + 1;
    nr[LRU_ACTIVE_ANON] = anon * fraction[0] / denominator;
    nr[LRU_INACTIVE_ANON] = anon * fraction[0] / denominator;
    nr[LRU_ACTIVE_FILE] = file * fraction[1] / denominator;
    nr[LRU_INACTIVE_FILE] = file * fraction[1] / denominator;
}
```

#### 2.3 直接回收机制

**__alloc_pages_slowpath直接回收：**
```c
static struct page *__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
                                          struct alloc_context *ac) {
    bool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;
    struct page *page = NULL;
    unsigned int alloc_flags;
    unsigned long pages_reclaimed = 0;

    // 第一次分配尝试
    page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);
    if (page)
        goto got_pg;

    // 唤醒kswapd
    wake_all_kswapds(order, ac);

    // 如果允许直接回收
    if (can_direct_reclaim) {
        page = __alloc_pages_direct_reclaim(gfp_mask, order,
                                          alloc_flags, ac,
                                          &pages_reclaimed);
        if (page)
            goto got_pg;
    }

    // 直接回收失败，可能触发OOM
    page = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);

got_pg:
    return page;
}
```

### 3. OOM Killer机制详解

#### 3.1 OOM触发条件

**内存不足检测：**
```c
bool out_of_memory(struct oom_control *oc) {
    struct task_struct *p;
    unsigned long totalpages;
    unsigned long freed = 0;

    // 检查是否真的内存不足
    if (oom_killer_disabled)
        return false;

    // 检查是否有其他方式释放内存
    if (!is_memcg_oom(oc)) {
        // 尝试系统级回收
        freed = global_reclaim(oc->gfp_mask, oc->order);
        if (freed > 0)
            return false;
    }

    // 确认需要OOM Kill
    if (oom_scan_process_thread(oc) == OOM_SCAN_ABORT)
        return false;

    // 选择受害者进程
    p = select_bad_process(oc);
    if (!p) {
        dump_header(oc, NULL);
        return false;
    }

    // 执行kill
    oom_kill_process(oc, p, "Out of memory");
    return true;
}
```

#### 3.2 OOM Killer算法

**badness评分算法：**
```c
unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,
                         const nodemask_t *nodemask, unsigned long totalpages) {
    long points;
    long adj;

    if (oom_unkillable_task(p, memcg, nodemask))
        return 0;

    // 获取进程的内存使用量（RSS + Swap + 页表）
    p = find_lock_task_mm(p);
    if (!p)
        return 0;

    // 计算基础分数：内存使用量/总内存 * 1000
    points = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +
             atomic_long_read(&p->mm->nr_ptes) + mm_nr_pmds(p->mm);
    task_unlock(p);

    // 转换为0-1000分
    points = points * 1000 / totalpages;

    // 应用oom_score_adj调整
    adj = (long)p->signal->oom_score_adj;
    if (adj == OOM_SCORE_ADJ_MAX) {
        task_unlock(p);
        return ULONG_MAX;  // 强制kill
    }

    if (adj == OOM_SCORE_ADJ_MIN) {
        task_unlock(p);
        return 0;  // 禁止kill
    }

    // 调整分数
    if (adj > 0) {
        points += adj * totalpages / 1000;
    } else {
        points = points * (1000 + adj) / 1000;
    }

    return points > 0 ? points : 1;
}
```

**进程选择算法：**
```c
static struct task_struct *select_bad_process(struct oom_control *oc) {
    struct task_struct *p;
    struct task_struct *chosen = NULL;
    unsigned long chosen_points = 0;

    rcu_read_lock();
    for_each_process(p) {
        unsigned long points;

        // 跳过内核线程
        if (!p->mm)
            continue;

        // 跳过已经在dying的进程
        if (test_tsk_thread_flag(p, TIF_MEMDIE))
            continue;

        // 计算badness分数
        points = oom_badness(p, oc->memcg, oc->nodemask, oc->totalpages);
        if (!points)
            continue;

        // 选择分数最高的进程
        if (points > chosen_points) {
            chosen = p;
            chosen_points = points;
        }
    }
    rcu_read_unlock();

    return chosen;
}
```

#### 3.3 OOM Kill执行

**进程终止过程：**
```c
static void oom_kill_process(struct oom_control *oc, struct task_struct *p,
                           const char *message) {
    struct task_struct *victim = p;
    struct task_struct *child;
    struct task_struct *t;
    struct mm_struct *mm;
    unsigned int victim_points = 0;

    // 输出OOM信息
    dump_header(oc, p);

    // 查找实际的mm_struct拥有者
    t = find_lock_task_mm(victim);
    if (!t) {
        put_task_struct(victim);
        return;
    }

    // 标记进程为OOM victim
    set_tsk_thread_flag(t, TIF_MEMDIE);

    // 发送SIGKILL信号
    do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);

    // 释放内存映射
    mm = victim->mm;
    if (mm) {
        mmput(mm);
    }

    // 设置exit code
    victim->signal->group_exit_code = SIGKILL;

    // 唤醒等待内存的进程
    wake_up_all(&oom_victims_wait);

    put_task_struct(victim);
}
```

### 4. 内存回收优化和调优

#### 4.1 系统参数调优

**关键内核参数：**
```bash
# /proc/sys/vm/下的重要参数

# swappiness: 控制swap倾向 (0-100)
echo 10 > /proc/sys/vm/swappiness    # 减少swap使用

# min_free_kbytes: 最小空闲内存
echo 65536 > /proc/sys/vm/min_free_kbytes  # 64MB保留内存

# dirty_ratio: 脏页比例触发回写
echo 10 > /proc/sys/vm/dirty_ratio   # 10%内存用于脏页

# dirty_background_ratio: 后台回写触发点
echo 5 > /proc/sys/vm/dirty_background_ratio

# vfs_cache_pressure: VFS缓存回收压力
echo 100 > /proc/sys/vm/vfs_cache_pressure

# oom_kill_allocating_task: OOM时kill申请内存的任务
echo 1 > /proc/sys/vm/oom_kill_allocating_task
```

**内存压力监控：**
```bash
#!/bin/bash
# 内存压力监控脚本

function check_memory_pressure() {
    # 检查内存使用率
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    mem_usage=$((100 * (mem_total - mem_available) / mem_total))

    # 检查swap使用
    swap_total=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
    swap_free=$(grep SwapFree /proc/meminfo | awk '{print $2}')
    if [ $swap_total -gt 0 ]; then
        swap_usage=$((100 * (swap_total - swap_free) / swap_total))
    else
        swap_usage=0
    fi

    # 检查kswapd活动
    kswapd_activity=$(grep pswpin /proc/vmstat | awk '{print $2}')

    echo "Memory Usage: ${mem_usage}%"
    echo "Swap Usage: ${swap_usage}%"
    echo "Kswapd Activity: $kswapd_activity pages"

    # 警告阈值
    if [ $mem_usage -gt 90 ]; then
        echo "WARNING: High memory usage!"
    fi

    if [ $swap_usage -gt 50 ]; then
        echo "WARNING: High swap usage!"
    fi
}

while true; do
    check_memory_pressure
    echo "---"
    sleep 30
done
```

#### 4.2 应用级优化

**内存使用模式优化：**
```c
#include <sys/mman.h>
#include <malloc.h>

// 使用madvise优化内存访问
void optimize_memory_usage(void *addr, size_t length) {
    // 告诉内核页面访问模式
    madvise(addr, length, MADV_SEQUENTIAL);   // 顺序访问
    madvise(addr, length, MADV_WILLNEED);     // 预取页面
    madvise(addr, length, MADV_DONTNEED);     // 释放页面（回收候选）
}

// 内存池减少碎片
struct memory_pool {
    void *pool_start;
    size_t pool_size;
    size_t block_size;
    void *free_list;
};

void* pool_alloc(struct memory_pool *pool) {
    if (!pool->free_list) {
        // 扩展池或返回NULL
        return NULL;
    }

    void *block = pool->free_list;
    pool->free_list = *(void**)pool->free_list;
    return block;
}

void pool_free(struct memory_pool *pool, void *ptr) {
    *(void**)ptr = pool->free_list;
    pool->free_list = ptr;
}
```

**OOM保护策略：**
```c
#include <sys/resource.h>

// 设置进程OOM调整值
void set_oom_score_adj(int score) {
    FILE *f = fopen("/proc/self/oom_score_adj", "w");
    if (f) {
        fprintf(f, "%d", score);
        fclose(f);
    }
}

// 监控内存使用并主动释放
void monitor_memory_usage() {
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);

    long rss_kb = usage.ru_maxrss;  // 当前RSS（KB）

    // 获取系统内存信息
    FILE *meminfo = fopen("/proc/meminfo", "r");
    long mem_available = 0;
    char line[256];
    while (fgets(line, sizeof(line), meminfo)) {
        if (sscanf(line, "MemAvailable: %ld kB", &mem_available) == 1)
            break;
    }
    fclose(meminfo);

    // 如果系统内存紧张且自己占用过多，主动释放
    if (mem_available < 1024 * 1024 && rss_kb > mem_available / 4) {  // 1GB且占用>25%
        // 释放缓存、压缩数据等
        malloc_trim(0);  // 释放malloc缓存

        // 通知应用层释放非关键数据
        application_free_caches();
    }
}
```

### 5. 高级内存管理特性

#### 5.1 Memory Cgroup控制

**Cgroup内存限制：**
```bash
# 创建memory cgroup
mkdir /sys/fs/cgroup/memory/myapp

# 设置内存限制
echo 1G > /sys/fs/cgroup/memory/myapp/memory.limit_in_bytes

# 设置swap限制
echo 1G > /sys/fs/cgroup/memory/myapp/memory.memsw.limit_in_bytes

# 启用OOM控制
echo 1 > /sys/fs/cgroup/memory/myapp/memory.oom_control

# 运行进程
echo $$ > /sys/fs/cgroup/memory/myapp/cgroup.procs
./myapp
```

**Cgroup内存统计：**
```c
// 读取cgroup内存使用情况
#include <stdio.h>

void print_cgroup_memory_stats(const char *cgroup_path) {
    char stat_file[256];
    snprintf(stat_file, sizeof(stat_file),
             "/sys/fs/cgroup/memory/%s/memory.stat", cgroup_path);

    FILE *f = fopen(stat_file, "r");
    if (!f) return;

    char line[256];
    while (fgets(line, sizeof(line), f)) {
        unsigned long value;
        if (sscanf(line, "rss %lu", &value) == 1) {
            printf("RSS: %lu KB\n", value / 1024);
        } else if (sscanf(line, "cache %lu", &value) == 1) {
            printf("Cache: %lu KB\n", value / 1024);
        } else if (sscanf(line, "swap %lu", &value) == 1) {
            printf("Swap: %lu KB\n", value / 1024);
        }
    }
    fclose(f);
}
```

#### 5.2 NUMA内存管理

**NUMA感知的内存回收：**
```c
// NUMA节点亲和性设置
#include <numa.h>

void setup_numa_policy() {
    if (numa_available() == -1) {
        printf("NUMA not available\n");
        return;
    }

    // 绑定到本地节点
    int node = numa_node_of_cpu(sched_getcpu());
    struct bitmask *nodemask = numa_allocate_nodemask();
    numa_bitmask_setbit(nodemask, node);

    // 设置内存分配策略
    numa_set_membind(nodemask);

    // 设置内存回收策略偏向本地节点
    numa_set_localalloc();

    numa_bitmask_free(nodemask);
}
```

### 6. 故障排查和调试

#### 6.1 内存回收分析工具

**使用sar监控内存回收：**
```bash
# 监控内存和swap活动
sar -r 1     # 内存使用情况
sar -W 1     # swap活动
sar -B 1     # 页面换入换出

# 查看kswapd活动
grep kswapd /proc/*/comm | wc -l

# 分析内存回收事件
grep -E "(kswapd|oom-killer)" /var/log/kern.log
```

**内存回收统计分析：**
```bash
#!/bin/bash
# 内存回收详细分析

function analyze_memory_reclaim() {
    echo "=== Memory Reclaim Analysis ==="

    # kswapd统计
    echo "Kswapd activity:"
    grep -E "pgscan_kswapd|pgsteal_kswapd" /proc/vmstat

    # 直接回收统计
    echo "Direct reclaim activity:"
    grep -E "pgscan_direct|pgsteal_direct" /proc/vmstat

    # OOM统计
    echo "OOM events:"
    grep oom_kill /proc/vmstat

    # 各zone水位状态
    echo "Zone watermarks:"
    cat /proc/zoneinfo | grep -E "(Node|zone|pages free|low|high)"

    # LRU统计
    echo "LRU statistics:"
    grep -E "nr_.*_lru" /proc/vmstat
}

analyze_memory_reclaim
```

#### 6.2 OOM分析

**OOM日志分析：**
```bash
# 提取OOM事件
dmesg | grep -E "(Out of memory|oom-killer|Killed process)"

# 分析OOM触发原因
grep -A 20 -B 5 "oom-killer" /var/log/kern.log

# 查看进程OOM分数
for pid in $(ps -eo pid --no-headers); do
    if [ -f /proc/$pid/oom_score ]; then
        score=$(cat /proc/$pid/oom_score 2>/dev/null)
        adj=$(cat /proc/$pid/oom_score_adj 2>/dev/null)
        comm=$(cat /proc/$pid/comm 2>/dev/null)
        echo "PID: $pid, Score: $score, Adj: $adj, Comm: $comm"
    fi
done | sort -k4 -nr | head -20
```

**预防OOM的监控脚本：**
```bash
#!/bin/bash
# OOM预警脚本

MEMORY_THRESHOLD=90  # 内存使用率阈值
SWAP_THRESHOLD=50    # swap使用率阈值

function check_oom_risk() {
    # 获取内存信息
    mem_total=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
    mem_available=$(awk '/MemAvailable/ {print $2}' /proc/meminfo)
    mem_usage=$((100 * (mem_total - mem_available) / mem_total))

    # 获取swap信息
    swap_total=$(awk '/SwapTotal/ {print $2}' /proc/meminfo)
    if [ $swap_total -gt 0 ]; then
        swap_free=$(awk '/SwapFree/ {print $2}' /proc/meminfo)
        swap_usage=$((100 * (swap_total - swap_free) / swap_total))
    else
        swap_usage=0
    fi

    # 检查风险
    if [ $mem_usage -gt $MEMORY_THRESHOLD ]; then
        echo "WARNING: Memory usage ${mem_usage}% exceeds threshold ${MEMORY_THRESHOLD}%"

        # 显示内存大户
        echo "Top memory consumers:"
        ps aux --sort=-%mem | head -10

        # 检查是否有kswapd活动
        if pgrep kswapd > /dev/null; then
            echo "kswapd is active - memory reclaim in progress"
        fi

        return 1
    fi

    if [ $swap_usage -gt $SWAP_THRESHOLD ]; then
        echo "WARNING: Swap usage ${swap_usage}% exceeds threshold ${SWAP_THRESHOLD}%"
        return 1
    fi

    return 0
}

# 持续监控
while true; do
    if ! check_oom_risk; then
        # 发送告警
        logger "OOM risk detected on $(hostname)"
        # 可以发送邮件、通知等
    fi
    sleep 60
done
```

### 7. 现代发展和优化

#### 7.1 Multi-Gen LRU

**新的LRU算法：**
```c
// Multi-generational LRU (MGLRU)
struct lru_gen_struct {
    unsigned long max_seq;      // 最大代数
    unsigned long min_seq[2];   // 最小代数[文件/匿名]
    struct list_head lists[MEMCG_NR_GENS][2][MAX_NR_ZONES];
    // ...
};

// 提供更精确的页面年龄信息
// 减少错误的页面回收
// 提高在不同工作负载下的性能
```

#### 7.2 PSI (Pressure Stall Information)

**内存压力监控：**
```bash
# 查看内存压力信息
cat /proc/pressure/memory
# some avg10=2.04 avg60=1.73 avg300=1.65 total=123456789
# full avg10=0.94 avg60=0.82 avg300=0.74 total=987654321

# 设置内存压力阈值告警
echo "some 80000000 1000000" > /proc/pressure/memory
```

### 总结

Linux内存回收机制是一个精密的多层次系统：

**kswapd机制优势：**
1. **主动回收**：基于水位标记提前释放内存
2. **后台运行**：不阻塞用户进程的内存分配
3. **智能调度**：根据内存压力动态调整回收强度

**OOM Killer保护：**
1. **最后防线**：在所有回收手段失效时保护系统
2. **智能选择**：基于内存使用量和重要性选择victim
3. **可配置性**：支持进程级别的OOM调整

**性能调优要点：**
- 合理设置swappiness（一般10-20）
- 监控内存压力指标（PSI）
- 使用cgroup限制关键服务
- 应用层主动内存管理

**现代优化：**
- Multi-Gen LRU提高回收精度
- PSI提供细粒度压力监控
- NUMA感知的内存管理
- 容器化环境的内存隔离

理解这些机制有助于系统性能调优、容量规划和故障诊断，对于运维高负载系统和开发内存敏感应用都至关重要。
