---
title: Linux 文件系统（inode、目录项、文件描述符）
tags:
  - 操作系统
status: robot
class: 操作系统
slug: linux-filesystem-inode-dentry-file-descriptor
ref:
---

## 核心要点

**Linux 文件系统的三个核心概念:**
- **inode (索引节点)**: 存储文件元数据 (权限、大小、时间戳) 和数据块位置,每个文件对应一个 inode
- **目录项 (dentry)**: 内核缓存的文件名到 inode 的映射,加速路径查找,存在于内存中
- **文件描述符 (fd)**: 进程打开文件时的句柄,本质是指向内核打开文件表的索引

**关系**: `文件名 (目录项) → inode → 数据块`,`进程 → fd → 内核打开文件表 → inode`

**关键点**: 硬链接共享 inode,软链接有独立 inode;删除文件名不一定删除数据 (inode 引用计数)

---

## 详细回答

### 一、inode (索引节点)

#### 什么是 inode?

**inode (index node)** 是文件系统中存储**文件元数据**的数据结构,每个文件/目录都有唯一的 inode。

**重要概念**: 在 Linux 中,文件名和文件数据是分离的!
- **inode**: 存储文件属性和数据位置
- **文件名**: 只是目录中指向 inode 的一个链接

#### inode 存储的信息

```c
struct inode {
    unsigned long i_ino;        // inode 编号 (唯一标识)
    umode_t       i_mode;       // 文件类型和权限 (rwxrwxrwx)
    uid_t         i_uid;        // 所有者 UID
    gid_t         i_gid;        // 所属组 GID
    off_t         i_size;       // 文件大小 (字节)
    time_t        i_atime;      // 最后访问时间 (access)
    time_t        i_mtime;      // 最后修改时间 (modify)
    time_t        i_ctime;      // 状态改变时间 (change)
    unsigned long i_blocks;     // 占用的块数
    unsigned int  i_nlink;      // 硬链接计数 (引用计数)
    // 数据块指针 (直接块、一级间接块、二级间接块...)
};
```

**注意**: inode **不存储文件名**!文件名存储在目录中。

#### 查看 inode 信息

```bash
# 查看 inode 编号
ls -i file.txt
# 输出: 123456 file.txt

# 查看 inode 详细信息
stat file.txt
# 输出:
# File: file.txt
# Size: 1024        Blocks: 8          IO Block: 4096
# Inode: 123456     Links: 1
# Access: 2025-10-10 10:00:00
# Modify: 2025-10-10 09:00:00
# Change: 2025-10-10 09:00:00

# 查看文件系统 inode 使用情况
df -i
```

#### inode 的数据块索引

**小文件 (< 48KB)**: 直接块指针 (12 个,每个 4KB)
```
inode → [块1][块2][块3]...[块12]
```

**中等文件**: 一级间接块
```
inode → 一级间接块 → [块1][块2]...[块1024]
```

**大文件**: 二级、三级间接块
```
inode → 二级间接块 → 一级间接块 → 数据块
```

---

### 二、目录项 (dentry, Directory Entry)

#### 什么是 dentry?

**目录项** 是内核为了加速文件路径查找而维护的**内存缓存**,记录文件名到 inode 的映射。

**关键特性:**
- **只存在于内存中** (不持久化到磁盘)
- 由内核自动管理 (LRU 淘汰)
- 组成树状结构,对应文件系统的目录树

#### 目录的本质

**目录是一种特殊文件**,其内容是一张表,记录 `文件名 → inode 编号` 的映射。

**磁盘上的目录结构** (ext4 示例):
```
目录文件内容:
┌──────────────┬──────────────┐
│  inode 编号  │   文件名     │
├──────────────┼──────────────┤
│   123456     │   file.txt   │
│   123457     │   photo.jpg  │
│   123458     │   docs/      │
└──────────────┴──────────────┘
```

#### dentry 缓存的作用

**场景**: 打开文件 `/home/user/docs/file.txt`

**无缓存时** (需要 4 次磁盘读取):
```
1. 读取根目录 inode (/)
2. 在根目录中查找 "home" → 读取 home 的 inode
3. 在 home 目录中查找 "user" → 读取 user 的 inode
4. 在 user 目录中查找 "docs" → 读取 docs 的 inode
5. 在 docs 目录中查找 "file.txt" → 读取 file.txt 的 inode
```

**有 dentry 缓存时** (直接命中):
```
dentry 缓存: "/home/user/docs/file.txt" → inode 123456
```

#### 查看 dentry 缓存

```bash
# 查看内核 slab 缓存统计
cat /proc/slabinfo | grep dentry
# dentry  12345  15000  192  20  1 : tunables
```

---

### 三、文件描述符 (File Descriptor, fd)

#### 什么是文件描述符?

**文件描述符** 是进程打开文件时,内核返回的一个**非负整数**,作为访问文件的句柄。

```c
int fd = open("file.txt", O_RDONLY);  // 返回 fd = 3
read(fd, buf, size);
close(fd);
```

**预定义的文件描述符:**
- `0`: 标准输入 (stdin)
- `1`: 标准输出 (stdout)
- `2`: 标准错误 (stderr)

#### 文件描述符的三层结构

```
进程 A                      内核
┌─────────────┐             ┌──────────────────────┐
│ 进程 fd 表  │             │  系统打开文件表       │        ┌─────────┐
├─────────────┤             ├──────────────────────┤        │ inode 表│
│ fd 0 → ───────────────────→│文件表项 (偏移量,标志)│───────→│ inode 1 │
│ fd 1 → ───────────────────→│文件表项              │───────→│ inode 2 │
│ fd 3 → ───────────────────→│文件表项              │───────→│ inode 3 │
└─────────────┘             └──────────────────────┘        └─────────┘
```

**三层表的作用:**

1. **进程 fd 表** (每个进程独立)
   - 记录 fd 到系统打开文件表的指针
   - `fork()` 后子进程复制 fd 表 (共享文件表项)

2. **系统打开文件表** (全局共享)
   - 记录文件偏移量 (offset)
   - 记录打开模式 (O_RDONLY, O_WRONLY...)
   - 引用 inode

3. **inode 表** (全局共享)
   - 存储文件元数据和数据块位置

#### 示例:父子进程共享文件偏移量

```c
int fd = open("file.txt", O_RDONLY);
fork();  // 父子进程共享同一个文件表项

// 父进程读取 10 字节
read(fd, buf1, 10);

// 子进程从偏移量 10 继续读 (共享偏移量!)
read(fd, buf2, 10);
```

#### 查看进程打开的文件描述符

```bash
# 查看进程 1234 打开的所有 fd
ls -l /proc/1234/fd
# 输出:
# lrwx------ 1 user user 0 -> /dev/null
# lrwx------ 1 user user 1 -> /dev/pts/0
# lrwx------ 2 user user 3 -> /home/user/file.txt
```

---

### 四、三者关系总结

#### 完整的文件访问流程

```
用户操作: open("/home/user/file.txt", O_RDONLY)

1. 路径解析 (使用 dentry 缓存)
   "/home/user/file.txt" → inode 123456

2. 创建文件表项
   - 在系统打开文件表中创建新项
   - 记录 inode 指针、偏移量 = 0、标志 = O_RDONLY

3. 分配文件描述符
   - 在进程 fd 表中找到最小未使用的 fd (如 3)
   - fd 3 指向上述文件表项

4. 返回 fd
   返回 3 给用户进程
```

**读取数据时:**
```
read(fd, buf, size)
→ fd 3 → 文件表项 → inode 123456 → 数据块地址 → 磁盘读取
```

#### 对比图

| 层次 | 作用 | 生命周期 | 共享性 |
|------|------|----------|--------|
| **文件描述符** | 进程访问文件的句柄 | 进程打开文件时创建 | 每个进程独立 (fork 后可共享) |
| **文件表项** | 记录文件偏移量和状态 | open 时创建,所有 fd 关闭后销毁 | 进程间可共享 |
| **inode** | 文件元数据和数据位置 | 文件创建时分配 | 全局唯一,所有进程共享 |
| **dentry** | 文件名到 inode 的缓存 | 内核自动管理 (LRU) | 全局共享 (内存缓存) |

---

### 五、实际案例分析

#### 案例 1: 删除正在运行的程序

```bash
# 运行一个程序
./myapp &  # PID = 1234

# 删除程序文件
rm myapp

# 程序仍在运行!
ps aux | grep myapp
# myapp 仍在运行
```

**原理:**
1. `./myapp` 时,内核打开文件并持有 inode 引用
2. `rm myapp` 只是删除目录中的文件名,inode 引用计数 `i_nlink - 1`
3. 由于进程仍持有 inode (通过 fd),`i_nlink = 0` 但 inode 未释放
4. 进程退出后,inode 引用归零,数据才真正删除

**应用**: 日志文件滚动 (删除旧日志时,程序仍能写入)

#### 案例 2: 硬链接和软链接

**硬链接** (共享 inode):
```bash
ln file.txt hardlink.txt
ls -i
# 123456 file.txt
# 123456 hardlink.txt  (相同 inode!)

# inode 引用计数 = 2
stat file.txt | grep Links
# Links: 2
```

**软链接** (独立 inode,存储目标路径):
```bash
ln -s file.txt symlink.txt
ls -i
# 123456 file.txt
# 789012 symlink.txt  (不同 inode!)

# 查看软链接内容
cat symlink.txt  # 读取 file.txt 的内容
readlink symlink.txt  # 输出: file.txt
```

#### 案例 3: dup2 系统调用重定向

```c
// 将 stdout 重定向到文件
int fd = open("output.txt", O_WRONLY | O_CREAT, 0644);
dup2(fd, 1);  // 复制 fd 到 fd 1 (stdout)
close(fd);

printf("Hello\n");  // 输出到 output.txt,而不是终端
```

**原理:**
```
原来: fd 1 (stdout) → 终端的文件表项
复制后: fd 1 (stdout) → output.txt 的文件表项
```

---

### 六、常见问题

#### Q1: 为什么 inode 会用完?

**场景**: 创建大量小文件 (如邮件队列、临时文件)

```bash
df -i
# /dev/sda1  100%  (inode 用尽!)
```

**解决:**
- 删除无用小文件
- 创建文件系统时增加 inode 数量: `mkfs.ext4 -N 10000000 /dev/sda1`

#### Q2: 删除文件后磁盘空间没释放?

**原因**: 进程仍持有文件 fd

**排查:**
```bash
lsof | grep deleted
# myapp  1234  user  3r  REG  /path/to/file (deleted)

# 重启进程或手动截断
> /proc/1234/fd/3
```

#### Q3: dentry 缓存过多导致内存不足?

```bash
# 手动释放 dentry 缓存
echo 2 > /proc/sys/vm/drop_caches  # 释放 dentry 和 inode 缓存
```

---

### 七、性能优化

#### 1. 减少路径查找开销

```c
// 不推荐: 重复解析路径
for (int i = 0; i < 10000; i++) {
    int fd = open("/var/log/app.log", O_APPEND);
    write(fd, buf, size);
    close(fd);
}

// 推荐: 只打开一次
int fd = open("/var/log/app.log", O_APPEND);
for (int i = 0; i < 10000; i++) {
    write(fd, buf, size);
}
close(fd);
```

#### 2. 使用 openat 避免竞态条件

```c
// 先打开目录
int dirfd = open("/home/user/", O_RDONLY);

// 相对路径打开,避免路径解析
int fd = openat(dirfd, "file.txt", O_RDONLY);
```

#### 3. 批量 stat 操作

```c
// 使用 fstatat 避免重复路径查找
int dirfd = open("/home/user/", O_RDONLY);
struct stat st;
fstatat(dirfd, "file1.txt", &st, 0);
fstatat(dirfd, "file2.txt", &st, 0);
```

---

### 八、总结

**记忆口诀:**
- **inode**: 文件的"身份证",记录文件属性和数据位置
- **dentry**: 文件的"索引",加速从文件名找到 inode
- **fd**: 进程的"钥匙",访问文件的句柄

**关键点:**
1. **文件名不是文件**: 文件名只是目录中指向 inode 的链接
2. **删除文件名 ≠ 删除数据**: inode 引用计数为 0 时才真正删除
3. **fd 是间接引用**: fd → 文件表项 → inode → 数据块

**面试加分项:**
- 能解释为什么删除正在运行的程序后程序仍能执行
- 理解硬链接和软链接在 inode 层面的区别
- 知道 dentry 缓存的作用和 `drop_caches` 的原理
- 能说明 fork 后父子进程共享文件偏移量的机制 (共享文件表项)
- 了解 inode 耗尽的场景和解决方法
