---
title: 内存碎片（内部碎片和外部碎片）
tags:
  - 内存管理
  - 操作系统
status: robot
class: 操作系统
slug: memory-fragmentation-internal-external
ref:
---

## 核心要点

**内部碎片**是分配单元内部未使用的空间（如分页系统最后一页未填满），**外部碎片**是分配单元之间无法使用的空闲块（如分段系统的不连续小空闲区）。分页有内部碎片无外部碎片，分段相反。解决方法：内部碎片用小页/变长分配，外部碎片用内存紧缩/伙伴系统。

---

## 详细回答

### 一、内存碎片的基本概念

**内存碎片（Memory Fragmentation）**是指内存中存在但无法被有效利用的空间。根据产生原因和位置，分为两类：

1. **内部碎片（Internal Fragmentation）**
   - 已分配给进程，但进程实际不使用的内存
   - 发生在**分配单元内部**

2. **外部碎片（External Fragmentation）**
   - 系统中存在足够的空闲内存，但不连续，无法满足分配请求
   - 发生在**分配单元之间**

**关键区别**
- 内部碎片：空间已分配，但浪费
- 外部碎片：空间未分配，但不可用

---

### 二、内部碎片详解

**定义**
- 分配给进程的内存块中，未被使用的部分

**产生原因**

**1. 分页系统的内部碎片**

在分页内存管理中，内存以固定大小的页为单位分配（如4KB）。进程最后一页通常无法完全填满。

**示例**
```
进程需要内存：13KB
页大小：4KB

分配情况：
页1: [████████████████████] 4KB (全部使用)
页2: [████████████████████] 4KB (全部使用)
页3: [████████████████████] 4KB (全部使用)
页4: [█████░░░░░░░░░░░░░░░] 1KB使用 + 3KB浪费

总分配：16KB
实际使用：13KB
内部碎片：3KB (页4中未使用的空间)
```

**平均内部碎片**
- 最坏情况：浪费整页 - 1字节
- 最好情况：0（正好填满）
- **平均浪费：页大小 / 2**

对于4KB页：平均内部碎片 = 2KB/进程

**2. 固定大小分配的内部碎片**

在一些内存分配器中，为了简化管理，按固定大小块分配（如malloc分配16、32、64字节等规格）。

**示例**
```
请求20字节 → 分配32字节 → 浪费12字节
请求50字节 → 分配64字节 → 浪费14字节
```

**3. 内存对齐导致的内部碎片**

为了性能优化，数据需要按特定边界对齐（如8字节对齐）。

**示例**
```c
struct Example {
    char a;      // 1字节
    // 3字节填充（对齐）
    int b;       // 4字节
    char c;      // 1字节
    // 7字节填充（对齐到8字节边界）
};
// 总大小：16字节（实际使用6字节，浪费10字节）
```

**计算公式**
```
内部碎片率 = (分配大小 - 实际使用大小) / 分配大小 × 100%
```

---

### 三、外部碎片详解

**定义**
- 系统中的空闲内存块因为不连续，无法满足较大的连续内存分配请求

**产生原因**

**1. 分段系统的外部碎片**

在分段内存管理中，段的大小可变。频繁分配和释放后，内存中会形成大量小的不连续空闲块。

**示例**
```
初始内存（1MB空闲）:
[░░░░░░░░░░░░░░░░░░░░░░░░░] 1MB空闲

分配段A(200KB)、段B(300KB)、段C(100KB):
[AAAA][BBBBBB][CCC][░░░░░░] A=200KB, B=300KB, C=100KB, 空闲=400KB

释放段B:
[AAAA][░░░░░░][CCC][░░░░░░]
空闲总量：300KB + 400KB = 700KB

请求分配500KB段D:
❌ 失败！虽然有700KB空闲，但最大连续块只有400KB

外部碎片：300KB（虽然空闲但不可用）
```

**2. 动态内存分配的外部碎片**

在堆内存管理中，频繁的malloc/free会产生外部碎片。

**示例（时间序列）**
```
1. 分配A(100)  [AAAA][░░░░░░░░░░░]
2. 分配B(200)  [AAAA][BBBBBBBB][░░]
3. 分配C(100)  [AAAA][BBBBBBBB][CC][░]
4. 释放A       [░░░░][BBBBBBBB][CC][░]
5. 释放C       [░░░░][BBBBBBBB][░░][░]

此时：
空闲总量：100 + 100 + 剩余 = 200+
但无法分配150的连续块（最大连续100）
外部碎片导致内存利用率下降
```

**50%规则（Knuth）**
- 理论研究表明，使用首次适应（First Fit）算法
- 如果有N个已分配块，平均有N/2个外部碎片块
- **实际可用内存 ≈ 总内存 × 2/3**

---

### 四、内部碎片 vs 外部碎片对比

| 对比维度 | 内部碎片 | 外部碎片 |
|---------|---------|---------|
| **定义** | 分配单元内部未使用的空间 | 分配单元之间不连续的空闲块 |
| **位置** | 已分配内存块内部 | 空闲内存区域 |
| **可用性** | 已分配给进程，但未使用 | 虽空闲但因不连续而不可用 |
| **产生场景** | 分页、固定大小分配 | 分段、可变分区 |
| **分页系统** | 有（平均页大小/2） | 无 |
| **分段系统** | 无 | 有 |
| **可否回收** | 不能（已分配给进程） | 可以（通过紧缩） |
| **典型大小** | 较小（字节到KB级） | 可大可小 |
| **计算** | 固定（可预测） | 动态（难预测） |

---

### 五、解决内部碎片的方法

**1. 使用更小的分配单元**
- **小页面**：使用2KB甚至1KB页（但页表会更大）
- **变长页**：支持多种页大小（4KB、2MB、1GB）
- Linux的Huge Pages机制，减少页表同时接受更大内部碎片

**2. 变长分配**
- 按实际需求分配，而非固定大小块
- 如slab分配器，针对不同对象大小使用不同slab

**3. 伙伴系统（Buddy System）改进**
- Linux使用的内存分配算法
- 按2的幂次分配（1KB、2KB、4KB...）
- 平衡了内部碎片和外部碎片

**4. 紧凑数据结构**
- 去除结构体中的填充字节
- 使用`__attribute__((packed))`（GCC）
- 权衡：可能影响访问性能

**5. 内存池技术**
- 预分配固定大小对象池
- 避免频繁分配释放
- 适用于对象大小固定的场景（如网络连接）

---

### 六、解决外部碎片的方法

**1. 内存紧缩（Compaction）**

将所有已分配的内存移动到一端，空闲内存集中到另一端。

**示例**
```
紧缩前:
[AAAA][░░][BBB][░░░][CCC][░░░░░]

紧缩后:
[AAAA][BBB][CCC][░░░░░░░░░░░░░]
                 ↑连续大块空闲
```

**优点**
- 彻底消除外部碎片

**缺点**
- **开销极大**：需复制所有数据
- **需更新指针**：所有指向移动数据的指针需修正
- **停顿时间长**：类似GC的Stop-The-World
- 实际很少使用（除特殊场景如Java GC）

**2. 分页系统**
- **最彻底的方法**：完全避免外部碎片
- 物理内存可以不连续分配
- 通过页表映射为连续虚拟地址
- 现代操作系统的主流选择

**3. 伙伴系统（Buddy System）**

Linux内核使用的内存分配算法，减少但不完全消除外部碎片。

**工作原理**
```
内存按2的幂次分割和合并

初始：[1MB]

分配256KB:
[256KB][░░░░░░░░░░░░░░░░░░░]

分配512KB:
[256KB][512KB][░░░░░]

释放256KB:
[░░░░░][512KB][256KB]

合并相邻伙伴:
[░░░░░░░░░░░░][256KB]
```

**优点**
- 快速分配和释放
- 减少外部碎片（可合并）
- 时间复杂度O(log N)

**缺点**
- 仍有一定内部碎片（按2的幂次分配）

**4. Slab分配器**

Linux内核的对象缓存机制，用于频繁分配相同大小对象。

**核心思想**
- 为特定大小对象维护专用缓存池
- 避免频繁通用分配导致的碎片

**结构**
```
Cache (如inode缓存)
  ↓
Slab (多个页的集合)
  ↓
Objects (相同大小的对象)
```

**优点**
- 几乎无外部碎片
- 分配/释放快速
- 对象重用（无需初始化）

**5. 分段 + 分页结合**
- 逻辑上分段（符合程序结构）
- 物理上分页（避免外部碎片）
- 现代x86架构的做法

**6. 最佳适应、首次适应、最坏适应算法**

选择合适的空闲块分配策略。

| 算法 | 策略 | 优点 | 缺点 |
|------|------|------|------|
| **首次适应(First Fit)** | 第一个足够大的块 | 快速 | 前端碎片多 |
| **最佳适应(Best Fit)** | 最小的足够块 | 减少浪费 | 产生大量小碎片 |
| **最坏适应(Worst Fit)** | 最大的块 | 剩余块较大 | 大块快速消耗 |
| **邻近适应(Next Fit)** | 上次位置继续找 | 分散碎片 | 命中率低 |

---

### 七、实际系统案例

**Linux内核内存管理**

```
物理内存分配（多层次）:
+---------------------------+
| Buddy System (页框分配)    | ← 减少外部碎片，按2^n页分配
+---------------------------+
        ↓
+---------------------------+
| Slab/Slub (对象分配)       | ← 避免碎片，缓存固定大小对象
+---------------------------+
        ↓
+---------------------------+
| kmalloc/vmalloc (通用)    | ← 用户接口
+---------------------------+
```

**查看碎片情况**
```bash
# 查看内存碎片指数（0-1000，越高越碎片化）
cat /proc/buddyinfo
cat /sys/kernel/debug/extfrag/extfrag_index

# 触发内存紧缩
echo 1 > /proc/sys/vm/compact_memory
```

**Java虚拟机（JVM）**
- 新生代：复制算法（无碎片）
- 老年代：标记-整理（定期紧缩）
- G1 GC：分区管理，增量紧缩

**数据库系统**
- MySQL InnoDB：页式管理（16KB页）
- 有内部碎片，定期需`OPTIMIZE TABLE`重组

---

### 八、面试回答策略

**简洁版本**（2分钟）
"内存碎片分为内部碎片和外部碎片两种。

**内部碎片**是分配给进程但未使用的内存，典型场景是分页系统中最后一页未填满的部分，平均浪费半个页大小。解决方法是使用更小的页或变长分配。

**外部碎片**是空闲内存因不连续而无法使用，常见于分段系统或动态内存分配。比如有3个100KB的空闲块，但都不连续，就无法分配200KB。解决方法包括内存紧缩（开销大）、使用分页系统（彻底避免）、或伙伴系统（减少碎片）。

现代操作系统通常用分页避免外部碎片，用小页或多级分配减少内部碎片。Linux的伙伴系统+Slab是典型实现。"

**深入版本**（5分钟）
在简洁版基础上，可以展开：
1. **定量分析**：内部碎片平均浪费页大小/2，外部碎片50%规则
2. **具体算法**：详细讲解伙伴系统或Slab的工作原理
3. **实际案例**：Linux内核的多层内存管理架构
4. **性能权衡**：内存紧缩的开销、页大小选择的平衡
5. **碎片检测**：/proc/buddyinfo等工具

**追问应对**
- "如何量化内存碎片？"→ 内部碎片可计算（平均页大小/2），外部碎片用碎片指数（最大可分配块/总空闲）
- "为什么现在都用分页？"→ 彻底避免外部碎片，只有可控的内部碎片
- "伙伴系统如何工作？"→ 详细说明2的幂次分割和合并过程
- "内存紧缩为什么少用？"→ 开销大、需停顿、指针修正复杂，只在GC等场景使用
- "如何检测系统碎片？"→ Linux用buddyinfo、extfrag_index；应用层监控分配失败率
- "大页如何影响碎片？"→ 减少页表同时增加内部碎片，适合大内存应用
