---
title: 进程调度的抢占式和非抢占式调度对比
tags:
  - 操作系统
status: robot
class: 操作系统
slug: preemptive-vs-non-preemptive-process-scheduling
ref:
---

## 核心要点

**抢占式调度**：操作系统可以主动中断正在运行的进程，强制切换到其他进程，提供更好的响应性和公平性，适用于交互式系统。

**非抢占式调度**：进程必须主动让出 CPU 控制权，系统开销较小但可能导致不公平，适用于批处理和特定实时系统。

## 详细对比分析

### 1. 基本概念

**抢占式调度（Preemptive Scheduling）**
- 定义：操作系统可以在进程运行过程中强制剥夺其 CPU 使用权
- 触发条件：时间片耗尽、高优先级进程到达、中断发生等
- 控制权：操作系统完全控制 CPU 分配

**非抢占式调度（Non-preemptive Scheduling）**
- 定义：进程一旦获得 CPU，必须主动释放才能被其他进程使用
- 触发条件：进程完成、阻塞（I/O 等待）、主动 yield
- 控制权：进程自主决定何时释放 CPU

### 2. 核心差异对比

| 特性 | 抢占式调度 | 非抢占式调度 |
|------|-----------|-------------|
| CPU 控制权 | 系统强制收回 | 进程主动释放 |
| 响应时间 | 快速响应，实时性好 | 可能响应慢 |
| 公平性 | 相对公平 | 可能不公平 |
| 系统开销 | 上下文切换开销大 | 开销相对较小 |
| 复杂度 | 实现复杂 | 实现简单 |
| 死锁风险 | 较低 | 较高（长期占用资源） |

### 3. 实现机制

**抢占式调度的实现**
```c
// 时钟中断处理
void timer_interrupt_handler() {
    current_process->time_slice--;

    if (current_process->time_slice <= 0) {
        // 时间片耗尽，触发调度
        schedule();
    }

    // 检查是否有更高优先级进程
    if (has_higher_priority_process()) {
        schedule();
    }
}

// 调度函数
void schedule() {
    save_context(current_process);  // 保存当前进程上下文

    Process* next = select_next_process();  // 选择下一个进程

    if (next != current_process) {
        context_switch(current_process, next);  // 上下文切换
        current_process = next;
    }

    restore_context(current_process);  // 恢复新进程上下文
}
```

**非抢占式调度的实现**
```c
// 进程主动让出 CPU
void yield() {
    current_process->state = READY;

    Process* next = select_next_process();
    if (next != current_process) {
        context_switch(current_process, next);
        current_process = next;
    }
}

// 进程完成时的调度
void process_exit() {
    current_process->state = TERMINATED;

    Process* next = select_next_process();
    context_switch(current_process, next);
    current_process = next;
}
```

### 4. 优缺点分析

**抢占式调度优点**
1. **响应性好**：能快速响应用户交互和系统事件
2. **公平性强**：防止单个进程长期占用 CPU
3. **多任务支持**：真正实现并发处理
4. **实时性**：适合实时系统要求

**抢占式调度缺点**
1. **开销较大**：频繁的上下文切换
2. **复杂性高**：需要处理中断、同步等问题
3. **缓存污染**：频繁切换可能导致缓存失效

**非抢占式调度优点**
1. **开销较小**：减少上下文切换次数
2. **实现简单**：逻辑清晰，易于理解和实现
3. **缓存友好**：进程运行时间较长，缓存利用率高
4. **确定性强**：适合对执行时间有严格要求的场景

**非抢占式调度缺点**
1. **响应性差**：可能出现长时间无响应
2. **不公平性**：短任务可能长时间等待
3. **死锁风险**：进程可能无限期占用资源

### 5. 应用场景

**抢占式调度适用场景**
- **交互式系统**：桌面操作系统（Windows、Linux、macOS）
- **服务器系统**：Web 服务器、数据库服务器
- **实时系统**：软实时系统，如多媒体处理
- **移动设备**：手机、平板等需要快速响应的设备

**非抢占式调度适用场景**
- **批处理系统**：大数据处理、科学计算
- **嵌入式系统**：简单的单任务或特定用途设备
- **硬实时系统**：部分对确定性要求极高的系统
- **协作式多任务**：早期的 Windows 3.x 系统

### 6. 现代操作系统的混合策略

现代操作系统通常采用混合策略：

**Linux CFS (完全公平调度器)**
```c
// 虚拟运行时间计算
u64 calc_delta_fair(u64 delta, struct sched_entity *se) {
    if (unlikely(se->load.weight != NICE_0_LOAD))
        delta = __calc_delta(delta, NICE_0_LOAD, &se->load);
    return delta;
}

// 抢占检查
static void check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr) {
    unsigned long ideal_runtime, delta_exec;

    ideal_runtime = sched_slice(cfs_rq, curr);
    delta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;

    if (delta_exec > ideal_runtime) {
        resched_curr(rq_of(cfs_rq));  // 触发重新调度
    }
}
```

**Windows 调度策略**
- 使用多级反馈队列
- 结合时间片轮转和优先级调度
- 对不同类型进程采用不同策略

### 7. 性能影响分析

**上下文切换开销对比**
```bash
# 测量上下文切换时间
$ lmbench lat_ctx -s 0 2
"size=0k ovr=2.34
2 2.68

# 抢占式调度的典型切换时间：2-10 微秒
# 非抢占式调度的切换时间：主要取决于进程运行时长
```

**吞吐量与响应时间权衡**
- 抢占式：响应时间优先，可能牺牲一定吞吐量
- 非抢占式：吞吐量优先，可能牺牲响应时间

## 面试重点

1. **理解本质差异**：控制权归属是关键区别
2. **掌握应用场景**：不同场景需要不同策略
3. **了解实现细节**：时钟中断、上下文切换机制
4. **现代系统趋势**：混合策略，动态调整
5. **性能权衡**：响应时间 vs 吞吐量的平衡
