---
title: 页面置换算法（FIFO、LRU、LFU、Clock）
tags:
  - 操作系统
status: robot
class: 操作系统
slug: page-replacement-algorithms-fifo-lru-lfu-clock
ref:
---

## 核心要点

页面置换算法用于决定缺页时淘汰哪个页面。**FIFO**最简单但有Belady异常；**LRU**最优但实现开销大；**LFU**考虑访问频率但对历史敏感；**Clock**是LRU的近似，性能和开销平衡最佳，是实际系统常用算法。

---

## 详细回答

### 一、为什么需要页面置换算法

在虚拟内存系统中：
1. 进程的虚拟地址空间通常远大于物理内存
2. 当访问的页不在物理内存中时，产生**缺页中断（Page Fault）**
3. 操作系统需要从磁盘加载该页到内存
4. 如果内存已满，必须选择一个页面**置换（淘汰）**到磁盘

**目标**：选择合适的页面置换，最小化缺页率（Page Fault Rate）

### 二、理想算法：OPT（最优置换算法）

**原理**
- 淘汰**未来最长时间不会被访问**的页面
- 理论上能达到最低的缺页率

**问题**
- 需要预知未来的页面访问序列，实际中无法实现
- 仅用于理论研究和作为其他算法的性能上界

**示例**
```
访问序列: 1 2 3 4 1 2 5 1 2 3 4 5
物理页框数: 3

时刻:  1  2  3  4  1  2  5  1  2  3  4  5
页框1: 1  1  1  4  4  4  4  4  4  3  3  3
页框2:    2  2  2  2  2  2  2  2  2  4  4
页框3:       3  3  3  3  5  5  5  5  5  5
缺页:  ✓  ✓  ✓  ✓           ✓           ✓  ✓
缺页次数: 7
```

---

### 三、FIFO（先进先出）

**原理**
- 淘汰**最早进入内存**的页面
- 用队列实现，新页面从队尾加入，淘汰时从队首移除

**优点**
- 实现简单，只需维护一个队列
- 逻辑清晰易懂

**缺点**
1. **性能差**：最早进入的页面可能是经常使用的（如代码段），不应该被淘汰
2. **Belady异常**：增加物理页框数，缺页率反而增加（违反直觉）

**Belady异常示例**
```
访问序列: 1 2 3 4 1 2 5 1 2 3 4 5

3个页框:
时刻:  1  2  3  4  1  2  5  1  2  3  4  5
页框1: 1  1  1  4  4  4  5  5  5  3  3  3
页框2:    2  2  2  1  1  1  1  1  1  4  4
页框3:       3  3  3  2  2  2  2  2  2  5
缺页:  ✓  ✓  ✓  ✓  ✓  ✓  ✓        ✓  ✓  ✓
缺页次数: 9

4个页框:
页框1: 1  1  1  1  1  1  5  5  5  5  4  4
页框2:    2  2  2  2  2  2  2  2  2  2  5
页框3:       3  3  3  3  3  3  3  3  3  3
页框4:          4  4  4  4  1  1  1  1  1
缺页:  ✓  ✓  ✓  ✓        ✓  ✓  ✓     ✓  ✓
缺页次数: 10 (反而增加!)
```

**实现代码（伪代码）**
```python
class FIFO:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = []  # 存储页号的队列
        self.page_set = set()  # 快速查找

    def access(self, page):
        if page in self.page_set:
            return False  # 命中，无缺页

        # 缺页处理
        if len(self.queue) >= self.capacity:
            removed = self.queue.pop(0)  # 淘汰队首
            self.page_set.remove(removed)

        self.queue.append(page)
        self.page_set.add(page)
        return True  # 缺页
```

---

### 四、LRU（Least Recently Used，最近最少使用）

**原理**
- 淘汰**最长时间未被访问**的页面
- 基于**局部性原理**：最近使用的页面，近期可能再次使用

**优点**
- 性能接近OPT，是实际可用的最优算法之一
- 符合程序的局部性特征

**缺点**
- **实现开销大**：需要记录每个页面的访问时间或维护访问顺序
- 硬件支持不足时，软件实现性能差

**实现方式**

**方法1：时间戳**
- 每次访问时记录时间戳
- 置换时遍历所有页面，选择时间戳最小的
- 时间复杂度：O(n)

**方法2：双向链表 + 哈希表**（常用）
- 双向链表维护访问顺序（最近使用在链表头）
- 哈希表快速定位节点
- 访问和置换都是O(1)

**实现代码**
```python
class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # 页号 -> 链表节点
        self.head = Node(0)  # 哨兵头节点
        self.tail = Node(0)  # 哨兵尾节点
        self.head.next = self.tail
        self.tail.prev = self.head

    def access(self, page):
        if page in self.cache:
            # 命中，移到链表头
            node = self.cache[page]
            self._remove(node)
            self._add_to_head(node)
            return False  # 无缺页

        # 缺页处理
        if len(self.cache) >= self.capacity:
            # 淘汰链表尾（最久未使用）
            removed = self.tail.prev
            self._remove(removed)
            del self.cache[removed.key]

        # 添加新页到链表头
        new_node = Node(page)
        self._add_to_head(new_node)
        self.cache[page] = new_node
        return True  # 缺页

    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add_to_head(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node
```

**执行示例**
```
访问序列: 1 2 3 4 1 2 5 1 2 3 4 5
物理页框数: 3

时刻:  1  2  3  4  1  2  5  1  2  3  4  5
页框1: 1  2  3  4  4  2  5  5  2  3  4  4
页框2:    1  2  3  1  1  1  1  1  1  3  3
页框3:       1  2  2  4  2  2  5  2  2  5
缺页:  ✓  ✓  ✓  ✓           ✓        ✓  ✓
缺页次数: 7
```

---

### 五、LFU（Least Frequently Used，最不经常使用）

**原理**
- 淘汰**访问次数最少**的页面
- 如果有多个页面访问次数相同，淘汰最久未访问的

**优点**
- 考虑了访问频率，对热点数据友好

**缺点**
1. **历史包袱**：早期频繁访问的页面即使后期不再使用，也很难被淘汰
2. **实现复杂**：需要维护访问计数器和优先队列
3. **新页面劣势**：新加入的页面访问次数少，容易被淘汰

**改进：LFU with Aging**
- 定期对所有页面的访问次数进行衰减（右移或减半）
- 降低历史数据的影响

**实现代码**
```python
class LFUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # 页号 -> (频率, 时间戳)
        self.min_freq = 0
        self.freq_map = {}  # 频率 -> 页号列表
        self.time = 0

    def access(self, page):
        self.time += 1

        if page in self.cache:
            # 命中，更新频率
            freq, _ = self.cache[page]
            self.freq_map[freq].remove(page)
            if not self.freq_map[freq] and freq == self.min_freq:
                self.min_freq += 1

            self.cache[page] = (freq + 1, self.time)
            self.freq_map.setdefault(freq + 1, []).append(page)
            return False

        # 缺页处理
        if len(self.cache) >= self.capacity:
            # 淘汰最小频率中最久未访问的
            evict = self.freq_map[self.min_freq].pop(0)
            del self.cache[evict]

        self.cache[page] = (1, self.time)
        self.freq_map.setdefault(1, []).append(page)
        self.min_freq = 1
        return True
```

---

### 六、Clock（时钟算法 / 二次机会算法）

**原理**
- LRU的近似实现，用**访问位（Reference Bit）**硬件支持
- 页面组织成环形链表（时钟），指针指向当前位置
- 每个页面有访问位：1表示最近访问过，0表示未访问

**置换过程**
1. 检查指针当前页面的访问位
2. 如果是1，置为0，指针前进，给该页第二次机会
3. 如果是0，淘汰该页，加载新页
4. 重复直到找到访问位为0的页

**优点**
- 实现简单，只需1位访问位（硬件支持）
- 性能接近LRU
- 无需维护复杂数据结构

**缺点**
- 最坏情况下需遍历所有页面（所有访问位都是1）

**执行示例**
```
访问序列: 1 2 3 4 1 2 5
物理页框数: 3

初始状态（所有访问位=0）:
[1,0] -> [2,0] -> [3,0] -> (循环)
 ↑指针

访问4（缺页）:
[1,0] -> [2,0] -> [3,0]  检查1的访问位=0，淘汰1
替换后:
[4,0] -> [2,0] -> [3,0]
         ↑指针移到下一位

访问1（缺页）:
[4,0] -> [2,0] -> [3,0]  检查2的访问位=0，淘汰2
替换后:
[4,0] -> [1,0] -> [3,0]
                  ↑

访问2（缺页）:
[4,0] -> [1,0] -> [3,0]  检查3的访问位=0，淘汰3
替换后:
[4,0] -> [1,0] -> [2,0]
 ↑

访问5（缺页）:
访问1后访问位变为1: [4,0] -> [1,1] -> [2,0]
检查4访问位=0，淘汰4
[5,0] -> [1,1] -> [2,0]
         ↑
```

**实现代码**
```python
class ClockCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.pages = []  # [(页号, 访问位)]
        self.pointer = 0

    def access(self, page):
        # 检查是否命中
        for i, (p, _) in enumerate(self.pages):
            if p == page:
                self.pages[i] = (page, 1)  # 设置访问位
                return False

        # 缺页处理
        if len(self.pages) < self.capacity:
            self.pages.append((page, 0))
            return True

        # 使用Clock算法淘汰
        while True:
            p, ref_bit = self.pages[self.pointer]
            if ref_bit == 0:
                # 淘汰该页
                self.pages[self.pointer] = (page, 0)
                self.pointer = (self.pointer + 1) % self.capacity
                return True
            else:
                # 给第二次机会
                self.pages[self.pointer] = (p, 0)
                self.pointer = (self.pointer + 1) % self.capacity
```

**改进版：Enhanced Clock（增强时钟算法）**
- 使用访问位 + 修改位（Dirty Bit）
- 优先级（从高到低）：
  1. (访问=0, 修改=0) - 最优，未访问且未修改
  2. (访问=0, 修改=1) - 次优，未访问但已修改
  3. (访问=1, 修改=0) - 最近访问但未修改
  4. (访问=1, 修改=1) - 最差，最近访问且已修改

---

### 七、算法对比总结

| 算法 | 缺页率 | 实现复杂度 | 硬件支持 | 实际应用 |
|------|--------|-----------|---------|---------|
| **OPT** | 最低（理论最优） | 无法实现 | - | 仅理论研究 |
| **FIFO** | 高（有Belady异常） | 极简单 | 不需要 | 几乎不用 |
| **LRU** | 低（接近OPT） | 复杂（需链表+哈希） | 时间戳/访问序列 | 数据库缓存、CPU缓存 |
| **LFU** | 中（对历史敏感） | 复杂（需计数器） | 计数器 | 特定场景（CDN缓存） |
| **Clock** | 低（接近LRU） | 简单 | 1位访问位 | **Linux、Windows等OS** |

---

### 八、实际系统应用

**Linux内核**
- 使用改进的Clock算法（Second Chance）
- 维护活跃链表（active list）和非活跃链表（inactive list）
- 结合LRU思想，通过双链表管理页面

**数据库系统（如MySQL）**
- Buffer Pool使用改进的LRU算法
- 解决全表扫描问题：防止大量临时数据淘汰热点数据
- 使用分段LRU（如5/8分割点），新页插入中间位置而非头部

**CPU缓存**
- L1/L2/L3缓存使用LRU或伪LRU（Pseudo-LRU）
- 硬件实现，访问速度要求极高

---

### 九、面试回答策略

**简洁版本**（2分钟）
"页面置换算法用于缺页时选择淘汰哪个页面。常见的有四种：

1. **FIFO**最简单，淘汰最早进入的页面，但性能差且有Belady异常
2. **LRU**淘汰最久未使用的页面，性能好但实现复杂，需要链表和哈希表
3. **LFU**淘汰访问次数最少的页面，对历史数据过于敏感
4. **Clock**是LRU的近似，用访问位实现，简单高效，Linux等操作系统实际采用

选择时需平衡性能和实现成本，Clock算法是工程实践的最佳选择。"

**深入版本**（5分钟）
在简洁版基础上，可以展开：
1. 详细描述一个算法的执行过程（建议选Clock，展示二次机会机制）
2. 对比缺页率和实现复杂度（用表格）
3. 举实际系统例子（Linux的active/inactive list、MySQL的改进LRU）
4. 提及硬件支持的重要性（访问位、修改位）

**追问应对**
- "为什么Linux用Clock而不用LRU？"→ 硬件只提供访问位，LRU需要额外的访问顺序记录，开销大
- "如何优化LRU？"→ 分段LRU、LRU-K（考虑倒数第K次访问时间）
- "什么是Belady异常？"→ 给出FIFO的具体例子，说明增加页框反而增加缺页
- "如何实现LRU的O(1)操作？"→ 详细说明双向链表+哈希表的数据结构
