---
title: 死锁的四个必要条件和预防方法
tags:
  - 操作系统
  - 死锁
status: robot
class: 操作系统
slug: deadlock-conditions-prevention-methods
ref:
---

## 核心要点

- **死锁的四个必要条件（Coffman条件）：互斥、占有并等待、不可剥夺、循环等待**
- **破坏任一条件即可预防死锁**
- **死锁预防、避免、检测与恢复是三种不同的处理策略**
- **实际应用：资源有序分配、超时机制、死锁检测算法**

---

## 详细回答

### 一、什么是死锁？

**死锁（Deadlock）** 是指两个或多个进程/线程在执行过程中，因争夺资源而造成的一种**互相等待**的现象。若无外力干涉，它们将永远无法继续执行。

**经典例子：哲学家就餐问题**

```
5位哲学家围坐在圆桌旁，每人面前有一盘意大利面。
相邻两人之间有一根筷子（共5根）。
每位哲学家需要同时拿到左右两根筷子才能进餐。

死锁场景：
1. 所有哲学家同时拿起左边的筷子
2. 所有哲学家尝试拿右边的筷子（被右边的人占用）
3. 所有人永远等待，形成死锁

   P1 ---筷子1--- P2 ---筷子2--- P3 ---筷子3--- P4 ---筷子4--- P5
   ↑                                                            |
   |                          筷子5                             |
   └------------------------------------------------------------┘
   （每个人持有一根筷子，等待另一根，形成环）
```

**代码示例：双锁死锁**

```go
var (
    mu1 sync.Mutex
    mu2 sync.Mutex
)

// 线程1
func thread1() {
    mu1.Lock()
    fmt.Println("Thread1: 获取mu1")
    time.Sleep(100 * time.Millisecond)  // 模拟处理
    mu2.Lock()  // 等待mu2（被thread2持有）
    fmt.Println("Thread1: 获取mu2")
    mu2.Unlock()
    mu1.Unlock()
}

// 线程2
func thread2() {
    mu2.Lock()
    fmt.Println("Thread2: 获取mu2")
    time.Sleep(100 * time.Millisecond)
    mu1.Lock()  // 等待mu1（被thread1持有）
    fmt.Println("Thread2: 获取mu1")
    mu1.Unlock()
    mu2.Unlock()
}

// 执行结果：
// Thread1: 获取mu1
// Thread2: 获取mu2
// [程序卡死，死锁发生]
```

---

### 二、死锁的四个必要条件（Coffman条件）

死锁的发生**必须同时满足**以下四个条件，缺一不可：

#### 1. 互斥条件（Mutual Exclusion）

**定义：** 资源在同一时刻只能被一个进程/线程占用。

**解释：**
- 如果资源可以共享（如只读文件），就不会产生死锁
- 互斥是资源本身的特性（如打印机、文件写锁、互斥锁）

**示例：**
```go
// 互斥资源：互斥锁
var mu sync.Mutex
mu.Lock()   // 只有一个线程能持有
// 临界区
mu.Unlock()
```

---

#### 2. 占有并等待条件（Hold and Wait）

**定义：** 进程已经持有至少一个资源，同时又在等待获取其他被占用的资源。

**解释：**
- 进程不释放已有资源的情况下等待新资源
- 形成"边占边等"的局面

**示例：**
```go
// 线程持有mu1，等待mu2
mu1.Lock()      // 已持有mu1
// ...处理...
mu2.Lock()      // 等待mu2（但不释放mu1）
// ...
mu2.Unlock()
mu1.Unlock()
```

**资源分配图：**
```
进程P1 → 持有资源R1 → 等待资源R2（被P2持有）
进程P2 → 持有资源R2 → 等待资源R1（被P1持有）
```

---

#### 3. 不可剥夺条件（No Preemption）

**定义：** 进程已获得的资源，在未使用完之前，不能被强制剥夺，只能由进程自己释放。

**解释：**
- 操作系统不能强制进程放弃资源
- 资源只能由占有者主动释放

**对比：**
- **不可剥夺资源**：互斥锁、打印机（可能死锁）
- **可剥夺资源**：CPU时间片（操作系统可抢占，不会死锁）

**示例（不可剥夺）：**
```go
mu.Lock()
// 其他线程无法强制让当前线程释放mu
// 只能等待当前线程调用Unlock()
mu.Unlock()
```

---

#### 4. 循环等待条件（Circular Wait）

**定义：** 存在一个进程集合 {P0, P1, ..., Pn}，其中P0等待P1占有的资源，P1等待P2占有的资源，...，Pn等待P0占有的资源，形成循环链。

**解释：**
- 等待关系形成**有向环**
- 这是死锁的直接表现

**资源分配图（有向环）：**

```
进程P1 → 等待资源R2
           ↑
           | 持有
           |
进程P2 → 等待资源R1
           ↑
           | 持有
           |
         (P1)  ← 形成环
```

**代码示例：**
```go
// 3个线程形成循环等待
// 线程1: 持有A，等待B
// 线程2: 持有B，等待C
// 线程3: 持有C，等待A
// 形成环：A → B → C → A
```

---

### 三、死锁预防（Prevention）

**核心思想：** 破坏死锁的四个必要条件之一，使死锁不可能发生。

#### 方法1：破坏互斥条件（不可行）

**理论：** 让资源可共享，取消互斥。

**现实困难：**
- 许多资源本质上必须互斥（如打印机、文件写锁）
- 无法通用应用

**少数可行场景：**
```go
// 将独占资源改为只读共享
var rwLock sync.RWMutex

// 多个读者可同时访问（破坏互斥）
rwLock.RLock()
data := readOnlyResource
rwLock.RUnlock()
```

---

#### 方法2：破坏占有并等待条件

**策略A：一次性分配所有资源**

```go
// 方案：在开始时获取所有锁，要么全拿到，要么全不拿
func transfer(from, to *Account, amount int) {
    // 一次性获取两个锁（原子操作）
    lockAll(from.mu, to.mu)
    defer unlockAll(from.mu, to.mu)

    from.balance -= amount
    to.balance += amount
}

// 伪代码实现
func lockAll(locks ...sync.Locker) {
    for {
        success := tryLockAll(locks...)
        if success {
            return
        }
        // 失败则释放所有已获取的锁，稍后重试
        unlockAll(locks...)
        time.Sleep(1 * time.Millisecond)
    }
}
```

**优点：** 彻底避免死锁
**缺点：** 资源利用率低（可能长时间持有不需要的资源）

---

**策略B：先释放已有资源再申请**

```go
func processWithRetry() {
    mu1.Lock()
    // 尝试获取mu2
    if !mu2.TryLock() {
        // 获取失败，释放mu1，稍后重试
        mu1.Unlock()
        time.Sleep(10 * time.Millisecond)
        processWithRetry()  // 重试
        return
    }
    // 成功获取两个锁
    defer mu2.Unlock()
    defer mu1.Unlock()
    // 临界区
}
```

**缺点：** 可能导致活锁（多个进程反复重试，谁都无法成功）

---

#### 方法3：破坏不可剥夺条件

**策略：允许抢占资源**

**实现方式（带超时的锁）：**

```go
// 使用context实现超时剥夺
func lockWithTimeout(mu *sync.Mutex, timeout time.Duration) bool {
    ch := make(chan struct{})
    go func() {
        mu.Lock()
        close(ch)
    }()

    select {
    case <-ch:
        return true  // 成功获取锁
    case <-time.After(timeout):
        return false  // 超时，放弃（相当于被剥夺）
    }
}

func process() {
    if lockWithTimeout(&mu1, 1*time.Second) {
        defer mu1.Unlock()
        if lockWithTimeout(&mu2, 1*time.Second) {
            defer mu2.Unlock()
            // 临界区
        } else {
            // 获取mu2超时，释放mu1重试
        }
    }
}
```

**数据库中的应用：**
- 事务等待锁超时后自动回滚（释放已有资源）
- MySQL的`innodb_lock_wait_timeout`参数

---

#### 方法4：破坏循环等待条件（最常用）

**策略：资源有序分配**

对所有资源进行全局编号，进程必须按**递增顺序**申请资源。

**实现示例：**

```go
// 给所有锁分配唯一ID
var (
    mu1 = &LockWithID{id: 1}
    mu2 = &LockWithID{id: 2}
    mu3 = &LockWithID{id: 3}
)

// 按ID顺序加锁
func lockInOrder(locks ...*LockWithID) {
    // 排序（按ID递增）
    sort.Slice(locks, func(i, j int) bool {
        return locks[i].id < locks[j].id
    })
    // 按顺序加锁
    for _, lock := range locks {
        lock.Lock()
    }
}

// 使用
func transfer(from, to *Account, amount int) {
    // 无论调用顺序如何，都按ID顺序加锁
    lockInOrder(from.mu, to.mu)
    defer unlockAll(from.mu, to.mu)

    from.balance -= amount
    to.balance += amount
}

// 所有线程都按 mu1 → mu2 → mu3 顺序获取
// 不会形成环，死锁不可能发生
```

**原理：**
```
线程1: 按顺序 mu1 → mu2
线程2: 按顺序 mu1 → mu2
不会出现：线程1持有mu2等mu1，线程2持有mu1等mu2的情况
```

**现实应用：**
- Linux内核的锁顺序规则
- 数据库的资源ID排序

---

### 四、死锁避免（Avoidance）

**核心思想：** 动态检查资源分配状态，只在**安全状态**下分配资源。

**代表算法：银行家算法（Banker's Algorithm）**

**关键概念：安全状态**
- 存在一个进程执行序列，使得每个进程都能获得所需资源并完成
- 如果分配资源后系统进入**不安全状态**（可能死锁），则拒绝分配

**示例（简化版）：**

```
系统资源总量：10个资源单位
当前状态：
进程P1: 已分配3，最多需要7（还需4）
进程P2: 已分配2，最多需要5（还需3）
可用资源：5

分析：
1. 先满足P2（需要3，可用5）→ P2完成释放2+3=5
2. 可用变为5+5=10，满足P1（需要4）→ P1完成
结论：安全状态，可以分配

若有P3请求6个资源：
可用5 < 6，且分配后可用=0，P1需要4、P2需要3都无法满足
结论：不安全状态，拒绝分配
```

**缺点：**
- 需要提前知道进程的最大资源需求（不现实）
- 计算开销大
- 资源利用率可能不高

---

### 五、死锁检测与恢复（Detection & Recovery）

**策略：** 允许死锁发生，但定期检测，发现后采取恢复措施。

#### 检测算法：资源分配图化简

**步骤：**
1. 构建资源分配图（进程→资源、资源→进程）
2. 找到一个**未阻塞**的进程（可以继续执行）
3. 释放该进程持有的资源
4. 重复步骤2-3，直到所有进程完成或无法继续
5. 若还有进程无法完成，则存在死锁

**示例：**

```
初始状态：
P1 → 持有R1 → 等待R2
P2 → 持有R2 → 等待R1

检测步骤：
1. 寻找未阻塞进程：无（P1等R2，P2等R1）
2. 无法化简，检测到死锁：P1-P2形成环
```

**Go语言检测示例（简化）：**

```go
// 记录锁的依赖关系
var lockGraph = make(map[string][]string)

func detectDeadlock() bool {
    // 检测是否存在环（DFS或拓扑排序）
    visited := make(map[string]bool)
    recStack := make(map[string]bool)

    for node := range lockGraph {
        if hasCycle(node, visited, recStack) {
            return true  // 检测到死锁
        }
    }
    return false
}

func hasCycle(node string, visited, recStack map[string]bool) bool {
    visited[node] = true
    recStack[node] = true

    for _, neighbor := range lockGraph[node] {
        if !visited[neighbor] {
            if hasCycle(neighbor, visited, recStack) {
                return true
            }
        } else if recStack[neighbor] {
            return true  // 发现环
        }
    }

    recStack[node] = false
    return false
}
```

#### 恢复方法

**方法1：终止进程**
- 终止所有死锁进程（简单粗暴）
- 逐个终止进程直到解除死锁（最小代价）

**方法2：资源抢占**
- 从某些进程夺取资源分配给其他进程
- 需要回滚被抢占进程的状态

**方法3：进程回退**
- 将部分进程回退到安全状态
- 重新分配资源

**实际应用：**
- 数据库死锁检测（MySQL InnoDB）
  ```sql
  -- MySQL自动检测死锁并回滚其中一个事务
  SHOW ENGINE INNODB STATUS;  -- 查看死锁日志
  ```

- Go的死锁检测器
  ```bash
  # 运行时检测死锁（所有goroutine阻塞）
  fatal error: all goroutines are asleep - deadlock!
  ```

---

### 六、实际应用场景与最佳实践

#### 场景1：数据库事务

**问题：** 事务T1和T2互相等待对方持有的行锁。

**解决方案：**
1. **资源有序**：按主键顺序更新行
   ```sql
   -- 错误：可能死锁
   T1: UPDATE ... WHERE id=10; UPDATE ... WHERE id=5;
   T2: UPDATE ... WHERE id=5;  UPDATE ... WHERE id=10;

   -- 正确：按ID顺序
   T1: UPDATE ... WHERE id IN (5, 10) ORDER BY id;
   T2: UPDATE ... WHERE id IN (5, 10) ORDER BY id;
   ```

2. **超时机制**：设置锁等待超时
   ```sql
   SET innodb_lock_wait_timeout = 5;
   ```

3. **死锁检测**：InnoDB自动检测并回滚代价小的事务

---

#### 场景2：分布式锁

**问题：** 多个微服务竞争Redis锁。

**解决方案：**
1. **设置过期时间**（破坏不可剥夺）
   ```go
   // 锁自动过期，避免永久持有
   redis.Set(ctx, "lock:order", "value", 30*time.Second)
   ```

2. **Redlock算法**：多数派获取锁，容忍部分节点故障

---

#### 场景3：多线程转账

**问题：** 转账时对两个账户加锁，可能死锁。

**解决方案：按账户ID排序加锁**

```go
func transfer(from, to *Account, amount int) error {
    // 按账户ID排序，破坏循环等待
    first, second := from, to
    if from.ID > to.ID {
        first, second = to, from
    }

    first.mu.Lock()
    defer first.mu.Unlock()

    second.mu.Lock()
    defer second.mu.Unlock()

    if from.balance < amount {
        return errors.New("余额不足")
    }
    from.balance -= amount
    to.balance += amount
    return nil
}
```

---

### 七、死锁处理策略对比

| 策略 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **预防** | 彻底避免死锁 | 资源利用率低、限制多 | 对可靠性要求极高的系统 |
| **避免** | 动态灵活 | 需提前知道资源需求、开销大 | 资源需求可预测的批处理系统 |
| **检测与恢复** | 资源利用率高 | 检测开销、恢复复杂 | 死锁频率低的交互系统 |
| **鸵鸟策略** | 无开销 | 死锁时系统失效 | 死锁极少发生的个人电脑 |

**现实选择：**
- **Linux/Windows**：主要使用预防（资源有序）+ 鸵鸟策略
- **数据库**：检测与恢复（InnoDB死锁检测）
- **实时系统**：预防（静态资源分配）

---

### 八、面试高频追问

#### Q1："如何判断系统是否发生死锁？"
**答：**
1. **症状**：所有相关进程/线程都阻塞，无法继续执行
2. **检测方法**：
   - 构建资源分配图，检测是否存在环
   - 使用死锁检测算法（如银行家算法的检测版本）
   - 工具：`jstack`（Java）、`gdb`（C/C++）、`pprof`（Go）

#### Q2："为什么按顺序加锁能避免死锁？"
**答：**
按顺序加锁破坏了**循环等待条件**。如果所有线程都按ID从小到大获取锁：
- 持有锁ID=2的线程，绝不会去等待ID=1的锁（已经获取或不需要）
- 不可能形成"A等B，B等A"的环
- 数学上，有向边都是从小ID指向大ID，不可能有环

#### Q3："活锁和死锁有什么区别？"
**答：**
- **死锁**：进程都阻塞，不消耗CPU，等待资源
- **活锁**：进程都在运行（不断重试），消耗CPU，但没有进展
- 例子：两人在走廊相遇，都向左让 → 都向右让 → 反复横跳，谁都过不去

---

### 九、总结

**死锁的本质：** 资源竞争 + 循环依赖

**四个必要条件记忆口诀：**
- **互**不相让（互斥）
- **占**着茅坑不拉屎（占有并等待）
- **不**给就不给（不可剥夺）
- **循**环往复（循环等待）

**预防死锁的关键：**
1. **资源有序分配**（最实用，破坏循环等待）
2. **一次性分配**（破坏占有并等待）
3. **超时回退**（破坏不可剥夺）

**工程实践建议：**
1. 优先使用无锁数据结构（atomic操作）
2. 锁的粒度尽可能小
3. 避免嵌套锁（减少复杂度）
4. 使用成熟的并发工具（channel、信号量）
5. 充分测试并发场景（压测、混沌工程）

死锁是并发编程的核心难题，理解其本质和预防方法对写出健壮的多线程程序至关重要。
