---
title: 线程同步的几种方式（互斥锁、信号量、条件变量）
tags:
  - 操作系统
status: robot
class: 操作系统
slug: thread-sync-methods-mutex-semaphore-condition-variable
ref:
---

## 核心要点

- **互斥锁(Mutex)：保证同一时刻只有一个线程访问临界区，解决竞态条件**
- **读写锁(RWLock)：允许多个读者或单个写者，提升读多写少场景性能**
- **信号量(Semaphore)：控制多个线程对有限资源的访问，可用作计数器**
- **条件变量(Condition Variable)：线程间的通知机制，配合互斥锁实现等待/唤醒**
- **自旋锁(Spinlock)：忙等待锁，适合临界区极短的场景**

---

## 详细回答

### 一、为什么需要线程同步？

由于多线程共享进程的地址空间，对共享资源的并发访问会导致**竞态条件（Race Condition）**，产生不可预期的结果。

**经典问题示例：银行账户转账**

```go
var balance = 1000  // 账户余额

// 线程1和线程2同时执行
func withdraw(amount int) {
    if balance >= amount {        // ① 检查余额
        time.Sleep(1 * time.Millisecond)  // 模拟延迟
        balance -= amount         // ② 扣款
        fmt.Printf("取出%d，余额%d\n", amount, balance)
    }
}

// 线程1: withdraw(600)
// 线程2: withdraw(600)
```

**执行时序分析（无锁）：**

```
时刻    线程1              线程2              balance
t0                                           1000
t1     检查: 1000>=600
t2                        检查: 1000>=600
t3     扣款: 1000-600=400
t4                        扣款: 1000-600=400  400（错误！）
```

最终余额400，但实际应该是-200（透支）或者有一个线程取款失败。这就是竞态条件导致的数据不一致。

**线程同步的核心目标：**
1. **互斥访问（Mutual Exclusion）**：同一时刻只有一个线程访问临界区
2. **顺序控制（Synchronization）**：控制线程执行的先后顺序
3. **可见性保证（Visibility）**：一个线程的修改对其他线程可见

---

### 二、五大同步机制详解

#### 1. 互斥锁（Mutex）

**原理：**
- Mutex = Mutual Exclusion（互斥）
- 任意时刻只有一个线程持有锁
- 其他线程尝试获取锁时会阻塞，直到锁被释放

**核心操作：**
- `lock()`：获取锁（如果已被占用则阻塞）
- `unlock()`：释放锁（唤醒等待的线程）

**Go语言实现：**

```go
import "sync"

var (
    balance = 1000
    mu      sync.Mutex  // 互斥锁
)

func withdraw(amount int) {
    mu.Lock()  // 加锁
    defer mu.Unlock()  // 确保解锁

    if balance >= amount {
        balance -= amount
        fmt.Printf("取出%d，余额%d\n", amount, balance)
    } else {
        fmt.Println("余额不足")
    }
}
```

**执行时序（有锁）：**

```
时刻    线程1              线程2              balance
t0                                           1000
t1     获取锁成功
t2                        尝试获取锁（阻塞）
t3     检查: 1000>=600
t4     扣款: 1000-600=400
t5     释放锁              400
t6                        获取锁成功
t7                        检查: 400>=600（失败） 400
```

**C++ POSIX实现：**

```cpp
#include <pthread.h>

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int balance = 1000;

void* withdraw(void* arg) {
    int amount = *(int*)arg;

    pthread_mutex_lock(&lock);  // 加锁

    if (balance >= amount) {
        balance -= amount;
        printf("取出%d，余额%d\n", amount, balance);
    }

    pthread_mutex_unlock(&lock);  // 解锁
    return NULL;
}
```

**互斥锁的性能开销：**
- 加锁/解锁涉及**原子操作**（CAS指令）
- 锁竞争时线程进入**睡眠状态**（上下文切换）
- 典型开销：无竞争时 ~25ns，有竞争时 ~1μs（含上下文切换）

---

#### 2. 读写锁（Read-Write Lock）

**原理：**
- 区分读操作和写操作
- 允许**多个读者同时访问**（共享锁）
- **写者独占访问**（排他锁）
- 读者和写者互斥

**适用场景：读多写少**

**Go语言实现：**

```go
import "sync"

var (
    data   = make(map[string]int)
    rwLock sync.RWMutex  // 读写锁
)

// 读操作：允许并发
func read(key string) int {
    rwLock.RLock()         // 读锁
    defer rwLock.RUnlock()
    return data[key]
}

// 写操作：独占访问
func write(key string, value int) {
    rwLock.Lock()          // 写锁
    defer rwLock.Unlock()
    data[key] = value
}
```

**并发示例：**

```
时刻    线程1(读)   线程2(读)   线程3(写)   锁状态
t0     获取读锁                          读锁×1
t1     读数据      获取读锁              读锁×2
t2                 读数据      尝试写锁    读锁×2（线程3阻塞）
t3     释放读锁                          读锁×1
t4                 释放读锁              无锁
t5                            获取写锁    写锁×1
t6                            写数据      写锁×1
t7                            释放写锁    无锁
```

**性能对比（10个线程，90%读操作）：**
- 互斥锁：吞吐量 ~10万次/秒
- 读写锁：吞吐量 ~50万次/秒（提升5倍）

**C++ C++17实现：**

```cpp
#include <shared_mutex>

std::shared_mutex rwLock;
std::map<std::string, int> data;

// 读操作
int read(const std::string& key) {
    std::shared_lock lock(rwLock);  // 共享锁
    return data[key];
}

// 写操作
void write(const std::string& key, int value) {
    std::unique_lock lock(rwLock);  // 独占锁
    data[key] = value;
}
```

---

#### 3. 信号量（Semaphore）

**原理：**
- 本质是一个**计数器**，表示可用资源数量
- 通过**P操作**（wait/减1）和**V操作**（signal/加1）控制访问

**分类：**
- **二值信号量（值0或1）**：等价于互斥锁
- **计数信号量（值≥0）**：控制多个资源的访问

**经典应用：生产者-消费者（有界缓冲区）**

```go
// 使用channel模拟信号量
type Semaphore chan struct{}

func (s Semaphore) P() { s <- struct{}{} }  // 获取资源
func (s Semaphore) V() { <-s }              // 释放资源

var (
    buffer = make([]int, 0, 10)  // 容量10的缓冲区
    mutex  = make(Semaphore, 1)  // 互斥信号量（初始值1）
    empty  = make(Semaphore, 10) // 空槽位信号量（初始值10）
    full   = make(Semaphore, 0)  // 满槽位信号量（初始值0）
)

// 生产者
func producer(item int) {
    empty.P()  // 等待空槽位（-1）
    mutex.P()  // 加锁
    buffer = append(buffer, item)
    fmt.Printf("生产: %d\n", item)
    mutex.V()  // 解锁
    full.V()   // 增加满槽位（+1）
}

// 消费者
func consumer() {
    full.P()   // 等待满槽位（-1）
    mutex.P()  // 加锁
    item := buffer[0]
    buffer = buffer[1:]
    fmt.Printf("消费: %d\n", item)
    mutex.V()  // 解锁
    empty.V()  // 增加空槽位（+1）
}
```

**POSIX信号量实现：**

```c
#include <semaphore.h>

sem_t mutex, empty, full;
int buffer[10];
int count = 0;

void init() {
    sem_init(&mutex, 0, 1);   // 互斥信号量
    sem_init(&empty, 0, 10);  // 空槽位
    sem_init(&full, 0, 0);    // 满槽位
}

void producer(int item) {
    sem_wait(&empty);  // P(empty)
    sem_wait(&mutex);  // P(mutex)

    buffer[count++] = item;

    sem_post(&mutex);  // V(mutex)
    sem_post(&full);   // V(full)
}

void consumer() {
    sem_wait(&full);   // P(full)
    sem_wait(&mutex);  // P(mutex)

    int item = buffer[--count];

    sem_post(&mutex);  // V(mutex)
    sem_post(&empty);  // V(empty)
}
```

**关键点：**
1. **顺序很重要**：先P(资源信号量)，再P(互斥信号量)，避免死锁
2. **配对使用**：每个P操作最终必须有对应的V操作

**信号量 vs 互斥锁：**
| 特性 | 互斥锁 | 信号量 |
|------|--------|--------|
| 初始值 | 1（二值） | 任意非负整数 |
| 主要用途 | 互斥访问临界区 | 控制资源数量/顺序同步 |
| 加锁/解锁 | 必须同一线程 | 可以不同线程（P和V分离） |

---

#### 4. 条件变量（Condition Variable）

**原理：**
- 线程间的**通知机制**
- 线程在某个条件不满足时**等待**（wait）
- 其他线程改变条件后**通知**（signal/broadcast）
- **必须配合互斥锁使用**

**核心操作：**
- `wait(lock)`：释放锁并等待，被唤醒后重新获取锁
- `signal()`：唤醒一个等待的线程
- `broadcast()`：唤醒所有等待的线程

**Go语言实现（使用sync.Cond）：**

```go
import "sync"

var (
    queue = make([]int, 0)
    mu    sync.Mutex
    cond  = sync.NewCond(&mu)  // 条件变量绑定互斥锁
)

// 生产者
func producer(item int) {
    mu.Lock()
    queue = append(queue, item)
    fmt.Printf("生产: %d\n", item)
    cond.Signal()  // 通知消费者
    mu.Unlock()
}

// 消费者
func consumer() {
    mu.Lock()
    for len(queue) == 0 {  // 必须用循环检查条件
        cond.Wait()        // 释放锁并等待（被唤醒后重新获取锁）
    }
    item := queue[0]
    queue = queue[1:]
    fmt.Printf("消费: %d\n", item)
    mu.Unlock()
}
```

**关键细节：为什么用while而不是if？**

```go
// 错误写法（if）
if len(queue) == 0 {
    cond.Wait()  // 被唤醒后不重新检查
}
item := queue[0]  // 可能panic（虚假唤醒或被其他线程抢占）

// 正确写法（for/while）
for len(queue) == 0 {
    cond.Wait()  // 被唤醒后重新检查条件
}
item := queue[0]  // 确保条件满足
```

**虚假唤醒（Spurious Wakeup）：**
- 操作系统可能在没有signal的情况下唤醒等待线程（优化或中断）
- 多个线程等待时，一个signal可能唤醒多个线程（取决于实现）

**C++ POSIX实现：**

```cpp
#include <pthread.h>

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
std::queue<int> queue;

// 生产者
void producer(int item) {
    pthread_mutex_lock(&lock);
    queue.push(item);
    pthread_cond_signal(&cond);  // 通知一个等待线程
    pthread_mutex_unlock(&lock);
}

// 消费者
void consumer() {
    pthread_mutex_lock(&lock);
    while (queue.empty()) {  // 循环检查
        pthread_cond_wait(&cond, &lock);  // 原子操作：释放锁+等待
    }
    int item = queue.front();
    queue.pop();
    pthread_mutex_unlock(&lock);
}
```

**条件变量的执行流程：**

```
消费者线程：
1. 获取锁
2. 检查条件（队列为空）
3. cond.Wait() → 释放锁并进入等待队列
4. [阻塞中...]
5. 被signal唤醒 → 重新获取锁
6. 再次检查条件（队列非空）
7. 取出数据
8. 释放锁

生产者线程：
1. 获取锁
2. 添加数据到队列
3. cond.Signal() → 唤醒一个等待线程
4. 释放锁
```

**signal vs broadcast：**
- `signal()`：唤醒一个等待线程（高效）
- `broadcast()`：唤醒所有等待线程（用于条件对多个线程有效的场景）

---

#### 5. 自旋锁（Spinlock）

**原理：**
- 获取锁失败时不阻塞，而是**循环检查锁状态**（忙等待）
- 适合临界区**极短**的场景（微秒级）
- 避免了线程上下文切换的开销

**实现原理（基于原子操作）：**

```go
import "sync/atomic"

type Spinlock struct {
    flag int32
}

func (s *Spinlock) Lock() {
    for !atomic.CompareAndSwapInt32(&s.flag, 0, 1) {
        // 自旋等待（CPU循环）
    }
}

func (s *Spinlock) Unlock() {
    atomic.StoreInt32(&s.flag, 0)
}
```

**C语言实现（x86 CAS指令）：**

```c
typedef struct {
    volatile int lock;
} spinlock_t;

void spin_lock(spinlock_t *s) {
    while (__sync_lock_test_and_set(&s->lock, 1)) {
        while (s->lock) {}  // 先读后CAS，减少总线流量
    }
}

void spin_unlock(spinlock_t *s) {
    __sync_lock_release(&s->lock);
}
```

**自旋锁 vs 互斥锁：**

| 特性 | 自旋锁 | 互斥锁 |
|------|--------|--------|
| 等待方式 | 忙等待（CPU循环） | 阻塞睡眠 |
| 上下文切换 | 无 | 有（~1μs） |
| CPU占用 | 持续占用CPU | 释放CPU |
| 适用场景 | 临界区极短（<10μs） | 临界区较长 |
| 典型应用 | 内核自旋锁、无锁队列 | 用户态通用锁 |

**性能对比（临界区1微秒）：**
- 自旋锁：延迟 ~1μs，CPU 100%
- 互斥锁：延迟 ~2μs（含上下文切换），CPU ~50%

**何时使用自旋锁？**
1. 临界区执行时间 < 线程切换时间（~1μs）
2. 多核CPU（单核自旋无意义）
3. 锁竞争不激烈（否则浪费CPU）

---

### 三、实际应用场景对比

#### 场景1：银行账户余额更新
**选择：互斥锁**
```go
var mu sync.Mutex
mu.Lock()
balance -= amount
mu.Unlock()
```
原因：操作简单，需要互斥访问

---

#### 场景2：配置中心（读多写少）
**选择：读写锁**
```go
var rwLock sync.RWMutex

func getConfig(key string) string {
    rwLock.RLock()
    defer rwLock.RUnlock()
    return config[key]
}

func updateConfig(key, value string) {
    rwLock.Lock()
    defer rwLock.Unlock()
    config[key] = value
}
```
原因：读操作占90%以上，读写锁允许并发读

---

#### 场景3：连接池（有限资源管理）
**选择：信号量**
```go
sem := make(chan struct{}, 10)  // 最多10个连接

func getConnection() *Connection {
    sem <- struct{}{}  // 获取资源
    return pool.Get()
}

func releaseConnection(conn *Connection) {
    pool.Put(conn)
    <-sem  // 释放资源
}
```
原因：控制资源数量，计数语义清晰

---

#### 场景4：任务队列（生产者-消费者）
**选择：条件变量**
```go
var (
    tasks []Task
    mu    sync.Mutex
    cond  = sync.NewCond(&mu)
)

func addTask(t Task) {
    mu.Lock()
    tasks = append(tasks, t)
    cond.Signal()
    mu.Unlock()
}

func worker() {
    mu.Lock()
    for len(tasks) == 0 {
        cond.Wait()
    }
    task := tasks[0]
    tasks = tasks[1:]
    mu.Unlock()
    task.Execute()
}
```
原因：需要等待条件满足，条件变量避免忙等待

---

#### 场景5：内核中断处理
**选择：自旋锁**
```c
spinlock_t lock;
spin_lock(&lock);
// 极短临界区（几十纳秒）
critical_section();
spin_unlock(&lock);
```
原因：中断处理不能睡眠，临界区极短

---

### 四、常见陷阱与最佳实践

#### 陷阱1：死锁（Deadlock）

**循环等待导致死锁：**
```go
// 线程1
mu1.Lock()
mu2.Lock()  // 等待mu2
// ...
mu2.Unlock()
mu1.Unlock()

// 线程2
mu2.Lock()
mu1.Lock()  // 等待mu1（死锁！）
// ...
mu1.Unlock()
mu2.Unlock()
```

**解决方案：按固定顺序获取锁**
```go
// 线程1和线程2都按 mu1 → mu2 顺序
mu1.Lock()
mu2.Lock()
// ...
mu2.Unlock()
mu1.Unlock()
```

---

#### 陷阱2：忘记解锁

**错误示例：**
```go
func transfer(from, to *Account, amount int) {
    from.mu.Lock()
    if from.balance < amount {
        return  // 忘记解锁！
    }
    from.balance -= amount
    to.balance += amount
    from.mu.Unlock()
}
```

**最佳实践：使用defer**
```go
func transfer(from, to *Account, amount int) {
    from.mu.Lock()
    defer from.mu.Unlock()  // 保证解锁

    if from.balance < amount {
        return  // 安全返回
    }
    from.balance -= amount
    to.balance += amount
}
```

---

#### 陷阱3：条件变量使用if而不是while

**错误示例：**
```go
mu.Lock()
if len(queue) == 0 {
    cond.Wait()
}
item := queue[0]  // 可能panic
mu.Unlock()
```

**正确做法：**
```go
mu.Lock()
for len(queue) == 0 {  // 循环检查
    cond.Wait()
}
item := queue[0]
mu.Unlock()
```

---

#### 陷阱4：读写锁的写者饥饿

**问题：**
持续的读操作可能导致写者永远无法获取锁

**Go的解决方案（写者优先）：**
- 当有写者等待时，新的读者会被阻塞
- 确保写者不会饥饿

---

### 五、性能对比总结

**锁的性能排序（从快到慢）：**
1. **无锁（原子操作）**：~10ns
2. **自旋锁（无竞争）**：~25ns
3. **互斥锁（无竞争）**：~25ns
4. **读写锁-读锁（无竞争）**：~30ns
5. **互斥锁（有竞争）**：~1μs
6. **条件变量（唤醒开销）**：~1-2μs

**选择建议：**
- 临界区 < 100ns → 原子操作或自旋锁
- 读多写少 → 读写锁
- 需要等待条件 → 条件变量
- 一般场景 → 互斥锁（简单可靠）

---

### 六、面试高频追问

#### Q1："互斥锁和信号量有什么区别？"
**答：**
1. **语义不同**：互斥锁用于互斥访问，信号量用于资源计数和顺序控制
2. **所有权**：互斥锁必须由加锁线程解锁，信号量的P和V可以在不同线程
3. **初始值**：互斥锁初始值为1（二值），信号量可以是任意非负整数
4. **用途**：互斥锁保护临界区，信号量管理资源池或实现同步

#### Q2："为什么条件变量必须配合互斥锁？"
**答：**
防止竞态条件。考虑不加锁的情况：
```
消费者检查队列为空 → 准备wait()
（此时生产者插入数据并signal，但消费者还没wait）
消费者执行wait() → 永远等待（错过了signal）
```
加锁后：
```
消费者：lock → 检查队列 → wait（原子释放锁+等待）
生产者：lock → 插入数据 → signal → unlock
消费者被唤醒 → 重新获取锁 → 检查队列 → 取数据
```

#### Q3："什么时候用自旋锁，什么时候用互斥锁？"
**答：**
- **自旋锁**：临界区极短（<10μs）、多核CPU、锁竞争不激烈
- **互斥锁**：临界区较长、单核CPU、或不确定临界区长度

计算公式：
```
自旋等待时间 < 上下文切换时间（~1μs） → 用自旋锁
否则 → 用互斥锁
```

---

### 总结

| 同步机制 | 主要用途 | 适用场景 | 关键优势 | 关键劣势 |
|---------|---------|---------|---------|---------|
| **互斥锁** | 互斥访问临界区 | 通用场景 | 简单可靠 | 读写不区分 |
| **读写锁** | 读多写少场景 | 配置中心、缓存 | 允许并发读 | 写者可能饥饿 |
| **信号量** | 资源计数/顺序控制 | 连接池、生产者-消费者 | 语义清晰 | 容易误用 |
| **条件变量** | 等待条件满足 | 任务队列、事件通知 | 避免忙等待 | 必须配合互斥锁 |
| **自旋锁** | 极短临界区 | 内核、无锁数据结构 | 无上下文切换 | 浪费CPU |

**核心原则：**
1. 能用无锁就不用锁
2. 能用读写锁就不用互斥锁
3. 能用条件变量就不用轮询
4. 临界区尽可能短
5. 避免在持有锁时调用外部函数
