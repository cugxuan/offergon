---
title: 银行家算法详解
tags:
  - 操作系统
status: robot
class: 操作系统
slug: bankers-algorithm-explained
ref:
---

## 核心要点

- **银行家算法是死锁避免算法，由Dijkstra提出**
- **核心思想：只在系统处于安全状态时分配资源**
- **安全状态：存在一个进程序列，使所有进程都能顺利完成**
- **关键数据结构：Available(可用)、Max(最大需求)、Allocation(已分配)、Need(还需要)**
- **时间复杂度O(n²m)，n为进程数，m为资源类型数**

---

## 详细回答

### 一、为什么需要银行家算法？

**问题背景：**
在多进程系统中，进程需要申请和释放资源。如果不加控制，可能导致死锁。

**三种死锁处理策略：**
1. **死锁预防**：破坏死锁四个必要条件之一（限制太多，资源利用率低）
2. **死锁检测与恢复**：允许死锁发生，定期检测并恢复（开销大）
3. **死锁避免**：动态检查资源分配请求，只在安全时分配（**银行家算法**）

**银行家算法的优势：**
- 比死锁预防更灵活（不严格限制资源申请顺序）
- 比死锁检测更主动（在分配前预判，而非事后检测）
- 保证系统始终处于安全状态

**算法名称由来：**
类比银行家发放贷款：
- 银行家（操作系统）拥有一定资金（系统资源）
- 客户（进程）需要贷款（申请资源）
- 银行家需确保即使所有客户同时要求贷款，也能按某种顺序让每个客户还款完成
- 如果某笔贷款会导致无法满足所有客户，则拒绝该贷款

---

### 二、核心概念

#### 1. 关键数据结构

假设系统有 **n 个进程** 和 **m 类资源**：

| 数据结构 | 维度 | 含义 | 示例 |
|---------|------|------|------|
| **Available[m]** | 1×m向量 | 每类资源的可用数量 | [3, 3, 2] 表示资源A有3个、B有3个、C有2个可用 |
| **Max[n][m]** | n×m矩阵 | 每个进程对每类资源的最大需求 | Max[P1][A]=7 表示进程P1最多需要7个资源A |
| **Allocation[n][m]** | n×m矩阵 | 每个进程当前已分配的资源数 | Allocation[P1][A]=2 表示P1已分配2个资源A |
| **Need[n][m]** | n×m矩阵 | 每个进程还需要的资源数 | Need = Max - Allocation |

**关系公式：**
```
Need[i][j] = Max[i][j] - Allocation[i][j]

系统资源总量 = Available + ΣAllocation[i]
```

---

#### 2. 安全状态 vs 不安全状态

**安全状态（Safe State）：**
存在一个进程序列 <P1, P2, ..., Pn>，对于每个进程Pi：
- Pi的剩余需求 ≤ 当前可用资源 + 所有Pj（j<i）已分配的资源
- 即每个进程都能获得所需资源并完成，释放资源后供后续进程使用

**不安全状态（Unsafe State）：**
- 找不到这样的安全序列
- **不一定会死锁，但有死锁的风险**

**状态关系图：**

```
┌─────────────────────────────────────┐
│          所有状态                    │
│  ┌───────────────────────────────┐  │
│  │       安全状态                 │  │
│  │  系统可以按某种顺序完成所有进程 │  │
│  └───────────────────────────────┘  │
│                                      │
│  ┌───────────────────────────────┐  │
│  │       不安全状态               │  │
│  │  ┌─────────────────────────┐  │  │
│  │  │     死锁状态             │  │  │
│  │  │  进程互相等待，无法继续  │  │  │
│  │  └─────────────────────────┘  │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘

安全状态 ⊂ 不安全状态 ⊂ 所有状态
```

---

### 三、银行家算法详细步骤

#### 算法流程图

```
进程Pi请求资源Request[m]
        ↓
    Request ≤ Need[i]?
        ↓ 否 → 拒绝（超过声明的最大需求）
        ↓ 是
    Request ≤ Available?
        ↓ 否 → 阻塞（资源不足）
        ↓ 是
    【试探性分配】
    Available -= Request
    Allocation[i] += Request
    Need[i] -= Request
        ↓
    执行安全性检查算法
        ↓
   系统是否安全?
   ↓是              ↓否
 分配成功      回滚试探性分配，阻塞进程
```

---

#### 详细步骤（以进程Pi请求资源Request为例）

**第1步：检查请求合法性**

```go
// 请求向量不能超过声明的最大需求
for j := 0; j < m; j++ {
    if Request[j] > Need[i][j] {
        return Error("请求超过最大需求")
    }
}
```

**第2步：检查资源可用性**

```go
// 请求的资源必须当前可用
for j := 0; j < m; j++ {
    if Request[j] > Available[j] {
        return Blocked("资源不足，进程等待")
    }
}
```

**第3步：试探性分配**

```go
// 模拟分配，修改系统状态
for j := 0; j < m; j++ {
    Available[j] -= Request[j]
    Allocation[i][j] += Request[j]
    Need[i][j] -= Request[j]
}
```

**第4步：安全性检查**

执行安全性算法（下文详述），判断新状态是否安全：
- **安全** → 正式分配，进程继续
- **不安全** → 回滚状态，进程阻塞

```go
if isSafe() {
    return Success("分配成功")
} else {
    // 回滚
    for j := 0; j < m; j++ {
        Available[j] += Request[j]
        Allocation[i][j] -= Request[j]
        Need[i][j] += Request[j]
    }
    return Blocked("不安全状态，拒绝分配")
}
```

---

### 四、安全性检查算法

**目标：** 判断当前系统状态是否安全（是否存在安全序列）

**算法步骤：**

```go
func isSafe() bool {
    // 1. 初始化工作向量和完成标志
    Work := Available.Clone()  // Work表示可用资源
    Finish := make([]bool, n)  // Finish[i]=true表示进程i能完成

    // 2. 寻找能完成的进程
    for {
        found := false
        for i := 0; i < n; i++ {
            if Finish[i] {
                continue  // 已完成的进程跳过
            }

            // 检查进程i的剩余需求是否 ≤ 当前可用资源
            canFinish := true
            for j := 0; j < m; j++ {
                if Need[i][j] > Work[j] {
                    canFinish = false
                    break
                }
            }

            if canFinish {
                // 进程i可以完成
                // 释放其占用的资源
                for j := 0; j < m; j++ {
                    Work[j] += Allocation[i][j]
                }
                Finish[i] = true
                SafeSequence = append(SafeSequence, i)  // 记录安全序列
                found = true
                break  // 找到一个，重新开始循环
            }
        }

        if !found {
            break  // 没找到能完成的进程，退出循环
        }
    }

    // 3. 检查是否所有进程都能完成
    for i := 0; i < n; i++ {
        if !Finish[i] {
            return false  // 存在无法完成的进程，不安全
        }
    }
    return true  // 所有进程都能完成，安全
}
```

**时间复杂度：** O(n²m)
- 外层循环最多n次（每次找一个进程）
- 内层循环n次（遍历所有进程）
- 每次检查m个资源

---

### 五、完整示例演示

#### 初始状态

**系统资源总量：**
- 资源A: 10个
- 资源B: 5个
- 资源C: 7个

**当前状态：**

| 进程 | Allocation(已分配) | Max(最大需求) | Need(还需要) | Available(可用) |
|------|-------------------|--------------|-------------|----------------|
|      | A  B  C | A  B  C | A  B  C | A  B  C |
| P0   | 0  1  0 | 7  5  3 | 7  4  3 | 3  3  2 |
| P1   | 2  0  0 | 3  2  2 | 1  2  2 | (初始) |
| P2   | 3  0  2 | 9  0  2 | 6  0  0 |        |
| P3   | 2  1  1 | 2  2  2 | 0  1  1 |        |
| P4   | 0  0  2 | 4  3  3 | 4  3  1 |        |

**计算Need：**
```
Need[P0] = Max[P0] - Allocation[P0] = [7,5,3] - [0,1,0] = [7,4,3]
Need[P1] = [3,2,2] - [2,0,0] = [1,2,2]
... 以此类推
```

**验证Available：**
```
系统总量：[10,5,7]
已分配总量：0+2+3+2+0=7, 1+0+0+1+0=2, 0+0+2+1+2=5
可用资源：[10-7, 5-2, 7-5] = [3,3,2] ✓
```

---

#### 安全性检查过程

**初始状态：**
```
Work = [3,3,2]（可用资源）
Finish = [F, F, F, F, F]（所有进程未完成）
SafeSequence = []
```

**第1轮查找：**
```
检查P0: Need[P0]=[7,4,3] ≤ Work=[3,3,2]? → 否（7>3）
检查P1: Need[P1]=[1,2,2] ≤ Work=[3,3,2]? → 是 ✓

执行P1：
  Work = Work + Allocation[P1] = [3,3,2] + [2,0,0] = [5,3,2]
  Finish[P1] = true
  SafeSequence = [P1]
```

**第2轮查找：**
```
检查P0: Need[P0]=[7,4,3] ≤ Work=[5,3,2]? → 否（7>5）
检查P2: Need[P2]=[6,0,0] ≤ Work=[5,3,2]? → 否（6>5）
检查P3: Need[P3]=[0,1,1] ≤ Work=[5,3,2]? → 是 ✓

执行P3：
  Work = [5,3,2] + [2,1,1] = [7,4,3]
  Finish[P3] = true
  SafeSequence = [P1, P3]
```

**第3轮查找：**
```
检查P0: Need[P0]=[7,4,3] ≤ Work=[7,4,3]? → 是 ✓

执行P0：
  Work = [7,4,3] + [0,1,0] = [7,5,3]
  Finish[P0] = true
  SafeSequence = [P1, P3, P0]
```

**第4轮查找：**
```
检查P2: Need[P2]=[6,0,0] ≤ Work=[7,5,3]? → 是 ✓

执行P2：
  Work = [7,5,3] + [3,0,2] = [10,5,5]
  Finish[P2] = true
  SafeSequence = [P1, P3, P0, P2]
```

**第5轮查找：**
```
检查P4: Need[P4]=[4,3,1] ≤ Work=[10,5,5]? → 是 ✓

执行P4：
  Work = [10,5,5] + [0,0,2] = [10,5,7]
  Finish[P4] = true
  SafeSequence = [P1, P3, P0, P2, P4]
```

**结论：** 所有进程都能完成，系统处于**安全状态**
**安全序列：** P1 → P3 → P0 → P2 → P4

---

#### 处理资源请求示例

**场景：进程P1请求资源 Request = [1,0,2]**

**第1步：检查合法性**
```
Request[1,0,2] ≤ Need[P1][1,2,2]?
检查：1≤1 ✓, 0≤2 ✓, 2≤2 ✓
合法！
```

**第2步：检查可用性**
```
Request[1,0,2] ≤ Available[3,3,2]?
检查：1≤3 ✓, 0≤3 ✓, 2≤2 ✓
可用！
```

**第3步：试探性分配**
```
Available = [3,3,2] - [1,0,2] = [2,3,0]
Allocation[P1] = [2,0,0] + [1,0,2] = [3,0,2]
Need[P1] = [1,2,2] - [1,0,2] = [0,2,0]
```

**第4步：安全性检查**

执行安全性算法：
```
Work = [2,3,0]
查找能完成的进程...
- P1: Need[0,2,0] ≤ Work[2,3,0]? → 是 ✓
  Work = [2,3,0] + [3,0,2] = [5,3,2]
- P3: Need[0,1,1] ≤ Work[5,3,2]? → 是 ✓
  Work = [5,3,2] + [2,1,1] = [7,4,3]
- P0: Need[7,4,3] ≤ Work[7,4,3]? → 是 ✓
  ...依次完成所有进程

安全序列：P1 → P3 → P0 → P2 → P4
```

**结论：** 系统仍安全，**分配成功**

---

#### 不安全状态示例

**场景：进程P0请求资源 Request = [0,2,0]**

**试探性分配后：**
```
Available = [3,3,2] - [0,2,0] = [3,1,2]
Allocation[P0] = [0,1,0] + [0,2,0] = [0,3,0]
Need[P0] = [7,4,3] - [0,2,0] = [7,2,3]
```

**安全性检查：**
```
Work = [3,1,2]
- P1: Need[1,2,2] ≤ Work[3,1,2]? → 否（2>1）
- P2: Need[6,0,0] ≤ Work[3,1,2]? → 否（6>3）
- P3: Need[0,1,1] ≤ Work[3,1,2]? → 是 ✓
  Work = [3,1,2] + [2,1,1] = [5,2,3]

- P0: Need[7,2,3] ≤ Work[5,2,3]? → 否（7>5）
- P1: Need[1,2,2] ≤ Work[5,2,3]? → 是 ✓
  Work = [5,2,3] + [2,0,0] = [7,2,3]

- P0: Need[7,2,3] ≤ Work[7,2,3]? → 是 ✓
  Work = [7,2,3] + [0,3,0] = [7,5,3]

- P2: Need[6,0,0] ≤ Work[7,5,3]? → 是 ✓
  ...

实际上这个例子仍是安全的，我们换一个：
```

**真正不安全的例子：P4请求 [3,3,0]**

```
Available = [3,3,2] - [3,3,0] = [0,0,2]
Work = [0,0,2]

查找进程：
- P1: Need[1,2,2] ≤ [0,0,2]? → 否
- P3: Need[0,1,1] ≤ [0,0,2]? → 否（0≥0但1>0）
- 所有进程都无法完成！

不安全状态，拒绝分配
```

---

### 六、Go语言完整实现

```go
package main

import "fmt"

type BankersAlgorithm struct {
    n         int       // 进程数
    m         int       // 资源类型数
    Available []int     // 可用资源
    Max       [][]int   // 最大需求
    Allocation [][]int  // 已分配
    Need      [][]int   // 还需要
}

func NewBanker(n, m int, available []int, max, allocation [][]int) *BankersAlgorithm {
    b := &BankersAlgorithm{
        n:          n,
        m:          m,
        Available:  available,
        Max:        max,
        Allocation: allocation,
        Need:       make([][]int, n),
    }

    // 计算Need = Max - Allocation
    for i := 0; i < n; i++ {
        b.Need[i] = make([]int, m)
        for j := 0; j < m; j++ {
            b.Need[i][j] = b.Max[i][j] - b.Allocation[i][j]
        }
    }
    return b
}

// 安全性检查算法
func (b *BankersAlgorithm) IsSafe() (bool, []int) {
    work := make([]int, b.m)
    copy(work, b.Available)

    finish := make([]bool, b.n)
    safeSequence := make([]int, 0, b.n)

    for {
        found := false
        for i := 0; i < b.n; i++ {
            if finish[i] {
                continue
            }

            // 检查Need[i] ≤ Work
            canFinish := true
            for j := 0; j < b.m; j++ {
                if b.Need[i][j] > work[j] {
                    canFinish = false
                    break
                }
            }

            if canFinish {
                // 释放资源
                for j := 0; j < b.m; j++ {
                    work[j] += b.Allocation[i][j]
                }
                finish[i] = true
                safeSequence = append(safeSequence, i)
                found = true
                break
            }
        }

        if !found {
            break
        }
    }

    // 检查是否所有进程都完成
    for i := 0; i < b.n; i++ {
        if !finish[i] {
            return false, nil
        }
    }
    return true, safeSequence
}

// 请求资源
func (b *BankersAlgorithm) RequestResources(pid int, request []int) bool {
    // 1. 检查请求合法性
    for j := 0; j < b.m; j++ {
        if request[j] > b.Need[pid][j] {
            fmt.Println("错误：请求超过最大需求")
            return false
        }
    }

    // 2. 检查资源可用性
    for j := 0; j < b.m; j++ {
        if request[j] > b.Available[j] {
            fmt.Println("资源不足，进程阻塞")
            return false
        }
    }

    // 3. 试探性分配
    for j := 0; j < b.m; j++ {
        b.Available[j] -= request[j]
        b.Allocation[pid][j] += request[j]
        b.Need[pid][j] -= request[j]
    }

    // 4. 安全性检查
    safe, sequence := b.IsSafe()
    if safe {
        fmt.Printf("分配成功！安全序列：%v\n", sequence)
        return true
    } else {
        // 回滚
        for j := 0; j < b.m; j++ {
            b.Available[j] += request[j]
            b.Allocation[pid][j] -= request[j]
            b.Need[pid][j] += request[j]
        }
        fmt.Println("不安全状态，拒绝分配")
        return false
    }
}

func main() {
    // 初始化：5个进程，3类资源
    available := []int{3, 3, 2}
    max := [][]int{
        {7, 5, 3},
        {3, 2, 2},
        {9, 0, 2},
        {2, 2, 2},
        {4, 3, 3},
    }
    allocation := [][]int{
        {0, 1, 0},
        {2, 0, 0},
        {3, 0, 2},
        {2, 1, 1},
        {0, 0, 2},
    }

    banker := NewBanker(5, 3, available, max, allocation)

    // 检查初始状态
    safe, seq := banker.IsSafe()
    fmt.Printf("初始状态安全：%v，安全序列：%v\n", safe, seq)

    // P1请求资源[1,0,2]
    fmt.Println("\nP1请求资源[1,0,2]")
    banker.RequestResources(1, []int{1, 0, 2})

    // P4请求资源[3,3,0]
    fmt.Println("\nP4请求资源[3,3,0]")
    banker.RequestResources(4, []int{3, 3, 0})
}
```

**输出：**
```
初始状态安全：true，安全序列：[1 3 0 2 4]

P1请求资源[1,0,2]
分配成功！安全序列：[1 3 0 2 4]

P4请求资源[3,3,0]
不安全状态，拒绝分配
```

---

### 七、优缺点分析

#### 优点

1. **避免死锁**：从源头上保证系统始终安全
2. **资源利用率较高**：相比死锁预防，限制更少
3. **理论完备**：有严格的数学证明

#### 缺点

1. **必须预先声明最大需求**
   - 实际应用中很难准确估计
   - 进程可能高估需求，降低资源利用率

2. **进程数和资源数固定**
   - 不支持动态增加进程或资源
   - 实际系统往往是动态的

3. **计算开销大**
   - 每次请求都要执行O(n²m)的安全性检查
   - n和m较大时性能问题明显

4. **过于保守**
   - 拒绝可能导致不安全的请求（即使实际不会死锁）
   - 资源利用率可能不是最优

---

### 八、实际应用与改进

#### 应用场景

1. **早期批处理系统**
   - 任务在运行前声明资源需求
   - 系统可以提前规划

2. **实时系统**
   - 任务需求相对固定
   - 对死锁零容忍

3. **教学演示**
   - 理解死锁避免的经典算法

#### 现代系统的选择

**为什么现代操作系统很少使用银行家算法？**

1. **无法预知资源需求**：
   - 现代程序动态申请资源（如malloc、文件打开）
   - 很难提前声明最大需求

2. **性能开销不可接受**：
   - 频繁的资源请求需要每次都检查
   - 多核并发下开销更大

3. **更好的替代方案**：
   - **死锁预防**：资源有序分配（Linux内核锁顺序）
   - **死锁检测**：数据库的死锁检测与恢复
   - **鸵鸟策略**：死锁概率极低时忽略（Windows/Linux）

#### 改进方向

1. **简化版安全性检查**
   - 只检查部分关键资源
   - 降低时间复杂度

2. **结合其他策略**
   - 银行家算法 + 超时机制
   - 银行家算法 + 资源有序分配

3. **应用于特定领域**
   - 云资源调度（可预估资源需求）
   - 嵌入式实时系统（任务固定）

---

### 九、面试高频追问

#### Q1："银行家算法能完全避免死锁吗？"
**答：**
只能避免**资源分配导致的死锁**，前提是：
1. 进程提前声明最大需求
2. 进程最终会释放资源
3. 资源数量固定

无法避免其他类型的死锁（如通信死锁、编程错误）。

#### Q2："不安全状态一定会死锁吗？"
**答：**
**不一定。** 不安全状态只是**可能**死锁：
- 如果进程实际需求小于声明的最大需求，可能不会死锁
- 如果进程主动释放资源，也不会死锁
- 银行家算法是保守的，拒绝所有可能不安全的请求

#### Q3："如何优化银行家算法的性能？"
**答：**
1. **缓存安全序列**：相似状态复用之前的检查结果
2. **增量检查**：只检查受影响的进程
3. **并行检查**：多核下并行执行安全性算法
4. **分层检查**：先粗粒度检查，再细粒度验证

---

### 十、总结

**银行家算法的核心：**
1. **预防性策略**：在分配前预判安全性
2. **安全状态保证**：只在安全状态下分配资源
3. **安全序列**：证明系统安全的进程执行顺序

**算法精髓：**
```
每次资源分配前问自己：
"如果我分配这些资源，是否存在一种顺序，
让所有进程都能拿到所需资源并完成？"
是 → 分配
否 → 拒绝
```

**实用建议：**
- 理论学习必备，实际应用需谨慎
- 适合资源需求可预测、对可靠性要求极高的系统
- 现代系统多采用死锁预防（锁顺序）+ 检测恢复（数据库）的组合策略

银行家算法虽然在实际系统中应用有限,但其**安全性检查**的思想深刻影响了现代资源调度和死锁避免策略的设计。
