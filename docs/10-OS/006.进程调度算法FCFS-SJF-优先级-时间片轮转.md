---
title: 进程调度算法（FCFS、SJF、优先级、时间片轮转）
tags:
  - 操作系统
status: robot
class: 操作系统
slug: process-scheduling-algorithms-fcfs-sjf-priority-round-robin
ref:
---

## 核心要点

- **FCFS（先来先服务）**：最简单，按到达顺序执行，但会产生"护航效应"
- **SJF（最短作业优先）**：平均等待时间最优，但难以预测执行时间且可能饿死长作业
- **优先级调度**：根据优先级分配CPU，灵活但可能导致低优先级进程饥饿
- **时间片轮转（RR）**：公平性好、响应时间快，时间片大小是关键参数

## 详细回答

### 一、FCFS（First Come First Serve，先来先服务）

#### 工作原理
按照进程到达就绪队列的先后顺序分配CPU，先到达的进程先执行，直到该进程执行完毕或主动放弃CPU。

#### 实现方式
使用FIFO队列维护就绪进程，调度器总是选择队首进程执行。

#### 优点
- 实现简单，公平
- 不需要额外的调度开销

#### 缺点
- **护航效应（Convoy Effect）**：如果一个长作业先到达，后续的短作业都要等待，导致平均周转时间和等待时间增加
- 对短作业不友好
- 不适合交互式系统（响应时间差）

#### 示例
假设有3个进程：
- P1：到达时间0ms，执行时间24ms
- P2：到达时间1ms，执行时间3ms
- P3：到达时间2ms，执行时间3ms

执行顺序：P1 → P2 → P3

平均等待时间 = (0 + 24 + 27) / 3 = 17ms

可以看到，P2和P3虽然执行时间短，但因为P1先到达，不得不等待很长时间。

### 二、SJF（Shortest Job First，最短作业优先）

#### 工作原理
优先选择执行时间最短的进程执行。分为两种：
- **非抢占式SJF**：进程一旦获得CPU就运行到完成
- **抢占式SJF（SRTF，最短剩余时间优先）**：当新进程到达时，如果其执行时间比当前进程剩余时间短，则抢占CPU

#### 优点
- **理论上平均等待时间最优**（对于给定的进程集合）
- 提高了系统吞吐量

#### 缺点
- **难以准确预测进程的执行时间**（实际系统中通常用历史数据估算）
- **可能导致长作业饥饿**：如果短作业不断到达，长作业可能永远得不到执行
- 对交互式进程不友好

#### 执行时间预测
实际系统中使用**指数平均法**预测下次CPU突发时间：

```
τ(n+1) = α × t(n) + (1-α) × τ(n)
```

其中：
- τ(n+1)：预测的下次CPU突发时间
- t(n)：第n次实际CPU突发时间
- τ(n)：第n次预测的CPU突发时间
- α：权重系数（0 ≤ α ≤ 1），通常取0.5

#### 示例
同样的3个进程（非抢占式SJF）：
- P1：到达时间0ms，执行时间24ms
- P2：到达时间1ms，执行时间3ms
- P3：到达时间2ms，执行时间3ms

执行顺序：P1（先执行完）→ P2 → P3

但如果采用抢占式SJF（SRTF）：
执行顺序：P1(0-1ms) → P2(1-4ms) → P3(4-7ms) → P1(7-31ms)

平均等待时间显著降低。

### 三、优先级调度（Priority Scheduling）

#### 工作原理
为每个进程分配一个优先级，CPU总是分配给优先级最高的进程。优先级可以是：
- **静态优先级**：创建时确定，运行过程中不变
- **动态优先级**：根据进程行为动态调整

#### 优先级确定因素
- 内部因素：时间限制、内存需求、I/O密集程度
- 外部因素：进程重要性、付费用户、政策要求

#### 实现方式
- **非抢占式**：运行中的进程不会被更高优先级进程打断
- **抢占式**：更高优先级进程到达时立即抢占CPU

#### 优点
- 灵活性高，可以满足不同需求
- 可以保证重要进程及时执行

#### 缺点
- **饥饿问题（Starvation）**：低优先级进程可能永远得不到执行

#### 解决饥饿问题的方法
**老化（Aging）技术**：随着进程在就绪队列中等待时间的增加，逐渐提高其优先级。

例如：每等待10ms，优先级+1，确保即使是低优先级进程最终也能得到执行。

#### 示例
假设优先级数字越小越高：
- P1：优先级3，执行时间10ms
- P2：优先级1，执行时间1ms
- P3：优先级2，执行时间2ms

执行顺序：P2 → P3 → P1

### 四、时间片轮转（Round Robin，RR）

#### 工作原理
将CPU时间划分为若干**时间片（Time Quantum）**，每个进程按FCFS顺序获得一个时间片的执行时间。时间片用完后，进程被强制切换，放到就绪队列末尾，CPU分配给下一个进程。

#### 关键参数：时间片大小
时间片的选择至关重要：

**时间片过大**：
- 退化为FCFS算法
- 响应时间变差

**时间片过小**：
- 进程切换频繁，上下文切换开销大
- CPU有效利用率降低

**经验法则**：
- 时间片应略大于一次上下文切换的时间
- 通常设置为10-100ms
- 80%的CPU突发应该短于时间片

#### 优点
- **公平性好**：每个进程都能定期获得CPU时间
- **响应时间短**：适合交互式系统和分时系统
- 不会出现进程饥饿

#### 缺点
- 平均周转时间通常比SJF长
- 上下文切换开销
- 时间片选择困难

#### 性能分析
假设有n个进程，时间片为q：
- 每个进程等待时间不超过 (n-1) × q
- 响应时间有保证

#### 示例
假设时间片为4ms，有3个进程：
- P1：执行时间24ms
- P2：执行时间3ms
- P3：执行时间3ms

执行序列：
```
P1(4) → P2(3,完成) → P3(3,完成) → P1(4) → P1(4) → P1(4) → P1(4) → P1(4)
```

- P1：等待时间 = (24-4) = 6×4 = 24ms（分6次执行，每次等待4ms）
- P2：等待时间 = 4ms
- P3：等待时间 = 7ms

平均等待时间 = (24 + 4 + 7) / 3 ≈ 11.67ms

### 五、算法对比总结

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| FCFS | 简单公平 | 护航效应，等待时间长 | 批处理系统 |
| SJF | 平均等待时间最优 | 难预测时间，长作业饥饿 | 批处理系统（已知执行时间） |
| 优先级 | 灵活，满足多样需求 | 可能饥饿 | 实时系统、多用户系统 |
| RR | 响应快，公平 | 上下文切换开销 | 分时系统、交互式系统 |

### 六、实际系统中的应用

现代操作系统通常不使用单一算法，而是**混合调度策略**：

**Linux系统**：
- 使用**完全公平调度器（CFS）**，基于虚拟运行时间的加权轮转
- 结合优先级（nice值）和动态调整

**Windows系统**：
- 多级反馈队列 + 优先级调度
- 32个优先级级别，动态调整优先级

**实时系统**：
- 通常使用优先级调度（抢占式）
- 保证高优先级任务的响应时间

这些算法为后续更复杂的调度策略（如多级反馈队列）奠定了基础。理解它们的优缺点和适用场景，是设计高效调度系统的关键。
