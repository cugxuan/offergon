---
title: epoll 的边缘触发和水平触发
tags:
  - 操作系统
status: robot
class: 操作系统
slug: epol-edge-trigger-vs-level-trigger
ref:
---

## 核心要点

**epoll 的两种事件通知模式:**
- **水平触发 (LT, Level Triggered)**: 只要 fd 有数据未读完,每次 epoll_wait 都会通知 (默认模式,类似 select/poll)
- **边缘触发 (ET, Edge Triggered)**: 只在 fd 状态变化时通知一次 (从无数据→有数据),必须一次性读完

**核心区别**: LT 是"状态驱动",ET 是"变化驱动"

**使用建议**: ET 性能更高但编程复杂,需配合非阻塞 IO + 循环读取直到 EAGAIN

---

## 详细回答

### 一、什么是触发模式

当文件描述符 (fd) 有数据可读/可写时,epoll 会通过 `epoll_wait()` 通知应用程序。但**何时通知**、**通知几次**,由触发模式决定。

---

### 二、水平触发 (Level Triggered, LT)

#### 概念

**"水平"** 借用电子工程术语,表示**持续的高电平信号** (只要有数据就一直通知)。

#### 工作机制

```
时间轴: ───[数据到达 100 字节]────────────────────>
          ↓
epoll_wait: [通知]
          ↓
应用读取:  [读了 50 字节]
          ↓
epoll_wait: [通知] (还有 50 字节未读!)
          ↓
应用读取:  [读了 50 字节]
          ↓
epoll_wait: [不通知] (数据已读完)
```

**关键特性:**
1. **只要 fd 就绪,每次 epoll_wait 都会返回该 fd**
2. 即使数据没读完,下次调用 epoll_wait 仍会通知
3. 直到应用程序把所有数据读完,fd 才不再被通知

#### 代码示例

```c
int epfd = epoll_create(1);
struct epoll_event ev;

// LT 模式 (默认)
ev.events = EPOLLIN;  // 不加 EPOLLET
ev.data.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);

while (1) {
    struct epoll_event events[10];
    int nfds = epoll_wait(epfd, events, 10, -1);

    for (int i = 0; i < nfds; i++) {
        if (events[i].events & EPOLLIN) {
            char buf[128];
            // 只读一次,即使没读完数据
            int n = read(events[i].data.fd, buf, sizeof(buf));
            // 下次 epoll_wait 仍会通知该 fd (如果还有数据)
        }
    }
}
```

#### 优缺点

**优点:**
- **编程简单**: 即使一次没读完数据,下次还会通知,不易丢数据
- **安全**: 适合新手和对性能要求不高的场景
- **兼容性**: 和 select/poll 行为一致

**缺点:**
- **效率低**: 同一个 fd 可能被多次通知,造成重复处理
- **无效唤醒**: 如果应用程序故意不读完数据,会导致 epoll_wait 频繁返回

---

### 三、边缘触发 (Edge Triggered, ET)

#### 概念

**"边缘"** 表示**信号跳变的瞬间** (从低电平→高电平),只在状态**变化时**通知一次。

#### 工作机制

```
时间轴: ───[数据到达 100 字节]────────────[新数据到达 50 字节]──>
          ↓                            ↓
epoll_wait: [通知] (状态变化!)        [通知] (新数据到达!)
          ↓                            ↓
应用读取:  [读了 50 字节]              [读了 150 字节]
          ↓
epoll_wait: [不通知!] (状态没变化,即使还有 50 字节未读)
```

**关键特性:**
1. **只在 fd 从"未就绪"变为"就绪"时通知一次**
2. 如果数据没读完,后续 epoll_wait **不会再通知**
3. 必须在通知时**一次性读完所有数据**,直到 read 返回 EAGAIN

#### 代码示例

```c
int epfd = epoll_create(1);
struct epoll_event ev;

// ET 模式
ev.events = EPOLLIN | EPOLLET;  // 关键: 添加 EPOLLET 标志
ev.data.fd = sockfd;

// 必须设置为非阻塞 IO
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);

while (1) {
    struct epoll_event events[10];
    int nfds = epoll_wait(epfd, events, 10, -1);

    for (int i = 0; i < nfds; i++) {
        if (events[i].events & EPOLLIN) {
            // 必须循环读取,直到 EAGAIN
            while (1) {
                char buf[1024];
                int n = read(events[i].data.fd, buf, sizeof(buf));

                if (n < 0) {
                    if (errno == EAGAIN || errno == EWOULDBLOCK) {
                        // 数据读完了
                        break;
                    } else {
                        // 真正的错误
                        perror("read");
                        break;
                    }
                } else if (n == 0) {
                    // 连接关闭
                    close(events[i].data.fd);
                    break;
                }

                // 处理数据...
            }
        }
    }
}
```

#### 为什么必须配合非阻塞 IO?

**反例 (错误示范):**
```c
// 如果用阻塞 IO
while (1) {
    char buf[1024];
    int n = read(sockfd, buf, sizeof(buf));  // 阻塞在这里!
    // 如果读完所有数据,下次 read 会一直阻塞等待新数据
}
```

**正确做法:**
```c
// 非阻塞 IO
while (1) {
    char buf[1024];
    int n = read(sockfd, buf, sizeof(buf));
    if (n < 0 && errno == EAGAIN) {
        break;  // 数据读完了,跳出循环
    }
}
```

#### 优缺点

**优点:**
- **性能极高**: 每个 fd 只通知一次,减少系统调用开销
- **减少无效唤醒**: 避免重复处理同一个 fd
- **适合高并发**: Nginx、Redis 等高性能服务器都用 ET 模式

**缺点:**
- **编程复杂**: 必须处理非阻塞 IO、EAGAIN 错误、循环读取
- **容易丢数据**: 如果忘记循环读取,剩余数据不会再通知
- **调试困难**: 状态管理更复杂

---

### 四、两者对比

| 特性 | 水平触发 (LT) | 边缘触发 (ET) |
|------|---------------|---------------|
| **通知时机** | 只要 fd 就绪就通知 | 只在状态变化时通知一次 |
| **通知次数** | 多次 (直到数据读完) | 一次 (状态变化时) |
| **数据读取** | 可以分多次读 | 必须一次性读完 |
| **IO 模式** | 阻塞/非阻塞均可 | 必须非阻塞 |
| **编程难度** | 简单 | 复杂 |
| **性能** | 较低 (重复通知) | 高 (减少系统调用) |
| **应用场景** | 低并发、对性能要求不高 | 高并发服务器 |
| **典型应用** | 传统 Web 服务 | Nginx、Redis、Node.js |

---

### 五、深入理解:为什么 ET 性能更高?

#### 性能对比示例

**场景**: 10000 个连接,其中 100 个有数据 (每个 10KB),应用程序每次只读 1KB

**LT 模式:**
```
epoll_wait() → 返回 100 个 fd
读取 100 次 (每次 1KB)
epoll_wait() → 再次返回 100 个 fd (数据没读完!)
读取 100 次
...
总共调用 epoll_wait 10 次,读取 1000 次
```

**ET 模式:**
```
epoll_wait() → 返回 100 个 fd
对每个 fd 循环读取 10 次 (直到 EAGAIN)
总共调用 epoll_wait 1 次,读取 1000 次
```

**结论**: ET 减少了 9 次 epoll_wait 系统调用!

---

### 六、实战案例:Nginx 为什么用 ET?

#### Nginx 的 ET 模式优化

```c
// Nginx 源码简化版
static void ngx_epoll_process_events() {
    events = epoll_wait(ep, event_list, nevents, timer);

    for (i = 0; i < events; i++) {
        // 获取连接
        c = event_list[i].data.ptr;

        // 循环读取,直到 EAGAIN
        do {
            n = recv(c->fd, buf, size, 0);

            if (n == NGX_EAGAIN) {
                break;  // ET 模式下数据读完了
            }

            // 处理请求...
        } while (1);
    }
}
```

**为什么 Nginx 用 ET:**
1. 单 worker 进程处理数万连接,减少 epoll_wait 调用至关重要
2. 大部分连接是长连接 (Keep-Alive),LT 会频繁无效唤醒
3. ET 配合非阻塞 IO,可以精确控制何时读取数据

---

### 七、常见陷阱和最佳实践

#### 陷阱 1: ET 模式下没有循环读取

```c
// 错误示范
if (events[i].events & EPOLLIN) {
    char buf[1024];
    read(fd, buf, sizeof(buf));  // 只读一次!
    // 剩余数据永远不会再被通知!
}
```

**正确做法**: 见上文"边缘触发代码示例"

#### 陷阱 2: ET 模式下使用阻塞 IO

```c
// 错误: 会导致死锁
while (1) {
    read(fd, buf, sizeof(buf));  // 阻塞等待,永不返回
}
```

#### 陷阱 3: LT 模式下故意不读数据

```c
// 错误: 会导致 epoll_wait 频繁返回
epoll_wait(...);  // 返回 fd
// 不调用 read,直接继续
epoll_wait(...);  // 又返回同一个 fd!
```

#### 最佳实践

1. **低并发/简单场景**: 用 LT,代码简单不易出错
2. **高并发场景**: 用 ET,但务必:
   - 设置非阻塞 IO (`fcntl`)
   - 循环读取直到 `EAGAIN`
   - 处理 `EINTR` 信号中断
3. **混合模式**: 可以对不同 fd 使用不同模式 (同一个 epoll 实例内)

---

### 八、总结

**选择建议:**
- **学习/小项目**: 用 LT,降低心智负担
- **生产环境高并发**: 用 ET,榨取极致性能
- **理解本质**: LT 是"有数据就说",ET 是"有新数据才说"

**记忆口诀:**
- **LT = Level = 平坦 = 持续通知 = 简单但啰嗦**
- **ET = Edge = 边缘 = 变化通知 = 高效但复杂**

**面试加分项:**
- 能解释为什么 ET 必须配合非阻塞 IO
- 知道 Nginx 用 ET 模式 + 非阻塞 IO 实现高并发
- 能写出正确的 ET 模式循环读取代码 (直到 EAGAIN)
- 理解 EPOLLONESHOT 标志 (多线程场景下配合 ET 使用)
