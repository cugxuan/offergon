---
title: Linux 的写时复制和内存去重技术（KSM）
tags:
  - 内存管理
  - 操作系统
status: robot
class: 操作系统
slug: copy-on-write-and-ksm-memory-deduplication
ref:
---

## 核心要点

**写时复制(COW)**是Linux进程创建和内存管理的核心优化技术，通过延迟实际内存分配直到写操作时才复制；**内存去重技术KSM**通过扫描识别相同内存页并合并，大幅减少物理内存使用，特别适用于虚拟化环境。

## 详细解答

### 1. 写时复制（Copy-on-Write, COW）

#### 1.1 基本原理

写时复制是一种资源管理优化策略，核心思想是：
- **延迟复制**：在需要修改时才进行实际的复制操作
- **共享只读**：多个进程可以共享同一份只读数据
- **按需分配**：只有真正需要独立副本时才分配新内存

#### 1.2 COW在fork()中的实现

**传统fork()的问题：**
```c
// 传统方式：立即复制所有内存
pid_t pid = fork();
// 父子进程各自拥有完整的内存副本
```

这种方式存在严重性能问题：
- 大量内存复制开销
- 可能复制永远不会被修改的数据
- 降低fork()操作的速度

**COW优化的fork()：**
```c
pid_t pid = fork();
if (pid == 0) {
    // 子进程：与父进程共享只读内存页
    // 只有写操作时才触发页面复制
} else {
    // 父进程：继续使用原有内存
}
```

#### 1.3 COW的工作机制

**步骤1：共享设置**
```c
// 内核为父子进程设置相同的页表项
// 所有页面标记为只读（即使原本可写）
pte_t pte = *pte_ptr;
pte = pte_wrprotect(pte); // 移除写权限
set_pte(pte_ptr, pte);
```

**步骤2：缺页中断处理**
```c
// 当进程尝试写入时，触发页面错误
static int do_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,
                      unsigned long address, pte_t *page_table, pte_t orig_pte)
{
    struct page *old_page, *new_page;

    old_page = vm_normal_page(vma, address, orig_pte);

    // 检查是否需要COW
    if (page_count(old_page) == 1) {
        // 只有一个引用，直接恢复写权限
        set_pte_at(mm, address, page_table, pte_mkwrite(orig_pte));
        return VM_FAULT_WRITE;
    }

    // 分配新页面
    new_page = alloc_page(GFP_KERNEL);
    if (!new_page)
        return VM_FAULT_OOM;

    // 复制页面内容
    copy_user_highpage(new_page, old_page, address, vma);

    // 更新页表
    set_pte_at(mm, address, page_table, mk_pte(new_page, vma->vm_page_prot));

    return VM_FAULT_WRITE;
}
```

#### 1.4 COW的性能优化效果

**内存使用优化：**
```bash
# fork前
PID   VIRT   RES   SHR
1234  100M   80M   20M

# fork后（COW）
PID   VIRT   RES   SHR
1234  100M   80M   60M  # 父进程，SHR增加
1235  100M   20M   60M  # 子进程，RES很小，SHR很大
```

**时间开销对比：**
- 传统fork()：O(n)，n为内存页数
- COW fork()：O(1)，几乎瞬时完成

#### 1.5 COW在其他场景的应用

**mmap()文件映射：**
```c
// 多个进程映射同一文件
void *addr = mmap(NULL, size, PROT_READ|PROT_WRITE,
                  MAP_PRIVATE, fd, 0);
// MAP_PRIVATE使用COW，修改不影响原文件
```

**动态库加载：**
```c
// 多个进程共享同一动态库的代码段
// 数据段使用COW，每个进程有独立副本
dlopen("libexample.so", RTLD_LAZY);
```

### 2. 内存去重技术（KSM - Kernel Samepage Merging）

#### 2.1 KSM设计目标

KSM解决的问题：
- **内存冗余**：虚拟化环境中多个VM运行相同OS
- **资源浪费**：相同内容的页面在内存中多次存储
- **可扩展性**：提高单机可运行VM数量

#### 2.2 KSM工作原理

**核心算法：**
1. **扫描阶段**：定期扫描可合并的内存区域
2. **比较阶段**：逐字节比较页面内容
3. **合并阶段**：将相同页面合并为一个COW页面
4. **维护阶段**：监控合并页面的变化

#### 2.3 KSM数据结构

**红黑树存储：**
```c
struct rmap_item {
    struct rmap_item *rmap_list;
    struct anon_vma *anon_vma;    // 匿名VMA
    struct mm_struct *mm;
    unsigned long address;
    unsigned int oldchecksum;     // 页面校验和
    union {
        struct rb_node node;      // 红黑树节点
        struct {
            struct stable_node *head;
            struct hlist_node hlist;
        };
    };
};

struct stable_node {
    struct hlist_head hlist;      // 相同页面链表
    struct rb_node node;          // 在稳定树中的位置
    unsigned int nid;            // NUMA节点ID
    unsigned long kpfn;          // 内核页面帧号
};
```

#### 2.4 KSM扫描流程

**初始化扫描：**
```c
// 应用程序标记内存区域为可合并
int madvise(void *addr, size_t length, MADV_MERGEABLE);

// 内核创建扫描任务
static int ksm_scan_thread(void *nothing)
{
    while (!kthread_should_stop()) {
        mutex_lock(&ksm_thread_mutex);

        if (ksmd_should_run())
            ksm_do_scan(ksm_thread_pages_to_scan);

        mutex_unlock(&ksm_thread_mutex);

        // 休眠直到下次扫描
        schedule_timeout_interruptible(
            msecs_to_jiffies(ksm_thread_sleep_millisecs));
    }
    return 0;
}
```

**页面比较和合并：**
```c
static void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)
{
    struct rmap_item *tree_rmap_item;
    struct page *tree_page = NULL;
    struct stable_node *stable_node;
    struct page *kpage;
    unsigned int checksum;
    int err;

    // 计算页面校验和
    checksum = calc_checksum(page);

    // 快速检查：校验和是否变化
    if (rmap_item->oldchecksum != checksum) {
        rmap_item->oldchecksum = checksum;
        return;
    }

    // 在稳定树中查找相同页面
    tree_rmap_item = unstable_tree_search_insert(rmap_item, page, &tree_page);

    if (tree_rmap_item) {
        // 找到相同页面，尝试合并
        kpage = try_to_merge_two_pages(rmap_item, page,
                                       tree_rmap_item, tree_page);
        if (kpage) {
            // 合并成功，创建稳定节点
            stable_node = stable_tree_insert(kpage);
            if (stable_node) {
                stable_tree_append(tree_rmap_item, stable_node);
                stable_tree_append(rmap_item, stable_node);
            }
        }
    }
}
```

#### 2.5 KSM性能指标

**关键参数配置：**
```bash
# KSM配置文件
/sys/kernel/mm/ksm/
├── run                    # 启用/禁用KSM (0/1/2)
├── pages_to_scan          # 每次扫描页面数
├── sleep_millisecs        # 扫描间隔(毫秒)
├── merge_across_nodes     # 是否跨NUMA节点合并
└── use_zero_pages         # 是否合并零页面

# 性能统计
├── pages_shared           # 当前共享页面数
├── pages_sharing          # 引用共享页面的总数
├── pages_unshared         # 无法合并的唯一页面
├── pages_volatile         # 经常变化的页面
└── full_scans            # 完成的完整扫描次数
```

**效果评估：**
```bash
# 查看KSM效果
echo "KSM节省内存: $(($(cat /sys/kernel/mm/ksm/pages_sharing) * 4))KB"
echo "共享页面数: $(cat /sys/kernel/mm/ksm/pages_shared)"

# 计算合并率
shared=$(cat /sys/kernel/mm/ksm/pages_shared)
sharing=$(cat /sys/kernel/mm/ksm/pages_sharing)
echo "合并率: $((sharing * 100 / (shared + sharing)))%"
```

### 3. 实际应用场景

#### 3.1 虚拟化环境优化

**QEMU/KVM虚拟机：**
```bash
# 启用KSM
echo 1 > /sys/kernel/mm/ksm/run

# 优化扫描参数
echo 100 > /sys/kernel/mm/ksm/pages_to_scan
echo 20 > /sys/kernel/mm/ksm/sleep_millisecs

# 虚拟机内存设置
qemu-system-x86_64 \
    -m 2048 \
    -mem-prealloc \
    -mem-path /dev/hugepages \
    # KSM会自动扫描这些内存
```

**容器环境：**
```bash
# Docker容器共享基础镜像
docker run --memory=512m \
           --kernel-memory=100m \
           ubuntu:20.04

# 多个容器运行相同镜像时，KSM会合并相同页面
```

#### 3.2 应用程序优化

**数据库缓存池：**
```c
// PostgreSQL共享缓冲区
void *shmem = mmap(NULL, size, PROT_READ|PROT_WRITE,
                   MAP_ANONYMOUS|MAP_SHARED, -1, 0);

// 启用KSM扫描
madvise(shmem, size, MADV_MERGEABLE);
```

**内存数据库：**
```c
// Redis内存优化
void enableKSM(void *ptr, size_t size) {
    if (madvise(ptr, size, MADV_MERGEABLE) == -1) {
        perror("madvise MADV_MERGEABLE failed");
    }
}
```

### 4. 性能影响分析

#### 4.1 COW性能特征

**优势：**
- fork()时间：从O(n)降到O(1)
- 内存使用：延迟分配，按需复制
- 缓存友好：父子进程共享热数据

**劣势：**
- 写时延迟：首次写入需要复制页面
- 内存碎片：可能产生更多小块内存
- TLB压力：页表项增加

#### 4.2 KSM性能权衡

**CPU开销：**
```bash
# 监控KSM CPU使用
top -p $(pgrep ksmd)

# 调优扫描强度
echo 50 > /sys/kernel/mm/ksm/pages_to_scan  # 降低CPU使用
echo 50 > /sys/kernel/mm/ksm/sleep_millisecs # 增加扫描间隔
```

**内存节省效果：**
```bash
# 典型虚拟化环境节省20-40%内存
# 相同应用多实例环境节省更多

# 监控脚本
#!/bin/bash
while true; do
    saved_kb=$(($(cat /sys/kernel/mm/ksm/pages_sharing) * 4))
    echo "$(date): KSM saved ${saved_kb}KB"
    sleep 60
done
```

### 5. 高级优化技巧

#### 5.1 NUMA感知优化

```c
// 绑定KSM扫描到特定NUMA节点
echo 0 > /sys/kernel/mm/ksm/merge_across_nodes

// 应用程序NUMA优化
void optimizeNUMA(void *addr, size_t size, int node) {
    // 绑定内存到指定节点
    mbind(addr, size, MPOL_BIND, &node_mask, 1, 0);

    // 启用KSM
    madvise(addr, size, MADV_MERGEABLE);
}
```

#### 5.2 透明大页(THP)集成

```bash
# THP与KSM协同工作
echo always > /sys/kernel/mm/transparent_hugepage/enabled
echo defer+madvise > /sys/kernel/mm/transparent_hugepage/defrag

# 监控大页面使用
cat /proc/meminfo | grep -E "(HugePages|Transparent)"
```

#### 5.3 应用级优化

```c
// 智能内存管理
class MemoryManager {
private:
    bool use_ksm;
    size_t threshold;

public:
    void* allocate(size_t size) {
        void* ptr = mmap(NULL, size, PROT_READ|PROT_WRITE,
                        MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);

        // 大块内存启用KSM
        if (use_ksm && size > threshold) {
            madvise(ptr, size, MADV_MERGEABLE);
        }

        return ptr;
    }

    void deallocate(void* ptr, size_t size) {
        madvise(ptr, size, MADV_UNMERGEABLE);
        munmap(ptr, size);
    }
};
```

### 6. 故障排查和监控

#### 6.1 常见问题诊断

**COW失效问题：**
```bash
# 检查内存使用模式
cat /proc/$PID/smaps | grep -E "(Private|Shared)"

# 分析页面错误
perf record -e page-faults ./program
perf report
```

**KSM效率低下：**
```bash
# 检查扫描效率
watch "cat /sys/kernel/mm/ksm/pages_*"

# 调优建议
if [ $pages_volatile -gt $pages_shared ]; then
    echo "数据变化太频繁，考虑调整扫描间隔"
fi
```

#### 6.2 性能监控脚本

```bash
#!/bin/bash
# KSM性能监控脚本

function ksm_stats() {
    local shared=$(cat /sys/kernel/mm/ksm/pages_shared)
    local sharing=$(cat /sys/kernel/mm/ksm/pages_sharing)
    local unshared=$(cat /sys/kernel/mm/ksm/pages_unshared)
    local volatile=$(cat /sys/kernel/mm/ksm/pages_volatile)

    local saved_mb=$(( (sharing - shared) * 4 / 1024 ))
    local efficiency=$(( sharing * 100 / (sharing + unshared + volatile) ))

    echo "KSM Statistics:"
    echo "  Memory saved: ${saved_mb}MB"
    echo "  Efficiency: ${efficiency}%"
    echo "  Shared pages: $shared"
    echo "  Sharing pages: $sharing"
}

while true; do
    ksm_stats
    sleep 30
done
```

### 总结

写时复制(COW)和内存去重技术(KSM)是Linux内存管理的两大优化技术：

**COW的价值：**
1. **进程创建优化**：使fork()操作几乎瞬时完成
2. **内存效率**：避免不必要的内存复制
3. **系统响应性**：减少大内存应用的启动时间

**KSM的价值：**
1. **虚拟化优化**：大幅提高VM密度
2. **内存节省**：典型环境可节省20-40%内存
3. **成本效益**：以少量CPU开销换取大量内存节省

**最佳实践：**
- 在虚拟化和容器环境中启用KSM
- 根据工作负载调优扫描参数
- 监控CPU和内存使用平衡
- 结合THP等其他优化技术

这些技术的深入理解有助于系统架构设计、性能调优和资源规划，是高性能系统开发的重要基础。
