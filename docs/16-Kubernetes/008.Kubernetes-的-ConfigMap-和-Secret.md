---
title: Kubernetes 的 ConfigMap 和 Secret
tags:
  - Kubernetes
status: robot
class: Kubernetes
slug: kubernetes-configmap-secret
ref:
---

## 核心要点

**ConfigMap 用于存储非敏感配置(环境变量、配置文件),Secret 用于存储敏感数据(密码、证书、密钥)。两者都可通过环境变量、Volume 挂载或 API 注入到 Pod,实现配置与代码分离,支持动态更新。**

---

## 详细回答

### 一、为什么需要 ConfigMap 和 Secret?

传统做法是将配置硬编码在镜像中或通过启动参数传入,存在以下问题:

- **配置变更需重新构建镜像**:修改配置需重新打包、发布
- **环境差异难管理**:开发、测试、生产环境配置不同,需维护多个镜像版本
- **敏感信息泄露风险**:密码、密钥存储在镜像或代码仓库中不安全

**ConfigMap 和 Secret 的优势**:

1. **配置与镜像解耦**:同一镜像适配多环境
2. **集中管理**:配置统一存储在 K8s 中,便于版本控制
3. **动态更新**:支持热更新配置(需应用支持)
4. **敏感数据保护**:Secret 提供 base64 编码和加密存储

### 二、ConfigMap 详解

#### 1. 创建 ConfigMap

**命令行创建**:

```bash
# 从字面值创建
kubectl create configmap app-config \
  --from-literal=log_level=info \
  --from-literal=max_connections=100

# 从文件创建
kubectl create configmap nginx-config --from-file=nginx.conf

# 从目录创建(目录中所有文件)
kubectl create configmap app-configs --from-file=./configs/

# 从环境变量文件创建
cat <<EOF > env.properties
DB_HOST=mysql.default.svc.cluster.local
DB_PORT=3306
EOF
kubectl create configmap db-config --from-env-file=env.properties
```

**YAML 定义**:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: default
data:
  # 键值对形式
  log_level: "info"
  max_connections: "100"

  # 文件内容形式
  nginx.conf: |
    server {
        listen 80;
        server_name example.com;
        location / {
            proxy_pass http://backend:8080;
        }
    }

  app.json: |
    {
      "feature_flags": {
        "new_ui": true,
        "beta_features": false
      }
    }
```

#### 2. 使用 ConfigMap

##### 方式一:环境变量注入

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app
    image: myapp:1.0
    env:
    # 单个键注入
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: log_level

    # 全部键注入(key 作为环境变量名)
    envFrom:
    - configMapRef:
        name: app-config
```

##### 方式二:Volume 挂载

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: config
      mountPath: /etc/nginx/conf.d  # 挂载目录
      readOnly: true
  volumes:
  - name: config
    configMap:
      name: nginx-config
      items:  # 可选:只挂载指定 key
      - key: nginx.conf
        path: default.conf  # 挂载后的文件名
```

**挂载后文件路径**:`/etc/nginx/conf.d/default.conf`

##### 方式三:subPath 挂载单个文件

当只需挂载单个文件且不覆盖整个目录时:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp
    volumeMounts:
    - name: config
      mountPath: /app/config.json  # 挂载到具体文件
      subPath: config.json  # 关键:只挂载 config.json,不覆盖 /app 目录
  volumes:
  - name: config
    configMap:
      name: app-config
      items:
      - key: app.json
        path: config.json
```

#### 3. 更新 ConfigMap

```bash
# 编辑 ConfigMap
kubectl edit configmap app-config

# 或替换整个 ConfigMap
kubectl apply -f configmap.yaml
```

**配置热更新机制**:

- **Volume 挂载**:ConfigMap 更新后,kubelet 会自动同步到 Pod(延迟约 1 分钟)
  - 通过 `inotify` 监听文件变化,应用需支持配置重载(如 Nginx `nginx -s reload`)
- **环境变量**:不支持热更新,需重启 Pod

**强制触发更新**:

```bash
# 重启 Deployment(滚动更新)
kubectl rollout restart deployment myapp
```

### 三、Secret 详解

#### 1. Secret 类型

| 类型                               | 用途                          | 示例                        |
| ---------------------------------- | ----------------------------- | --------------------------- |
| `Opaque`(默认)                     | 通用密钥(密码、Token)         | 数据库密码、API Key         |
| `kubernetes.io/tls`                | TLS 证书                      | HTTPS 证书(cert + key)      |
| `kubernetes.io/dockerconfigjson`   | 拉取私有镜像的凭证            | Docker Hub、Harbor 认证     |
| `kubernetes.io/basic-auth`         | HTTP Basic 认证               | 用户名 + 密码               |
| `kubernetes.io/ssh-auth`           | SSH 密钥                      | Git 私钥                    |
| `kubernetes.io/service-account-token` | ServiceAccount Token(自动创建)| Pod 访问 API Server 凭证    |

#### 2. 创建 Secret

**命令行创建**:

```bash
# 通用 Secret(Opaque)
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=P@ssw0rd

# TLS 证书
kubectl create secret tls tls-secret \
  --cert=server.crt \
  --key=server.key

# Docker 镜像仓库认证
kubectl create secret docker-registry harbor-secret \
  --docker-server=harbor.example.com \
  --docker-username=admin \
  --docker-password=Harbor12345 \
  --docker-email=admin@example.com
```

**YAML 定义**(需手动 base64 编码):

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  # 值必须是 base64 编码
  username: YWRtaW4=       # admin
  password: UEBzc3cwcmQ=   # P@ssw0rd

# 或使用 stringData(K8s 自动编码)
stringData:
  username: admin
  password: P@ssw0rd
```

**base64 编解码**:

```bash
# 编码
echo -n "admin" | base64  # YWRtaW4=

# 解码
echo "YWRtaW4=" | base64 -d  # admin
```

#### 3. 使用 Secret

##### 方式一:环境变量注入

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: db-client
spec:
  containers:
  - name: mysql-client
    image: mysql:8.0
    env:
    - name: MYSQL_USER
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: MYSQL_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
```

##### 方式二:Volume 挂载

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-server
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: tls
      mountPath: /etc/nginx/ssl
      readOnly: true
  volumes:
  - name: tls
    secret:
      secretName: tls-secret
      items:
      - key: tls.crt
        path: server.crt
      - key: tls.key
        path: server.key
```

**挂载后文件**:

- `/etc/nginx/ssl/server.crt`
- `/etc/nginx/ssl/server.key`

##### 方式三:imagePullSecrets(拉取私有镜像)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: private-app
spec:
  imagePullSecrets:
  - name: harbor-secret  # 引用 docker-registry 类型的 Secret
  containers:
  - name: app
    image: harbor.example.com/project/myapp:1.0
```

**全局配置**:将 Secret 绑定到 ServiceAccount

```bash
kubectl patch serviceaccount default \
  -p '{"imagePullSecrets": [{"name": "harbor-secret"}]}'
```

此后该命名空间所有 Pod 默认使用该 Secret 拉取镜像。

### 四、ConfigMap vs Secret 对比

| 特性           | ConfigMap                      | Secret                            |
| -------------- | ------------------------------ | --------------------------------- |
| **用途**       | 非敏感配置                     | 敏感数据(密码、证书、密钥)        |
| **存储格式**   | 明文                           | base64 编码(非加密!)              |
| **大小限制**   | 1MB                            | 1MB                               |
| **挂载方式**   | 环境变量、Volume               | 环境变量、Volume、imagePullSecrets|
| **热更新**     | Volume 挂载支持(延迟~1min)     | 同 ConfigMap                      |
| **etcd 加密**  | 默认明文存储                   | 可配置加密(EncryptionConfiguration)|

**重要提示**:Secret 的 base64 编码仅用于存储二进制数据,**不是加密**!任何能访问 etcd 或有 `get secret` 权限的用户都能看到原始数据。

### 五、安全加固最佳实践

#### 1. etcd 静态加密

K8s 1.13+ 支持对 Secret 进行加密存储。

**配置加密**(需在 API Server 配置):

```yaml
# encryption-config.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - aescbc:  # AES-CBC 加密
        keys:
        - name: key1
          secret: <base64-encoded-32-byte-key>
    - identity: {}  # 回退到明文(用于解密旧数据)
```

**启用加密**:

```bash
# API Server 启动参数添加
--encryption-provider-config=/etc/kubernetes/encryption-config.yaml

# 重新加密所有 Secret
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```

#### 2. RBAC 权限控制

限制对 Secret 的访问权限:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]  # 只允许读取,禁止 create/update/delete
  resourceNames: ["db-secret"]  # 只允许访问特定 Secret
```

#### 3. 使用外部密钥管理系统

对于高安全需求场景,不应将敏感数据存储在 K8s 中,而是使用专业密钥管理服务:

- **HashiCorp Vault**:集成 Vault Agent Injector,自动注入密钥
- **AWS Secrets Manager**:通过 External Secrets Operator 同步
- **Azure Key Vault**:使用 Secrets Store CSI Driver
- **阿里云 KMS**:通过 KMS 插件加密 Secret

**External Secrets Operator 示例**:

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: vault-secret
spec:
  secretStoreRef:
    name: vault-backend
  target:
    name: app-secret  # 生成的 K8s Secret 名称
  data:
  - secretKey: password  # K8s Secret 的 key
    remoteRef:
      key: secret/data/db  # Vault 路径
      property: password
```

#### 4. 镜像扫描与审计

- **禁止将 Secret 硬编码在镜像中**:使用镜像扫描工具(Trivy、Clair)检测泄露
- **审计日志**:开启 API Server 审计,记录 Secret 访问记录

### 六、常见使用场景

#### 1. 数据库连接配置

```yaml
# ConfigMap 存储非敏感配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: db-config
data:
  DB_HOST: "mysql.default.svc.cluster.local"
  DB_PORT: "3306"
  DB_NAME: "myapp"

---
# Secret 存储敏感信息
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
stringData:
  DB_USER: "admin"
  DB_PASSWORD: "P@ssw0rd"

---
# Pod 同时使用 ConfigMap 和 Secret
apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp
    envFrom:
    - configMapRef:
        name: db-config
    - secretRef:
        name: db-secret
```

#### 2. TLS 证书自动挂载

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-https
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 443
        volumeMounts:
        - name: tls
          mountPath: /etc/nginx/ssl
          readOnly: true
        - name: config
          mountPath: /etc/nginx/conf.d/default.conf
          subPath: default.conf
      volumes:
      - name: tls
        secret:
          secretName: tls-secret
      - name: config
        configMap:
          name: nginx-config
```

#### 3. 多环境配置管理

通过不同命名空间或 Kustomize 管理多环境配置:

```bash
# 开发环境
kubectl create configmap app-config --from-file=dev.env -n dev

# 生产环境
kubectl create configmap app-config --from-file=prod.env -n prod
```

**Kustomize 方案**:

```yaml
# base/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  LOG_LEVEL: info

---
# overlays/prod/configmap-patch.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  LOG_LEVEL: warn  # 生产环境覆盖
  MAX_CONNECTIONS: "1000"
```

```bash
kubectl apply -k overlays/prod/
```

### 七、常见问题与排查

| 问题                      | 原因                                  | 解决方法                             |
| ------------------------- | ------------------------------------- | ------------------------------------ |
| Pod 启动失败(ConfigMapNotFound)| ConfigMap 不存在或命名空间错误     | 检查 `kubectl get cm -n <ns>`        |
| 环境变量未注入            | key 名称错误或 ConfigMap 未更新       | 查看 `kubectl describe pod`          |
| Volume 挂载为空目录       | ConfigMap 中 key 不存在               | 检查 `items[].key` 是否正确          |
| Secret 数据乱码           | base64 编码问题                       | 使用 `stringData` 代替 `data`        |
| 配置更新后 Pod 未生效     | 使用环境变量注入,不支持热更新         | 改用 Volume 挂载,或重启 Pod          |
| 权限拒绝(Forbidden)       | ServiceAccount 无权限访问 Secret      | 检查 RBAC 规则                       |

**调试命令**:

```bash
# 查看 ConfigMap 内容
kubectl get configmap app-config -o yaml

# 查看 Secret 原始数据
kubectl get secret db-secret -o jsonpath='{.data.password}' | base64 -d

# 查看 Pod 环境变量
kubectl exec <pod-name> -- env

# 查看 Volume 挂载内容
kubectl exec <pod-name> -- ls -la /etc/config
kubectl exec <pod-name> -- cat /etc/config/app.json
```

### 八、总结

**ConfigMap 和 Secret 是 K8s 配置管理的基石**,实现了配置与代码的解耦,提升了应用的可移植性和安全性。

**核心设计理念**:

- **声明式配置**:配置作为 K8s 资源对象管理,支持版本控制
- **多种注入方式**:环境变量(简单)、Volume(支持热更新)、API(高级场景)
- **分层管理**:ConfigMap 存储通用配置,Secret 存储敏感数据

**最佳实践总结**:

1. **永远不要将 Secret 硬编码在代码或镜像中**
2. **使用 Volume 挂载而非环境变量**(支持热更新,避免日志泄露)
3. **启用 etcd 加密**,或使用外部密钥管理系统(Vault、云 KMS)
4. **通过 RBAC 严格控制 Secret 访问权限**
5. **使用 Kustomize 或 Helm 管理多环境配置**

在生产环境中,建议结合 GitOps 工具(ArgoCD、FluxCD)实现配置的自动化同步和审计,确保配置变更的可追溯性。
