---
title: Kubernetes 的 StatefulSet 和有状态应用
tags:
  - Kubernetes
status: robot
class: Kubernetes
slug: statefulset-and-stateful-applications
ref:
---

## 核心要点

**StatefulSet 是 K8s 用于管理有状态应用的控制器,提供稳定的网络标识(Pod 名称固定)、有序部署/扩缩容、持久化存储(PVC 自动绑定)等能力。与 Deployment 不同,StatefulSet 中的每个 Pod 都有唯一身份,适合数据库、消息队列、分布式存储等有状态服务。**

---

## 详细回答

### 一、什么是有状态应用?为什么需要 StatefulSet?

#### 有状态 vs 无状态应用

| 特性           | 无状态应用(Stateless)              | 有状态应用(Stateful)                     |
| -------------- | ---------------------------------- | ---------------------------------------- |
| **数据存储**   | 不存储数据或数据在外部(如数据库)   | 存储数据在本地磁盘                       |
| **实例可互换** | 任意实例都相同,可随意替换           | 每个实例有独立身份和数据,不可互换         |
| **网络标识**   | 不关心 IP 和主机名                  | 需要稳定的网络标识(如固定主机名)         |
| **启动顺序**   | 无顺序要求,可并行启动               | 有顺序依赖(如主从复制需要先启主节点)     |
| **扩缩容**     | 随意增删实例                        | 需按顺序扩缩容,避免数据丢失               |
| **示例**       | Web 服务、API 网关、无状态微服务    | MySQL、Redis、Kafka、ZooKeeper、Elasticsearch |

#### Deployment 的局限性

Deployment 设计用于无状态应用,存在以下问题:

- **Pod 名称随机**:如 `nginx-deployment-7d6b8c9f4-x5k2m`,重启后名称变化
- **无持久化身份**:Pod 重建后 IP、主机名都变化,无法用于主从选举
- **无序部署**:所有 Pod 并行创建,无法保证启动顺序
- **PVC 共享**:所有 Pod 使用同一个 PVC,无法实现每个 Pod 独立存储

**StatefulSet 解决的核心问题**:

1. **稳定的网络标识**:Pod 名称固定(如 `mysql-0`、`mysql-1`),重启后不变
2. **稳定的持久化存储**:每个 Pod 自动绑定独立的 PVC,数据不丢失
3. **有序部署/扩缩容**:按索引顺序启动(0 → 1 → 2),缩容时逆序删除(2 → 1 → 0)
4. **有序滚动更新**:从最大索引开始逐个更新,确保服务稳定

### 二、StatefulSet 架构与特性

#### 1. 核心特性

**稳定的网络标识**:

- Pod 名称格式:`<statefulset-name>-<ordinal-index>`
  - 例:`mysql-0`、`mysql-1`、`mysql-2`
  - 重启后名称不变
- 通过 Headless Service 访问:
  - Pod FQDN:`<pod-name>.<service-name>.<namespace>.svc.cluster.local`
  - 例:`mysql-0.mysql.default.svc.cluster.local`

**稳定的持久化存储**:

- 通过 `volumeClaimTemplates` 自动为每个 Pod 创建独立的 PVC
- PVC 名称格式:`<pvc-name>-<pod-name>`
  - 例:`data-mysql-0`、`data-mysql-1`
- Pod 删除后 PVC 不会自动删除,重新创建的 Pod 会绑定原来的 PVC

**有序部署与扩缩容**:

- **扩容**:顺序创建 Pod(0 → 1 → 2),每个 Pod 就绪后才创建下一个
- **缩容**:逆序删除 Pod(2 → 1 → 0),先删最新的
- **更新**:默认从最大索引开始逐个更新(RollingUpdate)

#### 2. StatefulSet vs Deployment 对比

| 特性               | StatefulSet                          | Deployment                           |
| ------------------ | ------------------------------------ | ------------------------------------ |
| **Pod 名称**       | 固定(mysql-0,mysql-1)                | 随机(nginx-7d6b8c9f4-x5k2m)          |
| **网络标识**       | 稳定(通过 Headless Service)          | 不稳定(IP 变化)                      |
| **存储**           | 每个 Pod 独立 PVC                    | 所有 Pod 共享 PVC 或无持久化          |
| **启动顺序**       | 有序(0 → 1 → 2)                      | 无序(并行启动)                       |
| **扩缩容**         | 有序扩缩容                           | 随意扩缩容                           |
| **更新策略**       | RollingUpdate(从大到小)或 OnDelete   | RollingUpdate 或 Recreate            |
| **适用场景**       | 有状态应用(数据库、消息队列)        | 无状态应用(Web 服务、API)            |

### 三、StatefulSet 定义与使用

#### 1. 完整示例(MySQL 主从复制)

```yaml
# Headless Service(用于稳定网络标识)
apiVersion: v1
kind: Service
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  clusterIP: None  # Headless Service 的关键
  selector:
    app: mysql
  ports:
  - name: mysql
    port: 3306

---
# StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql  # 关联 Headless Service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
          name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "password"
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
        - name: config
          mountPath: /etc/mysql/conf.d
      volumes:
      - name: config
        configMap:
          name: mysql-config
  # volumeClaimTemplates:自动为每个 Pod 创建 PVC
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "standard"
      resources:
        requests:
          storage: 10Gi
```

**关键点解析**:

##### Headless Service(`clusterIP: None`)

- **作用**:为每个 Pod 创建稳定的 DNS 记录,无需通过 ClusterIP 负载均衡
- **DNS 解析**:
  - Service 域名:`mysql.default.svc.cluster.local` → 所有 Pod IP
  - Pod 域名:`mysql-0.mysql.default.svc.cluster.local` → mysql-0 的 IP
- **为什么需要 Headless Service?**
  - 有状态应用需要直连特定 Pod(如主节点),而非随机负载均衡
  - 应用内部通过固定主机名进行主从选举、数据同步

##### serviceName 字段

- **作用**:指定关联的 Headless Service 名称
- **必须存在**:StatefulSet 依赖 Headless Service 生成 Pod DNS 记录

##### volumeClaimTemplates

- **作用**:自动为每个 Pod 创建独立的 PVC
- **生成 PVC 名称**:`<pvc-name>-<pod-name>`
  - 例:`data-mysql-0`,`data-mysql-1`,`data-mysql-2`
- **PVC 生命周期**:
  - Pod 删除后 PVC 不会删除(数据保留)
  - 重新创建同名 Pod 会自动绑定原来的 PVC
  - 手动删除 StatefulSet 不会删除 PVC(需显式删除)

#### 2. 常用操作命令

```bash
# 创建 StatefulSet
kubectl apply -f statefulset.yaml

# 查看 StatefulSet 状态
kubectl get statefulsets
kubectl describe statefulset mysql

# 查看 Pod(按索引排序)
kubectl get pods -l app=mysql
# 输出示例:
# mysql-0   1/1   Running   0   5m
# mysql-1   1/1   Running   0   4m
# mysql-2   1/1   Running   0   3m

# 查看 PVC(每个 Pod 对应一个)
kubectl get pvc -l app=mysql
# 输出示例:
# data-mysql-0   Bound   pv-001   10Gi
# data-mysql-1   Bound   pv-002   10Gi
# data-mysql-2   Bound   pv-003   10Gi

# 扩容(会创建 mysql-3)
kubectl scale statefulset mysql --replicas=4

# 缩容(会删除 mysql-3)
kubectl scale statefulset mysql --replicas=3

# 访问特定 Pod
kubectl exec -it mysql-0 -- mysql -u root -p

# 通过 DNS 访问(集群内)
mysql -h mysql-0.mysql.default.svc.cluster.local -u root -p

# 删除 StatefulSet(保留 Pod)
kubectl delete statefulset mysql --cascade=orphan

# 删除 StatefulSet 和 Pod(但保留 PVC)
kubectl delete statefulset mysql

# 删除 PVC(需显式操作)
kubectl delete pvc data-mysql-0 data-mysql-1 data-mysql-2
```

### 四、有序部署与更新机制

#### 1. Pod 管理策略(podManagementPolicy)

| 策略类型       | 行为                                 | 适用场景             |
| -------------- | ------------------------------------ | -------------------- |
| **OrderedReady**(默认)| 顺序启动,每个 Pod 就绪后才创建下一个 | 有启动依赖的应用(如主从复制) |
| **Parallel**   | 并行启动,类似 Deployment             | 独立节点(如分片集群) |

**示例**:

```yaml
spec:
  podManagementPolicy: Parallel  # 并行启动
```

**OrderedReady 流程**:

```
创建 mysql-0 → 等待 Ready → 创建 mysql-1 → 等待 Ready → 创建 mysql-2
```

**Parallel 流程**:

```
同时创建 mysql-0、mysql-1、mysql-2(类似 Deployment)
```

#### 2. 更新策略(updateStrategy)

##### RollingUpdate(默认)

从最大索引开始逐个更新,每个 Pod 更新完成并就绪后才更新下一个。

```yaml
spec:
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 0  # 灰度发布:只更新索引 >= partition 的 Pod
```

**更新流程**:

```bash
kubectl set image statefulset/mysql mysql=mysql:8.1
```

更新顺序:mysql-2 → mysql-1 → mysql-0

**partition 灰度发布**:

```yaml
# 第 1 步:只更新 mysql-2(partition=2)
spec:
  updateStrategy:
    rollingUpdate:
      partition: 2
# 应用后只有 mysql-2 更新到新版本

# 第 2 步:验证无问题,更新 mysql-1 和 mysql-2(partition=1)
spec:
  updateStrategy:
    rollingUpdate:
      partition: 1

# 第 3 步:全量更新(partition=0,默认)
spec:
  updateStrategy:
    rollingUpdate:
      partition: 0
```

##### OnDelete(手动更新)

只有手动删除 Pod 时才会使用新配置重建,适合需要人工介入的场景。

```yaml
spec:
  updateStrategy:
    type: OnDelete
```

**使用场景**:

- 数据库迁移需要逐个节点验证
- 需要在更新前手动备份数据

**操作流程**:

```bash
# 1. 更新 StatefulSet(Pod 不会自动更新)
kubectl apply -f statefulset.yaml

# 2. 手动删除 Pod(会用新配置重建)
kubectl delete pod mysql-2
# 等待 mysql-2 重建完成

kubectl delete pod mysql-1
# 等待 mysql-1 重建完成

kubectl delete pod mysql-0
```

### 五、常见有状态应用实践

#### 1. MySQL 主从复制

**架构**:1 个主节点(mysql-0)+ 多个从节点(mysql-1,mysql-2)

**关键配置**:

```yaml
# ConfigMap(主从配置)
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  master.cnf: |
    [mysqld]
    server-id = 1
    log-bin = mysql-bin
  slave.cnf: |
    [mysqld]
    server-id = 2
    relay-log = mysql-relay

---
# StatefulSet 初始化容器(根据 Pod 序号配置主从)
spec:
  template:
    spec:
      initContainers:
      - name: init-mysql
        image: mysql:8.0
        command:
        - bash
        - "-c"
        - |
          set -ex
          # 根据 Pod 名称判断主从
          [[ $(hostname) =~ -([0-9]+)$ ]] || exit 1
          ordinal=${BASH_REMATCH[1]}
          if [[ $ordinal -eq 0 ]]; then
            cp /mnt/config/master.cnf /etc/mysql/conf.d/
          else
            cp /mnt/config/slave.cnf /etc/mysql/conf.d/
          fi
        volumeMounts:
        - name: config
          mountPath: /mnt/config
        - name: conf
          mountPath: /etc/mysql/conf.d
      volumes:
      - name: conf
        emptyDir: {}
```

**主从切换**:通过外部工具(如 Orchestrator、MHA)监控主节点健康,故障时提升从节点为主。

#### 2. Redis 集群(主从 + Sentinel)

**架构**:3 个 Redis 主节点 + 3 个从节点 + 3 个 Sentinel

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis
spec:
  serviceName: redis
  replicas: 6
  template:
    spec:
      containers:
      - name: redis
        image: redis:7.0
        command:
        - sh
        - -c
        - |
          # 根据序号判断主从
          if [[ $(hostname) =~ -([0-3])$ ]]; then
            redis-server --port 6379  # 主节点
          else
            redis-server --port 6379 --slaveof redis-0.redis 6379  # 从节点
          fi
```

**访问方式**:应用通过 Sentinel 自动发现主节点,无需硬编码 IP。

#### 3. Kafka 集群

**架构**:3 个 Broker + ZooKeeper(或 KRaft 模式)

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kafka
spec:
  serviceName: kafka
  replicas: 3
  template:
    spec:
      containers:
      - name: kafka
        image: confluentinc/cp-kafka:7.5.0
        env:
        - name: KAFKA_BROKER_ID
          valueFrom:
            fieldRef:
              fieldPath: metadata.name  # 使用 Pod 名称作为 broker.id
        - name: KAFKA_ADVERTISED_LISTENERS
          value: "PLAINTEXT://$(hostname -f):9092"  # 使用 FQDN
        - name: KAFKA_ZOOKEEPER_CONNECT
          value: "zk-0.zk:2181,zk-1.zk:2181,zk-2.zk:2181"
```

**关键点**:

- `KAFKA_BROKER_ID`:使用 Pod 序号(kafka-0 → 0,kafka-1 → 1)
- `KAFKA_ADVERTISED_LISTENERS`:使用 Headless Service 的 FQDN,确保客户端能连接到固定节点

#### 4. Elasticsearch 集群

**架构**:3 个 Master 节点 + N 个 Data 节点

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: es-master
spec:
  serviceName: es-master
  replicas: 3
  template:
    spec:
      containers:
      - name: elasticsearch
        image: elasticsearch:8.10.0
        env:
        - name: cluster.name
          value: "es-cluster"
        - name: node.name
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: discovery.seed_hosts
          value: "es-master-0.es-master,es-master-1.es-master,es-master-2.es-master"
        - name: cluster.initial_master_nodes
          value: "es-master-0,es-master-1,es-master-2"
```

**优势**:通过 StatefulSet 保证 Master 节点的稳定身份,避免脑裂。

### 六、生产环境最佳实践

#### 1. 资源规划

```yaml
spec:
  template:
    spec:
      containers:
      - name: mysql
        resources:
          requests:
            cpu: 2
            memory: 4Gi
          limits:
            cpu: 4
            memory: 8Gi
```

**存储选型**:

- **本地盘(Local PV)**:IOPS 最高,但节点故障数据丢失
- **云盘(EBS,云硬盘)**:性能好,支持快照备份
- **分布式存储(Ceph,Longhorn)**:高可用,跨节点数据冗余

#### 2. 高可用配置

**反亲和性**(避免单点故障):

```yaml
spec:
  template:
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                app: mysql
            topologyKey: kubernetes.io/hostname  # 不同节点
```

**PodDisruptionBudget**(防止节点维护时集群不可用):

```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: mysql-pdb
spec:
  minAvailable: 2  # 至少保持 2 个 Pod 运行
  selector:
    matchLabels:
      app: mysql
```

#### 3. 备份与恢复

**定期备份**:

```bash
# 备份 mysql-0 的数据
kubectl exec mysql-0 -- mysqldump -u root -p --all-databases > backup.sql

# 或使用 CronJob 自动备份
```

**使用 Velero 备份整个 StatefulSet**:

```bash
velero backup create mysql-backup --selector app=mysql
```

#### 4. 监控与告警

**Prometheus 监控指标**:

- Pod 状态:`kube_statefulset_replicas` vs `kube_statefulset_status_replicas_ready`
- PVC 使用率:避免磁盘满
- 应用指标:MySQL 连接数、Redis 内存使用、Kafka 消息堆积

### 七、常见问题排查

| 问题                       | 原因                                 | 解决方法                             |
| -------------------------- | ------------------------------------ | ------------------------------------ |
| Pod 一直 Pending           | PVC 无法绑定(无可用 PV)              | 检查 StorageClass 和 PV 容量         |
| Pod 启动失败(CrashLoopBackOff)| 配置错误或数据损坏                 | 查看日志,检查挂载的 PVC 数据         |
| 扩容后新 Pod 无法启动      | 主从配置未适配新节点                 | 检查初始化脚本,确保支持动态扩容       |
| 缩容后数据丢失             | PVC 被误删                           | 确认 PVC 保留策略,备份数据           |
| DNS 解析失败               | Headless Service 配置错误            | 检查 serviceName 是否匹配            |
| 滚动更新卡住               | 新 Pod 未就绪                        | 检查 readinessProbe 配置             |

**调试命令**:

```bash
# 查看 StatefulSet 事件
kubectl describe statefulset mysql

# 查看 Pod 日志
kubectl logs mysql-0

# 查看 PVC 绑定状态
kubectl get pvc -l app=mysql

# 进入 Pod 调试
kubectl exec -it mysql-0 -- bash

# 测试 DNS 解析
kubectl run -it --rm debug --image=busybox -- nslookup mysql-0.mysql.default.svc.cluster.local
```

### 八、总结

**StatefulSet 是 K8s 管理有状态应用的核心**,通过稳定的网络标识、独立的持久化存储和有序的部署更新机制,满足了数据库、消息队列、分布式存储等有状态服务的需求。

**核心特性**:

- **稳定的网络标识**:Pod 名称和 DNS 固定,重启后不变
- **独立的持久化存储**:每个 Pod 自动绑定独立的 PVC
- **有序部署/扩缩容**:按索引顺序创建/删除,保证数据安全
- **有序滚动更新**:从大到小逐个更新,支持灰度发布(partition)

**最佳实践总结**:

1. **必须配置 Headless Service**,提供稳定的 DNS 解析
2. **使用 volumeClaimTemplates 实现每个 Pod 独立存储**
3. **配置反亲和性和 PodDisruptionBudget 保证高可用**
4. **定期备份数据**,使用 Velero 或应用层备份工具
5. **监控 PVC 使用率和应用健康指标**

**适用场景**:

- **数据库**:MySQL、PostgreSQL、MongoDB
- **缓存**:Redis Cluster
- **消息队列**:Kafka、RabbitMQ
- **分布式存储**:Elasticsearch、Cassandra、CockroachDB
- **协调服务**:ZooKeeper、etcd

对于无状态应用,应优先使用 Deployment,StatefulSet 只在需要稳定身份和持久化存储时使用。
