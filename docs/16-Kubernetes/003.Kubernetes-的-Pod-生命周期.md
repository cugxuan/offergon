---
title: Kubernetes 的 Pod 生命周期
tags:
  - Kubernetes
status: robot
class: Kubernetes
slug: kubernetes-pod-lifecycle
ref:
---

## 核心要点

**Pod 五大阶段**：Pending（等待调度/拉镜像）→ Running（至少一个容器运行中）→ Succeeded/Failed（终止状态）→ Unknown（通信失败）；**启动流程**：Init 容器 → 主容器 → PostStart 钩子；**健康检查**：Liveness（存活探针，失败则重启）、Readiness（就绪探针，失败则移出 Service）、Startup（启动探针，保护慢启动容器）；**优雅终止**：PreStop 钩子 → SIGTERM → 宽限期 → SIGKILL

---

## 详细回答

### 一、Pod 生命周期概览

Pod 是 Kubernetes 中**最小的调度单元**，其生命周期从创建到终止包含多个阶段和关键节点。理解 Pod 生命周期对于应用调试、健康检查和优雅关闭至关重要。

**生命周期图示**：
```
创建 → Pending → Running → Succeeded/Failed
                              ↓
                          Unknown（异常状态）
```

---

### 二、Pod 五大状态（Phase）

#### 1. **Pending（挂起）**

**含义**：Pod 已被 Kubernetes 接受，但一个或多个容器尚未创建或运行。

**常见原因**：
- **等待调度**：Scheduler 尚未为 Pod 分配节点
  - 资源不足（CPU/内存/磁盘）
  - 节点亲和性/污点不匹配
  - PV 无法挂载
- **拉取镜像**：节点正在下载容器镜像
  - 镜像较大导致拉取缓慢
  - 镜像拉取策略配置错误（如 ImagePullBackOff）
  - 私有仓库认证失败

**排查命令**：
```bash
kubectl describe pod <pod-name>  # 查看事件（Events）
kubectl get pod <pod-name> -o yaml  # 查看详细状态
```

---

#### 2. **Running（运行中）**

**含义**：Pod 已绑定到节点，所有容器已创建，**至少一个容器正在运行**或正在启动/重启。

**特点**：
- 不代表所有容器都健康（可能部分容器崩溃重启）
- Readiness 探针可能尚未通过（Pod 未准备好接收流量）

**查看容器状态**：
```bash
kubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[*].state}'
```

---

#### 3. **Succeeded（成功）**

**含义**：Pod 中**所有容器**都已**正常终止**（退出码为 0），且不会重启。

**适用场景**：
- **Job**：一次性任务（如数据迁移、批处理）
- **CronJob**：定时任务

**示例**：
```yaml
apiVersion: v1
kind: Pod
spec:
  restartPolicy: Never  # 或 OnFailure
  containers:
  - name: task
    image: busybox
    command: ["echo", "Task completed"]
```

---

#### 4. **Failed（失败）**

**含义**：Pod 中**所有容器**都已终止，且**至少一个容器**以非零退出码终止或被系统终止。

**常见原因**：
- 应用崩溃（如空指针异常、Panic）
- 容器被 OOMKilled（内存超限）
- 主进程退出码非零
- Liveness 探针持续失败导致容器被杀死

**查看失败原因**：
```bash
kubectl logs <pod-name> --previous  # 查看崩溃前的日志
kubectl describe pod <pod-name>  # 查看退出码和原因
```

---

#### 5. **Unknown（未知）**

**含义**：无法获取 Pod 状态，通常是**节点通信故障**。

**常见场景**：
- 节点网络断开
- Kubelet 进程崩溃或停止响应
- 节点宕机

**处理**：
- 检查节点状态：`kubectl get nodes`
- 驱逐 Pod：Kubernetes 会在超时后将 Pod 标记为 Terminating 并在其他节点重建

---

### 三、Pod 启动流程详解

#### **完整启动流程**：

```
1. API Server 创建 Pod 对象（状态：Pending）
2. Scheduler 选择节点并绑定
3. Kubelet 监听到 Pod 分配到本节点
4. 拉取镜像（如需要）
5. 创建 Pause 容器（Pod 的网络和存储基础）
6. 依次运行 Init 容器（串行执行）
7. 启动主容器（并行启动）
8. 执行 PostStart 钩子（如定义）
9. 执行健康检查（Startup → Liveness/Readiness）
10. 状态变为 Running
```

---

#### 1. **Init 容器（Init Containers）**

**作用**：在主容器启动前运行的**初始化容器**，用于准备环境。

**特点**：
- **串行执行**：按定义顺序依次运行，前一个成功后才启动下一个
- **必须成功**：所有 Init 容器成功后才启动主容器
- **独立镜像**：可使用与主容器不同的镜像和工具

**应用场景**：
- 等待依赖服务就绪（如数据库启动）
- 执行数据库迁移
- 下载配置文件或证书
- 修改文件权限

**示例**：
```yaml
spec:
  initContainers:
  - name: wait-for-db
    image: busybox
    command: ['sh', '-c', 'until nslookup mysql; do sleep 2; done']
  containers:
  - name: app
    image: myapp
```

---

#### 2. **主容器（Main Containers）**

**启动方式**：
- 所有主容器**并行启动**（无依赖顺序）
- 通过 Startup 探针确定启动完成

---

#### 3. **PostStart 钩子（Container Lifecycle Hook）**

**作用**：容器启动后**立即执行**的操作。

**特点**：
- 与容器主进程**并发执行**（不阻塞主进程）
- 如果 PostStart 失败，容器会被终止并根据 `restartPolicy` 重启

**应用场景**：
- 注册服务到服务发现系统
- 发送通知（如 Slack 消息）
- 执行额外的初始化脚本

**示例**：
```yaml
lifecycle:
  postStart:
    exec:
      command: ["/bin/sh", "-c", "echo Container started > /tmp/startup.log"]
```

---

### 四、健康检查（Probes）

Kubernetes 提供三种探针来监控容器健康状态：

#### 1. **Startup Probe（启动探针）**

**作用**：检测容器是否**已完成启动**。

**适用场景**：
- 启动时间长的应用（如 Java 应用需预热）
- 防止 Liveness 探针过早杀死容器

**行为**：
- Startup 探针成功前，Liveness 和 Readiness 探针**不会运行**
- 如果 Startup 探针在指定时间内失败，容器被杀死并重启

**示例**：
```yaml
startupProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 0
  periodSeconds: 10
  failureThreshold: 30  # 最多等待 300 秒（10*30）
```

---

#### 2. **Liveness Probe（存活探针）**

**作用**：检测容器是否**仍在运行**（应用是否死锁或崩溃）。

**行为**：
- 探针失败 → Kubelet 杀死容器 → 根据 `restartPolicy` 重启

**应用场景**：
- 检测应用死锁（进程存在但无响应）
- 检测崩溃（如内存泄漏导致 OOM）

**示例**：
```yaml
livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3  # 连续失败 3 次才重启
```

---

#### 3. **Readiness Probe（就绪探针）**

**作用**：检测容器是否**准备好接收流量**。

**行为**：
- 探针失败 → Pod 从 Service 的 Endpoints 中移除（不再接收流量）
- 探针成功 → Pod 重新加入 Service

**应用场景**：
- 应用启动后需加载数据或缓存
- 依赖外部服务（数据库未连接时不接受请求）
- 滚动更新时确保新 Pod 就绪后再终止旧 Pod

**示例**：
```yaml
readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 5
```

---

#### **三种探针对比**

| 探针 | 失败后果 | 适用场景 |
|------|---------|---------|
| Startup | 重启容器 | 保护慢启动应用 |
| Liveness | 重启容器 | 检测死锁/崩溃 |
| Readiness | 移出 Service | 控制流量接入 |

---

#### **探针实现方式**

1. **HTTP GET**：
```yaml
httpGet:
  path: /healthz
  port: 8080
  httpHeaders:
  - name: Custom-Header
    value: Awesome
```

2. **TCP Socket**：
```yaml
tcpSocket:
  port: 3306
```

3. **Exec 命令**：
```yaml
exec:
  command:
  - cat
  - /tmp/healthy
```

4. **gRPC**（Kubernetes 1.24+）：
```yaml
grpc:
  port: 9090
  service: liveness
```

---

### 五、Pod 终止流程

#### **优雅关闭流程**：

```
1. 用户删除 Pod（kubectl delete pod）
2. API Server 标记 Pod 为 Terminating
3. 同时执行以下操作：
   a. Endpoints Controller 从 Service 中移除 Pod（停止接收新流量）
   b. Kubelet 执行以下步骤：
      - 执行 PreStop 钩子（如定义）
      - 发送 SIGTERM 信号给容器主进程
      - 等待 terminationGracePeriodSeconds（默认 30 秒）
      - 如果超时，发送 SIGKILL 强制杀死
4. 容器终止后，Kubelet 清理资源（卷、网络）
5. Pod 从 API Server 删除
```

---

#### 1. **PreStop 钩子**

**作用**：容器终止前执行的操作（如优雅关闭连接、注销服务）。

**特点**：
- **阻塞容器终止**：PreStop 完成后才发送 SIGTERM
- 计入 `terminationGracePeriodSeconds` 时间

**示例**：
```yaml
lifecycle:
  preStop:
    exec:
      command: ["/bin/sh", "-c", "sleep 15"]  # 等待请求处理完成
```

---

#### 2. **宽限期（Grace Period）**

**配置**：
```yaml
spec:
  terminationGracePeriodSeconds: 60  # 默认 30 秒
```

**注意**：
- 宽限期包括 PreStop 钩子执行时间
- 超时后 Kubelet 强制杀死容器（SIGKILL）

---

#### 3. **最佳实践**

1. **应用捕获 SIGTERM**：
```go
// Go 示例
sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, syscall.SIGTERM)
<-sigChan
// 执行清理操作（关闭数据库连接、保存状态等）
```

2. **避免数据丢失**：
   - 使用 PreStop 钩子等待正在处理的请求完成
   - 持久化重要数据到存储卷

3. **设置合理的宽限期**：
   - 默认 30 秒对大多数应用足够
   - 长任务应用（如批处理）需增加宽限期

---

### 六、重启策略（Restart Policy）

**三种策略**：

1. **Always（默认）**：
   - 容器终止后总是重启
   - 适用于长期运行的服务（如 Web 服务、API）

2. **OnFailure**：
   - 容器非零退出时重启，正常退出（退出码 0）不重启
   - 适用于 Job

3. **Never**：
   - 容器终止后不重启
   - 适用于一次性任务

**示例**：
```yaml
spec:
  restartPolicy: OnFailure
```

---

### 七、常见问题与面试追问

#### **Q1：Pod 一直处于 Pending 状态怎么办？**
1. 检查调度问题：`kubectl describe pod <pod-name>`
   - 资源不足：调整资源请求或扩容节点
   - 污点/亲和性：检查节点标签和污点配置
2. 检查镜像拉取：
   - 查看 Events：`ImagePullBackOff` 或 `ErrImagePull`
   - 验证镜像地址和拉取凭证

---

#### **Q2：Liveness 和 Readiness 的区别？**
- **Liveness**：检测应用是否存活，失败则**重启容器**
- **Readiness**：检测应用是否就绪，失败则**移出 Service**（不重启）
- **关键区别**：Liveness 是"救命"，Readiness 是"控流"

---

#### **Q3：为什么需要 Startup 探针？**
- 某些应用（如 Java）启动时间长（可能几分钟）
- 如果只配置 Liveness，启动期间探针失败会导致容器被反复重启
- Startup 探针成功前，Liveness 不会运行，保护慢启动应用

---

#### **Q4：Pod 删除后为何还能看到？**
- Pod 进入 **Terminating** 状态后需要时间执行优雅关闭
- 如果 PreStop 钩子或应用清理时间过长，Pod 会一直显示
- 强制删除：`kubectl delete pod <pod-name> --grace-period=0 --force`

---

#### **Q5：如何实现零停机更新？**
1. 配置 Readiness 探针确保新 Pod 就绪
2. 使用 RollingUpdate 策略：
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0  # 确保至少保留所有副本
    maxSurge: 1        # 先启动新 Pod 再终止旧 Pod
```
3. 配置 PreStop 钩子和合理的宽限期
4. 应用捕获 SIGTERM 并优雅关闭

---

### 八、总结

Pod 生命周期管理的关键点：

1. **状态理解**：掌握 Pending、Running、Succeeded/Failed、Unknown 的含义和排查方法
2. **启动流程**：Init 容器 → 主容器 → PostStart → 健康检查
3. **健康检查**：
   - Startup 保护慢启动
   - Liveness 保证存活
   - Readiness 控制流量
4. **优雅终止**：PreStop → SIGTERM → 宽限期 → SIGKILL
5. **最佳实践**：
   - 合理配置资源请求/限制
   - 使用探针确保应用健康
   - 应用捕获 SIGTERM 实现优雅关闭
   - 设置合理的宽限期

理解 Pod 生命周期有助于构建健壮的应用和快速排查问题。
