---
title: Kubernetes 的架构和核心组件
tags:
  - Kubernetes
status: robot
class: Kubernetes
slug: kubernetes-architecture-core-components
ref:
---

## 核心要点

**控制平面（Master）+ 工作节点（Node）架构**：控制平面负责集群决策，工作节点运行应用容器；**核心组件**：API Server（集群网关）、etcd（分布式存储）、Scheduler（调度器）、Controller Manager（控制器）、Kubelet（节点代理）、Kube-proxy（网络代理）、Container Runtime（容器运行时）

---

## 详细回答

### 一、Kubernetes 整体架构

Kubernetes 采用**主从分布式架构**，分为两个核心部分：

#### 1. **控制平面（Control Plane / Master）**
- **职责**：负责集群的全局决策，包括调度、检测和响应集群事件
- **特点**：通常部署在专用节点上，实现高可用需要多副本部署

#### 2. **工作节点（Worker Node）**
- **职责**：运行实际的应用容器，接受控制平面的指令
- **特点**：可以动态扩缩容，每个节点运行必要的代理组件

---

### 二、控制平面核心组件

#### 1. **kube-apiserver（API 服务器）**

**作用**：
- 是整个集群的**唯一入口**和**核心网关**，所有组件都通过它交互
- 提供 RESTful API 接口供用户和组件调用
- 负责认证、授权、准入控制等安全机制
- 唯一直接与 etcd 交互的组件

**工作流程示例**：
```
用户执行 kubectl create pod → API Server 验证请求 → 写入 etcd →
Scheduler 监听到新 Pod → 分配节点 → Kubelet 创建容器
```

**特点**：
- 无状态，可水平扩展
- 所有组件通过 watch 机制监听 API Server 的资源变化

---

#### 2. **etcd（分布式键值存储）**

**作用**：
- 存储集群的**所有配置和状态数据**（如 Pod、Service、ConfigMap 等）
- 保证数据的强一致性（基于 Raft 协议）

**为什么选择 etcd**：
- 支持高可用（多副本）
- 提供 watch 机制，组件可实时监听数据变化
- 数据可靠性高，支持快照和备份

**注意事项**：
- etcd 性能直接影响集群性能，建议使用 SSD
- 生产环境至少部署 3 个 etcd 节点

---

#### 3. **kube-scheduler（调度器）**

**作用**：
- 为新创建的 Pod 选择合适的 Node
- 根据调度策略（资源需求、亲和性、污点容忍等）进行决策

**调度流程**：
1. **过滤**：筛选出满足条件的节点（如资源充足、无污点冲突）
2. **打分**：对候选节点评分（如资源利用率、数据本地性）
3. **绑定**：将 Pod 绑定到得分最高的节点

**扩展性**：
- 支持自定义调度器
- 支持调度插件（Scheduling Framework）

---

#### 4. **kube-controller-manager（控制器管理器）**

**作用**：
- 运行多个**控制器**，负责维护集群的**期望状态**
- 通过**控制循环**（Control Loop）不断调谐实际状态与期望状态

**核心控制器**：
- **Node Controller**：监控节点健康状态，处理节点故障
- **Replication Controller**：确保 Pod 副本数符合预期
- **Endpoints Controller**：维护 Service 和 Pod 的映射关系
- **ServiceAccount Controller**：为命名空间创建默认的 ServiceAccount

**工作原理**：
```
期望状态（Desired State）：Deployment 副本数 = 3
实际状态（Current State）：当前只有 2 个 Pod
→ Controller 创建 1 个新 Pod
```

---

#### 5. **cloud-controller-manager（云控制器管理器，可选）**

**作用**：
- 与云平台（AWS、Azure、GCP 等）集成
- 管理云资源（如负载均衡器、存储卷、节点生命周期）

**典型场景**：
- Service 类型为 LoadBalancer 时，自动创建云负载均衡器
- 删除节点时，通知云平台回收虚拟机

---

### 三、工作节点核心组件

#### 1. **kubelet（节点代理）**

**作用**：
- 运行在每个 Node 上的**核心代理**
- 负责管理 Pod 的生命周期（创建、启动、停止、监控）
- 通过 **PodSpec** 确保容器按预期运行

**工作流程**：
1. 监听 API Server 分配给本节点的 Pod
2. 调用 Container Runtime 创建容器
3. 定期上报 Pod 和 Node 状态给 API Server
4. 执行健康检查（Liveness/Readiness Probe）

**特点**：
- 支持静态 Pod（直接读取本地配置文件）
- 管理节点资源（如磁盘、网络）

---

#### 2. **kube-proxy（网络代理）**

**作用**：
- 维护节点上的**网络规则**，实现 Service 的负载均衡
- 将访问 Service 的流量转发到后端 Pod

**工作模式**：
- **iptables 模式**（默认）：通过 iptables 规则实现流量转发
- **IPVS 模式**：性能更高，支持更多负载均衡算法
- **userspace 模式**（已废弃）：通过用户空间代理转发

**示例**：
```
客户端访问 Service ClusterIP 10.96.0.10:80 →
kube-proxy 拦截流量 →
转发到后端 Pod 192.168.1.5:8080
```

---

#### 3. **Container Runtime（容器运行时）**

**作用**：
- 负责实际运行容器的软件（如 Docker、containerd、CRI-O）

**CRI 接口**：
- Kubernetes 通过 **Container Runtime Interface（CRI）** 与运行时交互
- 支持多种运行时，实现解耦

**主流运行时**：
- **containerd**：轻量级，CNCF 项目，推荐使用
- **CRI-O**：专为 Kubernetes 设计
- **Docker**（已弃用 dockershim）：需通过 cri-dockerd 适配

---

### 四、组件间交互流程示例

**创建 Deployment 的完整流程**：

1. 用户执行 `kubectl create deployment` → 请求发送到 **API Server**
2. **API Server** 验证请求并写入 **etcd**
3. **Deployment Controller** 监听到新的 Deployment，创建 ReplicaSet
4. **ReplicaSet Controller** 创建 Pod 对象（仅元数据，未分配节点）
5. **Scheduler** 监听到未调度的 Pod，选择合适的 Node 并绑定
6. **Kubelet** 监听到分配给本节点的 Pod，调用 Container Runtime 创建容器
7. **Kube-proxy** 更新网络规则，确保 Service 可访问 Pod

---

### 五、架构设计优势

1. **高可用性**：控制平面组件可多副本部署，etcd 支持分布式集群
2. **松耦合**：组件通过 API Server 交互，彼此独立，易于扩展和升级
3. **声明式设计**：用户描述期望状态，控制器自动调谐，减少手动干预
4. **可扩展性**：支持自定义 Controller、Scheduler、CNI、CSI 等插件

---

### 六、面试加分项

**追问：如果 API Server 宕机，集群会怎样？**
- 正在运行的 Pod 不受影响（Kubelet 和 kube-proxy 继续工作）
- 无法创建新资源或查询集群状态
- 控制器无法执行调谐操作（如故障恢复、扩缩容）

**追问：etcd 和 API Server 如何保证一致性？**
- API Server 通过乐观锁（Resource Version）防止并发冲突
- etcd 使用 Raft 协议保证分布式一致性

**追问：能否直接操作 etcd？**
- 不推荐，可能导致数据不一致（绕过准入控制、验证）
- 应始终通过 API Server 操作资源
