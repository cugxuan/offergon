---
title: Kubernetes 的 Service 和服务发现
tags:
  - Kubernetes
status: robot
class: Kubernetes
slug: kubernetes-service-discovery
ref:
---

## 核心要点

**Service 作用**：为动态变化的 Pod 提供稳定访问入口（固定 IP 和 DNS）；**四种类型**：ClusterIP（集群内访问）、NodePort（节点端口暴露）、LoadBalancer（云负载均衡器）、ExternalName（DNS CNAME）；**服务发现机制**：环境变量注入、DNS 解析（推荐）；**实现原理**：kube-proxy 通过 iptables/IPVS 实现负载均衡和流量转发；**高级特性**：Headless Service（无 ClusterIP，直接访问 Pod）、会话亲和性、拓扑感知路由

---

## 详细回答

### 一、为什么需要 Service？

在 Kubernetes 中，**Pod 是短暂的**：
- Pod 随时可能被销毁和重建（扩缩容、节点故障、滚动更新）
- 每次重建 Pod IP 都会变化
- 应用无法通过固定 IP 访问后端 Pod

**Service 解决的问题**：
1. **稳定访问入口**：提供固定的 ClusterIP 和 DNS 名称
2. **服务发现**：自动发现后端 Pod 并维护 Endpoints 列表
3. **负载均衡**：将流量分发到多个 Pod 副本
4. **解耦**：前端无需感知后端 Pod 的变化

---

### 二、Service 工作原理

#### **核心概念**

**Service** = **标签选择器（Label Selector）** + **虚拟 IP（ClusterIP）**

- Service 通过标签选择器匹配后端 Pod
- Endpoints Controller 自动维护匹配的 Pod IP 列表
- kube-proxy 在每个节点上配置转发规则（iptables/IPVS）
- 客户端访问 ClusterIP → kube-proxy 转发到后端 Pod

---

#### **流量转发流程**

```
客户端访问 Service ClusterIP:Port
    ↓
kube-proxy 拦截流量（通过 iptables/IPVS 规则）
    ↓
根据负载均衡算法选择后端 Pod
    ↓
将流量 DNAT（目标地址转换）到 Pod IP:Port
    ↓
请求到达目标 Pod
```

---

### 三、Service 四种类型

#### 1. **ClusterIP（默认）**

**作用**：为 Service 分配一个**集群内部虚拟 IP**，只能在集群内访问。

**适用场景**：
- 内部微服务间通信（如前端访问后端 API）
- 数据库、缓存等中间件服务

**示例**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  type: ClusterIP  # 默认类型，可省略
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 80        # Service 端口
    targetPort: 8080  # Pod 容器端口
```

**访问方式**：
- **通过 ClusterIP**：`curl 10.96.0.10:80`
- **通过 DNS**：`curl backend-service.default.svc.cluster.local:80`
- **同命名空间简写**：`curl backend-service:80`

---

#### 2. **NodePort**

**作用**：在每个节点上开放一个**静态端口**（30000-32767），外部可通过 `<NodeIP>:<NodePort>` 访问。

**适用场景**：
- 开发/测试环境快速暴露服务
- 边缘计算/物理机环境（无云负载均衡器）

**示例**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  type: NodePort
  selector:
    app: web
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
    nodePort: 30080  # 可选：指定端口（默认自动分配）
```

**访问方式**：
- 外部：`curl <任意节点IP>:30080`
- 集群内：仍可使用 ClusterIP

**流量路径**：
```
外部请求 → NodePort → kube-proxy → Service ClusterIP → Pod
```

**注意事项**：
- 端口范围有限（默认 30000-32767）
- 需要手动负载均衡多个节点 IP（通常需配合外部 LB）
- 安全性较低（端口暴露在所有节点上）

---

#### 3. **LoadBalancer**

**作用**：自动创建**云厂商的负载均衡器**（如 AWS ELB、GCP LB），分配外部 IP。

**适用场景**：
- 生产环境对外暴露服务
- 需要自动负载均衡和高可用

**示例**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  type: LoadBalancer
  selector:
    app: web
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
```

**访问方式**：
- 外部：`curl <LoadBalancer-IP>:80`（云厂商分配的外部 IP）
- 集群内：仍可使用 ClusterIP

**流量路径**：
```
外部请求 → 云 LB → NodePort → kube-proxy → Pod
```

**注意**：
- 仅支持云环境（需 Cloud Controller Manager）
- 每个 Service 创建一个 LB（成本较高）
- 本地环境可使用 MetalLB 模拟

---

#### 4. **ExternalName**

**作用**：将 Service 映射到**外部 DNS 名称**（返回 CNAME 记录）。

**适用场景**：
- 集成外部服务（如第三方 API、云数据库）
- 迁移期间逐步切换服务

**示例**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: external-db
spec:
  type: ExternalName
  externalName: db.example.com  # 外部 DNS
```

**访问方式**：
- 集群内访问 `external-db` → DNS 解析到 `db.example.com`

**特点**：
- 无 ClusterIP、无 Endpoints
- 纯 DNS 级别的转发
- 无法定义端口映射

---

### 四、服务发现机制

Kubernetes 提供两种服务发现方式：

#### 1. **环境变量（不推荐）**

**工作原理**：
- Pod 创建时，Kubelet 自动注入同命名空间下所有 Service 的信息

**示例**：
```bash
BACKEND_SERVICE_HOST=10.96.0.10
BACKEND_SERVICE_PORT=80
```

**缺点**：
- 只能发现 Pod 创建时已存在的 Service
- 环境变量多时难以管理
- 无法动态更新

---

#### 2. **DNS（推荐）**

**CoreDNS**：Kubernetes 内置 DNS 服务器，自动为每个 Service 创建 DNS 记录。

**DNS 格式**：
```
<service-name>.<namespace>.svc.<cluster-domain>
```

**示例**：
- 完整域名：`backend-service.default.svc.cluster.local`
- 同命名空间简写：`backend-service`
- 跨命名空间：`backend-service.prod`

**优势**：
- 动态更新（Service 变化时 DNS 自动同步）
- 简洁易用
- 支持跨命名空间访问

---

### 五、Endpoints 与 EndpointSlices

#### **Endpoints**

**作用**：记录 Service 对应的后端 Pod IP 和端口列表。

**自动维护**：
- Endpoints Controller 监听 Service 和 Pod 变化
- 自动添加/删除匹配标签的 Pod IP

**查看 Endpoints**：
```bash
kubectl get endpoints backend-service
```

**输出示例**：
```
NAME              ENDPOINTS
backend-service   192.168.1.5:8080,192.168.1.6:8080
```

---

#### **EndpointSlices（推荐）**

**背景**：大规模集群中，单个 Endpoints 对象可能包含数千个 IP，导致性能问题。

**改进**：
- 将 Endpoints 拆分成多个 EndpointSlice（每个最多 100 个地址）
- 仅更新变化的 Slice，减少 API 服务器负载

**启用**：Kubernetes 1.21+ 默认启用。

---

### 六、kube-proxy 工作模式

**kube-proxy** 负责实现 Service 的负载均衡和流量转发。

#### 1. **iptables 模式（默认）**

**工作原理**：
- 为每个 Service 创建 iptables 规则
- 流量匹配规则后，随机选择一个 Pod 并 DNAT 转发

**优点**：
- 成熟稳定
- 无需用户空间进程转发（性能较好）

**缺点**：
- 规则数量与 Service 数成正比（大规模集群性能下降）
- 负载均衡算法单一（随机）
- 不支持会话保持（默认）

---

#### 2. **IPVS 模式（推荐）**

**工作原理**：
- 使用 Linux 内核的 IPVS 模块（四层负载均衡器）
- 性能更高，支持多种负载均衡算法

**负载均衡算法**：
- **rr**（轮询）：默认
- **lc**（最少连接）
- **sh**（源地址哈希）：会话保持

**优点**：
- 高性能（支持数万 Service）
- 负载均衡算法丰富
- 连接跟踪更高效

**启用方式**：
```bash
kube-proxy --proxy-mode=ipvs
```

---

#### 3. **userspace 模式（已废弃）**

**工作原理**：
- kube-proxy 监听端口，用户空间转发流量

**缺点**：
- 性能差（用户态 <-> 内核态切换）
- 已在 Kubernetes 1.14 废弃

---

### 七、高级特性

#### 1. **Headless Service（无头服务）**

**特点**：不分配 ClusterIP（`clusterIP: None`），DNS 直接返回**所有后端 Pod IP**。

**适用场景**：
- 有状态应用（StatefulSet）：需要直接访问特定 Pod
- 自定义负载均衡（如 gRPC 客户端负载均衡）

**示例**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: headless-svc
spec:
  clusterIP: None  # 关键配置
  selector:
    app: database
  ports:
  - port: 3306
```

**DNS 解析**：
```bash
nslookup headless-svc.default.svc.cluster.local
# 返回所有 Pod IP：
# 192.168.1.5
# 192.168.1.6
# 192.168.1.7
```

**StatefulSet 的 DNS**：
```
<pod-name>.<service-name>.<namespace>.svc.cluster.local
# 示例：mysql-0.headless-svc.default.svc.cluster.local
```

---

#### 2. **会话亲和性（Session Affinity）**

**作用**：同一客户端的请求始终转发到同一 Pod（类似"粘性会话"）。

**配置**：
```yaml
spec:
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800  # 会话保持时间（默认 3 小时）
```

**实现原理**：
- iptables 模式：基于源 IP 哈希选择 Pod
- IPVS 模式：使用 `sh` 算法

**注意**：
- 仅支持 ClientIP（基于源 IP）
- 不支持基于 Cookie 的会话保持（需应用层实现）

---

#### 3. **拓扑感知路由（Topology Aware Routing）**

**作用**：优先将流量路由到**同节点/同可用区**的 Pod，减少跨区延迟和成本。

**启用**：
```yaml
spec:
  topologyKeys:
  - "kubernetes.io/hostname"  # 优先同节点
  - "topology.kubernetes.io/zone"  # 其次同可用区
  - "*"  # 最后任意节点
```

**注意**：Kubernetes 1.21+ 推荐使用 `service.kubernetes.io/topology-aware-hints` 注解。

---

#### 4. **ExternalIPs**

**作用**：将 Service 绑定到**特定外部 IP**（非云 LB）。

**示例**：
```yaml
spec:
  externalIPs:
  - 192.0.2.1  # 必须是节点可路由的 IP
```

**适用场景**：
- 物理机环境
- 自建负载均衡器

---

#### 5. **ExternalTrafficPolicy**

**控制外部流量的路由行为**（仅 NodePort 和 LoadBalancer 生效）。

**两种模式**：

1. **Cluster（默认）**：
   - 流量可转发到任意节点的 Pod
   - 会进行二次跳转（SNAT），源 IP 丢失

2. **Local**：
   - 流量仅转发到**当前节点**的 Pod
   - 保留源 IP
   - 如果当前节点无 Pod，连接失败

**示例**：
```yaml
spec:
  externalTrafficPolicy: Local
```

**用途**：
- 需要获取客户端真实 IP（如日志审计）
- 减少网络跳转（提升性能）

---

### 八、常见问题与面试追问

#### **Q1：Service 和 Ingress 的区别？**

| 特性 | Service | Ingress |
|------|---------|---------|
| 层级 | 四层（TCP/UDP） | 七层（HTTP/HTTPS） |
| 功能 | 负载均衡、服务发现 | 路由、TLS 终止、虚拟主机 |
| 暴露方式 | ClusterIP/NodePort/LB | 统一入口 + 路由规则 |
| 成本 | 每个 Service 一个 LB | 多个服务共享一个 LB |

**典型架构**：
```
外部流量 → Ingress Controller (Nginx/Traefik) → Service → Pod
```

---

#### **Q2：如何调试 Service 无法访问？**

**排查步骤**：

1. **检查 Service 是否存在**：
```bash
kubectl get svc <service-name>
```

2. **检查 Endpoints**：
```bash
kubectl get endpoints <service-name>
# 如果为空，说明没有匹配的 Pod
```

3. **检查标签选择器**：
```bash
kubectl get pods --show-labels
# 确认 Pod 标签与 Service selector 匹配
```

4. **测试 Pod 直连**：
```bash
kubectl get pods -o wide
curl <pod-ip>:<target-port>  # 直接访问 Pod
```

5. **检查 kube-proxy 日志**：
```bash
kubectl logs -n kube-system <kube-proxy-pod>
```

6. **检查网络策略（NetworkPolicy）**：
```bash
kubectl get networkpolicy
```

---

#### **Q3：ClusterIP 如何实现的？**

**核心机制**：
1. Service 创建时，API Server 分配 ClusterIP（从 Service CIDR 范围）
2. kube-proxy 监听 Service 和 Endpoints 变化
3. 在每个节点上创建 iptables/IPVS 规则：
   - 拦截目标为 ClusterIP 的流量
   - DNAT 到后端 Pod IP
4. 流量通过节点网络转发到目标 Pod

**ClusterIP 特性**：
- 虚拟 IP（不对应任何网络接口）
- 仅集群内可访问
- 通过 iptables/IPVS 规则实现转发

---

#### **Q4：为什么 NodePort 范围是 30000-32767？**

**原因**：
- IANA（互联网号码分配局）将 30000-32767 定义为**动态/私有端口范围**
- 避免与常用服务端口冲突（如 80、443、3306）
- 可通过 `--service-node-port-range` 参数自定义

---

#### **Q5：如何实现灰度发布？**

**方案 1：基于多个 Service**
```yaml
# Service A：稳定版本（90%）
selector:
  app: myapp
  version: v1

# Service B：灰度版本（10%）
selector:
  app: myapp
  version: v2
```

**方案 2：使用 Istio/Linkerd**
- 服务网格提供更精细的流量控制（按比例、按用户、按 Header）

---

### 九、最佳实践

1. **使用 DNS 进行服务发现**：
   - 避免使用环境变量
   - 简化跨命名空间访问

2. **合理选择 Service 类型**：
   - 内部服务：ClusterIP
   - 开发测试：NodePort
   - 生产外部：LoadBalancer 或 Ingress

3. **配置健康检查**：
   - Service 依赖 Readiness 探针判断 Pod 是否就绪
   - 未就绪的 Pod 不会加入 Endpoints

4. **使用 Headless Service 实现有状态应用**：
   - StatefulSet + Headless Service
   - 确保每个 Pod 有稳定的 DNS 名称

5. **监控 Service 性能**：
   - 监控 Endpoints 数量
   - 监控 kube-proxy 延迟

---

### 十、总结

Kubernetes Service 的核心要点：

1. **作用**：为动态 Pod 提供稳定访问入口和负载均衡
2. **四种类型**：
   - ClusterIP：集群内访问
   - NodePort：节点端口暴露
   - LoadBalancer：云负载均衡
   - ExternalName：DNS 映射
3. **服务发现**：DNS（推荐）、环境变量
4. **实现原理**：kube-proxy（iptables/IPVS）+ Endpoints
5. **高级特性**：
   - Headless Service（有状态应用）
   - 会话亲和性（粘性会话）
   - 拓扑感知路由（减少延迟）
   - ExternalTrafficPolicy（保留源 IP）

掌握 Service 机制是理解 Kubernetes 网络和微服务通信的关键。
