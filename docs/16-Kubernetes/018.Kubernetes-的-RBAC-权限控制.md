---
title: Kubernetes 的 RBAC 权限控制
tags:
  - Kubernetes
status: robot
class: Kubernetes
slug: kubernetes-rbac-access-control
ref:
---

## 核心要点

- **RBAC 机制**: Role-Based Access Control(基于角色的访问控制)
- **四大核心对象**: Role/ClusterRole(权限集合) + RoleBinding/ClusterRoleBinding(绑定主体与权限)
- **权限粒度**: API 组 + 资源类型 + 操作动词(get/list/create/update/delete/watch)
- **作用域**: Role(命名空间级) vs ClusterRole(集群级)
- **主体类型**: User(用户) / Group(用户组) / ServiceAccount(服务账号)

---

## 详细回答

### 一、为什么需要 RBAC

#### 1. 安全隔离场景

**问题**: 没有 RBAC 时,所有用户和应用都有集群管理员权限

```bash
# 开发者误操作删除生产环境资源
kubectl delete ns production  # 灾难!

# 应用 Pod 可以访问所有 Secret
# 包括数据库密码、API 密钥等敏感信息
```

**RBAC 解决方案**:
- **最小权限原则**: 用户/应用仅获得完成工作所需的最小权限
- **职责分离**: 开发者只能访问 dev 命名空间,运维负责生产环境
- **应用隔离**: 每个应用使用独立 ServiceAccount,无法访问其他应用资源

#### 2. 典型使用场景

| 场景 | 权限需求 |
|------|----------|
| **开发者** | 只读访问 dev 命名空间的 Pod、Deployment、Service |
| **CI/CD 系统** | 创建/更新/删除特定命名空间的 Deployment |
| **监控系统(Prometheus)** | 只读所有命名空间的 Pod、Node、Endpoints |
| **日志采集(Fluentd)** | 只读所有 Pod 元数据 |
| **集群管理员** | 完全控制所有资源 |

---

### 二、RBAC 核心概念

#### 1. 四大核心对象

```
┌─────────────────────────────────────────────────────┐
│                 RBAC 授权模型                        │
│                                                      │
│  ┌─────────────┐      ┌──────────────────┐         │
│  │   Subject   │      │   Permission     │         │
│  │   (主体)     │      │   (权限)          │         │
│  │             │      │                  │         │
│  │ - User      │      │  Role            │         │
│  │ - Group     │      │  ┌────────────┐  │         │
│  │ - SA        │      │  │ rules:     │  │         │
│  └──────┬──────┘      │  │ - get pods │  │         │
│         │             │  │ - list svc │  │         │
│         │             │  └────────────┘  │         │
│         │             │                  │         │
│         │             │  ClusterRole     │         │
│         │             │  ┌────────────┐  │         │
│         │             │  │ rules:     │  │         │
│         │             │  │ - * nodes  │  │         │
│         │             │  └────────────┘  │         │
│         │             └──────────────────┘         │
│         │                                           │
│         │  ┌──────────────────────────┐            │
│         └─▶│   Binding (绑定)         │            │
│            │                          │            │
│            │  RoleBinding             │            │
│            │  ClusterRoleBinding      │            │
│            └──────────────────────────┘            │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**① Role / ClusterRole(定义权限)**

- **Role**: 命名空间级别的权限集合
  - 只能访问同命名空间内的资源
  - 示例:允许读取 `dev` 命名空间的 Pod

- **ClusterRole**: 集群级别的权限集合
  - 访问集群资源(Node、PV、Namespace 等)
  - 跨所有命名空间的资源
  - 示例:读取所有命名空间的 Pod

**② RoleBinding / ClusterRoleBinding(绑定主体与权限)**

- **RoleBinding**: 在命名空间内绑定
  - 将 Role 或 ClusterRole 绑定到主体
  - 只在该命名空间生效

- **ClusterRoleBinding**: 在集群范围内绑定
  - 只能绑定 ClusterRole
  - 在所有命名空间生效

#### 2. 主体类型(Subject)

**① User(用户)**
- 代表真实用户(如开发者、管理员)
- K8s 不存储用户信息,由外部身份系统管理(LDAP、OIDC)
- 示例:`user:alice@example.com`

**② Group(用户组)**
- 用户的集合
- 简化批量授权
- 示例:`system:authenticated`(所有认证用户)

**③ ServiceAccount(服务账号)**
- 由 K8s 管理,专为 Pod 设计
- 每个命名空间有默认 SA:`default`
- Pod 通过挂载 SA token 访问 API Server
- 示例:`system:serviceaccount:default:my-app`

---

### 三、权限规则详解

#### 1. Rule 结构

```yaml
rules:
- apiGroups: [""]         # "" 表示 core API 组
  resources: ["pods"]     # 资源类型
  verbs: ["get", "list"]  # 允许的操作

- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "create", "update", "delete"]
  resourceNames: ["my-app"]  # 可选:限制特定资源实例
```

#### 2. API 组(apiGroups)

| API 组 | 包含的资源 |
|--------|-----------|
| `""` (core) | Pod, Service, ConfigMap, Secret, PV, PVC |
| `apps` | Deployment, StatefulSet, DaemonSet, ReplicaSet |
| `batch` | Job, CronJob |
| `networking.k8s.io` | NetworkPolicy, Ingress |
| `rbac.authorization.k8s.io` | Role, RoleBinding, ClusterRole |
| `storage.k8s.io` | StorageClass, VolumeAttachment |

**查看所有 API 组**:
```bash
kubectl api-resources -o wide
```

#### 3. 操作动词(verbs)

| 动词 | 说明 | 对应 kubectl 命令 |
|------|------|-------------------|
| `get` | 读取单个资源 | `kubectl get pod my-pod` |
| `list` | 列出资源集合 | `kubectl get pods` |
| `watch` | 监听资源变化 | `kubectl get pods --watch` |
| `create` | 创建资源 | `kubectl create -f pod.yaml` |
| `update` | 更新资源 | `kubectl apply -f pod.yaml` |
| `patch` | 部分更新 | `kubectl patch` |
| `delete` | 删除资源 | `kubectl delete pod my-pod` |
| `deletecollection` | 批量删除 | `kubectl delete pods --all` |

**通配符**:
```yaml
verbs: ["*"]  # 所有操作
```

#### 4. 子资源(subresources)

某些资源有子资源:
```yaml
rules:
- apiGroups: [""]
  resources: ["pods/log"]   # Pod 日志
  verbs: ["get"]

- apiGroups: [""]
  resources: ["pods/exec"]  # Pod 执行命令
  verbs: ["create"]

- apiGroups: ["apps"]
  resources: ["deployments/scale"]  # Deployment 扩缩容
  verbs: ["get", "update"]
```

---

### 四、实战示例

#### 示例 1:只读开发者权限(命名空间级)

**需求**: 开发者 `alice` 只读访问 `dev` 命名空间的 Pod、Service、Deployment

```yaml
---
# 1. 创建 Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: developer-reader
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps"]
  verbs: ["get", "list", "watch"]

- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]

---
# 2. 绑定用户到 Role
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: alice-developer-binding
  namespace: dev
subjects:
- kind: User
  name: alice@example.com
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: developer-reader
  apiGroup: rbac.authorization.k8s.io
```

**测试**:
```bash
# alice 可以读取
kubectl --as=alice@example.com get pods -n dev

# alice 无法创建(权限拒绝)
kubectl --as=alice@example.com run nginx --image=nginx -n dev
# Error: forbidden

# alice 无法访问其他命名空间
kubectl --as=alice@example.com get pods -n production
# Error: forbidden
```

#### 示例 2:CI/CD 部署权限

**需求**: Jenkins 服务账号能在 `staging` 命名空间创建/更新/删除 Deployment

```yaml
---
# 1. 创建 ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: staging

---
# 2. 创建 Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: staging
  name: deployment-manager
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]

- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list"]  # 查看部署结果

---
# 3. 绑定 ServiceAccount 到 Role
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: jenkins-deployment-binding
  namespace: staging
subjects:
- kind: ServiceAccount
  name: jenkins
  namespace: staging
roleRef:
  kind: Role
  name: deployment-manager
  apiGroup: rbac.authorization.k8s.io
```

**在 Pod 中使用**:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: jenkins-agent
  namespace: staging
spec:
  serviceAccountName: jenkins  # 使用该 SA
  containers:
  - name: kubectl
    image: bitnami/kubectl:latest
    command: ["sleep", "3600"]
```

Pod 内会自动挂载 token:
```bash
# 在 Pod 内
kubectl get deployments  # 使用 SA token 认证
```

#### 示例 3:集群级只读权限(所有命名空间)

**需求**: 监控系统(Prometheus)读取所有命名空间的 Pod、Service、Endpoints

```yaml
---
# 1. 创建 ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus-reader
rules:
# 读取所有命名空间的资源
- apiGroups: [""]
  resources: ["pods", "services", "endpoints", "nodes"]
  verbs: ["get", "list", "watch"]

- apiGroups: ["apps"]
  resources: ["deployments", "daemonsets", "statefulsets"]
  verbs: ["get", "list"]

# 读取集群资源
- apiGroups: [""]
  resources: ["nodes", "persistentvolumes"]
  verbs: ["get", "list"]

---
# 2. 创建 ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: monitoring

---
# 3. 集群级绑定
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus-reader-binding
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring
roleRef:
  kind: ClusterRole
  name: prometheus-reader
  apiGroup: rbac.authorization.k8s.io
```

#### 示例 4:聚合 ClusterRole(高级用法)

**场景**: 创建一个基础 ClusterRole,让其他 ClusterRole 自动聚合进来

```yaml
---
# 基础角色:定义聚合规则
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring-base
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.example.com/aggregate-to-monitoring: "true"
rules: []  # 会被自动填充

---
# 具体权限 1
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring-pods
  labels:
    rbac.example.com/aggregate-to-monitoring: "true"
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]

---
# 具体权限 2
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring-nodes
  labels:
    rbac.example.com/aggregate-to-monitoring: "true"
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list"]
```

`monitoring-base` 会自动聚合所有带标签的 ClusterRole 权限。

---

### 五、内置 ClusterRole

K8s 提供了预定义的 ClusterRole:

```bash
# 查看所有 ClusterRole
kubectl get clusterrole
```

#### 常用内置角色

| ClusterRole | 说明 |
|-------------|------|
| `cluster-admin` | 超级管理员(所有权限) |
| `admin` | 命名空间管理员(不含 RBAC 修改权限) |
| `edit` | 读写命名空间资源(不含 RBAC) |
| `view` | 只读命名空间资源 |
| `system:discovery` | 访问 API 发现端点 |
| `system:node` | Kubelet 使用 |

**使用示例**:
```yaml
# 授予用户 bob 对 dev 命名空间的编辑权限
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: bob-edit
  namespace: dev
subjects:
- kind: User
  name: bob@example.com
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole      # 引用内置 ClusterRole
  name: edit             # 使用 edit 角色
  apiGroup: rbac.authorization.k8s.io
```

**查看角色权限**:
```bash
# 查看 view 角色的详细权限
kubectl describe clusterrole view
```

---

### 六、权限测试与调试

#### 1. 模拟用户执行命令

```bash
# 以 alice 用户身份执行
kubectl --as=alice@example.com get pods -n dev

# 以用户组身份执行
kubectl --as=alice@example.com --as-group=developers get pods
```

#### 2. 检查用户权限

```bash
# 检查当前用户是否有权限
kubectl auth can-i create deployments -n dev

# 检查特定用户是否有权限
kubectl auth can-i delete pods -n production --as=alice@example.com

# 列出用户在命名空间的所有权限
kubectl auth can-i --list -n dev --as=alice@example.com
```

输出示例:
```
Resources                                       Verbs
pods                                            [get list watch]
services                                        [get list]
deployments.apps                                [get list watch]
```

#### 3. 查看 ServiceAccount 权限

```bash
# 查看 SA 的 token(在 Pod 内)
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# 查看 SA 绑定的 RoleBinding
kubectl get rolebinding -n dev -o yaml | grep serviceaccount

# 测试 SA 权限
kubectl auth can-i list pods --as=system:serviceaccount:dev:my-app -n dev
```

#### 4. 审计日志

启用审计日志记录所有 RBAC 决策:

```yaml
# kube-apiserver 审计策略
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Metadata
  verbs: ["get", "list", "watch"]

- level: RequestResponse
  verbs: ["create", "update", "patch", "delete"]
  omitStages: ["RequestReceived"]
```

---

### 七、最佳实践

#### 1. 最小权限原则

**错误示例**:
```yaml
# 授予过大权限
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
```

**正确做法**:
```yaml
# 仅授予必需权限
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get"]
  resourceNames: ["app-config"]  # 限制到特定资源
```

#### 2. 使用 ServiceAccount 而非 User

**应用权限管理**:
- ✅ 为每个应用创建独立 ServiceAccount
- ✅ 通过 RoleBinding 授予最小权限
- ❌ 不要使用 `default` ServiceAccount
- ❌ 不要在 Pod 中使用用户凭证

```yaml
# 禁用自动挂载 SA token(如果不需要访问 API)
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-app
automountServiceAccountToken: false
```

#### 3. 命名空间隔离

**多租户场景**:
```yaml
# 团队 A 只能访问 team-a 命名空间
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: team-a-binding
  namespace: team-a
subjects:
- kind: Group
  name: team-a
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: edit
  apiGroup: rbac.authorization.k8s.io
```

#### 4. 定期审计权限

```bash
# 查看所有 ClusterRoleBinding(重点检查)
kubectl get clusterrolebinding -o wide

# 查找使用 cluster-admin 的绑定
kubectl get clusterrolebinding -o json | \
  jq -r '.items[] | select(.roleRef.name=="cluster-admin") | .metadata.name'

# 检查匿名用户权限
kubectl auth can-i list secrets --as=system:anonymous
```

#### 5. 使用 RBAC Manager 工具

**rbac-tool**: 可视化 RBAC 关系
```bash
# 安装
brew install alcideio/tap/rbac-tool

# 查看用户权限
rbac-tool policy-rules -e user:alice@example.com

# 生成权限图
rbac-tool viz -o graph.html
```

---

### 八、常见问题与排查

#### 1. "User cannot list resource" 错误

**问题**:
```bash
kubectl get pods -n dev
# Error: User "alice" cannot list resource "pods" in namespace "dev"
```

**排查步骤**:
```bash
# 1. 检查用户身份
kubectl auth whoami

# 2. 查看用户权限
kubectl auth can-i list pods -n dev --as=alice

# 3. 查找相关 RoleBinding
kubectl get rolebinding -n dev -o yaml | grep alice

# 4. 检查 Role 规则
kubectl describe role <role-name> -n dev
```

**常见原因**:
- RoleBinding 中的用户名拼写错误
- Role 的 `verbs` 缺少 `list`
- 命名空间不匹配

#### 2. ServiceAccount Token 无法使用

**问题**: Pod 中无法访问 API

**检查 token 挂载**:
```bash
# 在 Pod 内
ls /var/run/secrets/kubernetes.io/serviceaccount/
# 应该看到: ca.crt  namespace  token

# 测试 token
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -H "Authorization: Bearer $TOKEN" \
     --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
     https://kubernetes.default.svc/api/v1/namespaces/default/pods
```

**检查 RBAC**:
```bash
kubectl auth can-i list pods \
  --as=system:serviceaccount:default:my-app
```

#### 3. ClusterRole 聚合不生效

**问题**: aggregationRule 定义后,规则为空

**原因**: 标签不匹配

```bash
# 检查被聚合的 ClusterRole 标签
kubectl get clusterrole monitoring-pods -o yaml

# 确保标签与 aggregationRule 选择器匹配
```

---

### 九、高级场景

#### 1. 动态准入控制集成

结合 OPA(Open Policy Agent)实现细粒度控制:

```yaml
# 示例: 限制容器镜像来源
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
data:
  policy.rego: |
    package kubernetes.admission

    deny[msg] {
      input.request.kind.kind == "Pod"
      image := input.request.object.spec.containers[_].image
      not startswith(image, "myregistry.com/")
      msg := sprintf("Image %v not from trusted registry", [image])
    }
```

#### 2. 多集群 RBAC 管理

使用 Kyverno 跨集群同步 RBAC 规则:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: sync-rbac
spec:
  rules:
  - name: sync-developer-role
    match:
      resources:
        kinds:
        - Namespace
    generate:
      kind: RoleBinding
      name: developers
      namespace: "{{request.object.metadata.name}}"
      data:
        subjects:
        - kind: Group
          name: developers
          apiGroup: rbac.authorization.k8s.io
        roleRef:
          kind: ClusterRole
          name: edit
          apiGroup: rbac.authorization.k8s.io
```

---

### 十、总结

Kubernetes RBAC 是集群安全的基石,核心要点:

1. **四大对象**: Role/ClusterRole 定义权限,RoleBinding/ClusterRoleBinding 绑定主体
2. **最小权限**: 始终遵循最小权限原则,避免过度授权
3. **命名空间隔离**: 利用 Role 实现租户隔离
4. **ServiceAccount**: 应用访问 API 的标准方式
5. **定期审计**: 定期检查 cluster-admin 绑定和高风险权限

面试建议关注:
- 能清晰解释 Role vs ClusterRole、RoleBinding vs ClusterRoleBinding 的区别
- 掌握 rules 的三要素(apiGroups、resources、verbs)
- 了解内置角色(cluster-admin、edit、view)的使用场景
- 熟悉权限测试命令(`kubectl auth can-i`)
- 能设计多租户场景下的 RBAC 方案
