---
title: 三数之和（LeetCode 15）
tags:
  - 算法
status: robot
class: 算法
slug: three-sum
ref:
---

## 核心要点

**一句话总结**：先排序，固定一个数，用双指针在剩余部分找两数之和，关键是**去重**（跳过重复元素）。

**关键技巧**：排序 + 固定一数 + 双指针，O(n²) 时间复杂度，重点在于三处去重逻辑。

---

## 问题分析

给定整数数组 `nums`，找出所有和为 0 的三元组 `[nums[i], nums[j], nums[k]]`。

**约束条件**：
- 答案不能包含重复的三元组
- 三元组内部顺序不重要，但结果集不能有重复

**示例**：
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
去重后输出两个不同的三元组
```

---

## 解法思路

### 核心思路：排序 + 双指针

**步骤**：
1. **排序**：将数组从小到大排序，便于去重和使用双指针
2. **固定第一个数**：遍历数组，固定 `nums[i]` 作为第一个数
3. **双指针查找**：在 `i` 右侧用双指针 `left` 和 `right` 找两数之和等于 `-nums[i]`
4. **去重处理**：在三个位置都要去重

**为什么排序**：
- 便于使用双指针（左右夹逼）
- 相同的数字会相邻，方便去重
- 当 `nums[i] > 0` 时可以直接终止（后面的数都更大，和不可能为 0）

**双指针移动规则**：
- `sum = nums[i] + nums[left] + nums[right]`
- 如果 `sum < 0`：左指针右移（需要更大的数）
- 如果 `sum > 0`：右指针左移（需要更小的数）
- 如果 `sum == 0`：找到一组解，记录后双指针同时移动，并跳过重复元素

**三处去重**：
1. **第一个数去重**：`nums[i] == nums[i-1]` 时跳过
2. **第二个数去重**：找到解后，left 右移时跳过重复元素
3. **第三个数去重**：找到解后，right 左移时跳过重复元素

---

## 代码实现

```go
func threeSum(nums []int) [][]int {
    result := [][]int{}
    n := len(nums)

    // 边界检查
    if n < 3 {
        return result
    }

    // 1. 排序
    sort.Ints(nums)

    // 2. 固定第一个数
    for i := 0; i < n-2; i++ {
        // 优化：第一个数大于0，后面的数更大，和不可能为0
        if nums[i] > 0 {
            break
        }

        // 去重：第一个数去重
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        // 3. 双指针查找
        left, right := i+1, n-1
        target := -nums[i]  // 需要找的两数之和

        for left < right {
            sum := nums[left] + nums[right]

            if sum == target {
                // 找到一组解
                result = append(result, []int{nums[i], nums[left], nums[right]})

                // 去重：第二个数去重
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                // 去重：第三个数去重
                for left < right && nums[right] == nums[right-1] {
                    right--
                }

                // 双指针同时移动
                left++
                right--

            } else if sum < target {
                // 和太小，左指针右移
                left++
            } else {
                // 和太大，右指针左移
                right--
            }
        }
    }

    return result
}
```

**执行过程示例**（nums = [-1,0,1,2,-1,-4]）：

排序后：`[-4,-1,-1,0,1,2]`

| i | nums[i] | left | right | nums[left] | nums[right] | sum | 操作 |
|---|---------|------|-------|------------|-------------|-----|------|
| 0 | -4 | 1 | 5 | -1 | 2 | -3 | sum < 0, left++ |
| 0 | -4 | 2 | 5 | -1 | 2 | -3 | sum < 0, left++ |
| 0 | -4 | 3 | 5 | 0 | 2 | -2 | sum < 0, left++ |
| 0 | -4 | 4 | 5 | 1 | 2 | -1 | sum < 0, left++ |
| 0 | -4 | 5 | 5 | - | - | - | left == right, 结束 |
| 1 | -1 | 2 | 5 | -1 | 2 | 0 | **找到解** [-1,-1,2] |
| 1 | -1 | 3 | 4 | 0 | 1 | 0 | **找到解** [-1,0,1] |
| 2 | -1 | - | - | - | - | - | **跳过**（去重）|

---

## 复杂度分析

**时间复杂度**：O(n²)
- 排序：O(n log n)
- 外层循环固定第一个数：O(n)
- 内层双指针遍历：O(n)
- 总体：O(n log n) + O(n²) = O(n²)

**空间复杂度**：O(log n) 或 O(n)
- 排序的空间复杂度（取决于排序算法）
- 不计算返回结果占用的空间

---

## 注意事项与易错点

### 1. **去重的时机和位置**

最容易出错的地方！必须在三个位置去重：

```go
// 错误示例1：第一个数去重位置错误
if i >= 0 && nums[i] == nums[i-1] {  // 错误：i=0时会越界
    continue
}

// 正确：
if i > 0 && nums[i] == nums[i-1] {  // i从1开始比较
    continue
}

// 错误示例2：找到解后不去重
result = append(result, []int{nums[i], nums[left], nums[right]})
left++   // 错误：没有跳过重复元素
right--

// 正确：
result = append(result, []int{nums[i], nums[left], nums[right]})
for left < right && nums[left] == nums[left+1] {
    left++
}
for left < right && nums[right] == nums[right-1] {
    right--
}
left++
right--
```

### 2. **排序的必要性**

排序不是为了提升性能，而是为了：
- 使用双指针技巧
- 方便去重（相同元素相邻）
- 提前终止（nums[i] > 0 时）

### 3. **边界条件**

```go
// 数组长度小于3
if n < 3 {
    return result
}

// 双指针越界检查
for left < right {  // 注意是 <，不是 <=
    // ...
}
```

### 4. **优化：提前终止**

```go
if nums[i] > 0 {
    break  // 第一个数大于0，后面的数更大，不可能和为0
}
```

### 5. **为什么是 O(n²) 而不是 O(n³)**

很多人误以为是 O(n³)，实际上：
- 外层循环：O(n)
- 内层双指针：O(n)，每个元素最多访问一次
- **不是**嵌套两层循环，而是双指针在一次遍历中收缩范围

---

## 面试要点

**面试时的回答流程**：
1. 先说暴力法：三层循环 O(n³)，需要用 set 去重
2. 优化方向：如何降到 O(n²)？→ 固定一个数，转化为两数之和
3. 两数之和怎么做？→ 排序后用双指针
4. 关键难点：去重！强调三处去重逻辑
5. 分析复杂度

**可能的追问**：

- **Q: 为什么不用哈希表？**
  - A: 可以用，但去重更复杂。需要用 set 存储三元组，或者自己实现去重逻辑。双指针方案更简洁。

- **Q: 如果要求四数之和呢？**
  - A: 同样思路，固定两个数，用双指针找另外两个。时间复杂度 O(n³)。

- **Q: 能否用两数之和的哈希表方法？**
  - A: 可以，外层循环固定第一个数，内层用哈希表找两数之和。但去重更麻烦，需要用 set 或排序后去重。

- **Q: 去重为什么要在找到解之后？**
  - A: 因为 `[-1,-1,2]` 是合法答案，第二个 `-1` 不能被跳过。只有在记录答案后，才跳过后续重复的 `-1`。

- **Q: 双指针移动规则的正确性如何证明？**
  - A: 排序后，如果 `sum < target`，说明左边的数太小，右边的数再怎么减小也无法使 sum 变大到 target，所以左指针必须右移。反之亦然。
