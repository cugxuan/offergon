---
title: 课程表（LeetCode 207）
tags:
  - 算法
status: robot
class: 算法
slug: course-schedule
ref:
---

## 核心要点

**拓扑排序 + BFS/DFS 检测有向图环**：构建邻接表和入度数组，通过拓扑排序判断是否存在环，时间复杂度 O(V+E)

---

## 题目描述

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1`。

在选修某些课程之前需要一些先修课程。先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]`，表示如果要学习课程 `ai` 则**必须**先学习课程 `bi`。

例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0`，你需要先完成课程 `1`。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true`；否则，返回 `false`。

**示例：**
```
输入: numCourses = 2, prerequisites = [[1,0]]
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。这是可能的。

输入: numCourses = 2, prerequisites = [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前需要先完成课程 0；
     学习课程 0 之前，需要先完成课程 1。这是不可能的。
```

---

## 解题思路

### 思路分析

这是一道典型的**拓扑排序**问题，本质是**检测有向图中是否存在环**：

1. **图的表示**：课程之间的依赖关系构成有向图
   - 节点：课程编号
   - 边：`[a, b]` 表示 b → a（b 指向 a，即 b 是 a 的前置课程）

2. **问题转化**：能否完成所有课程 = 图中是否存在环
   - 无环：可以按拓扑序依次完成所有课程
   - 有环：形成循环依赖，无法完成

3. **拓扑排序**：通过 BFS（Kahn 算法）或 DFS 实现
   - BFS：从入度为 0 的节点开始，逐步删除边
   - DFS：检测递归栈中是否有重复节点（回边）

---

## 代码实现

### 方法一：BFS（Kahn 算法）- 推荐

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
    // 步骤1: 构建邻接表和入度数组
    graph := make([][]int, numCourses)  // graph[i] 存储依赖课程 i 的所有课程
    inDegree := make([]int, numCourses) // inDegree[i] 表示课程 i 的前置课程数量

    for _, pre := range prerequisites {
        course := pre[0]
        preCourse := pre[1]
        graph[preCourse] = append(graph[preCourse], course)
        inDegree[course]++
    }

    // 步骤2: 将所有入度为 0 的节点加入队列
    queue := []int{}
    for i := 0; i < numCourses; i++ {
        if inDegree[i] == 0 {
            queue = append(queue, i)
        }
    }

    // 步骤3: BFS 拓扑排序
    visited := 0 // 已完成的课程数量
    for len(queue) > 0 {
        // 取出一个可以学习的课程
        curr := queue[0]
        queue = queue[1:]
        visited++

        // 更新依赖当前课程的所有课程的入度
        for _, next := range graph[curr] {
            inDegree[next]--
            // 如果某课程的前置课程都已完成，加入队列
            if inDegree[next] == 0 {
                queue = append(queue, next)
            }
        }
    }

    // 步骤4: 判断是否所有课程都能完成
    return visited == numCourses
}
```

### 方法二：DFS（检测环）

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
    // 构建邻接表
    graph := make([][]int, numCourses)
    for _, pre := range prerequisites {
        course := pre[0]
        preCourse := pre[1]
        graph[preCourse] = append(graph[preCourse], course)
    }

    // 访问状态：0-未访问，1-正在访问（在递归栈中），2-已完成
    visited := make([]int, numCourses)

    // DFS 函数：检测从节点 i 开始是否存在环
    var dfs func(i int) bool
    dfs = func(i int) bool {
        if visited[i] == 1 {
            // 发现回边，存在环
            return false
        }
        if visited[i] == 2 {
            // 已检查过，无环
            return true
        }

        // 标记为正在访问
        visited[i] = 1

        // 递归访问所有邻居节点
        for _, next := range graph[i] {
            if !dfs(next) {
                return false
            }
        }

        // 标记为已完成
        visited[i] = 2
        return true
    }

    // 检查所有节点
    for i := 0; i < numCourses; i++ {
        if visited[i] == 0 && !dfs(i) {
            return false
        }
    }

    return true
}
```

---

## 关键代码说明

### BFS 方法（Kahn 算法）

1. **邻接表构建**（第3-10行）：
   - `graph[preCourse]` 存储所有依赖 `preCourse` 的课程
   - `inDegree[course]` 记录课程的前置课程数量

2. **初始化队列**（第13-18行）：
   - 入度为 0 的课程没有前置依赖，可以直接学习

3. **BFS 删除边**（第21-33行）：
   - 每完成一门课程，将其指向的课程入度 -1
   - 新入度为 0 的课程加入队列

4. **判断条件**（第36行）：
   - `visited == numCourses`：所有课程都能完成（无环）
   - `visited < numCourses`：存在环，部分课程无法完成

### DFS 方法

1. **三色标记法**（第7行）：
   - `0`：未访问（白色）
   - `1`：正在访问（灰色，在递归栈中）
   - `2`：已完成（黑色，已检查完毕）

2. **环检测**（第12-15行）：
   - 遇到灰色节点 → 存在回边 → 有环
   - 遇到黑色节点 → 该子图已检查 → 直接返回

3. **递归搜索**（第18-26行）：
   - 标记为灰色 → 递归访问邻居 → 标记为黑色

---

## 复杂度分析

### BFS 方法
- **时间复杂度**：O(V + E)
  - V = numCourses（节点数）
  - E = prerequisites.length（边数）
  - 每个节点和边都访问一次

- **空间复杂度**：O(V + E)
  - 邻接表：O(E)
  - 入度数组：O(V)
  - 队列：O(V)

### DFS 方法
- **时间复杂度**：O(V + E)
  - 每个节点最多访问一次
  - 每条边最多检查一次

- **空间复杂度**：O(V + E)
  - 邻接表：O(E)
  - 递归栈：O(V)
  - visited 数组：O(V)

---

## 测试用例

```go
func main() {
    // 测试用例1: 无环，可以完成
    numCourses1 := 2
    prerequisites1 := [][]int{{1, 0}}
    fmt.Println(canFinish(numCourses1, prerequisites1)) // true

    // 测试用例2: 有环，无法完成
    numCourses2 := 2
    prerequisites2 := [][]int{{1, 0}, {0, 1}}
    fmt.Println(canFinish(numCourses2, prerequisites2)) // false

    // 测试用例3: 复杂依赖，无环
    numCourses3 := 4
    prerequisites3 := [][]int{{1, 0}, {2, 0}, {3, 1}, {3, 2}}
    fmt.Println(canFinish(numCourses3, prerequisites3)) // true

    // 测试用例4: 无依赖
    numCourses4 := 3
    prerequisites4 := [][]int{}
    fmt.Println(canFinish(numCourses4, prerequisites4)) // true

    // 测试用例5: 自环
    numCourses5 := 1
    prerequisites5 := [][]int{{0, 0}}
    fmt.Println(canFinish(numCourses5, prerequisites5)) // false
}
```

---

## 面试要点

1. **拓扑排序的前提条件是什么？**
   - 必须是有向无环图（DAG）
   - 有环的图无法进行拓扑排序

2. **BFS 和 DFS 如何选择？**
   - BFS（Kahn 算法）：更直观，易于理解和实现
   - DFS：代码更简洁，但需要理解三色标记法
   - 实际面试中 BFS 更常用

3. **如何判断有向图中是否存在环？**
   - BFS：最终能访问的节点数 < 总节点数 → 有环
   - DFS：递归栈中遇到灰色节点 → 有环

4. **为什么入度为 0 的节点可以直接处理？**
   - 入度为 0 表示没有前置依赖
   - 完成该课程不会影响其他课程的先后顺序

5. **如何输出具体的拓扑序列？**
   - 在 BFS 中，将出队的节点依次加入结果数组
   - 参见 LeetCode 210: 课程表 II

6. **时间复杂度为什么是 O(V + E)？**
   - 每个节点最多入队/出队一次：O(V)
   - 每条边在更新入度时被访问一次：O(E)

---

## 算法原理详解

### 拓扑排序的本质

拓扑排序是对有向无环图的所有节点进行排序，使得：
- 对于任意边 u → v，u 在排序中出现在 v 之前

**Kahn 算法核心思想：**
1. 不断移除入度为 0 的节点（没有前驱依赖）
2. 移除节点的同时，删除其指向的边（更新后继节点的入度）
3. 重复上述过程，直到所有节点被移除或无法继续

**DFS 三色标记法：**
- **白色（0）**：未访问
- **灰色（1）**：正在访问（在递归栈中）
- **黑色（2）**：已完成访问

如果访问过程中遇到灰色节点，说明存在回边（从后代节点指向祖先节点），即存在环。

---

## 相关题目

- LeetCode 210: 课程表 II（返回拓扑排序序列）
- LeetCode 802: 找到最终的安全状态（DFS 检测环）
- LeetCode 310: 最小高度树（类似拓扑排序思想）
- LeetCode 444: 序列重建（拓扑排序唯一性判断）
- LeetCode 1059: 从始点到终点的所有路径（有向图遍历）
