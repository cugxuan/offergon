---
title: 验证二叉搜索树(LeetCode 98)
tags:
  - 算法
status: robot
class: 算法
slug: validate-binary-search-tree
ref:
---

## 核心要点

**递归验证时传递上下界(min, max),确保每个节点不仅大于左子树、小于右子树,还要满足全局 BST 约束**

易错陷阱:不能只比较左子节点 < 根 < 右子节点,还要保证左子树所有节点 < 根,右子树所有节点 > 根。正确做法:递归时维护每个节点的取值范围 (min, max)。

---

## 详细解答

### 一、题目理解

给定一个二叉树的根节点,判断它是否是**有效的二叉搜索树(BST)**。

**BST 定义**:
- 节点的左子树只包含**小于**当前节点的数
- 节点的右子树只包含**大于**当前节点的数
- 所有左子树和右子树自身也必须是 BST

**陷阱示例**:
```
    5
   / \
  1   4       ❌ 不是 BST
     / \
    3   6
```
看似 `1 < 5 < 4`,但实际上 4 < 5,不满足"右子树所有节点 > 根"

---

### 二、思路分析

#### 错误思路:只比较左右子节点

```go
// ❌ 错误代码
func isValidBST(root *TreeNode) bool {
    if root == nil {
        return true
    }
    if root.Left != nil && root.Left.Val >= root.Val {
        return false
    }
    if root.Right != nil && root.Right.Val <= root.Val {
        return false
    }
    return isValidBST(root.Left) && isValidBST(root.Right)
}
```

**为什么错**:只检查了直接子节点,没有检查整个子树。上面的示例会通过这个错误的代码。

---

#### 正确思路 1:递归 + 上下界约束

**核心思想**:
- 每个节点都有一个**允许的取值范围** `(min, max)`
- 根节点范围:`(-∞, +∞)`
- 左子树范围继承父节点的 `min`,上界改为父节点值:`(min, root.Val)`
- 右子树范围继承父节点的 `max`,下界改为父节点值:`(root.Val, max)`

```
        10 (-∞, +∞)
       /  \
      5    15
   (-∞,10) (10,+∞)
     / \    / \
    2   7  12  20
 (-∞,5)(5,10)(10,15)(15,+∞)
```

---

#### 正确思路 2:中序遍历验证

**核心思想**:
- BST 的中序遍历结果是**严格递增**的序列
- 遍历过程中,检查当前值是否大于前一个值

---

### 三、代码实现

#### 解法 1:递归 + 上下界(推荐)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func isValidBST(root *TreeNode) bool {
    return validate(root, nil, nil)
}

// 验证节点值是否在 (min, max) 范围内
func validate(node *TreeNode, min, max *int) bool {
    if node == nil {
        return true
    }

    // 检查当前节点是否在合法范围内
    if min != nil && node.Val <= *min {
        return false
    }
    if max != nil && node.Val >= *max {
        return false
    }

    // 递归检查左右子树
    // 左子树:上界更新为当前节点值
    // 右子树:下界更新为当前节点值
    return validate(node.Left, min, &node.Val) &&
           validate(node.Right, &node.Val, max)
}
```

**关键点**:
- 使用 `*int` 指针表示上下界,`nil` 表示无界(正负无穷)
- 注意是**严格大于/小于**,不能等于(题目要求严格 BST)
- 传递 `&node.Val` 而不是直接传值,因为需要指针类型

---

#### 解法 2:中序遍历

```go
func isValidBST(root *TreeNode) bool {
    var prev *int // 前一个访问的节点值
    return inorder(root, &prev)
}

func inorder(node *TreeNode, prev **int) bool {
    if node == nil {
        return true
    }

    // 1. 检查左子树
    if !inorder(node.Left, prev) {
        return false
    }

    // 2. 检查当前节点
    if *prev != nil && node.Val <= **prev {
        return false // 当前值必须大于前一个值
    }
    *prev = &node.Val // 更新 prev

    // 3. 检查右子树
    return inorder(node.Right, prev)
}
```

**中序遍历迭代版(更直观)**:

```go
func isValidBST(root *TreeNode) bool {
    stack := []*TreeNode{}
    var prev *int
    current := root

    for current != nil || len(stack) > 0 {
        // 一直往左走
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }

        // 访问节点
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        // 检查是否严格递增
        if prev != nil && current.Val <= *prev {
            return false
        }
        prev = &current.Val

        // 转向右子树
        current = current.Right
    }

    return true
}
```

---

### 四、复杂度分析

**两种解法的复杂度相同**:

- **时间复杂度**: O(N)
  - 每个节点访问一次

- **空间复杂度**: O(H)
  - H 为树高
  - 递归栈或显式栈的深度
  - 最坏情况(链状树):O(N)
  - 平衡树:O(log N)

---

### 五、示例演示

#### 示例 1:有效 BST

```
    2
   / \
  1   3
```

**递归 + 上下界验证**:
```
节点 2: (-∞, +∞) ✓
  节点 1: (-∞, 2) ✓ (1 < 2)
  节点 3: (2, +∞) ✓ (3 > 2)
返回 true
```

**中序遍历验证**:
```
遍历序列: 1 → 2 → 3 (严格递增 ✓)
返回 true
```

---

#### 示例 2:无效 BST

```
    5
   / \
  1   4
     / \
    3   6
```

**递归 + 上下界验证**:
```
节点 5: (-∞, +∞) ✓
  节点 1: (-∞, 5) ✓
  节点 4: (5, +∞) ✗ (4 不大于 5)
返回 false
```

**中序遍历验证**:
```
遍历序列: 1 → 5 → 3 (5 > 3,不是递增 ✗)
返回 false
```

---

### 六、易错点

1. **只比较左右子节点**
   ```go
   // ❌ 错误
   if root.Left != nil && root.Left.Val >= root.Val {
       return false
   }
   ```
   **正解**:需要检查整个子树的范围

2. **忘记严格大于/小于**
   ```go
   // ❌ 错误:允许相等
   if node.Val < *min
   ```
   ```go
   // ✓ 正确:严格小于
   if node.Val <= *min
   ```

3. **边界值处理**
   - 使用 `math.MinInt` 和 `math.MaxInt` 作为初始边界可能有问题(节点值可能就是这些极值)
   - **推荐**:使用 `nil` 表示无界

4. **中序遍历的 prev 初始化**
   - 不能初始化为 0 或最小值,因为第一个节点可能就是这些值
   - **推荐**:使用 `nil` 或 `*int` 指针

---

### 七、进阶思考

#### Q1: 如果允许重复值怎么办?

**答**: 看题目要求:
- 如果左子树允许 `<=` 根,右子树允许 `>=` 根,修改判断条件为 `<` 和 `>`
- 实际上大多数 BST 实现不允许重复值

#### Q2: 如果树节点非常多,递归栈溢出怎么办?

**答**: 使用迭代版中序遍历,避免递归。

#### Q3: 能否提前终止(不遍历所有节点)?

**答**:
- 递归 + 上下界:一旦发现不合法节点,会立即返回 `false`,后续节点不再访问
- 中序遍历:一旦发现逆序,立即返回 `false`
- 两种方法都已经是最优的提前终止

---

### 八、面试技巧

1. **明确 BST 定义**
   - 强调"左子树**所有**节点 < 根,右子树**所有**节点 > 根"
   - 不是只比较左右子节点

2. **先说错误思路**
   - 展示对陷阱的认识
   - "一开始可能会想只比较左右子节点,但这是不够的..."

3. **画图演示**
   - 用上面的陷阱示例说明为什么需要上下界
   - 画出递归树和范围变化

4. **对比两种解法**
   - 递归 + 上下界:更直观,易于理解
   - 中序遍历:利用了 BST 性质,更优雅
   - 两种都要会,根据面试官偏好选择

5. **代码规范**
   - 使用 `nil` 表示无界而不是 `math.MinInt`
   - 注意严格不等号 `<` 和 `>`

**追问应对**:

- **Q: 两种解法哪种更好?**
  - A: 时间空间复杂度相同,递归 + 上下界更直观,中序遍历更能体现对 BST 性质的理解。面试中推荐先说递归 + 上下界,再说中序遍历作为补充。

- **Q: 如果要支持相等节点怎么改?**
  - A: 将 `<=` 改为 `<`,`>=` 改为 `>`,或者明确规定相等值放在左子树还是右子树,相应调整一侧的判断条件。

- **Q: 能否不用递归?**
  - A: 可以用迭代版中序遍历(上面已给出代码),或者用显式栈模拟递归 + 上下界的过程。

- **Q: 如果树非常大,内存有限怎么办?**
  - A: 使用迭代版避免递归栈;如果树存在磁盘上,可以流式遍历,逐个读取节点验证。

- **Q: 这道题的本质是什么?**
  - A: 本质是理解 BST 的全局性质(不仅是局部父子关系),以及如何通过递归传递约束信息,或利用中序遍历的有序性来验证全局性质。
