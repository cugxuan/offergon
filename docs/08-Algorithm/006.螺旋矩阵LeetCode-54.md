---
title: 螺旋矩阵（LeetCode 54）
tags:
  - 算法
status: robot
class: 算法
slug: spiral-matrix
ref:
---

## 核心要点

**一句话总结**：维护上下左右四个边界，按"右→下→左→上"顺序螺旋遍历，每遍历完一边收缩对应边界。

**关键技巧**：用四个变量 `top, bottom, left, right` 控制边界，每次遍历完一条边后更新边界并检查是否越界。

---

## 问题分析

给定一个 `m × n` 矩阵，按照顺时针螺旋顺序返回矩阵中的所有元素。

**示例**：
```
输入：matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
输出：[1,2,3,6,9,8,7,4,5]

遍历顺序：
1 → 2 → 3
        ↓
4 → 5   6
↑       ↓
7 ← 8 ← 9
```

**关键点**：
- 螺旋顺序：右 → 下 → 左 → 上，循环往复
- 边界收缩：每走完一条边，收缩对应边界
- 终止条件：边界相遇或交叉

---

## 解法思路

### 核心思路：模拟 + 边界控制

**算法流程**：
1. 初始化四个边界：`top=0, bottom=m-1, left=0, right=n-1`
2. 循环执行以下步骤，直到边界交叉：
   - **向右**：遍历 `top` 行，从 `left` 到 `right`，然后 `top++`
   - **向下**：遍历 `right` 列，从 `top` 到 `bottom`，然后 `right--`
   - **向左**：遍历 `bottom` 行，从 `right` 到 `left`（需检查 `top <= bottom`），然后 `bottom--`
   - **向上**：遍历 `left` 列，从 `bottom` 到 `top`（需检查 `left <= right`），然后 `left++`
3. 重复步骤 2，直到 `top > bottom` 或 `left > right`

**为什么需要边界检查？**
- 向左和向上时，可能已经遍历完所有元素
- 例如单行或单列矩阵，向左或向上时边界已经交叉

**边界更新顺序**：
```
1. 向右走完 → top++   （上边界下移）
2. 向下走完 → right--  （右边界左移）
3. 向左走完 → bottom-- （下边界上移）
4. 向上走完 → left++   （左边界右移）
```

---

## 代码实现

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return []int{}
    }

    m, n := len(matrix), len(matrix[0])
    result := make([]int, 0, m*n)

    top, bottom := 0, m-1
    left, right := 0, n-1

    for top <= bottom && left <= right {
        // 1. 向右：遍历 top 行
        for col := left; col <= right; col++ {
            result = append(result, matrix[top][col])
        }
        top++  // 上边界下移

        // 2. 向下：遍历 right 列
        for row := top; row <= bottom; row++ {
            result = append(result, matrix[row][right])
        }
        right--  // 右边界左移

        // 3. 向左：遍历 bottom 行（需检查是否还有行）
        if top <= bottom {
            for col := right; col >= left; col-- {
                result = append(result, matrix[bottom][col])
            }
            bottom--  // 下边界上移
        }

        // 4. 向上：遍历 left 列（需检查是否还有列）
        if left <= right {
            for row := bottom; row >= top; row-- {
                result = append(result, matrix[row][left])
            }
            left++  // 左边界右移
        }
    }

    return result
}
```

**执行过程示例**（matrix = [[1,2,3],[4,5,6],[7,8,9]]）：

| 轮次 | 方向 | 边界 | 遍历元素 | 边界更新 | result |
|------|------|------|----------|----------|--------|
| 1 | 右 | top=0, left=0→2 | 1,2,3 | top=1 | [1,2,3] |
| 1 | 下 | right=2, top=1→2 | 6,9 | right=1 | [1,2,3,6,9] |
| 1 | 左 | bottom=2, right=1→0 | 8,7 | bottom=1 | [1,2,3,6,9,8,7] |
| 1 | 上 | left=0, bottom=1→1 | 4 | left=1 | [1,2,3,6,9,8,7,4] |
| 2 | 右 | top=1, left=1→1 | 5 | top=2 | [1,2,3,6,9,8,7,4,5] |
| 2 | - | top > bottom | - | 结束 | [1,2,3,6,9,8,7,4,5] |

---

## 复杂度分析

**时间复杂度**：O(m × n)
- 每个元素访问一次

**空间复杂度**：O(1)
- 不计算返回结果占用的空间
- 只使用了常数个变量

---

## 注意事项与易错点

### 1. **向左和向上时的边界检查**

**为什么需要检查？**

考虑单行矩阵 `[[1,2,3]]`：
- 向右：遍历 `[1,2,3]`，`top=1`
- 向下：跳过（`top > bottom`）
- **向左**：如果不检查，会重复遍历 `[3,2,1]` ❌

考虑单列矩阵 `[[1],[2],[3]]`：
- 向右：遍历 `[1]`，`top=1`
- 向下：遍历 `[2,3]`，`right=-1`
- 向左：跳过（`left > right`）
- **向上**：如果不检查，会重复遍历 `[2,1]` ❌

**正确做法**：
```go
// 向左前检查
if top <= bottom {
    for col := right; col >= left; col-- {
        result = append(result, matrix[bottom][col])
    }
    bottom--
}

// 向上前检查
if left <= right {
    for row := bottom; row >= top; row-- {
        result = append(result, matrix[row][left])
    }
    left++
}
```

### 2. **边界更新的时机**

**错误示例**：
```go
// 错误：在遍历前更新边界
top++
for col := left; col <= right; col++ {
    result = append(result, matrix[top][col])  // 错误！跳过了第一行
}
```

**正确做法**：在遍历后更新边界。

### 3. **循环终止条件**

```go
// 正确：AND 条件
for top <= bottom && left <= right {
    // ...
}

// 错误：OR 条件
for top <= bottom || left <= right {  // 错误！可能导致越界
    // ...
}
```

### 4. **特殊情况**

```go
// 空矩阵
if len(matrix) == 0 || len(matrix[0]) == 0 {
    return []int{}
}

// 单元素矩阵
matrix = [[1]]  // 正确输出 [1]

// 单行矩阵
matrix = [[1,2,3]]  // 正确输出 [1,2,3]

// 单列矩阵
matrix = [[1],[2],[3]]  // 正确输出 [1,2,3]
```

### 5. **索引越界**

常见错误：
```go
// 错误：遍历时没有检查边界
for col := left; col <= right; col++ {
    result = append(result, matrix[top][col])
}
// 如果 right 已经 < left，循环不会执行，但如果边界检查错误会导致问题
```

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：顺时针螺旋遍历矩阵
2. 方向顺序：右 → 下 → 左 → 上
3. 边界控制：四个变量控制上下左右边界
4. 关键细节：向左和向上时需要额外边界检查
5. 终止条件：边界交叉时停止
6. 复杂度分析：O(m×n) 时间，O(1) 空间

**可能的追问**：

- **Q: 为什么向左和向上需要边界检查？**
  - A: 因为对于单行或单列矩阵，在向右或向下之后，边界可能已经交叉。如果不检查，会重复遍历已访问的元素。

- **Q: 能否用其他方法？**
  - A: 可以用方向向量 + 访问标记，但边界控制法更简洁高效。

- **Q: 如果要求逆时针螺旋呢？**
  - A: 改变遍历顺序为：下 → 右 → 上 → 左即可。

- **Q: 如何生成螺旋矩阵（LeetCode 59）？**
  - A: 同样的边界控制法，按螺旋顺序填充数字 1 到 n²。

- **Q: 矩阵很大时如何优化？**
  - A: 算法已经是 O(m×n) 最优。如果需要流式处理，可以按层遍历，避免一次性加载整个矩阵。

- **Q: 边界更新的顺序能否改变？**
  - A: 不能。必须先遍历完一条边，再更新对应边界，否则会跳过或重复元素。

**类似问题**：
- 螺旋矩阵 II（LeetCode 59）：生成螺旋矩阵
- 螺旋矩阵 III（LeetCode 885）：从中心开始螺旋遍历
- 对角线遍历（LeetCode 498）：Z 字形遍历

---

## 扩展：方向向量法

**另一种实现方式**：用方向向量控制前进方向。

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return []int{}
    }

    m, n := len(matrix), len(matrix[0])
    result := make([]int, 0, m*n)
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }

    // 方向向量：右、下、左、上
    dr := []int{0, 1, 0, -1}
    dc := []int{1, 0, -1, 0}

    r, c, dir := 0, 0, 0  // 当前位置和方向

    for i := 0; i < m*n; i++ {
        result = append(result, matrix[r][c])
        visited[r][c] = true

        // 计算下一个位置
        nr, nc := r+dr[dir], c+dc[dir]

        // 如果下一个位置越界或已访问，转向
        if nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc] {
            dir = (dir + 1) % 4  // 顺时针转向
            nr, nc = r+dr[dir], c+dc[dir]
        }

        r, c = nr, nc
    }

    return result
}
```

**对比**：
- 边界控制法：更简洁，O(1) 空间
- 方向向量法：更直观，但需要 O(m×n) 空间存储访问状态

**面试推荐**：边界控制法（效率更高）。
