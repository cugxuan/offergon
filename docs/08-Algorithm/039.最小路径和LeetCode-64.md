---
title: 最小路径和（LeetCode 64）
tags:
  - 算法
status: robot
class: 算法
slug: minimum-path-sum
ref:
---

## 核心要点

这是一道经典的**二维动态规划**问题，与"不同路径"类似但增加了权重：
- **核心思想**：到达某个格子的最小路径和 = min(从上方到达的最小和, 从左方到达的最小和) + 当前格子的值
- **状态定义**：`dp[i][j]` 表示从左上角 `(0,0)` 到达格子 `(i,j)` 的最小路径和
- **优化方法**：可以原地修改输入数组（空间 O(1)），或使用一维数组滚动优化（空间 O(n)）

---

## 详细解答

### 问题描述

给定一个包含非负整数的 `m x n` 网格 `grid`，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

**示例：**
```
输入：grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出：7
解释：路径 1 → 3 → 1 → 1 → 1 的总和最小（1+3+1+1+1=7）

输入：grid = [
  [1,2,3],
  [4,5,6]
]
输出：12
解释：路径 1 → 2 → 3 → 6 的总和最小（1+2+3+6=12）
```

---

### 解题思路

#### 动态规划分析

与"不同路径"问题的区别：
- **不同路径**：计算路径的**数量**
- **最小路径和**：计算路径的**最小权重和**

核心思想：
- 要到达 `(i, j)`，只能从 `(i-1, j)` 或 `(i, j-1)` 过来
- 选择路径和更小的那条路径，再加上当前格子的值

**状态转移方程：**
```
dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
```

**边界条件：**
- 第一行：只能从左边过来，`dp[0][j] = dp[0][j-1] + grid[0][j]`
- 第一列：只能从上面过来，`dp[i][0] = dp[i-1][0] + grid[i][0]`
- 起点：`dp[0][0] = grid[0][0]`

---

### 代码实现（Go）

**方法一：二维 DP（直观清晰）**

```go
func minPathSum(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    // 初始化起点
    dp[0][0] = grid[0][0]

    // 初始化第一列（只能从上往下）
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }

    // 初始化第一行（只能从左往右）
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    // 状态转移
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }

    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(m * n)

---

**方法二：原地修改（最优空间）**

如果可以修改原数组，可以直接在 `grid` 上进行 DP，空间复杂度降为 O(1)：

```go
func minPathSum(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])

    // 初始化第一列
    for i := 1; i < m; i++ {
        grid[i][0] += grid[i-1][0]
    }

    // 初始化第一行
    for j := 1; j < n; j++ {
        grid[0][j] += grid[0][j-1]
    }

    // 状态转移
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        }
    }

    return grid[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(1)（原地修改）

---

**方法三：一维 DP（空间优化）**

如果不能修改原数组，可以用一维数组滚动优化：

```go
func minPathSum(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])
    dp := make([]int, n)

    // 初始化第一行
    dp[0] = grid[0][0]
    for j := 1; j < n; j++ {
        dp[j] = dp[j-1] + grid[0][j]
    }

    // 逐行更新
    for i := 1; i < m; i++ {
        // 更新第一列（只能从上面来）
        dp[0] += grid[i][0]

        // 更新其他列
        for j := 1; j < n; j++ {
            // dp[j] 是上一行的值（从上面来）
            // dp[j-1] 是当前行左边的值（从左边来）
            dp[j] = min(dp[j], dp[j-1]) + grid[i][j]
        }
    }

    return dp[n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(n)

---

### 图解示例

以题目示例为例：

```
输入矩阵：
1  3  1
1  5  1
4  2  1

步骤 1：初始化第一行和第一列
1   4   5
2   ?   ?
6   ?   ?

第一行：1 → 1+3=4 → 4+1=5
第一列：1 → 1+1=2 → 2+4=6

步骤 2：计算 dp[1][1]
从上面来：4 + 5 = 9
从左边来：2 + 5 = 7
取最小：min(9, 7) = 7

1   4   5
2   7   ?
6   ?   ?

步骤 3：计算 dp[1][2]
从上面来：5 + 1 = 6
从左边来：7 + 1 = 8
取最小：min(6, 8) = 6

1   4   5
2   7   6
6   ?   ?

步骤 4：计算 dp[2][1]
从上面来：7 + 2 = 9
从左边来：6 + 2 = 8
取最小：min(9, 8) = 8

1   4   5
2   7   6
6   8   ?

步骤 5：计算 dp[2][2]
从上面来：6 + 1 = 7
从左边来：8 + 1 = 9
取最小：min(7, 9) = 7

1   4   5
2   7   6
6   8   7
```

最终答案是 `dp[2][2] = 7`。

---

## 面试要点总结

1. **识别 DP 问题**：最小路径和是典型的"路径选择"问题，需要在多个选择中找最优解
2. **状态转移清晰**：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`
3. **边界处理**：第一行和第一列需要单独初始化
4. **空间优化技巧**：
   - 如果可以修改原数组：原地 DP，O(1) 空间
   - 如果不能修改原数组：一维滚动数组，O(n) 空间
5. **类似问题扩展**：
   - **不同路径 I/II**：计数问题
   - **最大路径和**：求最大值（状态转移用 max 代替 min）
   - **地下城游戏**：从右下往左上的逆向 DP

这题是二维 DP 的经典问题，掌握后可以应对大部分网格路径类的动态规划题目。
