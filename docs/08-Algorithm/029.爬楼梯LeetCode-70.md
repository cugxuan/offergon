---
title: 爬楼梯(LeetCode 70)
tags:
  - 算法
status: robot
class: 算法
slug: climbing-stairs
ref:
---

## 核心要点

**经典动态规划入门题,状态转移方程: dp[i] = dp[i-1] + dp[i-2],本质是斐波那契数列**

到达第 n 阶的方法数 = 从第 n-1 阶跨 1 步 + 从第 n-2 阶跨 2 步。可优化空间至 O(1)。面试时要能说出暴力递归→记忆化→动态规划→空间优化的完整思路。

---

## 详细解答

### 一、题目理解

假设你正在爬楼梯,需要 n 阶才能到达楼顶。

每次你可以爬 **1 或 2 个台阶**。有多少种不同的方法可以爬到楼顶?

**示例**:
- 输入:`n = 3`
- 输出:`3`
- 解释:有三种方法爬到楼顶
  1. 1 阶 + 1 阶 + 1 阶
  2. 1 阶 + 2 阶
  3. 2 阶 + 1 阶

---

### 二、思路分析

#### 思路 1:暴力递归(超时)

**核心观察**:
- 要到达第 n 阶,最后一步有两种选择:
  - 从第 n-1 阶跨 1 步
  - 从第 n-2 阶跨 2 步
- 因此:`f(n) = f(n-1) + f(n-2)`

**递归边界**:
- `f(1) = 1`(只有一种方法:跨 1 步)
- `f(2) = 2`(两种方法:1+1 或 2)

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    return climbStairs(n-1) + climbStairs(n-2)
}
```

**时间复杂度**: O(2^n) - 存在大量重复计算,会超时

---

#### 思路 2:记忆化递归(可通过)

用数组缓存已计算的结果,避免重复计算。

```go
func climbStairs(n int) int {
    memo := make(map[int]int)
    return helper(n, memo)
}

func helper(n int, memo map[int]int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    if val, ok := memo[n]; ok {
        return val
    }
    memo[n] = helper(n-1, memo) + helper(n-2, memo)
    return memo[n]
}
```

**时间复杂度**: O(n)
**空间复杂度**: O(n) - 递归栈 + 缓存数组

---

#### 思路 3:动态规划(推荐)

**核心思想**: 从底向上计算,避免递归

**状态定义**: `dp[i]` 表示爬到第 i 阶的方法数

**状态转移**: `dp[i] = dp[i-1] + dp[i-2]`

**初始状态**:
- `dp[1] = 1`
- `dp[2] = 2`

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }

    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2

    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
```

**时间复杂度**: O(n)
**空间复杂度**: O(n)

---

#### 思路 4:空间优化(最优)

观察到 `dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]`,不需要保存整个数组,只需要两个变量。

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }

    prev2 := 1 // dp[i-2]
    prev1 := 2 // dp[i-1]

    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }

    return prev1
}
```

**时间复杂度**: O(n)
**空间复杂度**: O(1) ⭐

---

### 三、完整代码(空间优化版)

```go
func climbStairs(n int) int {
    // 处理边界情况
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }

    // 初始化前两个状态
    prev2 := 1 // 爬到第 1 阶的方法数
    prev1 := 2 // 爬到第 2 阶的方法数

    // 从第 3 阶开始计算
    for i := 3; i <= n; i++ {
        current := prev1 + prev2 // 状态转移
        prev2 = prev1            // 更新 prev2
        prev1 = current          // 更新 prev1
    }

    return prev1
}
```

---

### 四、复杂度分析

| 解法 | 时间复杂度 | 空间复杂度 | 是否推荐 |
|------|-----------|-----------|---------|
| 暴力递归 | O(2^n) | O(n) | ❌ 超时 |
| 记忆化递归 | O(n) | O(n) | ✓ 可通过 |
| 动态规划 | O(n) | O(n) | ✓ 推荐 |
| 空间优化 | O(n) | O(1) | ⭐ 最优 |

---

### 五、示例演示

#### 示例:n = 5

**计算过程**:

```
初始状态:
prev2 = 1 (第 1 阶)
prev1 = 2 (第 2 阶)

i = 3:
  current = 2 + 1 = 3
  prev2 = 2, prev1 = 3

i = 4:
  current = 3 + 2 = 5
  prev2 = 3, prev1 = 5

i = 5:
  current = 5 + 3 = 8
  prev2 = 5, prev1 = 8

返回: 8
```

**验证**:爬到第 5 阶的 8 种方法:
1. 1+1+1+1+1
2. 1+1+1+2
3. 1+1+2+1
4. 1+2+1+1
5. 2+1+1+1
6. 1+2+2
7. 2+1+2
8. 2+2+1

---

### 六、本质:斐波那契数列

仔细观察,这道题就是**斐波那契数列**的变形:

```
f(1) = 1
f(2) = 2
f(3) = 3
f(4) = 5
f(5) = 8
...
```

对比标准斐波那契数列:
```
fib(1) = 1
fib(2) = 1
fib(3) = 2
fib(4) = 3
fib(5) = 5
...
```

关系:`climbStairs(n) = fib(n+1)`

---

### 七、进阶优化:矩阵快速幂 O(log n)

如果 n 非常大(如 10^9),可以用**矩阵快速幂**优化到 O(log n):

斐波那契数列的矩阵形式:

```
[F(n+1)]   [1 1]^n   [1]
[F(n)  ] = [1 0]   × [0]
```

通过快速幂计算矩阵的 n 次方,时间复杂度 O(log n)。

**代码示例**(了解即可,面试一般不要求):

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }

    // 矩阵快速幂
    matrix := [][]int{{1, 1}, {1, 0}}
    result := matrixPow(matrix, n)
    return result[0][0]
}

func matrixPow(matrix [][]int, n int) [][]int {
    result := [][]int{{1, 0}, {0, 1}} // 单位矩阵
    base := matrix

    for n > 0 {
        if n%2 == 1 {
            result = matrixMultiply(result, base)
        }
        base = matrixMultiply(base, base)
        n /= 2
    }

    return result
}

func matrixMultiply(a, b [][]int) [][]int {
    return [][]int{
        {a[0][0]*b[0][0] + a[0][1]*b[1][0], a[0][0]*b[0][1] + a[0][1]*b[1][1]},
        {a[1][0]*b[0][0] + a[1][1]*b[1][0], a[1][0]*b[0][1] + a[1][1]*b[1][1]},
    }
}
```

---

### 八、易错点

1. **边界条件处理**
   - `n=1` 时返回 1,`n=2` 时返回 2
   - 不要忘记处理这两个特殊情况

2. **状态转移理解**
   - 不是 `dp[i] = dp[i-1] * 2`,而是 `dp[i] = dp[i-1] + dp[i-2]`
   - 要理解"加法原理":到达 n 的方法数 = 两种途径的方法数之和

3. **空间优化时的变量更新顺序**
   ```go
   current := prev1 + prev2
   prev2 = prev1  // 必须先更新 prev2
   prev1 = current // 再更新 prev1
   ```
   如果顺序反了,会导致 prev2 被覆盖

4. **初始值设置**
   - `prev2 = 1` 对应 `dp[1]`
   - `prev1 = 2` 对应 `dp[2]`
   - 循环从 `i=3` 开始

---

### 九、面试技巧

1. **完整展示思考过程**
   - 从暴力递归开始说起
   - 分析重复计算问题 → 记忆化
   - 再说动态规划 → 空间优化
   - 展示完整的优化思路

2. **画图辅助**
   - 画出递归树,展示重复计算
   - 画出 dp 数组的填充过程

3. **指出本质**
   - 强调这是斐波那契数列的变形
   - 展示数学洞察力

4. **主动讨论扩展**
   - 如果每次可以跨 1,2,3 步怎么办?
     - 状态转移:`dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`
   - 如果 n 非常大怎么办?
     - 提出矩阵快速幂优化

5. **代码规范**
   - 处理边界情况
   - 变量命名清晰(`prev1`, `prev2`, `current`)
   - 添加必要注释

**追问应对**:

- **Q: 如果可以跨 1,2,3,...,k 步怎么办?**
  - A: 状态转移变为 `dp[i] = sum(dp[i-1], dp[i-2], ..., dp[i-k])`,时间复杂度 O(nk),可以用前缀和优化到 O(n)。

- **Q: 如果某些台阶不能踩怎么办?**
  - A: 初始化 `dp[i] = 0` 对于不能踩的台阶,正常的台阶继续用状态转移方程。

- **Q: 能否用数学公式直接计算?**
  - A: 可以,斐波那契数列有通项公式(Binet公式):`F(n) = (φ^n - ψ^n) / √5`,其中 φ=(1+√5)/2,ψ=(1-√5)/2。但涉及浮点运算,精度问题,面试不推荐。

- **Q: 这道题考察什么?**
  - A: 考察动态规划思想、状态转移方程的推导、空间优化能力,以及对斐波那契数列的认识。是动态规划入门的经典题目。

---

### 十、变体题目

熟悉这道题后,可以尝试以下变体:

1. **LeetCode 746 - 使用最小花费爬楼梯**
   - 每个台阶有花费,求最小花费
   - 状态转移:`dp[i] = min(dp[i-1], dp[i-2]) + cost[i]`

2. **LeetCode 509 - 斐波那契数**
   - 直接求斐波那契数列第 n 项

3. **LeetCode 1137 - 第 N 个泰波那契数**
   - 状态转移:`T(n) = T(n-1) + T(n-2) + T(n-3)`

这些题目都是类似的递推思想,掌握了爬楼梯,其他题目也能迎刃而解。
