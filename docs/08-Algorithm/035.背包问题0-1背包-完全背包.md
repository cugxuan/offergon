---
title: 背包问题（0-1背包、完全背包）
tags:
  - 算法
status: robot
class: 算法
slug: knapsack-problem-01-complete
ref:
---

## 核心要点

- **0-1 背包**: 每个物品只能选一次,求最大价值
  - **状态**: `dp[i][j]` 表示前 i 个物品,容量为 j 时的最大价值
  - **转移**: `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`
  - **空间优化**: 一维数组**逆序**遍历
- **完全背包**: 每个物品可以选无限次,求最大价值
  - **状态**: 同 0-1 背包
  - **转移**: `dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])`
  - **空间优化**: 一维数组**正序**遍历
- **关键区别**: 0-1 背包依赖 `dp[i-1]`,完全背包依赖 `dp[i]`
- **变种问题**: 恰好装满、求方案数、求最小价值等

## 问题描述

### 0-1 背包问题

有 `n` 个物品和一个容量为 `W` 的背包。第 `i` 个物品的重量是 `w[i]`,价值是 `v[i]`。

**要求**: 每个物品只能选 0 次或 1 次,求背包能装下的最大价值。

**示例:**
```
输入:
n = 3, W = 4
w = [4, 2, 3]
v = [4, 2, 3]

输出: 4
解释: 选择第 1 个物品,重量 4,价值 4
```

### 完全背包问题

有 `n` 个物品和一个容量为 `W` 的背包。第 `i` 个物品的重量是 `w[i]`,价值是 `v[i]`。

**要求**: 每个物品可以选**无限次**,求背包能装下的最大价值。

**示例:**
```
输入:
n = 3, W = 10
w = [2, 3, 4]
v = [4, 5, 6]

输出: 20
解释: 选择第 1 个物品 5 次,重量 10,价值 20
```

## 0-1 背包详解

### 二维 DP 解法

#### 状态定义

`dp[i][j]` 表示从前 `i` 个物品中选择,背包容量为 `j` 时能获得的最大价值。

#### 状态转移方程

对于第 `i` 个物品(索引从 1 开始),有两种选择:

1. **不选第 i 个物品**: `dp[i][j] = dp[i-1][j]`
   - 最大价值等于前 i-1 个物品的最大价值

2. **选第 i 个物品**(前提: `j >= w[i]`): `dp[i][j] = dp[i-1][j-w[i]] + v[i]`
   - 先留出 `w[i]` 的空间给第 i 个物品
   - 剩余容量 `j - w[i]` 从前 i-1 个物品中选择
   - 加上第 i 个物品的价值 `v[i]`

**综合:**
```
if j >= w[i]:
    dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
else:
    dp[i][j] = dp[i-1][j]
```

#### 初始化

- `dp[0][j] = 0`: 没有物品时,价值为 0
- `dp[i][0] = 0`: 容量为 0 时,价值为 0

#### 代码实现

```go
func knapsack01(n int, W int, w []int, v []int) int {
    // dp[i][j] 表示前 i 个物品,容量为 j 时的最大价值
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }

    // 遍历物品
    for i := 1; i <= n; i++ {
        // 遍历容量
        for j := 0; j <= W; j++ {
            // 不选第 i 个物品
            dp[i][j] = dp[i-1][j]

            // 选第 i 个物品(如果容量足够)
            if j >= w[i-1] {
                dp[i][j] = max(dp[i][j], dp[i-1][j-w[i-1]] + v[i-1])
            }
        }
    }

    return dp[n][W]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 一维 DP 优化(重要!)

观察状态转移方程,`dp[i][j]` 只依赖于 `dp[i-1][...]`,可以用一维数组优化。

**关键点: 必须逆序遍历容量!**

**为什么逆序?**
- `dp[j]` 依赖于 `dp[j-w[i]]`
- 如果正序遍历,`dp[j-w[i]]` 可能已经被更新为第 i 轮的值
- 逆序遍历保证 `dp[j-w[i]]` 还是第 i-1 轮的值(即 `dp[i-1][j-w[i]]`)

#### 代码实现

```go
func knapsack01Optimized(n int, W int, w []int, v []int) int {
    // dp[j] 表示容量为 j 时的最大价值
    dp := make([]int, W+1)

    // 遍历物品
    for i := 0; i < n; i++ {
        // 逆序遍历容量(关键!)
        for j := W; j >= w[i]; j-- {
            dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        }
    }

    return dp[W]
}
```

**复杂度:**
- 时间复杂度: O(n × W)
- 空间复杂度: O(W)

## 完全背包详解

### 二维 DP 解法

#### 状态定义

`dp[i][j]` 表示从前 `i` 种物品中选择(每种可选无限次),背包容量为 `j` 时的最大价值。

#### 状态转移方程

与 0-1 背包的区别: 选第 i 个物品后,仍然可以再选第 i 个物品。

```
if j >= w[i]:
    dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
                                  ↑ 注意这里是 dp[i],不是 dp[i-1]
else:
    dp[i][j] = dp[i-1][j]
```

**关键区别:**
- **0-1 背包**: `dp[i-1][j-w[i]] + v[i]` (从前 i-1 个物品中选)
- **完全背包**: `dp[i][j-w[i]] + v[i]` (从前 i 个物品中选,可以重复选第 i 个)

#### 代码实现

```go
func knapsackComplete(n int, W int, w []int, v []int) int {
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }

    for i := 1; i <= n; i++ {
        for j := 0; j <= W; j++ {
            dp[i][j] = dp[i-1][j]

            if j >= w[i-1] {
                // 注意这里是 dp[i][j-w[i-1]],不是 dp[i-1][...]
                dp[i][j] = max(dp[i][j], dp[i][j-w[i-1]] + v[i-1])
            }
        }
    }

    return dp[n][W]
}
```

### 一维 DP 优化(重要!)

**关键点: 必须正序遍历容量!**

**为什么正序?**
- `dp[j]` 依赖于 `dp[j-w[i]]`
- 正序遍历时,`dp[j-w[i]]` 已经在本轮更新过,包含了第 i 个物品
- 这样就实现了"可以多次选择第 i 个物品"的效果

#### 代码实现

```go
func knapsackCompleteOptimized(n int, W int, w []int, v []int) int {
    dp := make([]int, W+1)

    // 遍历物品
    for i := 0; i < n; i++ {
        // 正序遍历容量(关键!)
        for j := w[i]; j <= W; j++ {
            dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        }
    }

    return dp[W]
}
```

**复杂度:**
- 时间复杂度: O(n × W)
- 空间复杂度: O(W)

## 0-1 背包 vs 完全背包对比

| 特征 | 0-1 背包 | 完全背包 |
|------|---------|---------|
| **物品使用次数** | 每个物品最多选 1 次 | 每个物品可选无限次 |
| **二维 DP 转移** | `dp[i-1][j-w[i]] + v[i]` | `dp[i][j-w[i]] + v[i]` |
| **一维 DP 遍历** | **逆序**遍历容量 | **正序**遍历容量 |
| **典型例题** | LeetCode 416 分割等和子集 | LeetCode 322 零钱兑换 |

**记忆口诀:**
- **0-1 背包逆序,完全背包正序**
- **0-1 依赖上一行(i-1),完全依赖本行(i)**

## 详细推导示例

### 0-1 背包示例

```
n = 3, W = 4
w = [4, 2, 3]
v = [4, 2, 3]

二维 DP 表格:

物品 \ 容量  0  1  2  3  4
    0       0  0  0  0  0
    1 (4,4) 0  0  0  0  4
    2 (2,2) 0  0  2  2  4
    3 (3,3) 0  0  2  3  4

解释:
dp[1][4] = 4: 选物品1,价值4
dp[2][2] = 2: 选物品2,价值2
dp[2][4] = 4: 选物品1(不选物品2)
dp[3][3] = 3: 选物品3,价值3
dp[3][4] = 4: 选物品1 或 选物品2+物品3(都是4)

答案: dp[3][4] = 4
```

### 完全背包示例

```
n = 3, W = 10
w = [2, 3, 4]
v = [4, 5, 6]

一维 DP 演示(逐步更新):

初始: dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

处理物品1 (w=2, v=4): 正序遍历
  dp[2] = max(0, dp[0] + 4) = 4
  dp[4] = max(0, dp[2] + 4) = 8
  dp[6] = max(0, dp[4] + 4) = 12
  dp[8] = max(0, dp[6] + 4) = 16
  dp[10] = max(0, dp[8] + 4) = 20

  结果: dp = [0, 0, 4, 4, 8, 8, 12, 12, 16, 16, 20]

处理物品2 (w=3, v=5): 正序遍历
  dp[3] = max(4, dp[0] + 5) = 5
  dp[5] = max(8, dp[2] + 5) = 9
  dp[6] = max(12, dp[3] + 5) = 12
  ...
  dp[10] = max(20, dp[7] + 5) = 20

  结果: dp = [0, 0, 4, 5, 8, 9, 12, 13, 16, 17, 20]

处理物品3 (w=4, v=6): 正序遍历
  dp[4] = max(8, dp[0] + 6) = 8
  dp[6] = max(12, dp[2] + 6) = 12
  dp[8] = max(16, dp[4] + 6) = 16
  dp[10] = max(20, dp[6] + 6) = 20

  最终: dp = [0, 0, 4, 5, 8, 9, 12, 13, 16, 17, 20]

答案: dp[10] = 20 (选5个物品1)
```

## 常见变种问题

### 1. 恰好装满背包

如果要求**恰好装满**背包(容量必须刚好是 W):

**初始化:**
```go
dp := make([]int, W+1)
for i := 1; i <= W; i++ {
    dp[i] = -∞  // 表示无法达到
}
dp[0] = 0  // 容量0可以达到,价值0
```

最后判断 `dp[W]` 是否仍为 -∞,如果是说明无法恰好装满。

### 2. 求方案数

求有多少种方案可以装满背包:

**状态定义**: `dp[j]` 表示容量为 j 的方案数

**初始化**: `dp[0] = 1`

**转移方程**:
- 0-1 背包: `dp[j] += dp[j-w[i]]` (逆序)
- 完全背包: `dp[j] += dp[j-w[i]]` (正序)

**例题**: LeetCode 494 目标和、LeetCode 518 零钱兑换 II

### 3. 求最小价值

如果要求最小价值(如最少硬币数):

**初始化**: `dp[j] = +∞` (除了 `dp[0] = 0`)

**转移方程**: `dp[j] = min(dp[j], dp[j-w[i]] + v[i])`

**例题**: LeetCode 322 零钱兑换

### 4. 多重背包

每个物品有数量限制 `nums[i]`:
- 如果 `nums[i]` 较小,可以拆成 nums[i] 个物品,用 0-1 背包
- 如果 `nums[i]` 很大,用二进制拆分优化

### 5. 分组背包

物品分成若干组,每组只能选一个物品。

### 6. 求具体方案

在 DP 的基础上,记录每个状态的选择,最后回溯构造方案。

## LeetCode 典型题目

### 0-1 背包类

1. **分割等和子集**(LeetCode 416): 判断是否能分成两个和相等的子集
   - 转化为: 是否能装满容量为 sum/2 的背包

2. **目标和**(LeetCode 494): 给数组元素添加 +/- 符号,使结果等于 target
   - 转化为: 0-1 背包求方案数

3. **最后一块石头的重量 II**(LeetCode 1049): 最小化两堆石头重量差
   - 转化为: 尽量装满容量为 sum/2 的背包

### 完全背包类

1. **零钱兑换**(LeetCode 322): 求最少硬币数
   - 完全背包求最小值

2. **零钱兑换 II**(LeetCode 518): 求凑成金额的方案数
   - 完全背包求方案数

3. **完全平方数**(LeetCode 279): 最少的完全平方数之和
   - 完全背包,物品是完全平方数

## 面试技巧

1. **快速识别背包类型**:
   - 听到"每个物品只能用一次" → 0-1 背包
   - 听到"每个物品可以用无限次" → 完全背包

2. **状态定义要清晰**: 说明 `dp[i][j]` 的含义

3. **画表格演示**: 用小例子画出 DP 表格,展示填表过程

4. **强调遍历顺序**:
   - 0-1 背包: 逆序遍历容量
   - 完全背包: 正序遍历容量
   - 解释为什么(依赖关系)

5. **变种问题的转化**: 说明如何把实际问题转化为背包问题

6. **初始化很重要**: 根据题目要求(最大值、最小值、方案数)选择合适的初始化

7. **边界情况**:
   - 背包容量为 0
   - 没有物品
   - 所有物品都放不下

## 总结

**背包问题是动态规划的核心模型**,掌握了背包问题,很多 DP 问题都能迎刃而解。

**记住两个关键点:**
1. **0-1 背包逆序,完全背包正序**(一维 DP)
2. **求最大值初始化 0,求最小值初始化 ∞,求方案数初始化 dp[0]=1**

**练习建议:**
- 先做 LeetCode 416、322、518 三道经典题
- 理解背包问题的本质: **在限制条件下优化目标函数**
- 多画图、多推导,理解状态转移的含义
