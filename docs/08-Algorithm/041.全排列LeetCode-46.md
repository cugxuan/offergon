---
title: 全排列(LeetCode 46)
tags:
  - 算法
status: robot
class: 算法
slug: permutations
ref:
---

## 核心要点

**回溯算法的经典应用，通过递归构建决策树，用"选择-递归-撤销"三步实现全排列生成。时间复杂度 O(n×n!)，空间复杂度 O(n)。**

---

## 题目描述

给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。

**示例：**
```
输入: nums = [1,2,3]
输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

---

## 解题思路

### 1. 问题分析

全排列问题的本质是：
- 从 n 个不同元素中依次选择，每次选择后剩余元素减少
- 每个元素在结果中只能出现一次
- 需要穷举所有可能的排列组合

### 2. 回溯算法框架

回溯算法的三个关键步骤：

```
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择 (将选择从选择列表移除，加入路径)
        backtrack(路径, 选择列表)
        撤销选择 (将选择从路径移除，恢复到选择列表)
```

### 3. 全排列的决策树

以 `[1,2,3]` 为例，决策树如下：

```
                        []
                   /    |    \
                 [1]   [2]   [3]
                / \    / \    / \
            [1,2][1,3][2,1][2,3][3,1][3,2]
             |    |    |    |    |    |
          [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
```

- **每一层**：表示在当前路径基础上可以做的选择
- **每个节点**：表示一个中间状态（部分排列）
- **叶子节点**：表示完整的排列结果

---

## 代码实现

### Go 语言实现

```go
func permute(nums []int) [][]int {
    result := [][]int{}
    used := make([]bool, len(nums))  // 标记数组，记录元素是否已被使用
    path := []int{}                   // 当前路径

    var backtrack func()
    backtrack = func() {
        // 递归终止条件：路径长度等于数组长度
        if len(path) == len(nums) {
            // 注意：必须复制 path，否则后续修改会影响已加入的结果
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }

        // 遍历所有可选元素
        for i := 0; i < len(nums); i++ {
            // 跳过已使用的元素
            if used[i] {
                continue
            }

            // 做选择
            path = append(path, nums[i])
            used[i] = true

            // 递归：继续选择下一个元素
            backtrack()

            // 撤销选择（回溯）
            path = path[:len(path)-1]
            used[i] = false
        }
    }

    backtrack()
    return result
}
```

### 另一种实现：不使用 used 数组

通过交换元素实现：

```go
func permute(nums []int) [][]int {
    result := [][]int{}

    var backtrack func(start int)
    backtrack = func(start int) {
        // 所有位置都已确定
        if start == len(nums) {
            temp := make([]int, len(nums))
            copy(temp, nums)
            result = append(result, temp)
            return
        }

        // 尝试将每个元素放在 start 位置
        for i := start; i < len(nums); i++ {
            // 交换：将 nums[i] 放到 start 位置
            nums[start], nums[i] = nums[i], nums[start]

            // 递归：处理下一个位置
            backtrack(start + 1)

            // 回溯：恢复原状
            nums[start], nums[i] = nums[i], nums[start]
        }
    }

    backtrack(0)
    return result
}
```

---

## 详细执行过程（以 [1,2,3] 为例）

### 第一种实现（used 数组）

```
初始: path=[], used=[false,false,false]

第1步: 选择1 -> path=[1], used=[true,false,false]
  第2步: 选择2 -> path=[1,2], used=[true,true,false]
    第3步: 选择3 -> path=[1,2,3] ✓ 结果加入 [[1,2,3]]
    回溯: path=[1,2], used=[true,true,false]
  回溯: path=[1], used=[true,false,false]

  第2步: 选择3 -> path=[1,3], used=[true,false,true]
    第3步: 选择2 -> path=[1,3,2] ✓ 结果加入 [[1,2,3],[1,3,2]]
    回溯: path=[1,3], used=[true,false,true]
  回溯: path=[1], used=[true,false,false]
回溯: path=[], used=[false,false,false]

第1步: 选择2 -> path=[2], used=[false,true,false]
  ... (类似过程)

第1步: 选择3 -> path=[3], used=[false,false,true]
  ... (类似过程)
```

---

## 复杂度分析

### 时间复杂度：O(n × n!)

- 共有 n! 个排列
- 每个排列需要 O(n) 时间复制到结果中
- 总时间：n × n!

### 空间复杂度：O(n)

- 递归调用栈深度为 n
- path 数组最大长度为 n
- used 数组长度为 n
- 不计算结果存储空间

---

## 关键要点总结

1. **回溯模板**：选择 → 递归 → 撤销，这是解决排列组合问题的通用框架

2. **去重机制**：
   - 方法1：used 数组标记已使用元素
   - 方法2：通过交换保证每个位置不重复选择

3. **深拷贝**：将 path 加入结果时必须复制，因为 path 会被后续修改

4. **剪枝优化**：used 数组实现了隐式剪枝，避免选择已使用的元素

5. **状态恢复**：回溯时必须恢复状态，保证不同分支互不影响

---

## 面试回答要点

**面试官：如何实现全排列？**

**回答框架：**

"全排列是回溯算法的经典应用。我会这样思考：

1. **问题建模**：把问题看作一棵决策树，每层选择一个未使用的元素
2. **回溯三部曲**：做选择→递归下探→撤销选择
3. **终止条件**：当路径长度等于数组长度时，得到一个完整排列
4. **去重策略**：用 used 数组标记已使用元素，避免重复选择

时间复杂度是 O(n×n!)，因为有 n! 个排列，每个需要 O(n) 时间复制。空间复杂度是 O(n)，主要是递归栈和辅助数组。

如果面试时间充裕，我可以进一步讨论交换法实现，以及如何处理包含重复元素的情况（LeetCode 47）。"

---

## 扩展问题

1. **全排列 II**（LeetCode 47）：如果数组包含重复元素怎么办？
   - 需要先排序，然后在回溯时跳过重复元素
   - 剪枝条件：`if i > 0 && nums[i] == nums[i-1] && !used[i-1]`

2. **第 k 个排列**（LeetCode 60）：如何直接计算第 k 个排列而不生成所有排列？
   - 使用康托展开（Cantor Expansion）数学方法

3. **下一个排列**（LeetCode 31）：给定一个排列，如何找到字典序的下一个排列？
   - 两遍扫描 + 交换 + 反转
