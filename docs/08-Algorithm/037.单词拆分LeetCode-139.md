---
title: 单词拆分（LeetCode 139）
tags:
  - 算法
status: robot
class: 算法
slug: word-break
ref:
---

## 核心要点

这是一道经典的**动态规划 + 字符串匹配**问题：
- **核心思想**：用 `dp[i]` 表示字符串前 `i` 个字符能否被字典中的单词拆分
- **状态转移**：对于每个位置 `i`，检查是否存在某个位置 `j < i`，使得 `dp[j] = true` 且 `s[j:i]` 在字典中
- **优化技巧**：使用 HashMap 存储字典，将单词查找从 O(n) 降低到 O(1)

---

## 详细解答

### 问题描述

给定一个**非空字符串** `s` 和一个包含**非空单词**的列表 `wordDict`，判断 `s` 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**
- 拆分时可以重复使用字典中的单词
- 你可以假设字典中没有重复的单词

**示例：**
```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: "leetcode" 可以拆分成 "leet" 和 "code"

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 可以拆分成 "apple pen apple"（注意可以重复使用字典中的单词）

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

---

### 解题思路

这题的关键是**动态规划**的思维：
1. 定义状态 `dp[i]`：表示字符串 `s[0:i]`（前 `i` 个字符）能否被拆分成字典中的单词
2. 初始化 `dp[0] = true`，表示空字符串可以被拆分（边界条件）
3. 状态转移：
   ```
   对于每个位置 i (1 ≤ i ≤ len(s))：
       遍历 j (0 ≤ j < i)：
           如果 dp[j] == true 且 s[j:i] 在字典中：
               dp[i] = true
               break
   ```

**为什么这样设计？**
- `dp[j] = true` 表示前 `j` 个字符可以拆分
- `s[j:i]` 在字典中表示从 `j` 到 `i` 的子串是一个合法单词
- 如果两个条件都满足，说明前 `i` 个字符可以拆分（前 `j` 个已经拆分好，后面接一个合法单词）

---

### 代码实现（Go）

```go
func wordBreak(s string, wordDict []string) bool {
    // 将字典转换为 map，方便 O(1) 查找
    wordSet := make(map[string]bool)
    for _, word := range wordDict {
        wordSet[word] = true
    }

    n := len(s)
    dp := make([]bool, n+1)
    dp[0] = true // 空字符串可以拆分

    // 遍历字符串的每个位置
    for i := 1; i <= n; i++ {
        // 尝试在 [0, i) 的每个位置 j 进行拆分
        for j := 0; j < i; j++ {
            // 如果前 j 个字符可以拆分，且 s[j:i] 是字典中的单词
            if dp[j] && wordSet[s[j:i]] {
                dp[i] = true
                break // 找到一种拆分方式即可
            }
        }
    }

    return dp[n]
}
```

---

### 复杂度分析

**时间复杂度：** O(n²)
- 外层循环遍历字符串长度 `n`
- 内层循环最多遍历 `n` 次
- 字符串切片 `s[j:i]` 在 Go 中是 O(1) 操作（引用原字符串）
- HashMap 查找是 O(1)

**空间复杂度：** O(n)
- `dp` 数组需要 O(n) 空间
- `wordSet` 需要 O(m*k) 空间，其中 `m` 是字典大小，`k` 是单词平均长度

---

### 优化思路

如果单词长度有限制（例如最长不超过 `maxLen`），可以优化内层循环：

```go
func wordBreak(s string, wordDict []string) bool {
    wordSet := make(map[string]bool)
    maxLen := 0
    for _, word := range wordDict {
        wordSet[word] = true
        if len(word) > maxLen {
            maxLen = len(word)
        }
    }

    n := len(s)
    dp := make([]bool, n+1)
    dp[0] = true

    for i := 1; i <= n; i++ {
        // 只需要往前检查 maxLen 长度
        for j := max(0, i-maxLen); j < i; j++ {
            if dp[j] && wordSet[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }

    return dp[n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

这样可以将时间复杂度降低到 **O(n * maxLen)**。

---

### 递归 + 记忆化搜索（另一种思路）

除了自底向上的 DP，也可以用自顶向下的记忆化搜索：

```go
func wordBreak(s string, wordDict []string) bool {
    wordSet := make(map[string]bool)
    for _, word := range wordDict {
        wordSet[word] = true
    }

    memo := make(map[int]bool)
    return dfs(s, 0, wordSet, memo)
}

func dfs(s string, start int, wordSet map[string]bool, memo map[int]bool) bool {
    // 如果已经到达字符串末尾，返回 true
    if start == len(s) {
        return true
    }

    // 如果已经计算过，直接返回结果
    if val, ok := memo[start]; ok {
        return val
    }

    // 尝试从 start 开始匹配每个可能的单词
    for end := start + 1; end <= len(s); end++ {
        word := s[start:end]
        if wordSet[word] && dfs(s, end, wordSet, memo) {
            memo[start] = true
            return true
        }
    }

    memo[start] = false
    return false
}
```

这种方法的时间复杂度也是 O(n²)，但在某些情况下（例如提前找到答案）可能会更快。

---

## 面试要点总结

1. **识别动态规划**：这题的关键是发现"能否拆分前 `i` 个字符"依赖于"能否拆分前 `j` 个字符"，是典型的 DP 思维
2. **状态定义**：`dp[i]` 表示前 `i` 个字符能否拆分，这是解题的核心
3. **优化技巧**：使用 HashMap 存储字典，限制内层循环范围（最长单词长度）
4. **边界条件**：`dp[0] = true` 表示空字符串可以拆分，这是递推的起点

这题在面试中非常常见，掌握 DP 解法和记忆化搜索两种思路会有优势。
