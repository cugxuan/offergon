---
title: 股票买卖的最佳时机系列（LeetCode 121/122/123）
tags:
  - 算法
status: robot
class: 算法
slug: stock-buy-sell-best-time-series
ref:
---

## 核心要点

这是一组经典的**动态规划**问题，考察对状态定义和状态转移的理解：
- **LeetCode 121（一次交易）**：一次遍历记录最低买入价，实时更新最大利润
- **LeetCode 122（无限次交易）**：贪心策略，累加所有上涨区间的利润
- **LeetCode 123（最多两次交易）**：用四个状态变量追踪"第一次买入"、"第一次卖出"、"第二次买入"、"第二次卖出"的最优值

---

## 详细解答

### 问题背景
股票买卖系列是动态规划的经典应用场景，核心难点在于如何定义状态以及如何设计状态转移方程。这三个问题分别对应不同的交易次数限制。

---

### LeetCode 121: 买卖股票的最佳时机（只能交易一次）

**问题描述：**
给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。你只能选择某一天买入并选择在未来的某一天卖出，计算最大利润。如果无法获利则返回 0。

**解题思路：**

核心思想是**单次遍历 + 贪心记录最低点**：
1. 维护一个变量 `minPrice` 记录到目前为止的最低买入价
2. 对于每一天的价格，计算 `当前价格 - minPrice` 得到当天卖出的利润
3. 更新最大利润 `maxProfit`

这样只需要一次遍历，时间复杂度 O(n)，空间复杂度 O(1)。

**代码实现（Go）：**

```go
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }

    minPrice := prices[0]
    maxProfit := 0

    for i := 1; i < len(prices); i++ {
        // 更新最低买入价
        if prices[i] < minPrice {
            minPrice = prices[i]
        }

        // 计算当前卖出的利润
        profit := prices[i] - minPrice
        if profit > maxProfit {
            maxProfit = profit
        }
    }

    return maxProfit
}
```

**时间复杂度：** O(n)
**空间复杂度：** O(1)

---

### LeetCode 122: 买卖股票的最佳时机 II（可以交易无限次）

**问题描述：**
给定一个数组 `prices`，你可以多次买卖股票（但必须在再次购买前卖出），求最大利润。

**解题思路：**

这题的关键是**贪心策略**：
- 只要相邻两天价格上涨（`prices[i] > prices[i-1]`），就把这段差价计入利润
- 本质上是把所有上涨区间的利润累加起来

为什么这样可行？因为允许无限次交易，我们可以把一个大的上涨区间拆分成多个连续的小涨幅，每个小涨幅都参与交易，总利润不变。

**代码实现（Go）：**

```go
func maxProfit(prices []int) int {
    maxProfit := 0

    for i := 1; i < len(prices); i++ {
        // 只要有涨幅就累加
        if prices[i] > prices[i-1] {
            maxProfit += prices[i] - prices[i-1]
        }
    }

    return maxProfit
}
```

**时间复杂度：** O(n)
**空间复杂度：** O(1)

---

### LeetCode 123: 买卖股票的最佳时机 III（最多交易两次）

**问题描述：**
给定一个数组 `prices`，你最多可以完成**两笔交易**（一笔交易由一次买入和一次卖出构成），求最大利润。

**解题思路：**

这是难度最高的一个变种，核心是**状态机 DP**：

定义四个状态变量：
- `buy1`: 第一次买入后的最大收益（负值，因为花钱了）
- `sell1`: 第一次卖出后的最大收益
- `buy2`: 第二次买入后的最大收益
- `sell2`: 第二次卖出后的最大收益

状态转移方程：
```go
buy1 = max(buy1, -prices[i])              // 第一次买入，花钱
sell1 = max(sell1, buy1 + prices[i])      // 第一次卖出，赚钱
buy2 = max(buy2, sell1 - prices[i])       // 第二次买入，基于第一次的收益
sell2 = max(sell2, buy2 + prices[i])      // 第二次卖出，最终收益
```

**代码实现（Go）：**

```go
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }

    // 初始化四个状态
    buy1, sell1 := -prices[0], 0
    buy2, sell2 := -prices[0], 0

    for i := 1; i < len(prices); i++ {
        // 更新第一次交易的状态
        buy1 = max(buy1, -prices[i])
        sell1 = max(sell1, buy1 + prices[i])

        // 更新第二次交易的状态
        buy2 = max(buy2, sell1 - prices[i])
        sell2 = max(sell2, buy2 + prices[i])
    }

    return sell2
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**为什么这样设计状态？**
- `buy1` 和 `sell1` 代表完成第一笔交易的最优状态
- `buy2` 依赖于 `sell1`，表示在完成第一笔交易后进行第二次买入
- `sell2` 是最终答案，表示完成两笔交易后的最大收益

**时间复杂度：** O(n)
**空间复杂度：** O(1)

---

## 面试要点总结

1. **LeetCode 121**：考察基本的贪心思想，一次遍历记录最低点
2. **LeetCode 122**：考察贪心策略，累加所有上涨区间
3. **LeetCode 123**：考察状态机 DP，需要正确定义和转移状态

这三题的难度递增，面试中如果遇到类似问题，要先理解交易次数限制，再选择合适的算法策略。LeetCode 123 可以扩展到**最多 k 次交易**（LeetCode 188），需要用二维 DP 数组。
