---
title: 接雨水（LeetCode 42）
tags:
  - 算法
status: robot
class: 算法
slug: trapping-rain-water
ref:
---

## 核心要点

**一句话总结**：每个位置能接的水 = min(左侧最高, 右侧最高) - 当前高度，可用双指针 O(n) 或单调栈解决。

**关键技巧**：双指针法——从两端向中间移动，维护左右最大高度，每次处理较矮一侧。

---

## 问题分析

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**核心理解**：
- 每个位置能接的水取决于两侧的最高柱子
- 水会从短板溢出（木桶原理）
- 总水量 = 所有位置接水量之和

**示例**：
```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6

可视化：
    █
█   █ █   █
█ █ █████ ███
```

---

## 解法思路

### 方法一：暴力法（不推荐）

对每个位置，找左右两侧最高柱子，计算能接的水。

**时间复杂度**：O(n²)

```go
func trap(height []int) int {
    n := len(height)
    if n == 0 {
        return 0
    }

    totalWater := 0
    for i := 0; i < n; i++ {
        // 找左侧最高
        leftMax := 0
        for j := 0; j <= i; j++ {
            leftMax = max(leftMax, height[j])
        }

        // 找右侧最高
        rightMax := 0
        for j := i; j < n; j++ {
            rightMax = max(rightMax, height[j])
        }

        // 计算当前位置接水量
        totalWater += min(leftMax, rightMax) - height[i]
    }

    return totalWater
}
```

### 方法二：动态规划（空间换时间）

**核心思想**：预处理每个位置左右两侧的最大高度。

**算法流程**：
1. 从左到右遍历，记录每个位置左侧的最大高度 `leftMax[i]`
2. 从右到左遍历，记录每个位置右侧的最大高度 `rightMax[i]`
3. 遍历每个位置，计算接水量：`min(leftMax[i], rightMax[i]) - height[i]`

**时间复杂度**：O(n)
**空间复杂度**：O(n)

```go
func trap(height []int) int {
    n := len(height)
    if n == 0 {
        return 0
    }

    // 预处理左侧最大高度
    leftMax := make([]int, n)
    leftMax[0] = height[0]
    for i := 1; i < n; i++ {
        leftMax[i] = max(leftMax[i-1], height[i])
    }

    // 预处理右侧最大高度
    rightMax := make([]int, n)
    rightMax[n-1] = height[n-1]
    for i := n - 2; i >= 0; i-- {
        rightMax[i] = max(rightMax[i+1], height[i])
    }

    // 计算总接水量
    totalWater := 0
    for i := 0; i < n; i++ {
        totalWater += min(leftMax[i], rightMax[i]) - height[i]
    }

    return totalWater
}
```

### 方法三：双指针（最优解）

**核心思想**：用两个指针从两端向中间移动，动态维护左右最大高度。

**关键洞察**：
- 当前位置能接的水由 `min(leftMax, rightMax) - height` 决定
- 如果 `leftMax < rightMax`，左侧是短板，当前位置的水量由 `leftMax` 决定
- 无需关心右侧具体有多高，只需知道右侧更高即可

**算法流程**：
1. 左右指针 `left`, `right`，左右最大高度 `leftMax`, `rightMax`
2. 如果 `height[left] < height[right]`：
   - 左侧是短板，处理左侧
   - 如果 `height[left] >= leftMax`：更新 `leftMax`（无法接水）
   - 否则：接水量 = `leftMax - height[left]`
   - `left++`
3. 否则处理右侧（对称操作）
4. 重复直到 `left >= right`

**时间复杂度**：O(n)
**空间复杂度**：O(1)

```go
func trap(height []int) int {
    n := len(height)
    if n == 0 {
        return 0
    }

    left, right := 0, n-1
    leftMax, rightMax := 0, 0
    totalWater := 0

    for left < right {
        if height[left] < height[right] {
            // 左侧是短板，处理左侧
            if height[left] >= leftMax {
                leftMax = height[left]  // 更新左侧最大高度
            } else {
                totalWater += leftMax - height[left]  // 接水
            }
            left++
        } else {
            // 右侧是短板，处理右侧
            if height[right] >= rightMax {
                rightMax = height[right]  // 更新右侧最大高度
            } else {
                totalWater += rightMax - height[right]  // 接水
            }
            right--
        }
    }

    return totalWater
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 方法四：单调栈（另一种 O(n) 解法）

**核心思想**：横向计算每一层的水量，用栈维护递减序列。

**算法流程**：
1. 维护一个递减的单调栈（存储索引）
2. 遇到比栈顶高的柱子时，形成"凹槽"，可以接水
3. 弹出栈顶作为"凹槽底部"，计算这一层的水量

**时间复杂度**：O(n)
**空间复杂度**：O(n)

```go
func trap(height []int) int {
    stack := []int{}
    totalWater := 0

    for i := 0; i < len(height); i++ {
        // 当前柱子比栈顶高，形成凹槽
        for len(stack) > 0 && height[i] > height[stack[len(stack)-1]] {
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]

            if len(stack) == 0 {
                break  // 没有左边界
            }

            // 计算这一层的水量
            left := stack[len(stack)-1]
            width := i - left - 1
            h := min(height[left], height[i]) - height[top]
            totalWater += width * h
        }

        stack = append(stack, i)
    }

    return totalWater
}
```

---

## 代码实现（推荐双指针法）

```go
func trap(height []int) int {
    n := len(height)
    if n == 0 {
        return 0
    }

    left, right := 0, n-1
    leftMax, rightMax := 0, 0
    totalWater := 0

    for left < right {
        if height[left] < height[right] {
            // 处理左侧
            if height[left] >= leftMax {
                leftMax = height[left]
            } else {
                totalWater += leftMax - height[left]
            }
            left++
        } else {
            // 处理右侧
            if height[right] >= rightMax {
                rightMax = height[right]
            } else {
                totalWater += rightMax - height[right]
            }
            right--
        }
    }

    return totalWater
}
```

**执行过程示例**（height = [0,1,0,2,1,0,1,3,2,1,2,1]）：

| left | right | height[L] | height[R] | leftMax | rightMax | 操作 | 接水量 | 总计 |
|------|-------|-----------|-----------|---------|----------|------|--------|------|
| 0 | 11 | 0 | 1 | 0 | 0 | L++ | 0 | 0 |
| 1 | 11 | 1 | 1 | 1 | 0 | R-- | 0 | 0 |
| 1 | 10 | 1 | 2 | 1 | 2 | L++ | 0 | 0 |
| 2 | 10 | 0 | 2 | 1 | 2 | L++ | 1 | 1 |
| 3 | 10 | 2 | 2 | 2 | 2 | L++ | 0 | 1 |
| 4 | 10 | 1 | 2 | 2 | 2 | L++ | 1 | 2 |
| 5 | 10 | 0 | 2 | 2 | 2 | L++ | 2 | 4 |
| 6 | 10 | 1 | 2 | 2 | 2 | L++ | 1 | 5 |
| 7 | 10 | 3 | 2 | 3 | 2 | R-- | 0 | 5 |
| 7 | 9 | 3 | 1 | 3 | 2 | R-- | 1 | 6 |
| 7 | 8 | 3 | 2 | 3 | 2 | R-- | 0 | 6 |

最终答案：**6**

---

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 推荐度 |
|------|------------|------------|--------|
| 暴力法 | O(n²) | O(1) | ❌ |
| 动态规划 | O(n) | O(n) | ⭐⭐⭐ |
| 双指针 | O(n) | O(1) | ⭐⭐⭐⭐⭐ |
| 单调栈 | O(n) | O(n) | ⭐⭐⭐⭐ |

**最优解**：双指针法，O(n) 时间，O(1) 空间。

---

## 注意事项与易错点

### 1. **双指针为什么正确？**

最容易困惑的地方！

**关键理解**：
- 当 `leftMax < rightMax` 时，左侧是短板
- 此时左指针位置的水量由 `leftMax` 决定，**不需要知道右侧的具体高度**
- 只需知道右侧更高（`rightMax > leftMax`），就足够了

**错误理解**：
- ❌ "需要知道右侧所有柱子的高度"
- ✅ "只需知道右侧存在更高的柱子"

### 2. **边界条件**

```go
// 空数组或单个元素
if n < 2 {
    return 0
}

// 循环终止条件
for left < right {  // 注意是 <，不是 <=
    // ...
}
```

### 3. **初始化**

```go
// 正确：初始化为 0
leftMax, rightMax := 0, 0

// 错误：初始化为 height[0] 和 height[n-1]
// 这样会跳过第一个和最后一个位置的计算
```

### 4. **接水量的计算**

```go
// 正确：先判断能否接水
if height[left] >= leftMax {
    leftMax = height[left]  // 更新最大高度
} else {
    totalWater += leftMax - height[left]  // 接水
}

// 错误：直接相减可能为负
totalWater += leftMax - height[left]  // 错误！
```

### 5. **与盛水容器的区别**

| 特性 | 盛水容器（LeetCode 11） | 接雨水（LeetCode 42） |
|------|-------------------------|----------------------|
| 选择 | 选两条边 | 所有柱子 |
| 计算 | 面积 = 宽度 × 短板 | 累加每个位置的水量 |
| 思路 | 双指针，移动短板 | 双指针，处理短板侧 |
| 时间 | O(n) | O(n) |

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：每个位置能接多少水？
2. 关键洞察：水量由两侧最高柱子的较小值决定
3. 暴力法：对每个位置找左右最大高度 O(n²)
4. 优化1：DP 预处理左右最大高度 O(n) 时间 + O(n) 空间
5. 优化2：双指针动态维护左右最大高度 O(n) 时间 + O(1) 空间
6. 说明双指针的正确性：处理短板侧，因为短板决定水量

**可能的追问**：

- **Q: 双指针为什么不会错过答案？**
  - A: 每次处理短板侧，因为短板决定了该位置的水量。长板侧的具体高度不影响短板侧的计算，只需知道长板更高即可。

- **Q: 能否用单调栈？**
  - A: 可以。单调栈是横向计算每一层的水量，而双指针是纵向计算每个位置的水量。两种思路都正确，双指针更省空间。

- **Q: 如果柱子可以有浮点高度？**
  - A: 算法不变，只需将 int 改为 float。

- **Q: 如果是二维接雨水（LeetCode 407）？**
  - A: 需要用优先队列（最小堆）+ BFS，从边界向内部扩展，类似"从低到高灌水"。

- **Q: 动态规划和双指针的权衡？**
  - A: DP 更容易理解，但需要额外空间。双指针更优，但需要理解为什么处理短板侧是正确的。面试时可以先说 DP，再优化到双指针。

- **Q: 单调栈的思路是什么？**
  - A: 维护递减栈，遇到更高的柱子时，弹出栈顶形成凹槽，横向计算这一层的水量。类似"积水成层"的思路。

**类似问题**：
- 盛水容器（LeetCode 11）：选两条边的最大面积
- 接雨水 II（LeetCode 407）：二维版本，用优先队列
- 柱状图中最大的矩形（LeetCode 84）：单调栈经典题

---

## 扩展：四种解法的本质

| 解法 | 核心思想 | 计算方向 | 优缺点 |
|------|----------|----------|--------|
| 暴力法 | 对每个位置独立计算 | 纵向（逐位置） | 重复计算，O(n²) |
| DP | 预处理左右最大高度 | 纵向（逐位置） | 易理解，需额外空间 |
| 双指针 | 动态维护左右最大高度 | 纵向（逐位置） | 最优，O(1) 空间 |
| 单调栈 | 找凹槽，横向计算 | 横向（逐层） | 思路独特，适合横向思维 |

**记忆技巧**：
- 纵向思维：每个位置能接多少水？→ 双指针/DP
- 横向思维：每一层能接多少水？→ 单调栈
