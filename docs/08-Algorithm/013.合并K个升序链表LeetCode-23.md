---
title: 合并K个升序链表（LeetCode 23）
tags:
  - 算法
status: robot
class: 算法
slug: merge-k-sorted-lists
ref:
---

## 核心要点

**最小堆(优先队列)**:维护K个链表的当前最小节点,每次取最小值,时间O(Nlog K)
**分治归并**:两两合并链表,类似归并排序,时间O(Nlog K)
**关键**:K个链表优化策略,避免逐个合并导致O(NK)复杂度
**空间**:堆解法O(K),分治解法O(log K)递归栈

---

## 详细解答

### 题目理解

给定K个升序链表的数组,将它们合并为一个升序链表并返回。

```
示例:
输入: lists = [[1,4,5],[1,3,4],[2,6]]
输出: [1,1,2,3,4,4,5,6]

解释: 合并3个链表
1->4->5
1->3->4
2->6
结果: 1->1->2->3->4->4->5->6
```

这道题是"合并两个有序链表"(LeetCode 21)的升级版,难度在于如何高效处理K个链表。

### 解法一:最小堆(优先队列) - 推荐

#### 核心思路

利用最小堆维护K个链表当前未合并的最小节点:

1. **初始化**:将K个链表的头节点加入最小堆
2. **循环取最小值**:
   - 从堆中弹出最小节点,接到结果链表
   - 如果该节点有后继节点,将后继节点加入堆
3. **终止条件**:堆为空时,所有节点已合并

**关键优势**:每次都能找到全局最小值,避免反复比较K个链表头节点。

#### 代码实现

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

// 定义最小堆
type MinHeap []*ListNode

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i].Val < h[j].Val }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(*ListNode))
}

func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    // 1. 初始化最小堆,加入所有非空链表的头节点
    h := &MinHeap{}
    heap.Init(h)

    for _, head := range lists {
        if head != nil {
            heap.Push(h, head)
        }
    }

    // 2. 创建哑节点,简化边界处理
    dummy := &ListNode{}
    curr := dummy

    // 3. 循环从堆中取最小节点
    for h.Len() > 0 {
        // 弹出最小节点
        minNode := heap.Pop(h).(*ListNode)

        // 接到结果链表
        curr.Next = minNode
        curr = curr.Next

        // 如果该节点有后继,将后继加入堆
        if minNode.Next != nil {
            heap.Push(h, minNode.Next)
        }
    }

    return dummy.Next
}
```

#### 复杂度分析

设总节点数为N,链表个数为K:

- **时间复杂度**: O(N log K)
  - 总共N个节点,每个节点入堆出堆各一次
  - 堆操作(Push/Pop)的时间复杂度为O(log K)
  - 总时间:N × log K
- **空间复杂度**: O(K) - 堆最多同时存储K个节点

#### 图解过程

```
初始状态:
lists = [1->4->5, 1->3->4, 2->6]

堆初始化: [1(链表0), 1(链表1), 2(链表2)]

步骤1: 弹出1(链表0), 结果:[1], 堆:[1(链表1), 2(链表2), 4]
步骤2: 弹出1(链表1), 结果:[1,1], 堆:[2(链表2), 3, 4]
步骤3: 弹出2(链表2), 结果:[1,1,2], 堆:[3, 4, 6]
步骤4: 弹出3, 结果:[1,1,2,3], 堆:[4(链表0), 4(链表1), 6]
...
最终结果:[1,1,2,3,4,4,5,6]
```

### 解法二:分治归并

#### 核心思路

类似归并排序的分治思想:

1. **分解**:将K个链表两两配对
2. **合并**:每对链表使用"合并两个有序链表"的方法合并
3. **递归**:重复上述过程,直到只剩一个链表

**时间复杂度推导**:
- 第1轮:K/2次合并,每次平均处理2N/K个节点,总计N
- 第2轮:K/4次合并,每次平均处理4N/K个节点,总计N
- ...
- 总共log K轮,每轮处理N个节点,总时间O(N log K)

#### 代码实现

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    return mergeDivide(lists, 0, len(lists)-1)
}

// 分治递归函数
func mergeDivide(lists []*ListNode, left, right int) *ListNode {
    if left == right {
        return lists[left]  // 只有一个链表,直接返回
    }

    if left > right {
        return nil
    }

    // 分治:二分
    mid := left + (right-left)/2
    l1 := mergeDivide(lists, left, mid)
    l2 := mergeDivide(lists, mid+1, right)

    // 合并两个有序链表
    return mergeTwoLists(l1, l2)
}

// 合并两个有序链表(经典双指针法)
func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    // 接上剩余节点
    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}
```

#### 复杂度分析

- **时间复杂度**: O(N log K)
  - 递归深度log K,每层合并N个节点
- **空间复杂度**: O(log K) - 递归栈深度

#### 分治过程图解

```
K=4个链表: [L0, L1, L2, L3]

          [L0, L1, L2, L3]
         /                \
    [L0, L1]            [L2, L3]
    /    \              /    \
  L0    L1            L2    L3
    \    /              \    /
   merge(L0,L1)      merge(L2,L3)
         \                /
          merge(结果1, 结果2)
                  ↓
              最终结果
```

### 解法三:逐个合并(不推荐,低效)

#### 思路

将第1个链表与第2个合并,结果再与第3个合并,依此类推。

#### 问题分析

- **时间复杂度**: O(NK)
  - 第1次合并:2N/K个节点
  - 第2次合并:3N/K个节点
  - ...
  - 第K-1次合并:N个节点
  - 总计:2N/K + 3N/K + ... + N = N(2+3+...+K)/K ≈ O(NK)
- **效率低**:重复处理前面已合并的节点

仅作对比说明,面试中不推荐。

### 两种最优解法对比

| 维度 | 最小堆法 | 分治归并法 |
|------|---------|-----------|
| 时间复杂度 | O(N log K) | O(N log K) |
| 空间复杂度 | O(K) | O(log K) ✅ |
| 代码复杂度 | 需要实现堆 | 需要递归+合并两链表 |
| 实现难度 | 中等 | 较低(复用经典算法) |
| 面试推荐 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

### 面试要点

1. **优先选择最小堆法**:
   - Go标准库`container/heap`提供现成接口
   - 思路直观,易于讲解
   - 时间复杂度最优
2. **分治法作为备选**:
   - 如果不允许使用额外数据结构,选择分治
   - 需要熟练掌握"合并两个有序链表"
3. **复杂度分析要清晰**:
   - 强调为何堆解法是O(N log K)而非O(NK)
   - 对比逐个合并的低效性
4. **边界处理**:
   - 空数组:返回nil
   - 包含空链表:初始化堆时过滤
   - 单个链表:直接返回
5. **扩展讨论**:
   - 如果K非常大(如百万级),如何优化?(外部排序、多路归并)
   - 如果链表不是完全有序怎么办?(先排序再合并)

### 常见错误

1. ❌ 堆的Less函数写反
   ```go
   func (h MinHeap) Less(i, j int) bool {
       return h[i].Val > h[j].Val  // 错误!这是最大堆
   }
   ```

2. ❌ 忘记处理空链表
   ```go
   for _, head := range lists {
       heap.Push(h, head)  // 错误!head可能为nil
   }
   // 正确:
   for _, head := range lists {
       if head != nil {
           heap.Push(h, head)
       }
   }
   ```

3. ❌ 分治边界错误
   ```go
   func mergeDivide(lists []*ListNode, left, right int) *ListNode {
       if left >= right {  // 错误!应该是left==right时返回
           return lists[left]
       }
   ```

### 实战技巧

1. **Go堆接口记忆口诀**:
   - Len, Less, Swap:标准排序接口
   - Push, Pop:堆特有接口
   - 必须使用`heap.Init`, `heap.Push`, `heap.Pop`(不能直接调用方法)
2. **时间控制**:
   - 堆解法:12-15分钟(含实现堆接口)
   - 分治法:8-10分钟(假设已实现mergeTwoLists)
3. **测试用例**:
   ```
   - 空数组:[]
   - 单链表:[[1,2,3]]
   - 包含空链表:[[1,2],[],[3,4]]
   - 正常情况:[[1,4,5],[1,3,4],[2,6]]
   ```
4. **画图辅助**:
   - 堆解法:画出堆的动态变化过程
   - 分治法:画出二叉树状的递归分解图

### 扩展知识

**多路归并应用场景**:
- 外部排序(External Sorting):大文件分块排序后合并
- 数据库查询优化:多个有序索引合并
- 日志系统:合并多个时间有序的日志流
- 分布式系统:合并多个节点的有序数据

**Go标准库heap使用技巧**:
```go
import "container/heap"

// 堆必须实现以下5个接口:
type Interface interface {
    sort.Interface         // Len() Less() Swap()
    Push(x interface{})    // 添加元素到末尾
    Pop() interface{}      // 移除并返回末尾元素
}

// 注意:
// - heap.Push内部会调用自定义的Push方法
// - heap.Pop内部会先调整堆再调用自定义的Pop方法
// - 直接调用h.Push()不会维护堆性质!必须用heap.Push(&h, x)
```

这道题是链表+堆的经典综合题,建议同时掌握两种解法,面试中根据场景灵活选择。最小堆法更通用,分治法展现分治思想,两者都能体现扎实的算法功底。
