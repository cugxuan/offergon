---
title: 最长回文子串（LeetCode 5）
tags:
  - 算法
status: robot
class: 算法
slug: longest-palindromic-substring
ref:
---

## 核心要点

**一句话总结**：从每个中心点向两边扩展寻找回文串，或用动态规划，最优解是中心扩展法 O(n²)。

**关键技巧**：注意回文串有奇数长度（单中心）和偶数长度（双中心）两种情况。

---

## 问题分析

给定字符串 `s`，找到 `s` 中最长的回文子串。

**示例**：
```
输入：s = "babad"
输出："bab" 或 "aba"

输入：s = "cbbd"
输出："bb"
```

---

## 解法思路

### 方法一：中心扩展法（推荐）

**核心思想**：以每个字符（或两个字符间）为中心，向两边扩展寻找回文串。

**关键点**：
- 奇数长度回文：中心是单个字符，如 "aba"
- 偶数长度回文：中心是两个字符之间，如 "abba"

**算法流程**：
1. 遍历每个可能的中心位置
2. 从中心向两边扩展，直到不是回文
3. 记录最长的回文子串

**时间复杂度**：O(n²)
**空间复杂度**：O(1)

```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }

    start, maxLen := 0, 1

    for i := 0; i < len(s); i++ {
        // 奇数长度回文（中心是单个字符）
        len1 := expandAroundCenter(s, i, i)
        // 偶数长度回文（中心是两个字符之间）
        len2 := expandAroundCenter(s, i, i+1)

        // 取较长的
        curLen := max(len1, len2)
        if curLen > maxLen {
            maxLen = curLen
            start = i - (curLen-1)/2
        }
    }

    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return right - left - 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 方法二：动态规划

**状态定义**：`dp[i][j]` 表示 `s[i:j+1]` 是否为回文串。

**状态转移**：
- `dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]`
- 边界：`i == j` 时为 true，`j = i+1` 时看 `s[i] == s[j]`

**时间复杂度**：O(n²)
**空间复杂度**：O(n²)

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }

    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
        dp[i][i] = true
    }

    start, maxLen := 0, 1

    // 按长度遍历
    for length := 2; length <= n; length++ {
        for i := 0; i <= n-length; i++ {
            j := i + length - 1

            if s[i] == s[j] {
                if length == 2 {
                    dp[i][j] = true
                } else {
                    dp[i][j] = dp[i+1][j-1]
                }

                if dp[i][j] && length > maxLen {
                    start = i
                    maxLen = length
                }
            }
        }
    }

    return s[start : start+maxLen]
}
```

### 方法三：Manacher 算法（最优但复杂）

**时间复杂度**：O(n)
**空间复杂度**：O(n)

面试中很少考察，了解即可。

---

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 推荐度 |
|------|------------|------------|--------|
| 暴力法 | O(n³) | O(1) | ❌ |
| 动态规划 | O(n²) | O(n²) | ⭐⭐⭐ |
| 中心扩展 | O(n²) | O(1) | ⭐⭐⭐⭐⭐ |
| Manacher | O(n) | O(n) | ⭐⭐ |

**推荐**：中心扩展法，代码简洁且空间最优。

---

## 注意事项与易错点

### 1. **起始位置计算**

中心扩展法找到长度后，如何计算起始位置？

```go
// 对于中心 i，回文长度 curLen
start = i - (curLen - 1) / 2

// 例如：i=2, curLen=5 ("babad" 中 "bab")
// start = 2 - (5-1)/2 = 2 - 2 = 0 ✓

// 例如：i=2, curLen=4 ("cbbd" 中 "bb")
// start = 2 - (4-1)/2 = 2 - 1 = 1 ✓
```

### 2. **奇偶长度的处理**

```go
// 错误：只考虑奇数长度
len1 := expandAroundCenter(s, i, i)
maxLen = max(maxLen, len1)

// 正确：同时考虑奇数和偶数
len1 := expandAroundCenter(s, i, i)
len2 := expandAroundCenter(s, i, i+1)
maxLen = max(len1, len2)
```

### 3. **边界条件**

```go
// 空字符串或单字符
if len(s) < 2 {
    return s
}

// expandAroundCenter 中的边界检查
for left >= 0 && right < len(s) && s[left] == s[right] {
    left--
    right++
}
```

### 4. **动态规划的遍历顺序**

```go
// 错误：从左到右遍历
for i := 0; i < n; i++ {
    for j := i; j < n; j++ {
        // dp[i][j] 依赖 dp[i+1][j-1]，可能还未计算
    }
}

// 正确：按长度从小到大遍历
for length := 1; length <= n; length++ {
    for i := 0; i <= n-length; i++ {
        j := i + length - 1
        // dp[i+1][j-1] 已经计算过
    }
}
```

---

## 面试要点

**面试时的回答流程**：
1. 暴力法：枚举所有子串 O(n²)，判断是否回文 O(n)，总共 O(n³)
2. 优化：中心扩展法，O(n²) 时间 + O(1) 空间
3. 细节：奇数和偶数长度回文的处理
4. 进一步优化：Manacher O(n)（了解即可）

**可能的追问**：

- **Q: 如何判断一个字符串是否是回文？**
  - A: 双指针从两端向中间移动，比较字符是否相等。

- **Q: 为什么中心扩展法是 O(n²)？**
  - A: n 个中心，每个中心最多扩展 n 次。

- **Q: Manacher 算法的原理？**
  - A: 利用回文的对称性，避免重复计算。通过维护最右回文边界和中心，实现 O(n)。

- **Q: 能否用后缀数组或后缀树？**
  - A: 可以，但实现复杂。面试中不推荐。

**类似问题**：
- 回文链表（LeetCode 234）
- 验证回文串（LeetCode 125）
- 最长回文子序列（LeetCode 516）：不连续，用 DP

---

## 扩展：Manacher 算法简介

Manacher 算法通过预处理字符串（插入特殊字符统一奇偶），利用回文的对称性避免重复计算，实现 O(n) 时间复杂度。

**核心思想**：
- 预处理：`"babad"` → `"#b#a#b#a#d#"`
- 维护最右回文边界和中心
- 利用对称性跳过已知的回文部分

面试中很少考察实现，了解思想即可。
