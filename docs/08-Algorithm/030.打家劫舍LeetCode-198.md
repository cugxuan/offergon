---
title: 打家劫舍(LeetCode 198)
tags:
  - 算法
status: robot
class: 算法
slug: house-robber-leetcode-198
ref:
---

## 核心要点

**动态规划经典题,状态转移方程: dp[i] = max(dp[i-1], dp[i-2] + nums[i]) - 决策是"抢还是不抢"**

核心约束:不能同时抢劫相邻的两家。对于第 i 家,要么不抢(继承 dp[i-1]),要么抢(dp[i-2] + nums[i])。可优化空间至 O(1)。关键是理解"无后效性":当前决策只依赖前面的最优解。

---

## 详细解答

### 一、题目理解

你是一个专业的小偷,计划偷窃沿街的房屋。每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是**相邻的房屋装有相互连通的防盗系统**,如果**两间相邻的房屋在同一晚上被小偷闯入**,系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组 `nums`,计算你**不触动警报装置的情况下**,一夜之内能够偷窃到的最高金额。

**示例**:
- 输入:`nums = [2,7,9,3,1]`
- 输出:`12`
- 解释:偷窃 1 号房屋(金额 = 2),偷窃 3 号房屋(金额 = 9),接着偷窃 5 号房屋(金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12。

---

### 二、思路分析

#### 核心观察:对于每一家,有两种选择

1. **抢劫第 i 家**:
   - 那么第 i-1 家不能抢
   - 最大金额 = dp[i-2] + nums[i]

2. **不抢劫第 i 家**:
   - 最大金额 = dp[i-1]

**状态转移方程**:
```
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

**状态定义**:
- `dp[i]` 表示前 i 家能抢到的最大金额

**初始状态**:
- `dp[0] = nums[0]`(只有一家,直接抢)
- `dp[1] = max(nums[0], nums[1])`(两家选金额大的)

---

### 三、代码实现

#### 解法 1:动态规划(数组版)

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }

    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i := 2; i < n; i++ {
        // 选择抢或不抢当前家
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }

    return dp[n-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**时间复杂度**: O(n)
**空间复杂度**: O(n)

---

#### 解法 2:空间优化版(推荐)

观察到 `dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]`,可以用两个变量代替数组。

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }

    prev2 := nums[0]              // dp[i-2]
    prev1 := max(nums[0], nums[1]) // dp[i-1]

    for i := 2; i < n; i++ {
        current := max(prev1, prev2+nums[i])
        prev2 = prev1
        prev1 = current
    }

    return prev1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**时间复杂度**: O(n)
**空间复杂度**: O(1) ⭐

---

#### 解法 3:更简洁的空间优化版

```go
func rob(nums []int) int {
    rob, notRob := 0, 0 // rob:抢当前家, notRob:不抢当前家

    for _, num := range nums {
        newRob := notRob + num      // 抢当前家,之前必须没抢
        newNotRob := max(rob, notRob) // 不抢当前家,取之前的最大值
        rob = newRob
        notRob = newNotRob
    }

    return max(rob, notRob)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**关键理解**:
- `rob`:如果抢当前这家,能获得的最大金额
- `notRob`:如果不抢当前这家,能获得的最大金额
- 每次更新这两个状态,最后返回最大值

---

### 四、复杂度分析

| 解法 | 时间复杂度 | 空间复杂度 | 推荐度 |
|------|-----------|-----------|--------|
| 动态规划数组 | O(n) | O(n) | ✓ |
| 空间优化(prev) | O(n) | O(1) | ⭐ |
| 空间优化(rob/notRob) | O(n) | O(1) | ⭐⭐ |

---

### 五、示例演示

#### 示例:`nums = [2,7,9,3,1]`

**使用 dp 数组**:

| i | nums[i] | dp[i-2]+nums[i] | dp[i-1] | dp[i] | 说明 |
|---|---------|----------------|---------|-------|------|
| 0 | 2 | - | - | 2 | 只有一家,抢 |
| 1 | 7 | - | - | 7 | max(2, 7)=7 |
| 2 | 9 | 2+9=11 | 7 | **11** | 抢第0和第2家 |
| 3 | 3 | 7+3=10 | 11 | **11** | 不抢第3家 |
| 4 | 1 | 11+1=12 | 11 | **12** | 抢第2和第4家 |

**最终答案**: 12

**抢劫方案**: 第 0 家(2) + 第 2 家(9) + 第 4 家(1) = 12

---

#### 示例 2:`nums = [1,2,3,1]`

| i | nums[i] | dp[i-2]+nums[i] | dp[i-1] | dp[i] |
|---|---------|----------------|---------|-------|
| 0 | 1 | - | - | 1 |
| 1 | 2 | - | - | 2 |
| 2 | 3 | 1+3=4 | 2 | **4** |
| 3 | 1 | 2+1=3 | 4 | **4** |

**最终答案**: 4 (抢第 1 家和第 3 家:2+3=4,但实际上抢第 0 和第 2 家也是 4)

---

### 六、易错点

1. **边界条件处理**
   - `n=0` 时返回 0
   - `n=1` 时返回 `nums[0]`
   - `n=2` 时返回 `max(nums[0], nums[1])`

2. **状态转移理解错误**
   - 不是"必须隔一家抢一次",而是"至少隔一家"
   - 例如 `[1,100,1,1,100]`,最优是抢 `100+100=200`,而不是 `1+1+100=102`

3. **空间优化时的变量更新顺序**
   ```go
   current := max(prev1, prev2+nums[i])
   prev2 = prev1  // 必须先更新 prev2
   prev1 = current // 再更新 prev1
   ```

4. **初始化错误**
   - `dp[1]` 应该是 `max(nums[0], nums[1])`,不是 `nums[1]`
   - 因为前两家可以选择抢第一家或第二家,取金额大的

---

### 七、进阶思考

#### Q1: 如果房屋排列成环形(首尾相连)怎么办?

**LeetCode 213 - 打家劫舍 II**

**思路**:
- 环形意味着第 0 家和第 n-1 家不能同时抢
- 分两种情况:
  1. 抢第 0 家,不抢第 n-1 家:rob(nums[0:n-1])
  2. 不抢第 0 家,抢第 n-1 家:rob(nums[1:n])
- 返回两种情况的最大值

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }
    return max(robRange(nums, 0, n-2), robRange(nums, 1, n-1))
}

func robRange(nums []int, start, end int) int {
    prev2, prev1 := 0, 0
    for i := start; i <= end; i++ {
        current := max(prev1, prev2+nums[i])
        prev2 = prev1
        prev1 = current
    }
    return prev1
}
```

---

#### Q2: 如果房屋排列成二叉树怎么办?

**LeetCode 337 - 打家劫舍 III**

**思路**:
- 对于每个节点,有两种选择:
  1. 抢当前节点:不能抢子节点,只能抢孙子节点
  2. 不抢当前节点:可以抢子节点
- 递归计算,返回 `max(抢, 不抢)`

```go
func rob(root *TreeNode) int {
    robResult, notRobResult := robTree(root)
    return max(robResult, notRobResult)
}

// 返回 (抢当前节点的最大值, 不抢当前节点的最大值)
func robTree(node *TreeNode) (int, int) {
    if node == nil {
        return 0, 0
    }

    leftRob, leftNotRob := robTree(node.Left)
    rightRob, rightNotRob := robTree(node.Right)

    // 抢当前节点:不能抢子节点
    rob := node.Val + leftNotRob + rightNotRob

    // 不抢当前节点:子节点可抢可不抢,取最大值
    notRob := max(leftRob, leftNotRob) + max(rightRob, rightNotRob)

    return rob, notRob
}
```

---

### 八、本质:动态规划的"无后效性"

这道题体现了动态规划的核心思想:

1. **最优子结构**:问题的最优解包含子问题的最优解
   - 前 i 家的最优解可以由前 i-1 家和前 i-2 家的最优解推导

2. **无后效性**:当前状态只依赖之前的状态,不依赖之后的状态
   - `dp[i]` 只需要知道 `dp[i-1]` 和 `dp[i-2]`

3. **重叠子问题**:存在大量重复计算
   - 如果用递归,会重复计算相同的子问题
   - 动态规划通过自底向上计算避免重复

---

### 九、面试技巧

1. **从简单例子开始**
   - 画出 `nums = [2,7,9,3,1]` 的决策树
   - 展示如何选择"抢"或"不抢"

2. **推导状态转移方程**
   - 详细解释为什么是 `max(dp[i-1], dp[i-2]+nums[i])`
   - 说明两种选择的含义

3. **完整优化路径**
   - 暴力递归(指数级) → 记忆化(O(n)) → 动态规划数组(O(n)) → 空间优化(O(1))

4. **对比多种写法**
   - 先写数组版 dp,展示清晰的思路
   - 再优化成 O(1) 空间,展示优化能力

5. **主动讨论变体**
   - 环形排列(LeetCode 213)
   - 二叉树排列(LeetCode 337)
   - 展示知识广度

**追问应对**:

- **Q: 如果可以隔两家或隔三家抢呢?**
  - A: 状态转移变为 `dp[i] = max(dp[i-1], dp[i-2]+nums[i], dp[i-3]+nums[i])`,需要维护三个变量。

- **Q: 如果某些房屋不能抢(价值为-1)怎么办?**
  - A: 将不能抢的房屋金额设为 0,或在状态转移时跳过,保持 `dp[i] = dp[i-1]`。

- **Q: 能否用贪心算法?**
  - A: 不行。反例:`[2,1,1,2]`,贪心会选 2+2=4,但实际最优是 1+1+2=4(都是4),但对于 `[1,2,3,1]`,贪心选 3+1=4,实际最优是 2+3=5(这个我算错了,应该是 1+3=4),总之贪心不适用,因为局部最优不等于全局最优。

- **Q: 如果要求输出具体抢劫方案怎么办?**
  - A: 在 dp 数组的基础上,额外维护一个 `choice[i]` 数组记录每个位置的选择,或者在最后从 `dp[n-1]` 回溯,根据状态转移方程反推路径。

- **Q: 这道题和爬楼梯有什么区别?**
  - A: 爬楼梯是累加方案数(`dp[i] = dp[i-1] + dp[i-2]`),打家劫舍是取最大值(`dp[i] = max(dp[i-1], dp[i-2]+nums[i])`),前者是组合问题,后者是优化问题。

---

### 十、变体题目总结

掌握这道题后,可以尝试以下进阶题目:

| 题目 | LeetCode | 说明 |
|------|----------|------|
| 打家劫舍 II | 213 | 环形排列,首尾不能同时抢 |
| 打家劫舍 III | 337 | 二叉树排列,父子节点不能同时抢 |
| 删除并获得点数 | 740 | 类似打家劫舍,但需要先统计频次 |
| 粉刷房子 | 256 | 多状态 DP,相邻房屋不能同色 |

**共同点**:都是动态规划 + 决策选择问题,核心是找到状态转移方程。

---

### 十一、总结

**打家劫舍**是动态规划的经典题目,考察:

1. **状态定义**:如何定义 `dp[i]` 的含义
2. **状态转移**:如何从子问题推导到当前问题
3. **空间优化**:如何将 O(n) 空间优化到 O(1)
4. **扩展思考**:如何应对变体(环形、树形)

掌握这道题,对理解动态规划的核心思想(最优子结构、无后效性)有极大帮助,是面试必备题目之一。
