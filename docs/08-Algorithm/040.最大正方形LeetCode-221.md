---
title: 最大正方形（LeetCode 221）
tags:
  - 算法
status: robot
class: 算法
slug: maximum-square
ref:
---

## 核心要点

这是一道**二维动态规划**的进阶题目，难度较高：
- **核心思想**：`dp[i][j]` 表示以 `(i,j)` 为**右下角**的最大正方形的边长
- **状态转移**：如果 `matrix[i][j] = '1'`，则 `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`
- **关键理解**：正方形的边长受限于左、上、左上三个方向的最小边长，形成"木桶效应"

---

## 详细解答

### 问题描述

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例：**
```
输入：matrix = [
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出：4
解释：最大正方形的边长为 2，面积为 2×2 = 4

输入：matrix = [
  ["0","1"],
  ["1","0"]
]
输出：1
解释：最大正方形的边长为 1，面积为 1×1 = 1

输入：matrix = [["0"]]
输出：0
```

---

### 解题思路

#### 为什么不能用暴力枚举？

最直观的想法是枚举每个点作为左上角，然后尝试不同边长的正方形。但这种方法时间复杂度是 O(m * n * min(m,n)²)，非常低效。

#### 动态规划的关键洞察

**关键思想：**
- 定义 `dp[i][j]` 为以 `(i, j)` 为**右下角**的最大正方形的边长
- 如果 `matrix[i][j] = '0'`，则 `dp[i][j] = 0`（无法构成正方形）
- 如果 `matrix[i][j] = '1'`，考虑它能扩展多大的正方形：

**状态转移方程（核心）：**
```
dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
```

**为什么是这样？**

要形成一个边长为 k 的正方形（以 `(i,j)` 为右下角），需要满足：
1. 左边 `(i, j-1)` 能形成边长至少为 k-1 的正方形
2. 上边 `(i-1, j)` 能形成边长至少为 k-1 的正方形
3. 左上 `(i-1, j-1)` 能形成边长至少为 k-1 的正方形

三个方向的最小值决定了当前正方形的最大边长（木桶效应）。

---

### 图解示例

以示例 1 为例：

```
原始矩阵：
1  0  1  0  0
1  0  1  1  1
1  1  1  1  1
1  0  0  1  0

DP 过程：

初始化第一行和第一列（直接复制原矩阵的值）：
1  0  1  0  0
1  ?  ?  ?  ?
1  ?  ?  ?  ?
1  ?  ?  ?  ?

计算 dp[1][1]：
matrix[1][1] = '0' → dp[1][1] = 0

1  0  1  0  0
1  0  ?  ?  ?
1  ?  ?  ?  ?
1  ?  ?  ?  ?

计算 dp[1][2]：
matrix[1][2] = '1'
dp[1][2] = min(dp[0][2], dp[1][1], dp[0][1]) + 1
         = min(1, 0, 0) + 1 = 1

1  0  1  0  0
1  0  1  ?  ?
1  ?  ?  ?  ?
1  ?  ?  ?  ?

继续计算所有位置：
1  0  1  0  0
1  0  1  1  1
1  1  1  2  2   ← dp[2][3] = min(1,1,1) + 1 = 2
1  0  0  1  0

最大边长为 2，面积为 2×2 = 4
```

---

### 代码实现（Go）

**方法一：二维 DP（清晰易懂）**

```go
func maximalSquare(matrix [][]byte) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }

    m, n := len(matrix), len(matrix[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    maxSide := 0

    // 初始化第一列
    for i := 0; i < m; i++ {
        if matrix[i][0] == '1' {
            dp[i][0] = 1
            maxSide = 1
        }
    }

    // 初始化第一行
    for j := 0; j < n; j++ {
        if matrix[0][j] == '1' {
            dp[0][j] = 1
            maxSide = 1
        }
    }

    // 状态转移
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if matrix[i][j] == '1' {
                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                if dp[i][j] > maxSide {
                    maxSide = dp[i][j]
                }
            }
        }
    }

    return maxSide * maxSide
}

func min(a, b, c int) int {
    if a < b {
        if a < c {
            return a
        }
        return c
    }
    if b < c {
        return b
    }
    return c
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(m * n)

---

**方法二：一维 DP（空间优化）**

注意到 `dp[i][j]` 只依赖于上一行和当前行，可以用一维数组优化：

```go
func maximalSquare(matrix [][]byte) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }

    m, n := len(matrix), len(matrix[0])
    dp := make([]int, n)
    maxSide := 0
    prev := 0 // 保存左上角的值（dp[i-1][j-1]）

    // 初始化第一行
    for j := 0; j < n; j++ {
        if matrix[0][j] == '1' {
            dp[j] = 1
            maxSide = 1
        }
    }

    // 逐行更新
    for i := 1; i < m; i++ {
        prev = dp[0] // 保存 dp[i-1][0]
        if matrix[i][0] == '1' {
            dp[0] = 1
            if dp[0] > maxSide {
                maxSide = dp[0]
            }
        } else {
            dp[0] = 0
        }

        for j := 1; j < n; j++ {
            temp := dp[j] // 暂存 dp[i-1][j]
            if matrix[i][j] == '1' {
                // prev 是 dp[i-1][j-1]
                // dp[j] 是 dp[i-1][j]
                // dp[j-1] 是 dp[i][j-1]
                dp[j] = min(dp[j], dp[j-1], prev) + 1
                if dp[j] > maxSide {
                    maxSide = dp[j]
                }
            } else {
                dp[j] = 0
            }
            prev = temp // 更新左上角的值
        }
    }

    return maxSide * maxSide
}

func min(a, b, c int) int {
    if a < b {
        if a < c {
            return a
        }
        return c
    }
    if b < c {
        return b
    }
    return c
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(n)

---

### 常见错误和注意事项

1. **状态定义错误**：不要把 `dp[i][j]` 定义为以 `(i,j)` 为左上角的最大正方形，这样无法进行状态转移
2. **边界初始化**：第一行和第一列需要单独处理
3. **返回值错误**：题目要求返回**面积**，不是边长（需要平方）
4. **字符类型比较**：`matrix[i][j]` 是 `byte` 类型，要和 `'1'` 比较（不是数字 1）

---

## 面试要点总结

1. **状态定义是关键**：定义为"以 (i,j) 为右下角的最大正方形边长"，这样才能进行状态转移
2. **木桶效应理解**：正方形的边长取决于左、上、左上三个方向的最小值
3. **状态转移方程**：`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`
4. **空间优化**：可以用一维数组滚动优化，但需要额外变量保存左上角的值
5. **类似问题扩展**：
   - **最大矩形（LeetCode 85）**：更难的变种，需要用单调栈或 DP
   - **最大全 1 子矩阵**：类似思路但计算方式不同

这题在面试中考察对 DP 状态设计的深度理解，属于中等偏难题目。掌握"右下角定义法"和"木桶效应"是解题的关键。
