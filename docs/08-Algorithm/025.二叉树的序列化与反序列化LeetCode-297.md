---
title: 二叉树的序列化与反序列化（LeetCode 297）
tags:
  - 算法
status: robot
class: 算法
slug: binary-tree-serialize-deserialize
ref:
---

## 核心要点

**问题本质**：将二叉树转换为字符串（序列化），并能从字符串恢复原树（反序列化）。

**解题关键**：
1. 序列化方式选择：前序遍历、层序遍历、后序遍历均可
2. 空节点标记：必须标记 null 节点（如 "null" 或 "#"），否则无法唯一确定树
3. 分隔符设计：用逗号或空格分隔节点值
4. 反序列化技巧：根据序列化方式对应使用递归或队列

---

## 题目描述

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列化/反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例 1：**
```
输入：root = [1,2,3,null,null,4,5]

树结构：
      1
     / \
    2   3
       / \
      4   5

输出："1,2,null,null,3,4,null,null,5,null,null"
```

**示例 2：**
```
输入：root = []
输出：""
```

**示例 3：**
```
输入：root = [1]
输出："1,null,null"
```

**约束条件：**
- 树中节点数范围：[0, 10^4]
- -1000 <= Node.val <= 1000

---

## 解题思路

### 方法一：前序遍历（DFS）- 推荐

前序遍历的特点：根 → 左 → 右，序列化和反序列化逻辑简单。

**序列化思路**：
1. 前序遍历二叉树（根 → 左 → 右）
2. 遇到空节点记录为 "null"
3. 用逗号分隔节点值

**反序列化思路**：
1. 将字符串按逗号分割成数组
2. 使用指针或队列按前序顺序构建树
3. 遇到 "null" 返回 nil

**示例**：
```
树：    1
       / \
      2   3
     /   / \
    4   5   6

前序遍历：1 2 4 null null null 3 5 null null 6 null null
序列化：  "1,2,4,null,null,null,3,5,null,null,6,null,null"
```

---

### 方法二：层序遍历（BFS）

层序遍历更直观，序列化结果更符合人类阅读习惯。

**序列化思路**：
1. 使用队列进行层序遍历
2. 每个节点（包括 null）都记录
3. 可以去掉末尾的连续 null（优化）

**反序列化思路**：
1. 第一个元素是根节点
2. 使用队列，每次取出一个节点，为其分配左右子节点
3. 按层级顺序构建树

**示例**：
```
树：    1
       / \
      2   3
     /   / \
    4   5   6

层序遍历：1 2 3 4 null 5 6 null null null null null null
序列化：  "1,2,3,4,null,5,6" (去掉末尾 null)
```

---

## 代码实现

### 方法一：前序遍历（DFS）

#### Go 实现

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

type Codec struct {}

func Constructor() Codec {
    return Codec{}
}

// 序列化：前序遍历
func (this *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return "null"
    }

    // 根 -> 左 -> 右
    return strconv.Itoa(root.Val) + "," +
           this.serialize(root.Left) + "," +
           this.serialize(root.Right)
}

// 反序列化：前序遍历重建
func (this *Codec) deserialize(data string) *TreeNode {
    nodes := strings.Split(data, ",")
    index := 0
    return this.buildTree(&nodes, &index)
}

func (this *Codec) buildTree(nodes *[]string, index *int) *TreeNode {
    if *index >= len(*nodes) || (*nodes)[*index] == "null" {
        *index++
        return nil
    }

    // 构建当前节点
    val, _ := strconv.Atoi((*nodes)[*index])
    *index++
    node := &TreeNode{Val: val}

    // 递归构建左右子树
    node.Left = this.buildTree(nodes, index)
    node.Right = this.buildTree(nodes, index)

    return node
}
```

#### Python 实现

```python
class Codec:

    def serialize(self, root):
        """将树序列化为字符串"""
        if not root:
            return "null"

        # 前序遍历：根 -> 左 -> 右
        return f"{root.val},{self.serialize(root.left)},{self.serialize(root.right)}"

    def deserialize(self, data):
        """将字符串反序列化为树"""
        nodes = data.split(',')
        self.index = 0
        return self.build_tree(nodes)

    def build_tree(self, nodes):
        if self.index >= len(nodes) or nodes[self.index] == "null":
            self.index += 1
            return None

        # 构建当前节点
        node = TreeNode(int(nodes[self.index]))
        self.index += 1

        # 递归构建左右子树
        node.left = self.build_tree(nodes)
        node.right = self.build_tree(nodes)

        return node
```

#### Java 实现

```java
public class Codec {

    // 序列化：前序遍历
    public String serialize(TreeNode root) {
        if (root == null) {
            return "null";
        }

        return root.val + "," +
               serialize(root.left) + "," +
               serialize(root.right);
    }

    // 反序列化：前序遍历重建
    public TreeNode deserialize(String data) {
        String[] nodes = data.split(",");
        int[] index = {0};
        return buildTree(nodes, index);
    }

    private TreeNode buildTree(String[] nodes, int[] index) {
        if (index[0] >= nodes.length || nodes[index[0]].equals("null")) {
            index[0]++;
            return null;
        }

        // 构建当前节点
        TreeNode node = new TreeNode(Integer.parseInt(nodes[index[0]]));
        index[0]++;

        // 递归构建左右子树
        node.left = buildTree(nodes, index);
        node.right = buildTree(nodes, index);

        return node;
    }
}
```

---

### 方法二：层序遍历（BFS）

#### Go 实现

```go
type Codec struct {}

func Constructor() Codec {
    return Codec{}
}

// 序列化：层序遍历
func (this *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return ""
    }

    result := []string{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]

        if node == nil {
            result = append(result, "null")
        } else {
            result = append(result, strconv.Itoa(node.Val))
            queue = append(queue, node.Left)
            queue = append(queue, node.Right)
        }
    }

    return strings.Join(result, ",")
}

// 反序列化：层序遍历重建
func (this *Codec) deserialize(data string) *TreeNode {
    if data == "" {
        return nil
    }

    nodes := strings.Split(data, ",")
    val, _ := strconv.Atoi(nodes[0])
    root := &TreeNode{Val: val}

    queue := []*TreeNode{root}
    index := 1

    for len(queue) > 0 && index < len(nodes) {
        node := queue[0]
        queue = queue[1:]

        // 处理左子节点
        if nodes[index] != "null" {
            val, _ := strconv.Atoi(nodes[index])
            node.Left = &TreeNode{Val: val}
            queue = append(queue, node.Left)
        }
        index++

        // 处理右子节点
        if index < len(nodes) && nodes[index] != "null" {
            val, _ := strconv.Atoi(nodes[index])
            node.Right = &TreeNode{Val: val}
            queue = append(queue, node.Right)
        }
        index++
    }

    return root
}
```

#### Python 实现

```python
from collections import deque

class Codec:

    def serialize(self, root):
        """层序遍历序列化"""
        if not root:
            return ""

        result = []
        queue = deque([root])

        while queue:
            node = queue.popleft()

            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append("null")

        return ",".join(result)

    def deserialize(self, data):
        """层序遍历反序列化"""
        if not data:
            return None

        nodes = data.split(',')
        root = TreeNode(int(nodes[0]))

        queue = deque([root])
        index = 1

        while queue and index < len(nodes):
            node = queue.popleft()

            # 处理左子节点
            if nodes[index] != "null":
                node.left = TreeNode(int(nodes[index]))
                queue.append(node.left)
            index += 1

            # 处理右子节点
            if index < len(nodes) and nodes[index] != "null":
                node.right = TreeNode(int(nodes[index]))
                queue.append(node.right)
            index += 1

        return root
```

---

## 复杂度分析

### 方法一：前序遍历
- **时间复杂度**：
  - 序列化：O(n)，遍历所有节点
  - 反序列化：O(n)，访问所有节点

- **空间复杂度**：
  - 序列化：O(n)，递归栈 + 字符串
  - 反序列化：O(n)，递归栈

### 方法二：层序遍历
- **时间复杂度**：
  - 序列化：O(n)
  - 反序列化：O(n)

- **空间复杂度**：
  - 序列化：O(n)，队列
  - 反序列化：O(n)，队列

---

## 关键细节与易错点

### 1. 为什么必须记录 null 节点？

**错误示例**（不记录 null）：

```
树 1：  1          树 2：  1
       /                    \
      2                      2

不记录 null 的序列化：都是 "1,2"
无法区分两棵不同的树！
```

**正确做法**：
```
树 1："1,2,null,null,null"
树 2："1,null,2,null,null"
```

### 2. 前序 vs 层序的选择

**前序遍历**：
- 优点：代码简洁，递归实现直观
- 缺点：序列化结果不易人工阅读

**层序遍历**：
- 优点：结果直观，可以优化去掉末尾 null
- 缺点：代码稍复杂，需要队列

### 3. 字符串拼接性能问题

**低效做法**（Go）：
```go
// ❌ 每次拼接都创建新字符串，O(n²)
func serialize(root *TreeNode) string {
    if root == nil {
        return "null"
    }
    return strconv.Itoa(root.Val) + "," + serialize(root.Left) + "," + serialize(root.Right)
}
```

**优化做法**：
```go
// ✅ 使用 StringBuilder 或数组，O(n)
func serialize(root *TreeNode) string {
    var sb strings.Builder
    serializeHelper(root, &sb)
    return sb.String()
}

func serializeHelper(node *TreeNode, sb *strings.Builder) {
    if node == nil {
        sb.WriteString("null,")
        return
    }
    sb.WriteString(strconv.Itoa(node.Val))
    sb.WriteString(",")
    serializeHelper(node.Left, sb)
    serializeHelper(node.Right, sb)
}
```

### 4. 反序列化的索引管理

**常见错误**：
```go
// ❌ 错误：index 不是指针，递归中无法更新
func buildTree(nodes []string, index int) *TreeNode {
    if nodes[index] == "null" {
        index++  // 这个修改不会影响调用者
        return nil
    }
    ...
}
```

**正确做法**：
```go
// ✅ 使用指针或类成员变量
func buildTree(nodes *[]string, index *int) *TreeNode {
    if (*nodes)[*index] == "null" {
        *index++
        return nil
    }
    ...
}
```

---

## 变体题目

### 变体 1：BST 的序列化（优化）

对于 BST，可以只记录前序遍历，不记录 null，利用 BST 性质恢复：

```go
// 序列化：只记录节点值
func serialize(root *TreeNode) string {
    if root == nil {
        return ""
    }
    result := []string{}
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        result = append(result, strconv.Itoa(node.Val))
        dfs(node.Left)
        dfs(node.Right)
    }
    dfs(root)
    return strings.Join(result, ",")
}

// 反序列化：利用 BST 性质
func deserialize(data string) *TreeNode {
    if data == "" {
        return nil
    }
    nodes := strings.Split(data, ",")
    vals := make([]int, len(nodes))
    for i, s := range nodes {
        vals[i], _ = strconv.Atoi(s)
    }
    index := 0
    return buildBST(&vals, &index, math.MinInt32, math.MaxInt32)
}

func buildBST(vals *[]int, index *int, min, max int) *TreeNode {
    if *index >= len(*vals) {
        return nil
    }
    val := (*vals)[*index]
    if val < min || val > max {
        return nil
    }
    *index++
    node := &TreeNode{Val: val}
    node.Left = buildBST(vals, index, min, val)
    node.Right = buildBST(vals, index, val, max)
    return node
}
```

### 变体 2：N 叉树的序列化

```go
// N 叉树节点定义
type Node struct {
    Val      int
    Children []*Node
}

// 序列化：前序遍历 + 记录子节点数量
func serialize(root *Node) string {
    if root == nil {
        return ""
    }
    var sb strings.Builder
    var dfs func(*Node)
    dfs = func(node *Node) {
        if node == nil {
            return
        }
        sb.WriteString(strconv.Itoa(node.Val))
        sb.WriteString(",")
        sb.WriteString(strconv.Itoa(len(node.Children))) // 记录子节点数量
        sb.WriteString(",")
        for _, child := range node.Children {
            dfs(child)
        }
    }
    dfs(root)
    return sb.String()
}

// 反序列化
func deserialize(data string) *Node {
    if data == "" {
        return nil
    }
    nodes := strings.Split(data, ",")
    index := 0
    return buildNaryTree(&nodes, &index)
}

func buildNaryTree(nodes *[]string, index *int) *Node {
    if *index >= len(*nodes) {
        return nil
    }
    val, _ := strconv.Atoi((*nodes)[*index])
    *index++
    childCount, _ := strconv.Atoi((*nodes)[*index])
    *index++

    node := &Node{Val: val, Children: make([]*Node, 0)}
    for i := 0; i < childCount; i++ {
        node.Children = append(node.Children, buildNaryTree(nodes, index))
    }
    return node
}
```

---

## 面试技巧

### 1. 思路表达

"这道题有多种解法，我推荐使用**前序遍历**：

**序列化**：
- 前序遍历（根 → 左 → 右）
- 遇到 null 记录为 \"null\"
- 用逗号分隔

**反序列化**：
- 将字符串按逗号分割
- 使用指针按前序顺序递归构建树
- 遇到 \"null\" 返回 nil

时间复杂度 O(n)，空间复杂度 O(n)。

如果需要更直观的结果，可以用**层序遍历**，但代码稍复杂一些。"

### 2. 画图说明

面试时建议画出序列化过程：

```
树：    1
       / \
      2   3
         / \
        4   5

前序遍历：
1 → 2 → null → null → 3 → 4 → null → null → 5 → null → null

序列化：
"1,2,null,null,3,4,null,null,5,null,null"
```

### 3. 追问准备

**面试官可能问**：

Q: "如果是 BST，能否优化？"
A: "可以只记录前序遍历的值，利用 BST 的性质（左 < 根 < 右）反序列化时确定左右子树边界。"

Q: "如果要求最短的序列化字符串呢？"
A: "对于 BST 只记录值；对于普通树，可以用括号表示法或层序遍历去掉末尾 null。"

Q: "能否用后序遍历？"
A: "可以，但反序列化时需要从右往左构建（先右子树再左子树），不如前序直观。"

---

## 典型错误示例

### 错误 1：忘记记录 null

```go
// ❌ 错误：无法区分不同结构的树
func serialize(root *TreeNode) string {
    if root == nil {
        return ""
    }
    return strconv.Itoa(root.Val) + "," + serialize(root.Left) + "," + serialize(root.Right)
}
```

### 错误 2：索引越界

```go
// ❌ 错误：没有检查索引边界
func buildTree(nodes []string, index *int) *TreeNode {
    val, _ := strconv.Atoi(nodes[*index])  // 可能越界
    ...
}

// ✅ 正确
func buildTree(nodes []string, index *int) *TreeNode {
    if *index >= len(nodes) || nodes[*index] == "null" {
        *index++
        return nil
    }
    ...
}
```

### 错误 3：层序遍历反序列化逻辑错误

```go
// ❌ 错误：每次循环处理两个子节点，但没有正确更新索引
for len(queue) > 0 {
    node := queue[0]
    queue = queue[1:]

    // 错误：应该先判断 index 是否越界
    node.Left = &TreeNode{Val: atoi(nodes[index])}
    index++
}
```

---

## 调试技巧

### 1. 打印中间结果

```go
// 序列化时打印结果
result := serialize(root)
fmt.Println("Serialized:", result)

// 反序列化时打印每步
func buildTree(nodes *[]string, index *int) *TreeNode {
    fmt.Printf("index=%d, val=%s\n", *index, (*nodes)[*index])
    ...
}
```

### 2. 边界测试

```go
// 测试空树
serialize(nil) // 应该返回 "" 或 "null"

// 测试单节点
serialize(&TreeNode{Val: 1}) // 应该返回 "1,null,null"

// 测试只有左子树/右子树
```

---

## 总结

这道题是**树的遍历 + 字符串处理**的综合应用，考察：

1. **遍历方式理解**：前序、中序、后序、层序的特点
2. **递归思维**：序列化和反序列化的对称性
3. **字符串处理**：分割、拼接、性能优化
4. **边界处理**：空节点、空树、索引越界

**记忆口诀**：
- 前序遍历最简洁，空节点标记别忘记
- 序列反序要对称，索引指针要仔细

掌握这道题后，可以轻松应对 N 叉树序列化、BST 优化序列化等变体问题。核心都是**选择合适的遍历方式 + 正确标记空节点**。

**实战建议**：
- 面试时优先选择**前序遍历**，代码最简洁
- 如果追求可读性，选择**层序遍历**
- 务必处理好**空节点**和**索引边界**，这是最常见的两个坑
