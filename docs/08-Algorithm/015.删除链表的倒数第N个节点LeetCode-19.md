---
title: 删除链表的倒数第N个节点（LeetCode 19）
tags:
  - 算法
status: robot
class: 算法
slug: remove-nth-node-from-end-of-list
ref:
---

## 核心要点

**快慢双指针(间隔N)**:快指针先走N步,然后快慢同步移动,快指针到末尾时慢指针在目标节点前驱
**一次遍历**:时间O(n)、空间O(1),避免两次遍历
**哑节点技巧**:处理删除头节点的边界情况
**关键细节**:快指针先走N+1步,慢指针指向待删除节点的前驱

---

## 详细解答

### 题目理解

给定链表,删除倒数第N个节点并返回头节点。要求只用一次遍历完成。

```
示例:
输入: head = [1,2,3,4,5], n = 2
输出: [1,2,3,5]
解释: 删除倒数第2个节点(4)

可视化:
1 -> 2 -> 3 -> 4 -> 5
             ↑
        倒数第2个
删除后: 1 -> 2 -> 3 -> 5
```

**难点**:
1. 如何一次遍历找到倒数第N个节点?
2. 如何处理删除头节点的情况?(n等于链表长度)
3. 如何找到待删除节点的前驱节点?(删除需要修改前驱的next)

### 解法:快慢双指针

#### 核心思路

使用快慢双指针,让它们保持N个节点的间隔:

1. **初始化**:
   - 创建哑节点指向head,处理删除头节点的情况
   - 快慢指针都从哑节点开始
2. **快指针先行**:
   - 快指针先走N+1步(注意是N+1,不是N!)
   - 目的:让慢指针最终停在待删除节点的前驱
3. **同步移动**:
   - 快慢指针同步向后移动
   - 当快指针到达null时,慢指针正好在待删除节点的前驱
4. **删除节点**:
   - `slow.Next = slow.Next.Next`
   - 返回`dummy.Next`

#### 为什么是N+1步?

```
示例: 1 -> 2 -> 3 -> 4 -> 5, n=2(删除4)

如果快指针先走N步(2步):
初始: dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
       slow    fast(走2步后到这里)
                    ↓
       dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
       slow              fast

同步移动到fast为NULL:
       dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
                            slow       fast
此时slow指向4,但我们需要的是3(4的前驱)!

如果快指针先走N+1步(3步):
初始: dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
       slow         fast(走3步后到这里)
                         ↓
       dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
       slow                   fast

同步移动到fast为NULL:
       dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
                         slow            fast
此时slow指向3,正是4的前驱!✅
```

#### 代码实现

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // 创建哑节点,处理删除头节点的情况
    dummy := &ListNode{Next: head}
    slow, fast := dummy, dummy

    // 快指针先走n+1步
    for i := 0; i <= n; i++ {
        fast = fast.Next
    }

    // 快慢指针同步移动
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }

    // 删除倒数第n个节点
    slow.Next = slow.Next.Next

    return dummy.Next
}
```

#### 复杂度分析

- **时间复杂度**: O(L) - L为链表长度,只遍历一次
- **空间复杂度**: O(1) - 仅使用两个指针

#### 图解过程

```
示例: head=[1,2,3,4,5], n=2

步骤1: 创建哑节点
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
slow,fast

步骤2: 快指针先走3步(n+1)
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
slow              fast

步骤3: 同步移动直到fast为NULL
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> NULL
                  slow            fast

步骤4: 删除slow.Next(节点4)
slow.Next = slow.Next.Next
dummy -> 1 -> 2 -> 3 -> 5 -> NULL

返回: dummy.Next = [1,2,3,5]
```

### 边界情况处理

1. **删除头节点**(n等于链表长度):
   ```
   输入: head=[1], n=1
   输出: []

   输入: head=[1,2], n=2
   输出: [2]

   哑节点的作用:
   dummy -> 1 -> 2 -> NULL
   slow         fast(先走3步到NULL)
   同步移动后:
   dummy -> 1 -> 2 -> NULL
        slow    fast(NULL)
   删除slow.Next(节点1),返回dummy.Next = [2]
   ```

2. **单节点链表**:
   ```
   输入: head=[1], n=1
   输出: []
   ```

3. **删除尾节点**:
   ```
   输入: head=[1,2,3], n=1
   输出: [1,2]
   ```

### 常见错误

1. ❌ 快指针只走N步而非N+1步
   ```go
   for i := 0; i < n; i++ {  // 错误!应该是i<=n
       fast = fast.Next
   }
   // 结果:slow指向待删除节点而非前驱
   ```

2. ❌ 忘记使用哑节点
   ```go
   slow, fast := head, head  // 错误!删除头节点时无法处理
   // 例如:[1], n=1时,无法返回空链表
   ```

3. ❌ 删除节点后未考虑空指针
   ```go
   slow.Next = slow.Next.Next  // 如果slow.Next为nil会崩溃
   // 正常情况下不会发生,但代码审查时会被质疑
   // 更安全(虽然题目保证n有效):
   if slow.Next != nil {
       slow.Next = slow.Next.Next
   }
   ```

4. ❌ 返回错误的头节点
   ```go
   return head  // 错误!如果删除的是头节点,head已被删除
   return dummy.Next  // 正确!
   ```

### 解法二:两次遍历(不推荐)

虽然题目要求一次遍历,但为了对比说明:

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}

    // 第一次遍历:计算链表长度
    length := 0
    curr := head
    for curr != nil {
        length++
        curr = curr.Next
    }

    // 第二次遍历:找到第(length-n)个节点的前驱
    curr = dummy
    for i := 0; i < length-n; i++ {
        curr = curr.Next
    }

    // 删除节点
    curr.Next = curr.Next.Next

    return dummy.Next
}
```

**缺点**:
- 时间复杂度仍是O(L),但常数因子更大(遍历两次)
- 不符合题目"一次遍历"的要求
- 代码更长,面试中展现不出双指针技巧

### 面试要点

1. **双指针精髓**:
   - 强调N+1的原因(为了定位到前驱节点)
   - 通过画图清晰展示指针移动过程
2. **哑节点价值**:
   - 统一处理删除头节点和普通节点
   - 避免复杂的条件判断
3. **一次遍历证明**:
   - 快指针走N+1步,慢指针和快指针同步走(L-N-1)步
   - 总共遍历L个节点,确实只需一次遍历
4. **边界讨论**:
   - n=1(删除尾节点)
   - n=length(删除头节点)
   - length=1(单节点链表)
5. **扩展思考**:
   - 如果n可能无效怎么办?(快指针走到null时计数)
   - 如果要删除倒数第K到第M个节点?(类似思路,双指针间隔调整)

### 变体题目

1. **LeetCode 61 - 旋转链表**:
   - 找倒数第K个节点,从该处断开重组
   - 使用类似的双指针技巧

2. **剑指Offer 22 - 链表中倒数第k个节点**:
   - 返回倒数第K个节点(不删除)
   - 快指针先走K步即可

3. **LeetCode 876 - 链表的中间节点**:
   - 快指针走2步,慢指针走1步
   - 双指针变体

### 实战技巧

1. **测试用例**:
   ```
   - 正常情况:[1,2,3,4,5], n=2 → [1,2,3,5]
   - 删除头节点:[1,2], n=2 → [2]
   - 删除尾节点:[1,2,3], n=1 → [1,2]
   - 单节点:[1], n=1 → []
   - 两节点删除第一个:[1,2], n=1 → [1]
   ```

2. **白板编码顺序**:
   - 先画图展示N+1的推导
   - 写代码时强调哑节点的作用
   - 写完后口头验证边界情况

3. **时间控制**:6-8分钟(含讲解+编码)

4. **常见追问**:
   - "为什么快指针要先走N+1步而不是N步?"(重点!必须能清晰解释)
   - "如果n无效(大于链表长度)怎么办?"(可在快指针先行时检测)
   - "能否用递归实现?"(可以,但空间O(L),不如双指针优)

### 递归解法(扩展)

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    removeNth(dummy, n)
    return dummy.Next
}

// 递归函数返回当前节点是倒数第几个
func removeNth(node *ListNode, n int) int {
    if node.Next == nil {
        return 0  // 尾节点是倒数第0个
    }

    index := removeNth(node.Next, n) + 1

    if index == n+1 {  // 当前节点的next是倒数第n个
        node.Next = node.Next.Next
    }

    return index
}
```

**特点**:
- 空间复杂度O(L)递归栈
- 代码简洁但不够直观
- 面试中除非面试官主动问,否则优先用双指针

### 知识总结

**双指针技巧分类**:
1. **快慢指针**(本题):间隔固定距离,解决倒数问题
2. **相向指针**:从两端向中间逼近,解决有序数组问题
3. **同向指针**:处理子数组/子串问题(滑动窗口)

**链表哑节点的使用场景**:
- 可能删除头节点
- 构建新链表
- 需要返回新头节点的场景

这道题是双指针技巧的经典应用,也是面试高频题。关键在于理解"为何是N+1步"这个细节,以及哑节点如何简化边界处理。建议多次练习,确保5分钟内无bug写出,面试时才能从容应对。
