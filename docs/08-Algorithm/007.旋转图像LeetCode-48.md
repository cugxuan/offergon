---
title: 旋转图像（LeetCode 48）
tags:
  - 算法
status: robot
class: 算法
slug: rotate-image
ref:
---

## 核心要点

**一句话总结**：顺时针旋转90度 = 先转置(沿主对角线翻转) + 再水平翻转(每行反转)，原地操作 O(1) 空间。

**关键技巧**：找规律 `matrix[i][j]` → `matrix[j][n-1-i]`，或用两步变换：转置 + 水平翻转。

---

## 问题分析

给定一个 `n × n` 的二维矩阵表示图像，将图像顺时针旋转 90 度。

**约束条件**：
- 必须**原地**旋转（不能使用额外的矩阵空间）
- 矩阵是正方形（n × n）

**示例**：
```
输入：matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]

输出：[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

可视化：
1 2 3      7 4 1
4 5 6  →   8 5 2
7 8 9      9 6 3
```

---

## 解法思路

### 方法一：两步变换（推荐）

**核心思路**：顺时针旋转90度 = 转置 + 水平翻转

**步骤**：
1. **转置**：沿主对角线翻转，`matrix[i][j]` 与 `matrix[j][i]` 交换
2. **水平翻转**：每行元素反转，`matrix[i][j]` 与 `matrix[i][n-1-j]` 交换

**为什么有效？**

以 `matrix[0][2] = 3` 为例：
- 转置后：`3` 从 `[0][2]` 移到 `[2][0]`
- 水平翻转：`3` 从 `[2][0]` 移到 `[2][2]`
- 最终位置恰好是顺时针旋转90度的位置

**代码实现**：

```go
func rotate(matrix [][]int) {
    n := len(matrix)

    // 步骤1：转置矩阵（沿主对角线翻转）
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {  // 注意：j从i+1开始，避免重复交换
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }

    // 步骤2：水平翻转（每行反转）
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
        }
    }
}
```

**执行过程示例**：

原矩阵：
```
1 2 3
4 5 6
7 8 9
```

转置后：
```
1 4 7
2 5 8
3 6 9
```

水平翻转后：
```
7 4 1
8 5 2
9 6 3
```

### 方法二：一次遍历（四元素循环交换）

**核心思路**：找到每个元素旋转后的位置，一次性完成四个位置的循环交换。

**位置映射规律**：
- `matrix[i][j]` → `matrix[j][n-1-i]`
- `matrix[j][n-1-i]` → `matrix[n-1-i][n-1-j]`
- `matrix[n-1-i][n-1-j]` → `matrix[n-1-j][i]`
- `matrix[n-1-j][i]` → `matrix[i][j]`

**代码实现**：

```go
func rotate(matrix [][]int) {
    n := len(matrix)

    // 只需遍历外层到内层的每一层
    for layer := 0; layer < n/2; layer++ {
        first := layer
        last := n - 1 - layer

        for i := first; i < last; i++ {
            offset := i - first

            // 保存 top
            top := matrix[first][i]

            // left -> top
            matrix[first][i] = matrix[last-offset][first]

            // bottom -> left
            matrix[last-offset][first] = matrix[last][last-offset]

            // right -> bottom
            matrix[last][last-offset] = matrix[i][last]

            // top -> right
            matrix[i][last] = top
        }
    }
}
```

---

## 代码实现（推荐方法一）

```go
func rotate(matrix [][]int) {
    n := len(matrix)

    // 步骤1：转置
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }

    // 步骤2：水平翻转
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
        }
    }
}
```

---

## 复杂度分析

**时间复杂度**：O(n²)
- 转置：O(n²)
- 水平翻转：O(n²)
- 总体：O(n²)

**空间复杂度**：O(1)
- 原地操作，只使用常数个临时变量

---

## 注意事项与易错点

### 1. **转置时的遍历范围**

**错误示例**：
```go
// 错误：会重复交换，相当于没变
for i := 0; i < n; i++ {
    for j := 0; j < n; j++ {  // 错误！
        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    }
}
```

**正确做法**：
```go
// 只遍历上三角矩阵（不含对角线）
for i := 0; i < n; i++ {
    for j := i + 1; j < n; j++ {  // j从i+1开始
        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    }
}
```

### 2. **水平翻转的范围**

```go
// 正确：只需交换左半部分和右半部分
for j := 0; j < n/2; j++ {
    matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
}

// 错误：会重复交换
for j := 0; j < n; j++ {  // 错误！
    matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
}
```

### 3. **不同旋转方向**

- **顺时针90度**：转置 + 水平翻转
- **逆时针90度**：转置 + 垂直翻转（每列反转）
- **180度**：水平翻转 + 垂直翻转（或直接对称交换）

```go
// 逆时针90度
func rotateCounterClockwise(matrix [][]int) {
    n := len(matrix)

    // 转置
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }

    // 垂直翻转（每列反转）
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]
        }
    }
}

// 180度旋转
func rotate180(matrix [][]int) {
    n := len(matrix)

    // 水平翻转
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
        }
    }

    // 垂直翻转
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]
        }
    }
}
```

### 4. **边界情况**

```go
// 1×1 矩阵
matrix = [[1]]  // 无需旋转

// 2×2 矩阵
matrix = [[1,2],[3,4]]  // 正确处理

// 空矩阵
if len(matrix) == 0 {
    return
}
```

### 5. **非正方形矩阵**

题目限制是正方形矩阵。如果是 `m × n` 矩阵（m ≠ n），无法原地旋转，需要额外空间。

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：顺时针旋转90度，原地操作
2. 观察规律：找到元素位置变化规律
3. 方法一：两步变换（转置 + 水平翻转），最直观
4. 方法二：四元素循环交换，一次遍历完成
5. 推荐方法一：代码简洁，易理解
6. 复杂度：O(n²) 时间，O(1) 空间

**可能的追问**：

- **Q: 为什么转置 + 水平翻转等于顺时针旋转90度？**
  - A: 转置是沿主对角线翻转，水平翻转是沿垂直中线翻转。两次操作的组合效果等同于绕中心顺时针旋转90度。可以手绘矩阵验证每个元素的移动轨迹。

- **Q: 如果要求逆时针旋转90度？**
  - A: 转置 + 垂直翻转。或者顺时针旋转3次。

- **Q: 如果要求旋转180度？**
  - A: 水平翻转 + 垂直翻转。或者顺时针旋转2次。

- **Q: 如果不要求原地旋转，有更简单的方法吗？**
  - A: 创建新矩阵，直接按 `newMatrix[j][n-1-i] = matrix[i][j]` 填充。空间复杂度 O(n²)。

- **Q: 四元素循环交换的方法更快吗？**
  - A: 时间复杂度相同都是 O(n²)，但四元素法只遍历一次，常数更小。转置+翻转法更直观易懂，面试推荐。

- **Q: 能否递归实现？**
  - A: 可以，按层递归旋转。但迭代更简单，递归会增加栈空间开销。

**类似问题**：
- 螺旋矩阵（LeetCode 54）：螺旋遍历
- 矩阵置零（LeetCode 73）：原地标记
- 对角线遍历（LeetCode 498）：对角线遍历

---

## 扩展：位置变换规律

**顺时针90度旋转的数学规律**：

对于 `n × n` 矩阵，`matrix[i][j]` 旋转后的位置是 `matrix[j][n-1-i]`。

**证明**：
- 原坐标：`(i, j)`，以左上角为原点
- 旋转中心：`(n/2, n/2)`
- 顺时针旋转90度后：
  - `x' = y`
  - `y' = n - 1 - x`
- 因此 `(i, j)` → `(j, n-1-i)`

**四个位置的循环**：
```
(i, j) → (j, n-1-i) → (n-1-i, n-1-j) → (n-1-j, i) → (i, j)
```

这就是方法二的数学基础。
