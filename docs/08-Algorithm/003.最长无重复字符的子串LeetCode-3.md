---
title: 最长无重复字符的子串（LeetCode 3）
tags:
  - 算法
status: robot
class: 算法
slug: longest-substring-without-repeating-characters
ref:
---

## 核心要点

**一句话总结**：滑动窗口 + 哈希表，右指针扩展窗口，遇到重复字符时左指针收缩，动态维护最大长度。

**关键技巧**：用哈希表记录字符最后出现位置，O(n) 时间复杂度一次遍历完成。

---

## 问题分析

给定字符串 `s`，找出其中不含重复字符的最长子串的长度。

**约束条件**：
- 子串必须是连续的字符序列
- 子串内不能有重复字符
- 只需返回长度，不需返回子串本身

**示例**：
```
输入：s = "abcabcbb"
输出：3
解释：最长无重复子串是 "abc"，长度为 3

输入：s = "bbbbb"
输出：1
解释：最长无重复子串是 "b"，长度为 1

输入：s = "pwwkew"
输出：3
解释：最长无重复子串是 "wke"，长度为 3
注意："pwke" 是子序列而非子串
```

---

## 解法思路

### 核心思路：滑动窗口

**窗口的定义**：
- 用 `[left, right]` 表示当前窗口
- 窗口内始终保持无重复字符
- `right` 不断右移扩展窗口，`left` 在遇到重复时收缩

**算法流程**：
1. 使用哈希表记录每个字符最后出现的位置
2. 右指针 `right` 遍历字符串
3. 如果 `s[right]` 已在窗口内出现过：
   - 左指针 `left` 移动到重复字符的下一个位置
4. 更新当前字符的位置到哈希表
5. 更新最大长度 `maxLen = max(maxLen, right - left + 1)`

**为什么有效**：
- 窗口内始终无重复字符（满足题意）
- 每个字符最多被访问两次（right 访问一次，left 可能跳过）
- 时间复杂度 O(n)

**关键点**：
- 哈希表存储字符的**索引位置**，而非布尔值
- `left` 的更新：`left = max(left, charMap[s[right]] + 1)`
  - 为什么要 `max`？防止 `left` 回退（见易错点）

---

## 代码实现

```go
func lengthOfLongestSubstring(s string) int {
    // 字符最后出现位置的哈希表
    charIndex := make(map[byte]int)
    maxLen := 0
    left := 0

    // 右指针遍历字符串
    for right := 0; right < len(s); right++ {
        char := s[right]

        // 如果字符已在窗口内，收缩左边界
        if lastIndex, exists := charIndex[char]; exists && lastIndex >= left {
            // 移动左指针到重复字符的下一个位置
            left = lastIndex + 1
        }

        // 更新字符的位置
        charIndex[char] = right

        // 更新最大长度
        currentLen := right - left + 1
        if currentLen > maxLen {
            maxLen = currentLen
        }
    }

    return maxLen
}
```

**优化版本（更简洁）**：

```go
func lengthOfLongestSubstring(s string) int {
    charIndex := make(map[byte]int)
    maxLen := 0
    left := 0

    for right := 0; right < len(s); right++ {
        char := s[right]

        // 如果字符在当前窗口内，更新左边界
        if idx, ok := charIndex[char]; ok && idx >= left {
            left = idx + 1
        }

        // 更新字符位置
        charIndex[char] = right

        // 更新最大长度
        maxLen = max(maxLen, right-left+1)
    }

    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**执行过程示例**（s = "abcabcbb"）：

| right | char | charIndex 状态 | left | 当前窗口 | 长度 | maxLen |
|-------|------|----------------|------|----------|------|--------|
| 0 | a | {a:0} | 0 | "a" | 1 | 1 |
| 1 | b | {a:0, b:1} | 0 | "ab" | 2 | 2 |
| 2 | c | {a:0, b:1, c:2} | 0 | "abc" | 3 | 3 |
| 3 | a | {a:3, b:1, c:2} | 1 | "bca" | 3 | 3 |
| 4 | b | {a:3, b:4, c:2} | 2 | "cab" | 3 | 3 |
| 5 | c | {a:3, b:4, c:5} | 3 | "abc" | 3 | 3 |
| 6 | b | {a:3, b:6, c:5} | 5 | "cb" | 2 | 3 |
| 7 | b | {a:3, b:7, c:5} | 7 | "b" | 1 | 3 |

---

## 复杂度分析

**时间复杂度**：O(n)
- 右指针遍历一次字符串：O(n)
- 左指针最多移动 n 次（不会回退）
- 哈希表操作：O(1)

**空间复杂度**：O(min(n, m))
- n 是字符串长度，m 是字符集大小
- 最坏情况：所有字符不重复，哈希表存储 n 个字符
- 如果字符集固定（如 ASCII），空间复杂度为 O(m) = O(128) = O(1)

---

## 注意事项与易错点

### 1. **左指针不能回退**

最容易出错的地方！必须用 `left = max(left, charIndex[char] + 1)`

**错误示例**：
```go
// 错误：直接更新 left，可能导致回退
left = charIndex[char] + 1

// 问题场景：s = "abba"
// right=3, char='a', charIndex['a']=0
// left 会从 2 回退到 1，错误！
```

**正确做法**：
```go
if idx, ok := charIndex[char]; ok && idx >= left {
    left = idx + 1  // 只在字符在当前窗口内时更新
}
```

### 2. **哈希表存储索引而非布尔值**

```go
// 错误：只存储是否存在
charExists := make(map[byte]bool)

// 正确：存储索引位置
charIndex := make(map[byte]int)
```

为什么？因为需要知道重复字符的位置，才能正确移动 `left`。

### 3. **边界条件**

```go
// 空字符串
if len(s) == 0 {
    return 0
}

// 单字符
if len(s) == 1 {
    return 1
}
```

实际上代码已经自动处理了这些情况，无需特殊判断。

### 4. **窗口长度计算**

```go
// 长度 = right - left + 1（包含两端）
currentLen := right - left + 1
```

注意是 `+1`，因为索引从 0 开始。

### 5. **字符集的影响**

- ASCII 字符集：可以用数组 `var charIndex [128]int` 替代 map，更快
- Unicode 字符集：必须用 map

**数组优化版本**（仅适用于 ASCII）：

```go
func lengthOfLongestSubstring(s string) int {
    var charIndex [128]int  // ASCII 字符集
    for i := range charIndex {
        charIndex[i] = -1  // 初始化为 -1
    }

    maxLen := 0
    left := 0

    for right := 0; right < len(s); right++ {
        char := s[right]

        if charIndex[char] >= left {
            left = charIndex[char] + 1
        }

        charIndex[char] = right
        maxLen = max(maxLen, right-left+1)
    }

    return maxLen
}
```

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：子串（连续）vs 子序列（不连续）
2. 暴力法：枚举所有子串 O(n³)，用 set 检查重复
3. 优化方向：如何避免重复计算？→ 滑动窗口
4. 滑动窗口实现：双指针 + 哈希表
5. 关键点：左指针如何移动？→ 跳到重复字符的下一个位置
6. 复杂度分析：O(n) 时间，O(m) 空间

**可能的追问**：

- **Q: 如果要求返回最长子串本身而非长度？**
  - A: 在更新 `maxLen` 时，同时记录 `start` 和 `end` 位置，最后返回 `s[start:end+1]`。

- **Q: 能否不用哈希表？**
  - A: 可以用数组替代（ASCII 字符集），或者用两层循环（暴力法）。

- **Q: 为什么左指针不会回退？**
  - A: 因为窗口始终向右扩展，如果 `left` 回退，窗口内可能包含更早的重复字符，不符合题意。

- **Q: 如果要求子串的字符出现次数都不超过 k 次？**
  - A: 同样滑动窗口，但哈希表存储字符出现次数，当次数超过 k 时收缩左边界。

- **Q: 为什么是 O(n) 而不是 O(n²)？**
  - A: 虽然有两个指针，但每个字符最多被访问两次（right 遍历一次，left 可能跳过一次）。`left` 只会向右移动，不会重复访问。

- **Q: 滑动窗口的通用模板是什么？**
  - A:
    1. 右指针扩展窗口
    2. 判断窗口是否满足条件
    3. 不满足时，左指针收缩窗口
    4. 更新结果

**变体问题**：
- 最长子串包含至多 k 个不同字符（LeetCode 340）
- 最小覆盖子串（LeetCode 76）
- 字符串排列（LeetCode 567）

这些都可以用滑动窗口 + 哈希表解决。
