---
title: 环形链表 II(LeetCode 142)
tags:
  - 算法
status: robot
class: 算法
slug: linked-list-cycle-ii
ref:
---

## 核心要点

**快慢双指针**:快指针每次走2步、慢指针走1步,相遇则存在环
**数学推导**:相遇后,一指针回到头节点,两指针同速前进,再次相遇点即为环入口
**关键公式**:设头到环入口距离a,环入口到相遇点b,环长c,则a=(n-1)c+c-b
**时间O(n)、空间O(1)**,优于哈希表解法

---

## 详细解答

### 题目理解

给定一个链表,判断链表是否有环,如果有环则返回环的入口节点,否则返回null。

```
示例:
输入: head = [3,2,0,-4], pos = 1 (环入口在节点2)
     3 -> 2 -> 0 -> -4
          ↑__________↓
输出: 节点2
```

这道题是LeetCode 141"环形链表"的进阶版,不仅要判断是否有环,还要找到环的入口位置,难度在于如何用O(1)空间实现。

### 解法一:快慢指针+数学推导(最优解)

#### 核心思路

整个算法分为两个阶段:

**阶段1:判断是否有环**
- 使用快慢双指针(Floyd判圈算法)
- 慢指针每次走1步,快指针每次走2步
- 如果有环,快慢指针必定在环内相遇
- 如果快指针走到null,说明无环

**阶段2:找到环的入口(关键)**
- 相遇后,将其中一个指针移回头节点
- 两指针以相同速度(每次1步)前进
- 再次相遇的节点就是环的入口

#### 数学证明

设定变量:
- **a**: 头节点到环入口的距离
- **b**: 环入口到首次相遇点的距离
- **c**: 环的长度

快慢指针相遇时:
- 慢指针走过的距离: `a + b`
- 快指针走过的距离: `a + b + nc` (n为快指针在环内多走的圈数,n≥1)

由于快指针速度是慢指针的2倍:
```
2(a + b) = a + b + nc
=> a + b = nc
=> a = nc - b = (n-1)c + (c-b)
```

**关键结论**: 从头节点到环入口的距离a,等于从相遇点继续走(n-1)圈后再走(c-b)的距离。

因此,当一个指针从头节点出发,另一个从相遇点出发,两者以相同速度前进时,它们会在环入口相遇!

#### 代码实现

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    // 阶段1:判断是否有环
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next       // 慢指针走1步
        fast = fast.Next.Next  // 快指针走2步

        if slow == fast {  // 相遇,说明有环
            // 阶段2:找环入口
            ptr := head  // 一个指针从头开始

            for ptr != slow {  // 两指针同速前进
                ptr = ptr.Next
                slow = slow.Next
            }

            return ptr  // 相遇点即为环入口
        }
    }

    return nil  // 快指针到达末尾,无环
}
```

#### 复杂度分析

- **时间复杂度**: O(n)
  - 阶段1:快指针最多走n+环长,慢指针最多走n
  - 阶段2:最多再走n步
  - 总体O(n)
- **空间复杂度**: O(1) - 仅使用两个指针

#### 图解过程

```
链表结构: 3 -> 2 -> 0 -> -4
                ↑__________↓

阶段1:快慢指针相遇
step 0: slow=3, fast=3
step 1: slow=2, fast=0
step 2: slow=0, fast=2
step 3: slow=-4, fast=-4  [相遇!]

阶段2:找环入口
ptr从头开始,slow从相遇点(-4)开始
step 0: ptr=3,  slow=-4
step 1: ptr=2,  slow=2    [相遇!环入口是节点2]
```

### 解法二:哈希表法(空间换时间)

#### 思路

遍历链表,用哈希表(map或set)记录访问过的节点,第一个重复出现的节点就是环入口。

#### 代码实现

```go
func detectCycle(head *ListNode) *ListNode {
    visited := make(map[*ListNode]bool)

    curr := head
    for curr != nil {
        if visited[curr] {
            return curr  // 第一个重复节点即为环入口
        }
        visited[curr] = true
        curr = curr.Next
    }

    return nil
}
```

#### 复杂度分析

- **时间复杂度**: O(n) - 遍历链表一次
- **空间复杂度**: O(n) - 哈希表存储所有节点

### 两种解法对比

| 维度 | 快慢指针法 | 哈希表法 |
|------|-----------|---------|
| 时间复杂度 | O(n) | O(n) |
| 空间复杂度 | O(1) ✅ | O(n) |
| 代码复杂度 | 较高(需要理解数学原理) | 简单直观 |
| 面试推荐度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

### 面试要点

1. **优先答快慢指针法**:这是面试官期待的最优解,体现算法功底
2. **数学推导要清晰**:建议通过画图推导a=(n-1)c+(c-b),证明为何两指针会在环入口相遇
3. **边界处理**:
   - 空链表:返回nil
   - 无环:快指针到达末尾返回nil
   - 单节点自环:正确返回该节点
4. **变体讨论**:
   - 如何求环的长度?(相遇后再走一圈计数)
   - 如何判断两链表是否相交?(类似思路)
5. **可以先说哈希表解法表明思路,再优化到快慢指针**

### 常见错误

1. ❌ 快指针判断条件不完整
   ```go
   for fast != nil {  // 错误!fast.Next可能为nil
       fast = fast.Next.Next  // 空指针错误
   }
   // 正确写法:
   for fast != nil && fast.Next != nil
   ```

2. ❌ 阶段2两指针速度不一致
   ```go
   for ptr != slow {
       ptr = ptr.Next
       slow = slow.Next.Next  // 错误!应该同速
   }
   ```

3. ❌ 忘记相遇判断
   ```go
   for fast != nil && fast.Next != nil {
       slow = slow.Next
       fast = fast.Next.Next
   }
   // 忘记在循环内判断slow==fast
   ```

### 实战技巧

1. **画图是关键**:面试时一定要画出链表结构图,标注a、b、c距离
2. **分阶段讲解**:先讲判环,再讲找入口,逻辑清晰
3. **时间控制**:10分钟内完成编码+讲解数学原理
4. **测试用例**:
   - 无环链表:[1,2,3,4]
   - 有环链表:[3,2,0,-4],pos=1
   - 单节点自环:[1],pos=0
   - 空链表:[]

### 扩展知识

**Floyd判圈算法**的应用场景:
- 检测链表环(本题)
- 检测数组中的重复数字(LeetCode 287)
- 检测函数迭代的循环
- 密码学中的Pollard's rho算法

这道题是链表经典题,掌握快慢指针+数学推导是核心,建议反复练习直到能快速推导出a=(n-1)c+(c-b)的结论。
