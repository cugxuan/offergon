---
title: 最长公共子序列(LeetCode 1143)
tags:
  - 算法
status: robot
class: 算法
slug: longest-common-subsequence
ref:
---

## 核心要点

- **问题本质**: 求两个序列的最长公共子序列(LCS)长度,子序列不要求连续
- **经典二维 DP**: `dp[i][j]` 表示 text1 的前 i 个字符和 text2 的前 j 个字符的 LCS 长度
- **状态转移**:
  - 字符相同: `dp[i][j] = dp[i-1][j-1] + 1`
  - 字符不同: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
- **与编辑距离的关系**: 只允许删除操作的编辑距离 = m + n - 2 × LCS
- **应用场景**: diff 工具、版本控制、DNA 序列比对、文本相似度

## 题目描述

给定两个字符串 `text1` 和 `text2`,返回这两个字符串的**最长公共子序列**的长度。如果不存在公共子序列,返回 0。

一个字符串的**子序列**是指这样一个新的字符串:它是由原字符串在不改变字符的相对顺序的情况下删除某些字符(也可以不删除任何字符)后组成的新字符串。

- 例如,"ace" 是 "abcde" 的子序列,但 "aec" 不是 "abcde" 的子序列。

两个字符串的**公共子序列**是这两个字符串所共同拥有的子序列。

**示例 1:**
```
输入: text1 = "abcde", text2 = "ace"
输出: 3
解释: 最长公共子序列是 "ace",它的长度为 3
```

**示例 2:**
```
输入: text1 = "abc", text2 = "abc"
输出: 3
解释: 最长公共子序列是 "abc",它的长度为 3
```

**示例 3:**
```
输入: text1 = "abc", text2 = "def"
输出: 0
解释: 两个字符串没有公共子序列,返回 0
```

**提示:**
- 1 ≤ text1.length, text2.length ≤ 1000
- text1 和 text2 仅由小写英文字符组成

## 解题思路

### 问题分析

最长公共子序列(Longest Common Subsequence, LCS)是经典的二维动态规划问题。

**关键点:**
- **子序列 vs 子串**: 子序列不要求连续,子串要求连续
- **最优子结构**: LCS 问题具有最优子结构,适合用动态规划
- **两个维度**: 需要同时考虑两个字符串的状态

### 动态规划解法

#### 状态定义

`dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。

**说明:**
- `text1[0...i-1]` 和 `text2[0...j-1]` 的 LCS 长度
- `dp[0][0] = 0`: 两个空字符串的 LCS 长度为 0

#### 状态转移方程

对于 `dp[i][j]`,考虑 `text1[i-1]` 和 `text2[j-1]`:

**情况 1: 字符相同** (`text1[i-1] == text2[j-1]`)

```
dp[i][j] = dp[i-1][j-1] + 1
```

- 当前字符相同,可以加入到公共子序列中
- LCS 长度 = 前面的 LCS 长度 + 1

**情况 2: 字符不同** (`text1[i-1] != text2[j-1]`)

```
dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

- 当前字符不匹配,不能同时加入 LCS
- 有两种选择:
  - `dp[i-1][j]`: 不用 `text1[i-1]`,看 `text1[0...i-2]` 和 `text2[0...j-1]` 的 LCS
  - `dp[i][j-1]`: 不用 `text2[j-1]`,看 `text1[0...i-1]` 和 `text2[0...j-2]` 的 LCS
- 取两者的最大值

#### 初始化

**第一行**: `dp[0][j] = 0` (空字符串与任何字符串的 LCS 为 0)

**第一列**: `dp[i][0] = 0` (任何字符串与空字符串的 LCS 为 0)

由于 Go 的 make 函数默认初始化为 0,不需要显式初始化。

### 详细推导示例

```
text1 = "abcde", text2 = "ace"

构建 DP 表格:

       ""  a  c  e
    "" 0   0  0  0
    a  0   ?  ?  ?
    b  0   ?  ?  ?
    c  0   ?  ?  ?
    d  0   ?  ?  ?
    e  0   ?  ?  ?

逐步填充:

dp[1][1]: text1[0]='a' vs text2[0]='a' (相同)
  = dp[0][0] + 1 = 1

dp[1][2]: text1[0]='a' vs text2[1]='c' (不同)
  = max(dp[0][2], dp[1][1]) = max(0, 1) = 1

dp[1][3]: text1[0]='a' vs text2[2]='e' (不同)
  = max(dp[0][3], dp[1][2]) = max(0, 1) = 1

dp[2][1]: text1[1]='b' vs text2[0]='a' (不同)
  = max(dp[1][1], dp[2][0]) = max(1, 0) = 1

dp[2][2]: text1[1]='b' vs text2[1]='c' (不同)
  = max(dp[1][2], dp[2][1]) = max(1, 1) = 1

dp[2][3]: text1[1]='b' vs text2[2]='e' (不同)
  = max(dp[1][3], dp[2][2]) = max(1, 1) = 1

dp[3][1]: text1[2]='c' vs text2[0]='a' (不同)
  = max(dp[2][1], dp[3][0]) = max(1, 0) = 1

dp[3][2]: text1[2]='c' vs text2[1]='c' (相同)
  = dp[2][1] + 1 = 1 + 1 = 2

dp[3][3]: text1[2]='c' vs text2[2]='e' (不同)
  = max(dp[2][3], dp[3][2]) = max(1, 2) = 2

dp[4][1]: text1[3]='d' vs text2[0]='a' (不同)
  = max(dp[3][1], dp[4][0]) = max(1, 0) = 1

dp[4][2]: text1[3]='d' vs text2[1]='c' (不同)
  = max(dp[3][2], dp[4][1]) = max(2, 1) = 2

dp[4][3]: text1[3]='d' vs text2[2]='e' (不同)
  = max(dp[3][3], dp[4][2]) = max(2, 2) = 2

dp[5][1]: text1[4]='e' vs text2[0]='a' (不同)
  = max(dp[4][1], dp[5][0]) = max(1, 0) = 1

dp[5][2]: text1[4]='e' vs text2[1]='c' (不同)
  = max(dp[4][2], dp[5][1]) = max(2, 1) = 2

dp[5][3]: text1[4]='e' vs text2[2]='e' (相同)
  = dp[4][2] + 1 = 2 + 1 = 3

最终 DP 表格:

       ""  a  c  e
    "" 0   0  0  0
    a  0   1  1  1
    b  0   1  1  1
    c  0   1  2  2
    d  0   1  2  2
    e  0   1  2  3

答案: dp[5][3] = 3,对应的 LCS 是 "ace"
```

### 为什么这样设计?

**字符相同时**: `dp[i][j] = dp[i-1][j-1] + 1`
- 两个字符串都"使用"当前字符,加入到公共子序列中
- 问题规模缩小: 变为求前面部分的 LCS

**字符不同时**: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
- 不能同时使用两个字符
- 尝试"放弃"其中一个字符:
  - `dp[i-1][j]`: 放弃 text1 的当前字符
  - `dp[i][j-1]`: 放弃 text2 的当前字符
- 两种选择取最大值

## 代码实现

### Go 实现 - 二维 DP

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)

    // dp[i][j] 表示 text1[0...i-1] 和 text2[0...j-1] 的 LCS 长度
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    // 第一行和第一列默认为 0,不需要显式初始化

    // 状态转移
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                // 字符相同,LCS 长度 +1
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                // 字符不同,取两种选择的最大值
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 空间优化: 一维 DP

由于 `dp[i][j]` 只依赖于上一行和当前行的前一个元素,可以用一维数组优化。

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)

    // 使用一维数组,只保存上一行的结果
    dp := make([]int, n+1)

    // 逐行更新
    for i := 1; i <= m; i++ {
        prev := 0  // 对应二维 dp 的 dp[i-1][j-1]

        for j := 1; j <= n; j++ {
            temp := dp[j]  // 保存当前值(上一行的 dp[j])

            if text1[i-1] == text2[j-1] {
                dp[j] = prev + 1
            } else {
                dp[j] = max(dp[j], dp[j-1])
            }

            prev = temp  // 更新左上角的值
        }
    }

    return dp[n]
}
```

### 如何构造具体的 LCS 序列?

如果需要输出具体的公共子序列,可以在 DP 的基础上回溯:

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    // 构建 DP 表
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    // 回溯构造 LCS
    result := []byte{}
    i, j := m, n

    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            // 当前字符在 LCS 中
            result = append(result, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            // 来自上方
            i--
        } else {
            // 来自左方
            j--
        }
    }

    // 反转结果(因为是从后往前构造的)
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }

    return string(result)
}
```

## 复杂度分析

### 二维 DP
- **时间复杂度**: O(m × n),其中 m 和 n 分别是两个字符串的长度
- **空间复杂度**: O(m × n),二维 DP 数组

### 一维 DP
- **时间复杂度**: O(m × n)
- **空间复杂度**: O(n),一维滚动数组

## 与其他问题的关系

### 1. 最长公共子串 (连续)

如果要求子序列必须**连续**,状态转移方程需要修改:

```go
if text1[i-1] == text2[j-1] {
    dp[i][j] = dp[i-1][j-1] + 1
} else {
    dp[i][j] = 0  // 不连续,重新开始
}
```

答案不是 `dp[m][n]`,而是整个 DP 表的最大值。

### 2. 编辑距离

**只允许删除操作的编辑距离**与 LCS 的关系:

```
编辑距离 = m + n - 2 × LCS(text1, text2)
```

**原理:**
- 要把 text1 变成 text2,需要:
  - 删除 text1 中不在 LCS 中的字符: `m - LCS`
  - 删除 text2 中不在 LCS 中的字符(等价于在 text1 中插入): `n - LCS`
- 总共: `m - LCS + n - LCS = m + n - 2 × LCS`

### 3. 不相交的线 (LeetCode 1035)

本质上就是 LCS 问题,只是换了一种描述方式。

## 实际应用

### 1. diff 工具

Unix 的 `diff` 命令使用 LCS 算法找到两个文件的差异:
- 公共子序列是未修改的行
- 不在 LCS 中的行是被删除或添加的

### 2. 版本控制

Git 等版本控制系统使用 LCS 的变种算法进行三方合并(three-way merge)。

### 3. DNA 序列比对

在生物信息学中,LCS 用于比对 DNA 序列,找到相似的基因片段。

### 4. 抄袭检测

通过计算文档的 LCS,可以检测代码或文章的相似度。

## 相关题目

1. **不相交的线**(LeetCode 1035): 本质是 LCS
2. **两个字符串的删除操作**(LeetCode 583): 用 LCS 求解
3. **最长重复子数组**(LeetCode 718): 连续版本的 LCS
4. **最小 ASCII 删除和**(LeetCode 712): 带权重的 LCS

## 面试技巧

1. **区分子序列和子串**: 明确子序列不要求连续,子串要求连续
2. **画表格演示**: 在白板上画出 DP 表格,手动填充几个格子
3. **分情况讨论**: 字符相同和不同两种情况的处理逻辑
4. **举例说明**: 用简单例子(如 "abcde" 和 "ace")完整推导
5. **空间优化**: 如果面试官追问,讨论如何用一维数组优化
6. **构造 LCS**: 如果要求输出具体序列,说明如何回溯
7. **实际应用**: 提到 diff 工具、版本控制等应用场景
8. **边界情况**:
   - 一个或两个字符串为空
   - 两个字符串完全相同
   - 两个字符串完全不同(无公共字符)

## 常见变形

### 最长公共子序列的个数

如果要求有多少个不同的 LCS,需要额外维护一个 count 数组。

### 三个字符串的 LCS

状态扩展为三维: `dp[i][j][k]`,表示三个字符串前缀的 LCS。

### K 个字符串的 LCS

可以用记忆化搜索或多维 DP,但复杂度会很高。
