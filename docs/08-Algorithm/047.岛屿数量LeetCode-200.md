---
title: 岛屿数量（LeetCode 200）
tags:
  - 算法
status: robot
class: 算法
slug: number-of-islands
ref:
---

## 核心要点

**DFS/BFS 图遍历**：遍历网格，遇到陆地就用 DFS/BFS 标记整个岛屿，计数器+1，时间复杂度 O(m·n)

---

## 题目描述

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例：**
```
输入: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出: 1

输入: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出: 3
```

---

## 解题思路

### 思路分析

这是一道经典的**图的连通分量**问题，可以用 DFS 或 BFS 解决：

1. **遍历网格**：扫描整个二维数组
2. **发现岛屿**：遇到 `'1'` 时，说明发现了一个新岛屿
3. **淹没岛屿**：用 DFS/BFS 将整个岛屿的所有 `'1'` 标记为 `'0'`（避免重复计数）
4. **计数累加**：每次发现新岛屿，计数器 +1

### 核心技巧

- **原地修改**：直接将访问过的 `'1'` 改为 `'0'`，省去额外的 visited 数组
- **四方向扩展**：从当前陆地向上下左右四个方向递归/迭代搜索
- **边界检查**：确保索引不越界且是未访问的陆地

---

## 代码实现

### 方法一：DFS（深度优先搜索）

```go
func numIslands(grid [][]byte) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])
    count := 0

    // DFS函数：淹没整个岛屿
    var dfs func(i, j int)
    dfs = func(i, j int) {
        // 边界检查：越界或者是水域
        if i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0' {
            return
        }

        // 标记当前位置为已访问（淹没）
        grid[i][j] = '0'

        // 向四个方向递归搜索
        dfs(i-1, j) // 上
        dfs(i+1, j) // 下
        dfs(i, j-1) // 左
        dfs(i, j+1) // 右
    }

    // 遍历整个网格
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            // 发现陆地，说明遇到新岛屿
            if grid[i][j] == '1' {
                count++
                // 淹没整个岛屿
                dfs(i, j)
            }
        }
    }

    return count
}
```

### 方法二：BFS（广度优先搜索）

```go
func numIslands(grid [][]byte) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])
    count := 0

    // 四个方向的偏移量
    directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}

    // BFS函数：淹没整个岛屿
    bfs := func(startI, startJ int) {
        queue := [][]int{{startI, startJ}}
        grid[startI][startJ] = '0' // 标记起点

        for len(queue) > 0 {
            // 取出队首元素
            curr := queue[0]
            queue = queue[1:]
            i, j := curr[0], curr[1]

            // 向四个方向扩展
            for _, dir := range directions {
                ni, nj := i+dir[0], j+dir[1]

                // 边界检查 + 陆地判断
                if ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == '1' {
                    queue = append(queue, []int{ni, nj})
                    grid[ni][nj] = '0' // 入队时立即标记，避免重复入队
                }
            }
        }
    }

    // 遍历整个网格
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == '1' {
                count++
                bfs(i, j)
            }
        }
    }

    return count
}
```

### 方法三：并查集（Union-Find）

```go
type UnionFind struct {
    parent []int
    count  int
}

func NewUnionFind(grid [][]byte) *UnionFind {
    m, n := len(grid), len(grid[0])
    uf := &UnionFind{
        parent: make([]int, m*n),
        count:  0,
    }

    // 初始化并查集
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == '1' {
                idx := i*n + j
                uf.parent[idx] = idx
                uf.count++
            }
        }
    }
    return uf
}

func (uf *UnionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x]) // 路径压缩
    }
    return uf.parent[x]
}

func (uf *UnionFind) union(x, y int) {
    rootX := uf.find(x)
    rootY := uf.find(y)
    if rootX != rootY {
        uf.parent[rootX] = rootY
        uf.count-- // 合并后岛屿数量减1
    }
}

func numIslands(grid [][]byte) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])
    uf := NewUnionFind(grid)

    // 遍历每个陆地，与右边和下边的陆地合并
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == '1' {
                idx := i*n + j
                // 向右合并
                if j+1 < n && grid[i][j+1] == '1' {
                    uf.union(idx, idx+1)
                }
                // 向下合并
                if i+1 < m && grid[i+1][j] == '1' {
                    uf.union(idx, idx+n)
                }
            }
        }
    }

    return uf.count
}
```

---

## 关键代码说明

### DFS 方法
1. **原地修改**（第18行）：将 `'1'` 改为 `'0'`，标记为已访问
2. **递归终止条件**（第14-16行）：越界或遇到水域时返回
3. **四方向扩展**（第21-24行）：递归搜索上下左右四个相邻位置

### BFS 方法
1. **队列结构**（第12行）：用切片模拟队列，存储待访问的坐标
2. **入队时标记**（第26行）：避免同一位置重复入队，减少空间开销
3. **方向数组**（第10行）：统一处理四个方向，代码更简洁

### 并查集方法
1. **路径压缩**（第12行）：`find` 时将节点直接连到根节点，优化查询效率
2. **计数维护**（第21行）：每次合并操作，岛屿数量减 1
3. **索引映射**（第38行）：二维坐标 `(i, j)` 映射为一维索引 `i*n + j`

---

## 复杂度分析

### DFS/BFS 方法
- **时间复杂度**：O(m·n)
  - 外层双重循环：O(m·n)
  - 每个格子最多被访问一次（访问后标记为 `'0'`）

- **空间复杂度**：
  - DFS：O(m·n)（递归栈深度，最坏情况整个网格都是陆地）
  - BFS：O(min(m, n))（队列最大长度，最坏情况是对角线扩展）

### 并查集方法
- **时间复杂度**：O(m·n·α(m·n))
  - α 是 Ackermann 函数的反函数，实际接近 O(1)

- **空间复杂度**：O(m·n)
  - parent 数组存储所有节点

---

## 测试用例

```go
func main() {
    // 测试用例1: 单个大岛屿
    grid1 := [][]byte{
        {'1', '1', '1', '1', '0'},
        {'1', '1', '0', '1', '0'},
        {'1', '1', '0', '0', '0'},
        {'0', '0', '0', '0', '0'},
    }
    fmt.Println(numIslands(grid1)) // 输出: 1

    // 测试用例2: 三个分离的岛屿
    grid2 := [][]byte{
        {'1', '1', '0', '0', '0'},
        {'1', '1', '0', '0', '0'},
        {'0', '0', '1', '0', '0'},
        {'0', '0', '0', '1', '1'},
    }
    fmt.Println(numIslands(grid2)) // 输出: 3

    // 测试用例3: 全水域
    grid3 := [][]byte{
        {'0', '0', '0'},
        {'0', '0', '0'},
    }
    fmt.Println(numIslands(grid3)) // 输出: 0

    // 测试用例4: 全陆地
    grid4 := [][]byte{
        {'1', '1'},
        {'1', '1'},
    }
    fmt.Println(numIslands(grid4)) // 输出: 1
}
```

---

## 面试要点

1. **为什么可以原地修改？**
   - 题目没有要求保留原数组，原地修改节省空间
   - 如果需要保留原数组，可以用 `visited[m][n]bool` 数组标记

2. **DFS 和 BFS 的选择？**
   - DFS 代码更简洁，但递归栈可能溢出（极端细长岛屿）
   - BFS 空间复杂度更优，更适合处理大规模数据

3. **并查集的优势？**
   - 动态连通性问题的通用解法
   - 支持增量更新（如果岛屿会动态增加）
   - 但本题中 DFS/BFS 更直观高效

4. **如何避免重复访问？**
   - 方法1：原地修改，将 `'1'` 改为 `'0'`
   - 方法2：额外 visited 数组
   - BFS 中必须在入队时标记，而非出队时标记

5. **变体问题如何处理？**
   - 最大岛屿面积：在 DFS/BFS 中累加面积
   - 岛屿周长：遍历时检查每个陆地的四条边
   - 封闭岛屿：先淹没边界连通的陆地，再统计

---

## 相关题目

- LeetCode 695: 岛屿的最大面积（在 DFS 中统计面积）
- LeetCode 463: 岛屿的周长（检查边界数量）
- LeetCode 1254: 统计封闭岛屿的数目（先处理边界）
- LeetCode 827: 最大人工岛（填海造岛，动态规划+并查集）
