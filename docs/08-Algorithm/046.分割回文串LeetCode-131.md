---
title: 分割回文串（LeetCode 131）
tags:
  - 算法
status: robot
class: 算法
slug: palindrome-partitioning
ref:
---

## 核心要点

**回溯算法 + 动态规划预处理**：通过回溯枚举所有分割方案，用DP表快速判断回文串，时间复杂度 O(n·2^n)

---

## 题目描述

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。返回 `s` 所有可能的分割方案。

**示例：**
```
输入: s = "aab"
输出: [["a","a","b"],["aa","b"]]

输入: s = "a"
输出: [["a"]]
```

---

## 解题思路

### 思路分析

这道题是典型的**回溯算法**问题，需要枚举所有可能的分割方案。关键在于：

1. **决策过程**：在每个位置决定"切还是不切"，形成一棵决策树
2. **剪枝条件**：只有当前子串是回文串时才继续递归
3. **优化手段**：用动态规划预处理所有子串是否为回文，避免重复计算

### 算法步骤

**步骤1：动态规划预处理回文判断**
- 使用二维DP表 `dp[i][j]` 表示 s[i...j] 是否为回文串
- 状态转移：`dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]`
- 边界条件：单字符和相邻字符的情况

**步骤2：回溯枚举分割方案**
- 从位置 `start` 开始，尝试所有可能的结束位置 `end`
- 如果 s[start...end] 是回文串，加入当前路径并继续递归
- 到达字符串末尾时，将当前路径加入结果集

**步骤3：回溯撤销选择**
- 递归返回后，移除最后添加的子串，尝试其他分割位置

---

## 代码实现

### Go 语言实现

```go
func partition(s string) [][]string {
    n := len(s)
    result := [][]string{}
    path := []string{}

    // 步骤1: 动态规划预处理，判断所有子串是否为回文
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
        // 单个字符必然是回文
        dp[i][i] = true
    }

    // 从后往前填充DP表（因为dp[i][j]依赖dp[i+1][j-1]）
    for i := n - 1; i >= 0; i-- {
        for j := i + 1; j < n; j++ {
            if s[i] == s[j] {
                // 相邻字符或中间部分是回文
                if j - i == 1 || dp[i+1][j-1] {
                    dp[i][j] = true
                }
            }
        }
    }

    // 步骤2: 回溯搜索所有分割方案
    var backtrack func(start int)
    backtrack = func(start int) {
        // 递归终止条件：已处理完整个字符串
        if start == n {
            // 深拷贝当前路径
            temp := make([]string, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }

        // 枚举所有可能的结束位置
        for end := start; end < n; end++ {
            // 剪枝：只有当前子串是回文时才继续
            if dp[start][end] {
                // 做选择
                path = append(path, s[start:end+1])
                // 递归处理剩余部分
                backtrack(end + 1)
                // 撤销选择（回溯）
                path = path[:len(path)-1]
            }
        }
    }

    backtrack(0)
    return result
}
```

### 关键代码说明

1. **DP表构建**（第7-21行）：
   - `dp[i][j]` 表示 s[i...j] 是否为回文
   - 从后往前填充，保证计算 `dp[i][j]` 时 `dp[i+1][j-1]` 已经计算好

2. **回溯函数**（第24-44行）：
   - `start` 表示当前处理的起始位置
   - 终止条件：`start == n` 表示已分割完整个字符串
   - 深拷贝路径避免引用问题

3. **剪枝优化**（第38行）：
   - 只有 `dp[start][end]` 为真时才递归，大幅减少无效搜索

---

## 复杂度分析

- **时间复杂度**：O(n·2^n)
  - DP预处理：O(n²)
  - 回溯部分：最坏情况下有 2^(n-1) 种分割方案（每个间隙都可以选择切或不切）
  - 每个方案需要 O(n) 时间拷贝路径

- **空间复杂度**：O(n²)
  - DP表：O(n²)
  - 递归栈深度：O(n)
  - 路径存储：O(n)

---

## 测试用例

```go
func main() {
    // 测试用例1: 有多种分割方案
    s1 := "aab"
    fmt.Println(partition(s1))
    // 输出: [[a a b] [aa b]]

    // 测试用例2: 单字符
    s2 := "a"
    fmt.Println(partition(s2))
    // 输出: [[a]]

    // 测试用例3: 全回文
    s3 := "aba"
    fmt.Println(partition(s3))
    // 输出: [[a b a] [aba]]

    // 测试用例4: 无法组成多字符回文
    s4 := "abc"
    fmt.Println(partition(s4))
    // 输出: [[a b c]]
}
```

---

## 面试要点

1. **为什么用动态规划预处理？**
   - 如果每次判断回文都用双指针，时间复杂度会变成 O(n²·2^n)
   - 预处理后查询回文只需 O(1)，整体复杂度降为 O(n·2^n)

2. **能否不用DP表？**
   - 可以，但会超时。对于长字符串，重复判断回文的开销极大

3. **如何避免结果集中的引用问题？**
   - 必须深拷贝 `path`，否则所有结果会指向同一个切片

4. **回溯的本质是什么？**
   - 暴力枚举所有可能性 + 剪枝优化，通过"做选择-递归-撤销选择"三步实现

5. **如何优化空间？**
   - DP表可以优化为滚动数组，但实际意义不大（因为结果集本身就需要 O(n·2^n) 空间）

---

## 相关题目

- LeetCode 132: 分割回文串II（最小分割次数，DP优化）
- LeetCode 5: 最长回文子串
- LeetCode 647: 回文子串（统计个数）
