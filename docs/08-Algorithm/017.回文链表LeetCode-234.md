---
title: 回文链表(LeetCode 234)
tags:
  - 算法
status: robot
class: 算法
slug: palindrome-linked-list
ref:
---

## 核心要点

**快慢指针找中点+反转后半部分+双指针对比**：用快慢指针找到链表中点,反转后半部分链表,然后从两端向中间对比节点值。这是 O(n) 时间、O(1) 空间的最优解法。

---

## 题目描述

给你一个单链表的头节点 `head`,请你判断该链表是否为回文链表。如果是,返回 `true`;否则,返回 `false`。

**示例 1:**
```
输入: head = [1,2,2,1]
输出: true
```

**示例 2:**
```
输入: head = [1,2]
输出: false
```

**要求:**
- 时间复杂度 O(n)
- 空间复杂度 O(1)(进阶要求)

---

## 解题思路

### 方法一:快慢指针+反转链表(推荐)

**核心思想:**

回文链表的特点是从前往后和从后往前读是一样的。由于单链表无法从后往前遍历,我们可以:

1. **找到中点:** 用快慢指针找到链表的中间位置
2. **反转后半部分:** 反转后半部分链表
3. **双指针对比:** 从两端同时向中间移动,比较节点值
4. **恢复链表(可选):** 将链表恢复原状

**图解过程:**

```
原链表: 1 → 2 → 3 → 2 → 1

步骤 1: 快慢指针找中点
slow 指向 3, fast 指向 null
1 → 2 → 3 → 2 → 1
         ↑slow

步骤 2: 反转后半部分(从 slow 开始)
前半部分: 1 → 2 → 3
后半部分: 1 → 2 (反转后)

步骤 3: 双指针对比
p1: 1 → 2 → 3
p2: 1 → 2
↑   ↑   ↑
相等 相等 结束
```

**算法步骤:**

1. 使用快慢指针找到链表中点(slow 最终指向中点或中点的下一个节点)
2. 反转 slow 之后的链表
3. 比较前半部分和反转后的后半部分
4. (可选)恢复链表并返回结果

**代码实现(Go):**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func isPalindrome(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return true
    }

    // 步骤 1: 用快慢指针找到中点
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    // 步骤 2: 反转后半部分链表
    secondHalf := reverseList(slow)

    // 步骤 3: 比较前半部分和后半部分
    p1, p2 := head, secondHalf
    result := true
    for result && p2 != nil {
        if p1.Val != p2.Val {
            result = false
        }
        p1 = p1.Next
        p2 = p2.Next
    }

    // 步骤 4: 恢复链表(可选,保持原链表不变)
    // reverseList(secondHalf)

    return result
}

// 反转链表的辅助函数
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**时间复杂度:** O(n),需要遍历链表找中点、反转后半部分、比较
**空间复杂度:** O(1),只使用几个指针变量

---

### 方法二:数组+双指针

**思路:**

1. 遍历链表,将所有节点值存入数组
2. 使用双指针从数组两端向中间移动比较

**代码实现(Go):**

```go
func isPalindrome(head *ListNode) bool {
    vals := []int{}

    // 将链表值存入数组
    for node := head; node != nil; node = node.Next {
        vals = append(vals, node.Val)
    }

    // 双指针比较
    left, right := 0, len(vals)-1
    for left < right {
        if vals[left] != vals[right] {
            return false
        }
        left++
        right--
    }

    return true
}
```

**时间复杂度:** O(n)
**空间复杂度:** O(n),需要额外数组存储所有节点值

---

### 方法三:递归法

**思路:**

利用递归的特性,递归到链表末尾后,在回溯过程中与前面的节点比较。

**代码实现(Go):**

```go
func isPalindrome(head *ListNode) bool {
    frontPointer := head

    var recursiveCheck func(*ListNode) bool
    recursiveCheck = func(currentNode *ListNode) bool {
        if currentNode != nil {
            // 递归到链表末尾
            if !recursiveCheck(currentNode.Next) {
                return false
            }
            // 回溯时比较
            if currentNode.Val != frontPointer.Val {
                return false
            }
            // 前指针向后移动
            frontPointer = frontPointer.Next
        }
        return true
    }

    return recursiveCheck(head)
}
```

**时间复杂度:** O(n)
**空间复杂度:** O(n),递归调用栈深度为 n

---

## 关键细节

### 1. 快慢指针找中点的边界情况

```go
// 奇数个节点: 1 → 2 → 3 → 2 → 1
// slow 最终指向 3(中间节点)

// 偶数个节点: 1 → 2 → 2 → 1
// slow 最终指向第二个 2(中间偏右)
```

循环条件 `fast != nil && fast.Next != nil` 确保:
- 奇数节点时,slow 指向正中间
- 偶数节点时,slow 指向中间偏右的节点

### 2. 为什么比较时 p2 到达 null 就可以停止?

因为后半部分可能比前半部分少一个节点(奇数长度时),比较完后半部分即可判断。

```
奇数: 1 → 2 → 3 → 2 → 1
前半: 1 → 2 → 3
后半: 1 → 2 (反转后)
只需比较 2 个节点
```

### 3. 是否需要恢复链表?

- **需要恢复:** 如果题目要求不修改原链表结构
- **不需要恢复:** 如果只是判断回文,不关心链表是否被修改

恢复方法:再次反转后半部分即可。

---

## 易错点与注意事项

1. **边界条件:** 空链表或单节点链表都是回文,需要特判
2. **快指针条件:** 必须同时检查 `fast != nil` 和 `fast.Next != nil`
3. **反转链表:** 确保反转函数正确实现,不要漏掉 `prev` 初始化为 `nil`
4. **比较终止条件:** 使用 `p2 != nil` 而不是 `p1 != nil`,因为后半部分可能更短

---

## 面试技巧

**面试官可能的追问:**

1. **能否用 O(1) 空间复杂度解决?**
   - 答:可以,使用快慢指针找中点+反转后半部分+双指针对比的方法。

2. **如何处理奇数和偶数长度的链表?**
   - 答:快慢指针的移动方式天然处理了这两种情况。奇数时 slow 指向中点,偶数时指向中间偏右,反转后都能正确比较。

3. **是否需要恢复原链表?**
   - 答:取决于题目要求。如果需要,可以在比较完后再次反转后半部分。代码中可以添加恢复步骤。

4. **如果链表很长,有更优化的方法吗?**
   - 答:时间复杂度已经是 O(n) 最优。如果链表极长且不是回文,可以在比较时提前返回 false,减少不必要的比较。

5. **如果允许修改节点值,有更简单的方法吗?**
   - 答:可以用栈存储前半部分,然后与后半部分比较,但空间复杂度为 O(n/2)。

---

## 方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 快慢指针+反转 | O(n) | O(1) | 空间最优,符合进阶要求 | 代码稍复杂,修改了链表结构 |
| 数组+双指针 | O(n) | O(n) | 代码简单,易理解 | 需要额外空间 |
| 递归 | O(n) | O(n) | 代码优雅 | 递归栈空间消耗,不符合进阶要求 |

---

## 总结

回文链表的最优解法是**快慢指针+反转链表+双指针对比**,这是面试中的最佳答案。关键步骤:

1. **找中点:** 快慢指针,快指针走两步,慢指针走一步
2. **反转:** 反转后半部分链表
3. **比较:** 从两端同时向中间比较节点值
4. **恢复(可选):** 再次反转后半部分恢复原链表

这种方法体现了对链表操作的深刻理解,包括快慢指针技巧、链表反转、以及空间复杂度优化。在面试中能完整实现这个方法,会给面试官留下深刻印象。
