---
title: 组合总和（LeetCode 39）
tags:
  - 算法
status: robot
class: 算法
slug: combination-sum
ref:
---

## 核心要点

**回溯算法处理"可重复选择"的组合问题，关键在于递归时从当前位置开始（允许重复使用）而非 i+1（不允许重复）。通过剪枝优化（排序+提前终止）提升效率。时间复杂度 O(n^target)，空间复杂度 O(target)。**

---

## 题目描述

给你一个**无重复元素**的整数数组 `candidates` 和一个目标整数 `target`，找出 `candidates` 中可以使数字和为目标数 `target` 的所有**不同组合**，并以列表形式返回。

**你可以按任意顺序返回这些组合。**

**关键特性：**
- `candidates` 中的**同一个数字可以无限制重复被选取**
- 所有数字（包括 `target`）都是**正整数**

**示例：**
```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]

解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

---

## 解题思路

### 1. 问题分析

这是一个**组合问题**（不是排列），与标准子集问题的关键区别：
- **可以重复选择同一元素**（如 [2,2,3]）
- **需要满足和等于 target**（有约束条件）
- **不能有重复组合**（[2,3] 和 [3,2] 视为同一组合）

### 2. 回溯框架设计

```
def backtrack(start, path, sum):
    if sum == target:
        result.add(path)  # 找到一个解
        return

    if sum > target:
        return  # 剪枝：超过目标值，提前终止

    for i in range(start, len(candidates)):
        path.add(candidates[i])
        # 关键：从 i 开始而不是 i+1，允许重复选择
        backtrack(i, path, sum + candidates[i])
        path.remove(candidates[i])
```

### 3. 决策树（以 candidates=[2,3,6,7], target=7 为例）

```
                           []
                    /      |      \       \
                  [2]     [3]    [6]     [7]
                 / | \     / \     |       |
           [2,2][2,3][2,6][3,3][3,6]   sum=7✓
            / |    |
      [2,2,2][2,2,3][2,2,6]
         |     |
      [2,2,2,2]sum=7✓
      (sum>7)
```

**关键观察：**
- 每层从当前索引 `i` 开始（允许重复选择当前元素）
- 通过 `start` 参数保证组合不重复（避免 [2,3] 和 [3,2] 同时出现）
- `sum > target` 时提前剪枝

---

## 代码实现

### 基础版本（无优化）

```go
func combinationSum(candidates []int, target int) [][]int {
    result := [][]int{}
    path := []int{}

    var backtrack func(start, sum int)
    backtrack = func(start, sum int) {
        // 找到一组解
        if sum == target {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }

        // 剪枝：当前和已超过目标值
        if sum > target {
            return
        }

        // 从 start 开始遍历（允许重复选择）
        for i := start; i < len(candidates); i++ {
            // 做选择
            path = append(path, candidates[i])

            // 递归：注意传入 i 而非 i+1（允许重复选择当前元素）
            backtrack(i, sum+candidates[i])

            // 撤销选择
            path = path[:len(path)-1]
        }
    }

    backtrack(0, 0)
    return result
}
```

### 优化版本（排序 + 剪枝）

通过先排序，可以提前终止不必要的搜索：

```go
func combinationSum(candidates []int, target int) [][]int {
    // 先排序，便于剪枝
    sort.Ints(candidates)

    result := [][]int{}
    path := []int{}

    var backtrack func(start, sum int)
    backtrack = func(start, sum int) {
        if sum == target {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }

        for i := start; i < len(candidates); i++ {
            // 优化：由于数组已排序，后面的元素更大，直接跳出
            if sum+candidates[i] > target {
                break  // 使用 break 而非 continue
            }

            path = append(path, candidates[i])
            backtrack(i, sum+candidates[i])
            path = path[:len(path)-1]
        }
    }

    backtrack(0, 0)
    return result
}
```

**优化要点：**
1. **排序**：使数组有序，便于剪枝
2. **break vs continue**：由于数组已排序，当 `sum + candidates[i] > target` 时，后续元素都不满足，直接 `break` 跳出循环

---

## 详细执行过程（以 [2,3,6,7], target=7 为例）

```
初始: path=[], sum=0

第1层: start=0
  选择2 → path=[2], sum=2
    第2层: start=0
      选择2 → path=[2,2], sum=4
        第3层: start=0
          选择2 → path=[2,2,2], sum=6
            第4层: start=0
              选择2 → sum=8 > 7，剪枝返回
              选择3 → sum=9 > 7，剪枝返回
          回溯 path=[2,2]

          选择3 → path=[2,2,3], sum=7 ✓ 加入结果 [[2,2,3]]
          回溯 path=[2,2]

          选择6 → sum=10 > 7，剪枝返回
          选择7 → sum=11 > 7，剪枝返回
      回溯 path=[2]

      选择3 → path=[2,3], sum=5
        第3层: start=1
          选择3 → sum=8 > 7，剪枝返回
          选择6 → sum=11 > 7，剪枝返回
          选择7 → sum=12 > 7，剪枝返回
      回溯 path=[2]

      选择6 → sum=8 > 7，剪枝返回
      选择7 → sum=9 > 7，剪枝返回
  回溯 path=[]

  选择3 → path=[3], sum=3
    ... (类似过程，无解)
  回溯 path=[]

  选择6 → path=[6], sum=6
    ... (无解)
  回溯 path=[]

  选择7 → path=[7], sum=7 ✓ 加入结果 [[2,2,3],[7]]
  回溯 path=[]

最终结果: [[2,2,3],[7]]
```

---

## 复杂度分析

### 时间复杂度：O(n^(target/min))

- n 是 `candidates` 的长度
- `target/min` 是最多能选择的元素个数（min 是数组最小值）
- 最坏情况下，每个位置有 n 种选择，搜索深度为 target/min
- 实际复杂度受剪枝影响，通常远小于理论上界

### 空间复杂度：O(target/min)

- 递归调用栈的深度最大为 `target/min`
- path 数组的最大长度也是 `target/min`
- 不计算结果存储空间

---

## 关键要点总结

1. **可重复选择的实现**：递归时传入 `i`（而非 `i+1`），允许继续选择当前元素

2. **去重策略**：通过 `start` 参数保证只向后选择，避免产生重复组合（如 [2,3] 和 [3,2]）

3. **剪枝优化**：
   - **排序后剪枝**：当 `sum + candidates[i] > target` 时，后续元素必然超标，直接 `break`
   - **提前终止**：在递归入口处判断 `sum > target`

4. **深拷贝**：将 path 加入结果时必须复制，因为 path 会被后续修改

5. **与子集问题的区别**：
   - 子集：每个元素最多选一次，递归传 `i+1`
   - 组合总和：元素可重复选，递归传 `i`

---

## 面试回答要点

**面试官：如何实现组合总和问题？**

**回答框架：**

"组合总和是回溯算法的典型应用，与标准子集问题的核心区别在于元素可以重复选择。我会这样实现：

1. **回溯框架**：
   - 终止条件：`sum == target` 时找到一组解
   - 剪枝条件：`sum > target` 时提前返回

2. **可重复选择的关键**：递归时传入当前索引 `i`（而非 `i+1`），允许继续选择当前元素

3. **去重策略**：使用 `start` 参数保证只向后选择，避免 [2,3] 和 [3,2] 重复

4. **优化手段**：
   - 先排序数组
   - 当 `sum + candidates[i] > target` 时直接 `break`（而非 `continue`）

时间复杂度约 O(n^(target/min))，空间复杂度 O(target/min)，其中 min 是数组最小值。

如果面试官追问其他变种，我可以讨论：
- 组合总和 II（元素不能重复使用）
- 组合总和 III（固定元素个数）
- 组合总和 IV（顺序不同视为不同组合，用 DP 解决）"

---

## 扩展问题

### 1. 组合总和 II（LeetCode 40）

**变化：** 数组包含重复元素，每个元素只能使用一次

```go
func combinationSum2(candidates []int, target int) [][]int {
    sort.Ints(candidates) // 必须排序
    result := [][]int{}
    path := []int{}

    var backtrack func(start, sum int)
    backtrack = func(start, sum int) {
        if sum == target {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }

        for i := start; i < len(candidates); i++ {
            // 跳过同层重复元素（关键去重逻辑）
            if i > start && candidates[i] == candidates[i-1] {
                continue
            }

            if sum+candidates[i] > target {
                break
            }

            path = append(path, candidates[i])
            backtrack(i+1, sum+candidates[i]) // 注意：传 i+1（不允许重复）
            path = path[:len(path)-1]
        }
    }

    backtrack(0, 0)
    return result
}
```

**关键区别：**
- 递归传入 `i+1`（元素只能用一次）
- 跳过同层重复元素：`if i > start && candidates[i] == candidates[i-1]`

### 2. 组合总和 III（LeetCode 216）

**变化：** 只使用数字 1-9，每个数字最多用一次，找出所有 k 个数字之和为 n 的组合

```go
func combinationSum3(k int, n int) [][]int {
    result := [][]int{}
    path := []int{}

    var backtrack func(start, sum int)
    backtrack = func(start, sum int) {
        // 剪枝：长度已达到 k
        if len(path) == k {
            if sum == n {
                temp := make([]int, len(path))
                copy(temp, path)
                result = append(result, temp)
            }
            return
        }

        for i := start; i <= 9; i++ {
            if sum+i > n {
                break
            }

            path = append(path, i)
            backtrack(i+1, sum+i) // 传 i+1，数字不重复
            path = path[:len(path)-1]
        }
    }

    backtrack(1, 0)
    return result
}
```

### 3. 组合总和 IV（LeetCode 377）

**变化：** 顺序不同的序列视为不同的组合（这是排列问题，不是组合问题）

**解法：** 使用动态规划，不适合回溯

```go
func combinationSum4(nums []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1

    for i := 1; i <= target; i++ {
        for _, num := range nums {
            if i >= num {
                dp[i] += dp[i-num]
            }
        }
    }

    return dp[target]
}
```

---

## 问题对比总结

| 问题 | 元素可重复使用？ | 数组有重复元素？ | 递归参数 | 去重方法 |
|------|----------------|----------------|---------|---------|
| **组合总和（39）** | ✅ 是 | ❌ 否 | `backtrack(i, ...)` | 使用 start 参数 |
| **组合总和 II（40）** | ❌ 否 | ✅ 是 | `backtrack(i+1, ...)` | 排序 + 跳过同层重复 |
| **组合总和 III（216）** | ❌ 否 | ❌ 否（1-9） | `backtrack(i+1, ...)` | 使用 start 参数 |
| **组合总和 IV（377）** | ✅ 是 | ❌ 否 | 不适用（DP） | 不适用 |

---

## 常见错误与注意事项

### 错误 1：忘记排序导致剪枝失效

```go
// ❌ 错误：未排序，break 剪枝无效
func combinationSum(candidates []int, target int) [][]int {
    for i := start; i < len(candidates); i++ {
        if sum+candidates[i] > target {
            break  // 未排序时，后面可能还有小的元素
        }
    }
}

// ✅ 正确：先排序
sort.Ints(candidates)
```

### 错误 2：递归参数传错（i+1 vs i）

```go
// ❌ 错误：传 i+1，导致元素不能重复使用
backtrack(i+1, sum+candidates[i])

// ✅ 正确：传 i，允许重复使用当前元素
backtrack(i, sum+candidates[i])
```

### 错误 3：使用 continue 而非 break

```go
// ⚠️ 低效：后续元素仍然会尝试
if sum+candidates[i] > target {
    continue  // 仍会继续循环
}

// ✅ 高效：直接跳出循环
if sum+candidates[i] > target {
    break  // 后面的元素更大，直接终止
}
```

### 错误 4：忘记深拷贝

```go
// ❌ 错误：直接添加 path 的引用
result = append(result, path)

// ✅ 正确：深拷贝
temp := make([]int, len(path))
copy(temp, path)
result = append(result, temp)
```

---

## 总结

组合总和问题是回溯算法的经典应用，掌握它可以解决一大类组合优化问题。核心要点：

1. **可重复选择**：递归时传入当前索引 `i`
2. **排序优化**：先排序，配合 `break` 剪枝
3. **去重策略**：使用 `start` 参数（组合问题）或跳过同层重复（数组有重复元素）
4. **状态恢复**：回溯时必须恢复 path 状态

面试时建议先写出基础版本，再讨论优化方案，展示你对问题的深入理解。
