---
title: 正则表达式匹配（LeetCode 10）
tags:
  - 算法
status: robot
class: 算法
slug: regular-expression-matching
ref:
---

## 核心要点

**一句话总结**：动态规划，`dp[i][j]` 表示 `s[0:i]` 和 `p[0:j]` 是否匹配，关键是处理 `*` 的匹配0次和多次情况。

**关键技巧**：`.` 匹配任意单字符，`*` 匹配前一个字符0次或多次，需要分情况讨论状态转移。

---

## 问题分析

实现支持 `.` 和 `*` 的正则表达式匹配。

**规则**：
- `.` 匹配任意单个字符
- `*` 匹配零个或多个前面的元素

**示例**：
```
输入：s = "aa", p = "a"
输出：false（"a" 不能匹配整个 "aa"）

输入：s = "aa", p = "a*"
输出：true（"*" 表示 "a" 可以重复任意次）

输入：s = "ab", p = ".*"
输出：true（".*" 表示任意字符可以重复任意次）
```

---

## 解法思路

### 核心思路：动态规划

**状态定义**：
- `dp[i][j]` 表示 `s[0:i]` 和 `p[0:j]` 是否匹配
- `i` 表示 s 的前 i 个字符，`j` 表示 p 的前 j 个字符

**状态转移**：

1. **基础情况**：
   - `dp[0][0] = true`（空字符串匹配空模式）
   - `dp[i][0] = false` (i > 0)（非空字符串不匹配空模式）
   - `dp[0][j]` 需要特殊处理（空字符串匹配模式，如 "a*b*c*"）

2. **普通字符或 `.`**：
   ```
   if p[j-1] == s[i-1] or p[j-1] == '.':
       dp[i][j] = dp[i-1][j-1]
   ```

3. **`*` 的情况**：
   ```
   if p[j-1] == '*':
       // * 匹配0次：忽略 p[j-2] 和 *
       dp[i][j] = dp[i][j-2]

       // * 匹配多次：如果 p[j-2] 能匹配 s[i-1]
       if p[j-2] == s[i-1] or p[j-2] == '.':
           dp[i][j] = dp[i][j] or dp[i-1][j]
   ```

---

## 代码实现

```go
func isMatch(s string, p string) bool {
    m, n := len(s), len(p)
    dp := make([][]bool, m+1)
    for i := range dp {
        dp[i] = make([]bool, n+1)
    }

    // 基础情况
    dp[0][0] = true

    // 处理 "a*b*c*" 这种可以匹配空字符串的模式
    for j := 2; j <= n; j++ {
        if p[j-1] == '*' {
            dp[0][j] = dp[0][j-2]
        }
    }

    // 状态转移
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if p[j-1] == '*' {
                // * 匹配0次
                dp[i][j] = dp[i][j-2]

                // * 匹配多次（前提是 p[j-2] 能匹配 s[i-1]）
                if p[j-2] == s[i-1] || p[j-2] == '.' {
                    dp[i][j] = dp[i][j] || dp[i-1][j]
                }
            } else if p[j-1] == '.' || p[j-1] == s[i-1] {
                // 普通字符匹配或 . 匹配
                dp[i][j] = dp[i-1][j-1]
            }
        }
    }

    return dp[m][n]
}
```

**执行过程示例**（s = "aa", p = "a*"）：

```
dp 数组（行是 s，列是 p）：
     ""  a   *
""   T   F   T
a    F   T   T
a    F   F   T

最终 dp[2][2] = true
```

---

## 复杂度分析

**时间复杂度**：O(m × n)
- m 是 s 的长度，n 是 p 的长度

**空间复杂度**：O(m × n)
- DP 数组

**优化**：可以用滚动数组优化到 O(n) 空间。

---

## 注意事项与易错点

### 1. **`*` 的含义**

`*` 匹配**前面的元素**0次或多次，不是独立的字符。

```
"a*" 可以匹配：""（0个a）, "a", "aa", "aaa", ...
".*" 可以匹配：任意字符串
```

### 2. **初始化**

```go
// dp[0][0] = true（空匹配空）
dp[0][0] = true

// 处理 "a*b*" 这种可以匹配空串的情况
for j := 2; j <= n; j++ {
    if p[j-1] == '*' {
        dp[0][j] = dp[0][j-2]
    }
}
```

### 3. **状态转移的顺序**

必须从前往后遍历，因为 `dp[i][j]` 依赖 `dp[i-1][j-1]` 和 `dp[i-1][j]`。

### 4. **索引问题**

`dp[i][j]` 对应 `s[i-1]` 和 `p[j-1]`（字符串索引从0开始，dp数组索引从1开始）。

### 5. **`*` 匹配0次 vs 多次**

```go
// 错误：只考虑匹配0次
if p[j-1] == '*' {
    dp[i][j] = dp[i][j-2]
}

// 正确：同时考虑匹配0次和多次
if p[j-1] == '*' {
    dp[i][j] = dp[i][j-2]  // 匹配0次
    if p[j-2] == s[i-1] || p[j-2] == '.' {
        dp[i][j] = dp[i][j] || dp[i-1][j]  // 匹配多次
    }
}
```

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：`.` 和 `*` 的含义
2. 思路：动态规划
3. 状态定义：`dp[i][j]` 表示 `s[0:i]` 和 `p[0:j]` 是否匹配
4. 关键点：`*` 的两种情况（匹配0次和多次）
5. 初始化：处理空字符串和 "a*b*" 等模式
6. 复杂度：O(m×n) 时间和空间

**可能的追问**：

- **Q: 如何理解 `*` 匹配多次的状态转移？**
  - A: `dp[i-1][j]` 表示 `s[0:i-1]` 已经匹配 `p[0:j]`，现在 `s[i-1]` 也能被 `p[j-2]*` 匹配（因为 `*` 可以重复），所以 `dp[i][j] = true`。

- **Q: 为什么 `*` 匹配0次是 `dp[i][j-2]`？**
  - A: 匹配0次意味着忽略 `p[j-2]` 和 `p[j-1]`（`*`），所以看 `s[0:i]` 和 `p[0:j-2]` 是否匹配。

- **Q: 能否用递归实现？**
  - A: 可以，但会有大量重复计算，需要记忆化搜索。DP 是自底向上的解法，更高效。

- **Q: 通配符匹配（LeetCode 44）与本题的区别？**
  - A: 通配符匹配的 `*` 可以匹配任意字符序列，而本题的 `*` 只匹配前一个字符。状态转移不同。

**类似问题**：
- 通配符匹配（LeetCode 44）：`*` 匹配任意序列，`?` 匹配单个字符
- 编辑距离（LeetCode 72）：也是字符串匹配的DP问题

---

## 扩展：递归 + 记忆化

```go
func isMatch(s string, p string) bool {
    memo := make(map[string]bool)
    return helper(s, p, 0, 0, memo)
}

func helper(s, p string, i, j int, memo map[string]bool) bool {
    key := fmt.Sprintf("%d,%d", i, j)
    if val, ok := memo[key]; ok {
        return val
    }

    // 模式匹配完
    if j == len(p) {
        return i == len(s)
    }

    // 当前字符是否匹配
    firstMatch := i < len(s) && (p[j] == s[i] || p[j] == '.')

    var result bool
    // 下一个字符是 *
    if j+1 < len(p) && p[j+1] == '*' {
        // 匹配0次 or 匹配多次
        result = helper(s, p, i, j+2, memo) ||
                 (firstMatch && helper(s, p, i+1, j, memo))
    } else {
        // 普通字符匹配
        result = firstMatch && helper(s, p, i+1, j+1, memo)
    }

    memo[key] = result
    return result
}
```

**对比**：
- 递归：自顶向下，更直观
- DP：自底向上，避免递归栈开销

面试中两种方法都可以，DP 更常用。
