---
title: 反转链表(LeetCode 206)
tags:
  - 算法
status: robot
class: 算法
slug: reverse-linked-list
ref:
---

## 核心要点

**迭代法**:使用三指针(prev、curr、next)逐个反转节点指向,时间O(n)、空间O(1)
**递归法**:递归到尾节点后回溯反转,理解难度较高但代码简洁,空间O(n)栈开销
**关键**:防止链表断裂,需要临时保存next指针;返回新头节点

---

## 详细解答

### 题目理解

反转链表是一道经典的链表操作题,要求将单向链表的指针方向全部反转。例如:

```
原链表: 1 -> 2 -> 3 -> 4 -> 5 -> NULL
反转后: 5 -> 4 -> 3 -> 2 -> 1 -> NULL
```

核心挑战在于单链表节点只有一个next指针,反转时需要小心处理指针关系,避免链表断裂导致后续节点丢失。

### 解法一:迭代法(推荐)

#### 思路分析

使用三个指针遍历链表并逐个反转节点的指向关系:

1. **prev**:指向当前节点的前驱节点(初始为nil)
2. **curr**:指向当前处理的节点(初始为head)
3. **next**:临时保存下一个节点,防止链表断裂

每次迭代执行三步:
1. 保存next节点 → `next = curr.Next`
2. 反转当前节点指向 → `curr.Next = prev`
3. 指针后移 → `prev = curr`, `curr = next`

遍历结束后,prev指向新的头节点。

#### 代码实现

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil  // 前驱节点,初始为nil
    curr := head              // 当前节点

    for curr != nil {
        next := curr.Next     // 1. 保存下一个节点
        curr.Next = prev      // 2. 反转当前节点的指针
        prev = curr           // 3. prev和curr指针后移
        curr = next
    }

    return prev  // 返回新的头节点
}
```

#### 复杂度分析

- **时间复杂度**: O(n) - 遍历链表一次,n为节点数
- **空间复杂度**: O(1) - 仅使用常量级额外空间

#### 图解过程

```
初始状态:  prev=nil, curr=1
           nil   1 -> 2 -> 3 -> NULL

第1次迭代后:
           nil <- 1   2 -> 3 -> NULL
                prev  curr

第2次迭代后:
           nil <- 1 <- 2   3 -> NULL
                      prev curr

第3次迭代后:
           nil <- 1 <- 2 <- 3   NULL
                           prev curr
```

### 解法二:递归法

#### 思路分析

递归的核心思想是"先递归反转后面的链表,再将当前节点接到末尾"。

1. **递归终止条件**:当前节点为空或只有一个节点,直接返回
2. **递归逻辑**:
   - 递归调用`reverseList(head.Next)`,得到反转后的新头节点
   - 关键操作: `head.Next.Next = head` 将当前节点接到原下一个节点的后面
   - 断开原指向: `head.Next = nil`

#### 代码实现

```go
func reverseList(head *ListNode) *ListNode {
    // 递归终止条件
    if head == nil || head.Next == nil {
        return head
    }

    // 递归反转后面的链表,newHead是反转后的头节点
    newHead := reverseList(head.Next)

    // 关键:将当前节点接到原下一个节点的后面
    // 例如:1->2->3,递归到2时,head=2,head.Next=3
    // 执行head.Next.Next=head后变成:3->2
    head.Next.Next = head

    // 断开原来的指向,防止环
    head.Next = nil

    return newHead  // 始终返回新头节点(原链表尾节点)
}
```

#### 递归过程图解

```
原链表: 1 -> 2 -> 3 -> NULL

递归过程:
reverseList(1)
  └─ reverseList(2)
      └─ reverseList(3)
          └─ reverseList(nil) // 返回3

回溯过程:
3 <- 2    1 (head.Next.Next = head)
     ↓    ↓
    nil  nil (head.Next = nil)
```

#### 复杂度分析

- **时间复杂度**: O(n) - 递归n层,每层O(1)操作
- **空间复杂度**: O(n) - 递归栈深度为n

### 面试要点

1. **优先选择迭代法**:代码直观、空间效率高,容错性强
2. **递归法难点**:`head.Next.Next = head`这行代码的理解是关键,建议通过画图推导
3. **边界处理**:空链表和单节点链表都应正确处理
4. **变体题目**:
   - 反转链表前N个节点
   - 反转链表区间[m,n]
   - K个一组反转链表(LeetCode 25)
5. **扩展讨论**:如果是双向链表如何反转?原地反转还是创建新链表?

### 常见错误

1. ❌ 忘记保存next指针,导致链表断裂
   ```go
   curr.Next = prev  // 这样会丢失后续节点
   curr = curr.Next  // curr.Next已经被改了!
   ```

2. ❌ 递归法忘记断开`head.Next`,导致环形链表
   ```go
   head.Next.Next = head
   // 必须加上下面这行
   head.Next = nil
   ```

3. ❌ 返回错误的头节点
   ```go
   return head  // 错误!应该返回prev或newHead
   ```

### 实战建议

- **白板编码**:先画图推导3-4个节点的反转过程,再写代码
- **语言选择**:Go的指针语法清晰,适合这类题目
- **测试用例**:空链表、单节点、两节点、多节点
- **时间把控**:迭代法5分钟内完成,递归法需要额外2-3分钟解释逻辑
