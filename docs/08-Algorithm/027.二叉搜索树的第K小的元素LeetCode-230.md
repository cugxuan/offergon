---
title: 二叉搜索树的第K小的元素（LeetCode 230）
tags:
  - 算法
status: robot
class: 算法
slug: kth-smallest-element-in-bst
ref:
---

## 核心要点

**利用二叉搜索树(BST)的中序遍历结果是升序序列的性质,找第 K 小元素即中序遍历第 K 个节点**

BST 性质:左子树 < 根 < 右子树。中序遍历(左→根→右)可以得到递增序列,第 K 小元素就是遍历到的第 K 个节点。时间 O(H+K),H 为树高。

---

## 详细解答

### 一、题目理解

给定一个**二叉搜索树(BST)** 的根节点和整数 k,返回树中**第 k 小**的元素(从 1 开始计数)。

**二叉搜索树(BST)定义**:
- 左子树所有节点值 < 根节点值
- 右子树所有节点值 > 根节点值
- 左右子树也都是 BST

**示例**:
```
    5
   / \
  3   6
 / \
2   4
/
1
```
k=3,返回 3(第3小的元素)

---

### 二、思路分析

#### 核心观察:BST 的中序遍历是升序序列

**中序遍历顺序**:左子树 → 根节点 → 右子树

对于上面的 BST,中序遍历结果为:`1, 2, 3, 4, 5, 6`(严格递增)

因此,**第 K 小的元素 = 中序遍历的第 K 个元素**

#### 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 完整中序遍历 | O(N) | O(N) | 遍历所有节点,存储到数组,返回第 K 个 |
| 提前终止的中序遍历 | O(H+K) | O(H) | 遍历到第 K 个就停止,H 为树高 |
| Morris 遍历 | O(N) | O(1) | 无需栈,但实现复杂 |

**推荐解法**:提前终止的中序遍历(递归或迭代),兼顾效率和代码简洁性。

---

### 三、代码实现

#### 解法1:递归中序遍历(提前终止)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func kthSmallest(root *TreeNode, k int) int {
    result := 0
    count := 0

    var inorder func(*TreeNode) bool
    inorder = func(node *TreeNode) bool {
        if node == nil {
            return false
        }

        // 1. 遍历左子树
        if inorder(node.Left) {
            return true // 已经找到,提前返回
        }

        // 2. 访问根节点
        count++
        if count == k {
            result = node.Val
            return true // 找到目标,返回 true 标记
        }

        // 3. 遍历右子树
        return inorder(node.Right)
    }

    inorder(root)
    return result
}
```

**关键点**:
- 用 `count` 记录已访问节点数
- 当 `count == k` 时,记录当前节点值并返回 `true`
- `true` 作为提前终止的信号,逐层向上返回

---

#### 解法2:迭代中序遍历(更直观)

```go
func kthSmallest(root *TreeNode, k int) int {
    stack := []*TreeNode{}
    current := root
    count := 0

    for current != nil || len(stack) > 0 {
        // 1. 一直往左走,压栈
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }

        // 2. 弹出栈顶(最左节点)
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        // 3. 访问当前节点
        count++
        if count == k {
            return current.Val
        }

        // 4. 转向右子树
        current = current.Right
    }

    return -1 // 不会到达(题目保证 k 有效)
}
```

**迭代版优势**:
- 更容易理解和调试
- 显式控制遍历过程
- 面试时推荐这种写法(逻辑清晰)

---

### 四、复杂度分析

#### 提前终止的中序遍历

- **时间复杂度**: O(H + K)
  - H 为树的高度(需要先走到最左叶子)
  - K 为需要访问的节点数
  - 最坏情况(K=N):O(N)
  - 最好情况(K=1):O(H)

- **空间复杂度**: O(H)
  - 递归栈或显式栈的深度
  - 完全不平衡树:O(N)
  - 平衡树:O(log N)

---

### 五、示例演示

以题目示例为例:

```
    5
   / \
  3   6
 / \
2   4
/
1
```

**迭代过程(k=3)**:

| 步骤 | 栈内容 | current | 动作 | count | 说明 |
|-----|--------|---------|------|-------|------|
| 1 | [5,3,2,1] | null | 压入左路径 | 0 | 一直往左走 |
| 2 | [5,3,2] | 1 | 访问节点 1 | 1 | 弹出最左节点 |
| 3 | [5,3] | 2 | 访问节点 2 | 2 | 1 无右子树,继续弹栈 |
| 4 | [5] | 3 | 访问节点 3 | **3** | **找到第3小,返回3** |

---

### 六、易错点

1. **计数从 1 还是 0 开始**
   - 题目说"第 k 小",通常从 1 开始计数
   - `count++` 应该在访问节点时执行,而不是在入栈时

2. **提前终止的实现**
   - 递归版:返回值需要逐层传递终止信号
   - 迭代版:找到后直接 `return`,更简单

3. **栈操作**
   - Go 中切片模拟栈:`append` 压栈,`[:len-1]` 弹栈
   - 注意检查栈是否为空

4. **边界条件**
   - k 的范围:题目保证 `1 <= k <= n`,无需额外检查
   - 但面试时可以主动询问

---

### 七、进阶思考

#### Q1: 如果需要频繁查询不同的 k 值,如何优化?

**答**:在 BST 的每个节点额外存储"左子树节点数",可以实现 O(H) 查询:

```go
type TreeNodeWithCount struct {
    Val   int
    Left  *TreeNodeWithCount
    Right *TreeNodeWithCount
    LeftCount int // 左子树节点数
}

func kthSmallest(root *TreeNodeWithCount, k int) int {
    leftCount := 0
    if root.Left != nil {
        leftCount = root.Left.LeftCount + 1 // +1 是算上左子树根节点
    }

    if k <= leftCount {
        return kthSmallest(root.Left, k) // 在左子树
    } else if k == leftCount + 1 {
        return root.Val // 就是根节点
    } else {
        return kthSmallest(root.Right, k - leftCount - 1) // 在右子树
    }
}
```

**时间复杂度**: O(H),H 为树高

---

#### Q2: 如果需要找第 K 大的元素?

**答**:反向中序遍历(右→根→左),得到降序序列:

```go
func kthLargest(root *TreeNode, k int) int {
    result := 0
    count := 0

    var inorder func(*TreeNode) bool
    inorder = func(node *TreeNode) bool {
        if node == nil {
            return false
        }

        // 先遍历右子树(大的先访问)
        if inorder(node.Right) {
            return true
        }

        count++
        if count == k {
            result = node.Val
            return true
        }

        return inorder(node.Left)
    }

    inorder(root)
    return result
}
```

---

### 八、面试技巧

1. **从 BST 性质入手**
   - 强调 BST 的关键性质:中序遍历有序
   - 这是解题的核心洞察

2. **对比不同解法**
   - 先说最简单的:完整遍历存数组
   - 再说优化版:提前终止
   - 展示思考深度

3. **代码选择**
   - 迭代版更适合面试(逻辑清晰,易调试)
   - 如果面试官要求递归,再写递归版

4. **复杂度分析**
   - 详细解释 O(H+K) 的组成
   - 说明最好/最坏情况

5. **主动讨论扩展**
   - 频繁查询的优化(增强节点)
   - 找第 K 大(反向中序遍历)
   - 展示知识广度

**追问应对**:
- Q: 如果树不是 BST 呢?
  - A: 只能 O(N) 遍历所有节点,排序后取第 K 个,或用快速选择算法 O(N) 找第 K 小

- Q: 空间复杂度能优化到 O(1) 吗?
  - A: 可以用 Morris 遍历,但实现复杂,需要临时修改树结构(遍历后恢复),面试不推荐

- Q: 树会动态变化(插入/删除),如何维护第 K 小查询?
  - A: 使用增强 BST(每个节点存左子树大小),插入/删除时更新计数,查询时二分,复杂度都是 O(H)
