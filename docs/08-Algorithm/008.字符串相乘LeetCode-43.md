---
title: 字符串相乘（LeetCode 43）
tags:
  - 算法
status: robot
class: 算法
slug: string-multiplication
ref:
---

## 核心要点

**一句话总结**：模拟竖式乘法，`num1[i] × num2[j]` 的结果存储在 `result[i+j]` 和 `result[i+j+1]`，处理进位即可。

**关键技巧**：用数组存储中间结果，最后转换成字符串，注意去除前导零。

---

## 问题分析

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，乘积也以字符串形式表示。

**约束条件**：
- 不能使用内置的大整数库（如 BigInteger）
- 不能直接将字符串转换为整数
- `num1` 和 `num2` 长度均小于 110
- 只包含数字 0-9

**示例**：
```
输入：num1 = "123", num2 = "456"
输出："56088"

输入：num1 = "0", num2 = "0"
输出："0"
```

---

## 解法思路

### 核心思路：模拟竖式乘法

**竖式乘法过程**：
```
    1 2 3
  ×   4 5 6
  ---------
    7 3 8    (123 × 6)
  6 1 5      (123 × 5, 左移一位)
4 9 2        (123 × 4, 左移两位)
-----------
5 6 0 8 8
```

**关键洞察**：
- `num1` 长度为 m，`num2` 长度为 n
- 结果最多 m + n 位（如 99 × 99 = 9801, 2+2=4位）
- `num1[i] × num2[j]` 的结果应该加到 `result[i+j]` 和 `result[i+j+1]` 位置

**算法流程**：
1. 创建长度为 `m + n` 的结果数组
2. 从右到左遍历 `num1` 和 `num2`
3. 计算 `num1[i] × num2[j]`，加到 `result[i+j+1]`
4. 处理进位：将 `result[i+j+1]` 的十位加到 `result[i+j]`
5. 将结果数组转换为字符串，去除前导零

---

## 代码实现

```go
func multiply(num1 string, num2 string) string {
    // 特殊情况：任意一个为 "0"
    if num1 == "0" || num2 == "0" {
        return "0"
    }

    m, n := len(num1), len(num2)
    result := make([]int, m+n)

    // 从右到左遍历
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            // 计算单位乘积
            mul := int(num1[i]-'0') * int(num2[j]-'0')

            // 加到对应位置
            p1, p2 := i+j, i+j+1
            sum := mul + result[p2]

            result[p2] = sum % 10     // 个位
            result[p1] += sum / 10    // 进位
        }
    }

    // 转换为字符串
    var sb strings.Builder
    for i, digit := range result {
        // 跳过前导零
        if i == 0 && digit == 0 {
            continue
        }
        sb.WriteByte(byte(digit + '0'))
    }

    return sb.String()
}
```

**执行过程示例**（num1 = "123", num2 = "45"）：

```
初始: result = [0,0,0,0,0]

i=2, j=1: 3×4=12
  p1=3, p2=4
  sum=12+0=12
  result[4]=2, result[3]+=1
  result = [0,0,0,1,2]

i=2, j=0: 3×5=15
  p1=2, p2=3
  sum=15+1=16
  result[3]=6, result[2]+=1
  result = [0,0,1,6,2]

i=1, j=1: 2×4=8
  p1=2, p2=3
  sum=8+6=14
  result[3]=4, result[2]+=1
  result = [0,0,2,4,2]

i=1, j=0: 2×5=10
  p1=1, p2=2
  sum=10+2=12
  result[2]=2, result[1]+=1
  result = [0,1,2,4,2]

i=0, j=1: 1×4=4
  p1=1, p2=2
  sum=4+2=6
  result[2]=6, result[1]+=0
  result = [0,1,6,4,2]

i=0, j=0: 1×5=5
  p1=0, p2=1
  sum=5+1=6
  result[1]=6, result[0]+=0
  result = [0,6,6,4,2]

去除前导零，输出 "6642"
```

---

## 复杂度分析

**时间复杂度**：O(m × n)
- 双层循环遍历两个字符串

**空间复杂度**：O(m + n)
- 结果数组长度为 m + n

---

## 注意事项与易错点

### 1. **索引映射**

**关键**：`num1[i] × num2[j]` 的结果放在哪？
- 个位：`result[i+j+1]`
- 十位（进位）：`result[i+j]`

**为什么？**
- `num1[i]` 代表 10^(m-1-i) 位
- `num2[j]` 代表 10^(n-1-j) 位
- 乘积代表 10^(m-1-i+n-1-j) = 10^(m+n-2-i-j) 位
- 在结果数组中，索引 `i+j+1` 对应 10^(m+n-2-i-j) 位

### 2. **前导零处理**

```go
// 错误：可能返回 "056088"
for _, digit := range result {
    sb.WriteByte(byte(digit + '0'))
}

// 正确：跳过前导零
for i, digit := range result {
    if i == 0 && digit == 0 {
        continue
    }
    sb.WriteByte(byte(digit + '0'))
}
```

### 3. **特殊情况**

```go
// "0" × 任意数 = "0"
if num1 == "0" || num2 == "0" {
    return "0"
}

// 避免返回空字符串
if sb.Len() == 0 {
    return "0"
}
```

### 4. **进位处理**

```go
// 正确：先计算 sum，再分离个位和进位
sum := mul + result[p2]
result[p2] = sum % 10
result[p1] += sum / 10

// 错误：可能丢失进位
result[p2] += mul
```

### 5. **字符转数字**

```go
// 正确
digit := int(num1[i] - '0')

// 错误：ASCII 值
digit := int(num1[i])  // 错误！'1' 的 ASCII 是 49
```

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：大数乘法，不能用内置库
2. 思路：模拟竖式乘法
3. 关键点：结果数组的索引映射 `result[i+j]` 和 `result[i+j+1]`
4. 细节：进位处理、前导零、特殊情况
5. 复杂度：O(m×n) 时间，O(m+n) 空间

**可能的追问**：

- **Q: 为什么结果数组长度是 m + n？**
  - A: 最大情况是 999...×999... = 999...000...，长度为 m+n。例如 99×99=9801，2+2=4位。

- **Q: 能否优化到 O(n log n)？**
  - A: 可以用快速傅里叶变换（FFT）或 Karatsuba 算法，但实现复杂，面试中不常考。

- **Q: 如果要实现大数加法、减法、除法？**
  - A:
    - 加法：模拟竖式加法，处理进位
    - 减法：模拟竖式减法，处理借位，注意结果符号
    - 除法：模拟长除法，更复杂

- **Q: 为什么不直接转换为整数相乘？**
  - A: 字符串可能表示超过 int64 范围的大整数，直接转换会溢出。

- **Q: 如何处理负数？**
  - A: 记录符号，对绝对值计算，最后添加符号。本题限定非负数。

**类似问题**：
- 字符串相加（LeetCode 415）：大数加法
- 二进制求和（LeetCode 67）：二进制加法
- 两数相加 II（LeetCode 445）：链表表示的大数相加

---

## 扩展：其他方法

### 方法二：逐位相乘后相加

```go
func multiply(num1 string, num2 string) string {
    if num1 == "0" || num2 == "0" {
        return "0"
    }

    result := "0"

    for i := len(num2) - 1; i >= 0; i-- {
        digit := int(num2[i] - '0')

        // 计算 num1 × digit
        carry := 0
        temp := make([]byte, len(num1)+1)
        for j := len(num1) - 1; j >= 0; j-- {
            prod := int(num1[j]-'0')*digit + carry
            temp[j+1] = byte(prod%10 + '0')
            carry = prod / 10
        }
        if carry > 0 {
            temp[0] = byte(carry + '0')
        }

        // 添加尾部的0（左移）
        for k := 0; k < len(num2)-1-i; k++ {
            temp = append(temp, '0')
        }

        // 加到结果
        result = addStrings(result, string(temp))
    }

    return result
}

func addStrings(num1, num2 string) string {
    // 大数加法实现
    // ...
}
```

这种方法更接近人工竖式计算，但需要额外实现大数加法。

**推荐**：方法一（直接在结果数组中累加），更简洁高效。
