---
title: 两数之和（LeetCode 1）
tags:
  - 算法
status: robot
class: 算法
slug: two-sum
ref:
---

## 核心要点

**一句话总结**：使用哈希表存储已遍历的数字及其索引，通过 `target - nums[i]` 查找配对元素，时间复杂度 O(n)。

**关键技巧**：空间换时间，用哈希表将查找时间从 O(n) 降到 O(1)。

---

## 问题分析

给定一个整数数组 `nums` 和目标值 `target`，找出数组中和为 `target` 的两个数的索引。

**约束条件**：
- 每个输入只对应一个答案
- 不能使用同一个元素两次
- 可以按任意顺序返回结果

**示例**：
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：nums[0] + nums[1] = 2 + 7 = 9
```

---

## 解法思路

### 方法一：暴力法（不推荐）
两层循环遍历所有配对，时间复杂度 O(n²)。

### 方法二：哈希表（最优解）

**核心思路**：
1. 遍历数组时，对于当前元素 `nums[i]`，计算配对数字 `complement = target - nums[i]`
2. 在哈希表中查找 `complement` 是否存在
3. 如果存在，返回两个索引；如果不存在，将当前数字和索引存入哈希表
4. 继续遍历下一个元素

**为什么有效**：
- 哈希表查找是 O(1) 时间复杂度
- 只需遍历一次数组，避免了嵌套循环

**关键点**：
- 先查找再插入，避免使用同一个元素两次
- 哈希表的 key 是数组值，value 是索引

---

## 代码实现

```go
func twoSum(nums []int, target int) []int {
    // 创建哈希表：key为数组值，value为索引
    numMap := make(map[int]int)

    // 遍历数组
    for i, num := range nums {
        // 计算配对数字
        complement := target - num

        // 在哈希表中查找配对数字
        if index, exists := numMap[complement]; exists {
            // 找到答案，返回两个索引
            return []int{index, i}
        }

        // 将当前数字和索引存入哈希表
        numMap[num] = i
    }

    // 题目保证有解，这里不会执行
    return nil
}
```

**执行过程示例**（nums = [2,7,11,15], target = 9）：

| 步骤 | i | num | complement | numMap 状态 | 结果 |
|------|---|-----|------------|-------------|------|
| 1 | 0 | 2 | 7 | {2:0} | 未找到，存入 |
| 2 | 1 | 7 | 2 | {2:0, 7:1} | 找到！返回 [0,1] |

---

## 复杂度分析

**时间复杂度**：O(n)
- 只遍历一次数组，每次哈希表操作为 O(1)

**空间复杂度**：O(n)
- 最坏情况下需要存储 n-1 个元素到哈希表

---

## 注意事项与易错点

1. **先查找后插入**：必须先检查哈希表中是否存在 complement，再将当前元素插入。如果先插入，会导致同一个元素被使用两次。

   错误示例：
   ```go
   numMap[num] = i  // 错误：先插入
   if index, exists := numMap[complement]; exists {
       return []int{index, i}
   }
   ```

2. **返回索引而非值**：题目要求返回索引，不是数组元素的值。

3. **哈希表的 key-value 设计**：
   - Key：数组元素的值（用于查找配对）
   - Value：数组元素的索引（用于返回结果）

4. **处理重复元素**：如果数组中有重复元素，哈希表会覆盖旧的索引，但不影响正确性。
   - 示例：`nums = [3,3], target = 6`
   - 第一次循环：查找 3（不存在），存入 {3:0}
   - 第二次循环：查找 3（存在），返回 [0,1] ✓

5. **题目保证有解**：根据题目描述，不需要处理无解的情况。

---

## 面试要点

**面试时的回答流程**：
1. 先说暴力解法（两层循环 O(n²)）
2. 分析优化方向：查找操作能否加速？→ 哈希表
3. 说明哈希表方案：空间换时间，O(n) 时间 + O(n) 空间
4. 讲解实现细节：遍历 + 查表 + 插入
5. 分析复杂度和边界情况

**可能的追问**：
- Q: 如果要求返回所有可能的配对怎么办？
  - A: 需要继续遍历，不能在找到第一个解时返回，需要用数组存储所有结果

- Q: 如果数组已排序，有更好的方法吗？
  - A: 可以用双指针，左右夹逼，空间复杂度降到 O(1)

- Q: 能否使用同一个元素两次？
  - A: 题目明确不能使用同一个元素两次，所以必须先查找再插入
