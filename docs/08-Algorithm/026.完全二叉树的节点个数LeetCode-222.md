---
title: 完全二叉树的节点个数（LeetCode 222）
tags:
  - 算法
status: robot
class: 算法
slug: count-complete-binary-tree-nodes
ref:
---

## 核心要点

**利用完全二叉树特性,结合满二叉树公式和递归,时间复杂度优化至 O(log²n)**

完全二叉树的最后一层从左到右连续填充,可以分解为:若左右子树高度相同,左子树是满二叉树;否则右子树是满二叉树。满二叉树节点数公式为 `2^h - 1`。

---

## 详细解答

### 一、题目理解

给定一个**完全二叉树**的根节点,求树的节点总数。

**完全二叉树**定义:除了最后一层外,其他层节点数都达到最大,最后一层节点从左到右连续填充(中间不能有空缺)。

**要求**:时间复杂度低于 O(n)(普通遍历的复杂度)。

---

### 二、思路分析

#### 1. 朴素解法 - O(n)

直接遍历整棵树(DFS/BFS)计数,时间复杂度 O(n),但没有利用完全二叉树的特性。

#### 2. 优化解法 - O(log²n)

**关键观察**:
- 完全二叉树可以分解为更小的子问题
- 对于任意节点,比较其左右子树的高度:
  - 如果**左右子树高度相等**,说明左子树是**满二叉树**,可以直接用公式计算左子树节点数,然后递归计算右子树
  - 如果**左子树高度大于右子树**,说明右子树是**满二叉树**,可以直接用公式计算右子树节点数,然后递归计算左子树

**满二叉树节点数公式**:高度为 h 的满二叉树节点数为 `2^h - 1`

**时间复杂度分析**:
- 树高度为 O(log n)
- 每次递归需要计算左右子树高度,耗时 O(log n)
- 递归深度为 O(log n)
- 总时间复杂度:O(log n × log n) = **O(log²n)**

---

### 三、代码实现

#### Go 实现

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func countNodes(root *TreeNode) int {
    if root == nil {
        return 0
    }

    // 计算左子树高度(一直往左走)
    leftHeight := getHeight(root.Left)
    // 计算右子树高度(一直往左走)
    rightHeight := getHeight(root.Right)

    if leftHeight == rightHeight {
        // 左右子树高度相等,说明左子树是满二叉树
        // 左子树节点数: 2^leftHeight - 1
        // 加上根节点: 2^leftHeight
        // 再加上右子树节点数(递归计算)
        return (1 << leftHeight) + countNodes(root.Right)
    } else {
        // 左子树高度 > 右子树高度,说明右子树是满二叉树
        // 右子树节点数: 2^rightHeight - 1
        // 加上根节点: 2^rightHeight
        // 再加上左子树节点数(递归计算)
        return (1 << rightHeight) + countNodes(root.Left)
    }
}

// 计算树的高度(一直往左走到底)
func getHeight(node *TreeNode) int {
    height := 0
    for node != nil {
        height++
        node = node.Left
    }
    return height
}
```

---

### 四、复杂度分析

- **时间复杂度**: O(log²n)
  - 递归深度 O(log n)
  - 每次递归计算高度 O(log n)

- **空间复杂度**: O(log n)
  - 递归调用栈的深度

---

### 五、示例演示

假设有如下完全二叉树:

```
        1
       / \
      2   3
     / \ /
    4  5 6
```

**执行过程**:

1. 根节点 1:
   - leftHeight(节点2) = 2 (2→4)
   - rightHeight(节点3) = 1 (3→6)
   - leftHeight > rightHeight,右子树是满二叉树
   - 右子树节点数 = 2¹ = 2,加上根节点 3 = 3
   - 递归计算左子树(节点2)

2. 节点 2:
   - leftHeight(节点4) = 1
   - rightHeight(节点5) = 1
   - 高度相等,左子树是满二叉树
   - 左子树节点数 = 2¹ = 2,加上根节点 2 = 3
   - 递归计算右子树(节点5)

3. 节点 5:
   - 叶子节点,返回 0

4. 回溯计算:节点2 = 2 + 0 + 1 = 3
5. 最终结果:节点1 = 3 + 3 = **6**

---

### 六、易错点

1. **高度计算错误**:注意高度从 1 开始计数(单个节点高度为 1),还是从 0 开始
2. **位运算理解**:`1 << h` 等价于 `2^h`,是满二叉树加根节点的节点数
3. **递归边界**:空节点返回 0
4. **完全二叉树性质**:计算高度时只需要沿着**最左侧路径**即可,因为完全二叉树的最左侧路径就是树的高度

---

### 七、面试技巧

1. **先说朴素解法**:O(n) 遍历,表明你理解基础解法
2. **引出优化思路**:强调利用"完全二叉树"特性,不是普通二叉树
3. **画图说明**:画出左右子树高度相等/不等的两种情况,帮助面试官理解
4. **复杂度分析**:清晰说明 O(log²n) 的由来(递归深度 × 每次计算高度)
5. **代码细节**:解释位运算 `1 << h` 的含义,展示对位运算的理解

**追问应对**:
- Q: 如果是普通二叉树怎么办?
  - A: 只能 O(n) 遍历,完全二叉树的特殊性质无法利用

- Q: 能否优化到 O(log n)?
  - A: 理论上不行,因为每次递归都需要计算子树高度 O(log n),除非用额外空间缓存高度信息

- Q: 满二叉树和完全二叉树的区别?
  - A: 满二叉树每层都填满;完全二叉树只有最后一层可能未满,但必须从左到右连续填充
