---
title: 不同路径（LeetCode 62）
tags:
  - 算法
status: robot
class: 算法
slug: unique-paths
ref:
---

## 核心要点

这是一道经典的**二维动态规划**问题：
- **核心思想**：机器人只能向右或向下移动，到达某个格子的路径数 = 从上方到达的路径数 + 从左方到达的路径数
- **状态定义**：`dp[i][j]` 表示从起点 `(0,0)` 到达格子 `(i,j)` 的不同路径数
- **优化方法**：可以用一维数组滚动优化，也可以用组合数学公式 O(1) 空间求解

---

## 详细解答

### 问题描述

一个机器人位于一个 `m x n` 网格的**左上角**（起始点标记为 `(0, 0)`）。

机器人每次只能**向下**或者**向右**移动一步。机器人试图到达网格的**右下角**（位置 `(m-1, n-1)`）。

问总共有多少条不同的路径？

**示例：**
```
输入：m = 3, n = 7
输出：28

输入：m = 3, n = 2
输出：3
解释：从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

---

### 解题思路

#### 方法一：二维动态规划（经典解法）

**核心思想：**
- 机器人要到达 `(i, j)`，只能从 `(i-1, j)` 向下走或从 `(i, j-1)` 向右走
- 因此：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

**初始化：**
- 第一行和第一列只有一条路径：`dp[0][j] = 1`，`dp[i][0] = 1`

**状态转移方程：**
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

---

### 代码实现（Go）

**方法一：二维 DP（直观清晰）**

```go
func uniquePaths(m int, n int) int {
    // 创建二维 dp 数组
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    // 初始化第一行和第一列
    for i := 0; i < m; i++ {
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }

    // 状态转移
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(m * n)

---

**方法二：一维 DP（空间优化）**

注意到 `dp[i][j]` 只依赖于当前行和上一行，可以用一维数组滚动优化：

```go
func uniquePaths(m int, n int) int {
    // 只需要一维数组存储当前行的状态
    dp := make([]int, n)

    // 初始化第一行
    for j := 0; j < n; j++ {
        dp[j] = 1
    }

    // 逐行更新
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            // dp[j] 此时存储的是上一行的值（相当于 dp[i-1][j]）
            // dp[j-1] 是当前行左边的值（相当于 dp[i][j-1]）
            dp[j] = dp[j] + dp[j-1]
        }
    }

    return dp[n-1]
}
```

**时间复杂度：** O(m * n)
**空间复杂度：** O(n)

---

**方法三：组合数学（最优解）**

从 `(0, 0)` 到 `(m-1, n-1)`，机器人需要：
- 向右走 `n-1` 步
- 向下走 `m-1` 步
- 总共走 `(m-1) + (n-1) = m + n - 2` 步

这相当于在 `m + n - 2` 个位置中选择 `m-1` 个位置向下走（或选择 `n-1` 个位置向右走），是一个**组合问题**：

$$
\text{路径数} = C(m+n-2, m-1) = \frac{(m+n-2)!}{(m-1)! \cdot (n-1)!}
$$

为了避免大数溢出，我们可以边乘边除：

```go
func uniquePaths(m int, n int) int {
    // 计算 C(m+n-2, min(m-1, n-1))
    // 选择较小的数进行计算，减少计算量
    total := m + n - 2
    k := m - 1
    if n-1 < k {
        k = n - 1
    }

    result := 1
    // 计算 C(total, k) = total! / (k! * (total-k)!)
    // 展开为：(total * (total-1) * ... * (total-k+1)) / (k * (k-1) * ... * 1)
    for i := 1; i <= k; i++ {
        result = result * (total - k + i) / i
    }

    return result
}
```

**时间复杂度：** O(min(m, n))
**空间复杂度：** O(1)

---

### 图解示例

以 `m = 3, n = 3` 为例：

```
初始状态（第一行和第一列都是 1）：
1  1  1
1  ?  ?
1  ?  ?

计算 dp[1][1]：dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2
1  1  1
1  2  ?
1  ?  ?

计算 dp[1][2]：dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3
1  1  1
1  2  3
1  ?  ?

计算 dp[2][1]：dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3
1  1  1
1  2  3
1  3  ?

计算 dp[2][2]：dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6
1  1  1
1  2  3
1  3  6
```

最终答案是 `dp[2][2] = 6`，表示有 6 条不同的路径。

---

## 面试要点总结

1. **识别 DP 问题**：到达某个位置的路径数依赖于前面位置的路径数，典型的 DP 问题
2. **状态定义清晰**：`dp[i][j]` 表示到达 `(i, j)` 的路径数
3. **初始化重要**：第一行和第一列都是 1（只有一种走法）
4. **空间优化**：二维可以优化为一维，进一步可以用组合数学公式达到 O(1) 空间
5. **组合数学解法**：如果面试官问有没有更优的解法，可以提到组合数学 C(m+n-2, m-1)

这题是 DP 的入门题，掌握后可以延伸到 **不同路径 II**（带障碍物）和 **最小路径和**（带权重）等问题。
