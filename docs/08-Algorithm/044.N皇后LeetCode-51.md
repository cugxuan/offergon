---
title: N皇后（LeetCode 51）
tags:
  - 算法
status: robot
class: 算法
slug: n-queens-leetcode-51
ref:
---

## 核心要点

**回溯算法的经典难题，通过逐行放置皇后并检查列、主对角线、副对角线冲突实现。关键在于三个剪枝条件和对角线坐标转换技巧。时间复杂度 O(n!)，空间复杂度 O(n)。**

---

## 题目描述

**n 皇后问题**研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个不同的 n 皇后问题的棋盘配置，其中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**皇后的攻击规则：**
- 皇后可以攻击同一行、同一列、同一对角线上的任何棋子

**示例：**

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]

解释：
方案1:          方案2:
. Q . .        . . Q .
. . . Q        Q . . .
Q . . .        . . . Q
. . Q .        . Q . .
```

```
输入：n = 1
输出：[["Q"]]
```

---

## 解题思路

### 1. 问题分析

**核心约束：**
- 每行只能放一个皇后
- 每列只能放一个皇后
- 每条主对角线（左上到右下）只能放一个皇后
- 每条副对角线（右上到左下）只能放一个皇后

**搜索策略：**
- 逐行放置皇后（每行必须放一个）
- 对于每一行，尝试在每一列放置
- 检查是否与已放置的皇后冲突
- 回溯尝试其他位置

### 2. 对角线坐标转换技巧

这是本题的关键难点！

#### 主对角线（左上→右下）

同一主对角线上的所有点满足：**`row - col = 常数`**

```
棋盘坐标:        row-col值:
(0,0)(0,1)(0,2)    0  -1  -2
(1,0)(1,1)(1,2)    1   0  -1
(2,0)(2,1)(2,2)    2   1   0
```

由于 `row - col` 可能为负数，需要加上 `n-1` 转换为非负索引：
- **主对角线编号** = `row - col + (n-1)`
- 范围：0 到 2n-2，共 2n-1 条对角线

#### 副对角线（右上→左下）

同一副对角线上的所有点满足：**`row + col = 常数`**

```
棋盘坐标:        row+col值:
(0,0)(0,1)(0,2)    0   1   2
(1,0)(1,1)(1,2)    1   2   3
(2,0)(2,1)(2,2)    2   3   4
```

- **副对角线编号** = `row + col`
- 范围：0 到 2n-2，共 2n-1 条对角线

### 3. 回溯框架

```
def backtrack(row):
    if row == n:
        result.add(当前棋盘)  # 找到一个解
        return

    for col in range(n):
        if 列col未占用 and 主对角线未占用 and 副对角线未占用:
            放置皇后(row, col)
            标记列、对角线为已占用
            backtrack(row + 1)  # 处理下一行
            移除皇后(row, col)
            恢复列、对角线为未占用
```

---

## 代码实现

### 方法一：使用标记数组（推荐）

```go
func solveNQueens(n int) [][]string {
    result := [][]string{}
    board := make([][]byte, n)
    for i := range board {
        board[i] = make([]byte, n)
        for j := range board[i] {
            board[i][j] = '.'
        }
    }

    // 标记数组
    cols := make([]bool, n)              // 列占用情况
    diag1 := make([]bool, 2*n-1)         // 主对角线占用情况
    diag2 := make([]bool, 2*n-1)         // 副对角线占用情况

    var backtrack func(row int)
    backtrack = func(row int) {
        // 所有行都已放置，找到一个解
        if row == n {
            solution := make([]string, n)
            for i := 0; i < n; i++ {
                solution[i] = string(board[i])
            }
            result = append(result, solution)
            return
        }

        // 尝试在当前行的每一列放置皇后
        for col := 0; col < n; col++ {
            // 计算对角线编号
            d1 := row - col + (n - 1)  // 主对角线编号
            d2 := row + col            // 副对角线编号

            // 检查是否冲突
            if cols[col] || diag1[d1] || diag2[d2] {
                continue  // 该位置不合法，尝试下一列
            }

            // 做选择：放置皇后
            board[row][col] = 'Q'
            cols[col] = true
            diag1[d1] = true
            diag2[d2] = true

            // 递归：处理下一行
            backtrack(row + 1)

            // 撤销选择：回溯
            board[row][col] = '.'
            cols[col] = false
            diag1[d1] = false
            diag2[d2] = false
        }
    }

    backtrack(0)
    return result
}
```

### 方法二：不使用标记数组（效率较低）

每次都遍历已放置的皇后检查冲突：

```go
func solveNQueens(n int) [][]string {
    result := [][]string{}
    board := make([][]byte, n)
    for i := range board {
        board[i] = make([]byte, n)
        for j := range board[i] {
            board[i][j] = '.'
        }
    }

    // 检查在 (row, col) 放置皇后是否合法
    isValid := func(row, col int) bool {
        // 检查列冲突
        for i := 0; i < row; i++ {
            if board[i][col] == 'Q' {
                return false
            }
        }

        // 检查主对角线冲突（左上）
        for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
            if board[i][j] == 'Q' {
                return false
            }
        }

        // 检查副对角线冲突（右上）
        for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 {
            if board[i][j] == 'Q' {
                return false
            }
        }

        return true
    }

    var backtrack func(row int)
    backtrack = func(row int) {
        if row == n {
            solution := make([]string, n)
            for i := 0; i < n; i++ {
                solution[i] = string(board[i])
            }
            result = append(result, solution)
            return
        }

        for col := 0; col < n; col++ {
            if !isValid(row, col) {
                continue
            }

            board[row][col] = 'Q'
            backtrack(row + 1)
            board[row][col] = '.'
        }
    }

    backtrack(0)
    return result
}
```

---

## 详细执行过程（以 n=4 为例）

```
初始: board = [....][....][....][....]

第1行 (row=0):
  尝试 col=0: 放置 Q → [Q...][....][....][....]
    标记: cols[0]=true, diag1[3]=true, diag2[0]=true

    第2行 (row=1):
      尝试 col=0: ❌ cols[0]=true，冲突
      尝试 col=1: ❌ diag1[3]=true，冲突
      尝试 col=2: ✓ 合法 → [Q...][..Q.][....][....]
        标记: cols[2]=true, diag1[2]=true, diag2[3]=true

        第3行 (row=2):
          尝试 col=0: ❌ diag2[2]=false, 但 diag1[5]=false... 检查
          尝试 col=1: ❌ diag2[3]=true，冲突
          尝试 col=2: ❌ cols[2]=true，冲突
          尝试 col=3: ❌ diag1[2]=true，冲突
          (无解，回溯)
      回溯 [Q...][....][....][....]

      尝试 col=3: ✓ 合法 → [Q...][...Q][....][....]
        ... (继续搜索)

  回溯，尝试 col=1: 放置 Q → [.Q..][....][....][....]
    第2行 (row=1):
      尝试 col=0: ❌ diag2[1]=true，冲突
      尝试 col=1: ❌ cols[1]=true，冲突
      尝试 col=2: ❌ diag1[1]=true，冲突
      尝试 col=3: ✓ 合法 → [.Q..][...Q][....][....]
        第3行 (row=2):
          尝试 col=0: ✓ 合法 → [.Q..][...Q][Q...][....]
            第4行 (row=3):
              尝试 col=2: ✓ 合法 → [.Q..][...Q][Q...][..Q.]
                row==4, 找到解! ✓
                result = [[".Q..","...Q","Q...","..Q."]]

... (继续搜索其他解)

最终结果: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
```

---

## 复杂度分析

### 时间复杂度：O(n!)

- 第1行有 n 个选择
- 第2行约有 n-2 个选择（排除冲突）
- 第3行约有 n-4 个选择
- ...
- 总体约 n × (n-2) × (n-4) × ... ≈ O(n!)

### 空间复杂度：O(n)

- 递归调用栈深度：O(n)
- board 二维数组：O(n²)
- 标记数组：O(n)
- 总体：O(n²)，但递归栈是主要部分

---

## 关键要点总结

1. **逐行放置策略**：每行必须放一个皇后，按行递归避免了行冲突检查

2. **对角线编号公式**（核心难点）：
   - 主对角线：`row - col + (n-1)`
   - 副对角线：`row + col`

3. **剪枝条件**：
   - 列冲突：`cols[col]`
   - 主对角线冲突：`diag1[row - col + n - 1]`
   - 副对角线冲突：`diag2[row + col]`

4. **标记数组优化**：使用布尔数组 O(1) 判断冲突，比每次遍历检查 O(n) 更高效

5. **回溯模板**：放置→标记→递归→回溯→恢复标记

---

## 面试回答要点

**面试官：如何解决 N 皇后问题？**

**回答框架：**

"N 皇后是回溯算法的经典难题。核心思路是逐行放置皇后，每行尝试所有列，通过剪枝排除冲突位置。

**实现要点：**

1. **搜索策略**：按行递归，每行必放一个皇后，避免行冲突检查

2. **冲突判断**：需要检查三个方向：
   - 列冲突：用 `cols[col]` 数组标记
   - 主对角线冲突：同一对角线满足 `row - col = 常数`，编号为 `row - col + n - 1`
   - 副对角线冲突：同一对角线满足 `row + col = 常数`，编号为 `row + col`

3. **优化手段**：使用三个布尔数组提前标记占用情况，O(1) 时间判断冲突

4. **回溯流程**：放置皇后→标记为已占用→递归下一行→回溯→恢复为未占用

时间复杂度 O(n!)，空间复杂度 O(n)。

对角线编号公式是本题的关键难点，理解它需要画图分析同一对角线上坐标的数学关系。"

---

## 扩展问题

### 1. N 皇后 II（LeetCode 52）

**变化：** 只返回解的数量，不需要具体方案

**优化：** 不需要构建 board 数组，只计数即可

```go
func totalNQueens(n int) int {
    count := 0
    cols := make([]bool, n)
    diag1 := make([]bool, 2*n-1)
    diag2 := make([]bool, 2*n-1)

    var backtrack func(row int)
    backtrack = func(row int) {
        if row == n {
            count++
            return
        }

        for col := 0; col < n; col++ {
            d1 := row - col + n - 1
            d2 := row + col

            if cols[col] || diag1[d1] || diag2[d2] {
                continue
            }

            cols[col] = true
            diag1[d1] = true
            diag2[d2] = true

            backtrack(row + 1)

            cols[col] = false
            diag1[d1] = false
            diag2[d2] = false
        }
    }

    backtrack(0)
    return count
}
```

### 2. 位运算优化（高级技巧）

使用位运算表示占用状态，速度更快：

```go
func solveNQueens(n int) [][]string {
    result := [][]string{}
    board := make([]int, n) // board[i] 表示第 i 行皇后的列位置

    var backtrack func(row, cols, diag1, diag2 int)
    backtrack = func(row, cols, diag1, diag2 int) {
        if row == n {
            // 构建解
            solution := make([]string, n)
            for i := 0; i < n; i++ {
                line := make([]byte, n)
                for j := range line {
                    line[j] = '.'
                }
                line[board[i]] = 'Q'
                solution[i] = string(line)
            }
            result = append(result, solution)
            return
        }

        // availablePositions 的每个 1 表示该列可以放置
        availablePositions := ((1 << n) - 1) & ^(cols | diag1 | diag2)

        for availablePositions > 0 {
            // 获取最低位的 1（最右边的可用位置）
            position := availablePositions & -availablePositions
            availablePositions &= availablePositions - 1 // 移除该位

            // 计算列号
            col := bits.TrailingZeros(uint(position))
            board[row] = col

            backtrack(
                row+1,
                cols|position,
                (diag1|position)<<1,
                (diag2|position)>>1,
            )
        }
    }

    backtrack(0, 0, 0, 0)
    return result
}
```

**优点：** 位运算比数组访问快，适合竞赛优化

**缺点：** 代码可读性差，面试不推荐（除非面试官明确要求优化）

---

## 对角线理解图解

### 主对角线（\）

```
棋盘坐标:           row-col:        编号 (row-col+3):
(0,0) (0,1) (0,2) (0,3)    0 -1 -2 -3      3  2  1  0
(1,0) (1,1) (1,2) (1,3)    1  0 -1 -2      4  3  2  1
(2,0) (2,1) (2,2) (2,3)    2  1  0 -1      5  4  3  2
(3,0) (3,1) (3,2) (3,3)    3  2  1  0      6  5  4  3

同一主对角线的点 row-col 相同:
- (0,0), (1,1), (2,2), (3,3) → row-col = 0 → 编号 3
- (0,1), (1,2), (2,3)        → row-col = -1 → 编号 2
- (1,0), (2,1), (3,2)        → row-col = 1 → 编号 4
```

### 副对角线（/）

```
棋盘坐标:           row+col:
(0,0) (0,1) (0,2) (0,3)    0  1  2  3
(1,0) (1,1) (1,2) (1,3)    1  2  3  4
(2,0) (2,1) (2,2) (2,3)    2  3  4  5
(3,0) (3,1) (3,2) (3,3)    3  4  5  6

同一副对角线的点 row+col 相同:
- (0,3), (1,2), (2,1), (3,0) → row+col = 3
- (0,2), (1,1), (2,0)        → row+col = 2
- (1,3), (2,2), (3,1)        → row+col = 4
```

---

## 常见错误与注意事项

### 错误 1：对角线编号计算错误

```go
// ❌ 错误：主对角线忘记加偏移量
d1 := row - col  // 可能为负数！

// ✅ 正确：加上 n-1 转换为非负索引
d1 := row - col + (n - 1)
```

### 错误 2：回溯时忘记恢复标记

```go
// ❌ 错误：没有恢复标记
cols[col] = true
backtrack(row + 1)
// 忘记 cols[col] = false

// ✅ 正确：必须恢复
cols[col] = true
diag1[d1] = true
diag2[d2] = true
backtrack(row + 1)
cols[col] = false
diag1[d1] = false
diag2[d2] = false
```

### 错误 3：字符串拼接效率低

```go
// ⚠️ 低效：字符串拼接
solution[i] = ""
for j := 0; j < n; j++ {
    if board[i][j] == 'Q' {
        solution[i] += "Q"
    } else {
        solution[i] += "."
    }
}

// ✅ 高效：直接转换字节数组
solution[i] = string(board[i])
```

### 错误 4：检查冲突时遍历不完整

```go
// ❌ 错误：只检查了一个方向的对角线
for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
    if board[i][j] == 'Q' {
        return false
    }
}
// 忘记检查另一个方向！

// ✅ 正确：两个方向都要检查
// 左上对角线
for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 { ... }
// 右上对角线
for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 { ... }
```

---

## 总结

N 皇后问题是回溯算法的巅峰之作，综合考查：

1. **回溯框架掌握**：选择→递归→撤销的熟练应用
2. **数学建模能力**：对角线坐标关系的理解
3. **剪枝优化思维**：标记数组加速冲突判断
4. **代码实现能力**：边界条件、状态恢复的细节处理

面试中建议：
- 先画图说明思路（特别是对角线编号）
- 写出清晰的标记数组版本
- 时间允许再讨论位运算优化
- 强调对角线公式的推导过程

这道题能很好地展示你的算法功底和问题分析能力。
