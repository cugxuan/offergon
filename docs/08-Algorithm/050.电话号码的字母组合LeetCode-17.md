---
title: 电话号码的字母组合（LeetCode 17）
tags:
  - 算法
status: robot
class: 算法
slug: letter-combinations-of-phone-number
ref:
---

## 核心要点

**回溯算法**：建立数字到字母的映射表，递归枚举所有可能的字母组合，时间复杂度 O(4^n)

---

## 题目描述

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按**任意顺序**返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```
2 -> abc
3 -> def
4 -> ghi
5 -> jkl
6 -> mno
7 -> pqrs
8 -> tuv
9 -> wxyz
```

**示例：**
```
输入: digits = "23"
输出: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

输入: digits = ""
输出: []

输入: digits = "2"
输出: ["a","b","c"]
```

---

## 解题思路

### 思路分析

这是一道经典的**回溯算法**问题，本质是多个集合的笛卡尔积：

1. **映射关系**：建立数字到字母的映射表（哈希表或数组）

2. **递归结构**：
   - 当前层：选择当前数字对应的某个字母
   - 下一层：处理剩余数字
   - 终止条件：处理完所有数字

3. **决策树**：以 `"23"` 为例
   ```
                      ""
            /          |          \
          a            b            c
        / | \        / | \        / | \
       d  e  f      d  e  f      d  e  f
   ```
   最终生成 3×3 = 9 种组合

4. **关键点**：
   - 不需要剪枝（所有路径都是有效的）
   - 回溯通过字符串拼接自然完成（或显式移除最后字符）

---

## 代码实现

### 方法一：回溯（字符串拼接）

```go
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }

    // 数字到字母的映射表
    phoneMap := map[byte]string{
        '2': "abc",
        '3': "def",
        '4': "ghi",
        '5': "jkl",
        '6': "mno",
        '7': "pqrs",
        '8': "tuv",
        '9': "wxyz",
    }

    result := []string{}

    // 回溯函数
    // current: 当前构建的字母组合
    // index: 当前处理到 digits 的第几位
    var backtrack func(current string, index int)
    backtrack = func(current string, index int) {
        // 终止条件：处理完所有数字
        if index == len(digits) {
            result = append(result, current)
            return
        }

        // 获取当前数字对应的所有字母
        digit := digits[index]
        letters := phoneMap[digit]

        // 遍历当前数字的所有可能字母
        for i := 0; i < len(letters); i++ {
            // 选择当前字母，递归处理下一个数字
            backtrack(current+string(letters[i]), index+1)
        }
    }

    backtrack("", 0)
    return result
}
```

### 方法二：回溯（使用 byte 切片优化）

```go
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }

    phoneMap := map[byte]string{
        '2': "abc", '3': "def", '4': "ghi", '5': "jkl",
        '6': "mno", '7': "pqrs", '8': "tuv", '9': "wxyz",
    }

    result := []string{}
    path := make([]byte, 0, len(digits)) // 预分配空间

    var backtrack func(index int)
    backtrack = func(index int) {
        // 终止条件
        if index == len(digits) {
            result = append(result, string(path))
            return
        }

        // 获取当前数字对应的字母
        letters := phoneMap[digits[index]]

        // 遍历所有可能的字母
        for i := 0; i < len(letters); i++ {
            path = append(path, letters[i])     // 做选择
            backtrack(index + 1)                // 递归
            path = path[:len(path)-1]           // 撤销选择（回溯）
        }
    }

    backtrack(0)
    return result
}
```

### 方法三：迭代法（队列）

```go
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }

    phoneMap := map[byte]string{
        '2': "abc", '3': "def", '4': "ghi", '5': "jkl",
        '6': "mno", '7': "pqrs", '8': "tuv", '9': "wxyz",
    }

    // 初始化队列，包含一个空字符串
    result := []string{""}

    // 遍历每个数字
    for i := 0; i < len(digits); i++ {
        letters := phoneMap[digits[i]]
        temp := []string{}

        // 对当前队列中的每个组合，添加所有可能的字母
        for _, combination := range result {
            for j := 0; j < len(letters); j++ {
                temp = append(temp, combination+string(letters[j]))
            }
        }

        result = temp
    }

    return result
}
```

---

## 关键代码说明

### 回溯方法（方法一）

1. **映射表**（第7-16行）：
   - 使用 `map[byte]string` 存储数字到字母的映射
   - 也可以用数组 `[]string` 实现（下标为数字减去 '0'）

2. **递归参数**（第21-23行）：
   - `current`：当前已构建的字母组合
   - `index`：正在处理 digits 的第几个数字

3. **终止条件**（第26-29行）：
   - `index == len(digits)`：所有数字都已处理

4. **递归逻辑**（第32-38行）：
   - 获取当前数字对应的字母集合
   - 遍历每个字母，递归处理下一个数字

### 优化方法（方法二）

- **优势**：使用 `[]byte` 代替字符串拼接，减少内存分配
- **回溯**：显式移除最后一个字符（第31行）

### 迭代法（方法三）

- **思路**：逐层扩展
  - 初始队列：`[""]`
  - 处理数字 '2'：`["a", "b", "c"]`
  - 处理数字 '3'：`["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]`

---

## 复杂度分析

### 回溯方法
- **时间复杂度**：O(4^n · n)
  - n = digits.length
  - 最坏情况（全是 7 或 9）：每个数字对应 4 个字母
  - 共有 4^n 种组合，每个组合需要 O(n) 时间构建字符串

- **空间复杂度**：O(n)
  - 递归栈深度：O(n)
  - 不计结果集的空间

### 迭代法
- **时间复杂度**：O(4^n · n)
  - 与回溯方法相同

- **空间复杂度**：O(4^n · n)
  - 需要存储所有中间状态

---

## 测试用例

```go
func main() {
    // 测试用例1: 标准输入
    fmt.Println(letterCombinations("23"))
    // 输出: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

    // 测试用例2: 空字符串
    fmt.Println(letterCombinations(""))
    // 输出: []

    // 测试用例3: 单个数字
    fmt.Println(letterCombinations("2"))
    // 输出: ["a","b","c"]

    // 测试用例4: 包含 7 和 9（4 个字母）
    fmt.Println(letterCombinations("79"))
    // 输出: 4×4 = 16 种组合

    // 测试用例5: 长输入
    result := letterCombinations("234")
    fmt.Printf("输入 '234' 生成 %d 种组合\n", len(result))
    // 输出: 3×3×3 = 27 种组合

    // 测试用例6: 最坏情况
    result2 := letterCombinations("7777")
    fmt.Printf("输入 '7777' 生成 %d 种组合\n", len(result2))
    // 输出: 4^4 = 256 种组合
}
```

---

## 面试要点

1. **为什么选择回溯而不是循环嵌套？**
   - digits 长度不固定，循环嵌套层数无法确定
   - 回溯可以处理任意长度的输入

2. **如何优化空间复杂度？**
   - 方法一：字符串拼接会创建新对象，隐式回溯
   - 方法二：使用 `[]byte` 手动管理，显式回溯
   - 方法二更节省内存，但代码略复杂

3. **迭代法和递归法的对比？**
   - 递归：代码简洁，易于理解，空间占用低
   - 迭代：避免递归栈溢出，但需要存储中间状态

4. **时间复杂度为什么是 O(4^n)？**
   - 最坏情况下（全是 7 或 9），每个数字对应 4 个字母
   - 决策树有 4^n 个叶子节点
   - 实际复杂度取决于输入（平均为 3^n）

5. **如何处理无效输入？**
   - 题目保证输入只包含 2-9
   - 实际工程中需要校验输入合法性

6. **能否用 BFS 实现？**
   - 可以，迭代法本质就是 BFS
   - 从空字符串开始，逐层扩展

---

## 算法原理详解

### 回溯的决策树

以 `digits = "23"` 为例：

```
Level 0:          ""
                  |
                  2
            /     |     \
Level 1:   a      b      c
          /|\    /|\    /|\
         d e f  d e f  d e f   (数字 3)
Level 2:
结果:   ad ae af bd be bf cd ce cf
```

- **深度**：digits 的长度
- **每层分支数**：当前数字对应的字母数量
- **叶子节点**：最终的字母组合

### 回溯三要素

1. **选择列表**：当前数字对应的字母集合
2. **路径**：已选择的字母组成的字符串
3. **结束条件**：处理完所有数字

### 笛卡尔积的本质

```
digits = "23"
集合 A = {a, b, c}  (数字 2)
集合 B = {d, e, f}  (数字 3)
结果 = A × B = {(a,d), (a,e), (a,f), (b,d), ..., (c,f)}
```

---

## 相关题目

- LeetCode 22: 括号生成（回溯 + 剪枝）
- LeetCode 39: 组合总和（回溯 + 去重）
- LeetCode 46: 全排列（回溯 + 标记数组）
- LeetCode 77: 组合（回溯 + 剪枝）
- LeetCode 78: 子集（回溯 + 位运算）
- LeetCode 131: 分割回文串（回溯 + 动态规划）
