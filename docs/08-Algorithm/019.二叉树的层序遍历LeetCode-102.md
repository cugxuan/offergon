---
title: 二叉树的层序遍历（LeetCode 102）
tags:
  - 算法
status: robot
class: 算法
slug: binary-tree-level-order-traversal
ref:
---

## 核心要点

**BFS 广度优先搜索+队列实现分层**：使用队列存储每层节点,遍历当前层的所有节点时,将下一层节点加入队列。关键是记录每层的节点数量,确保每次循环处理完整一层。

---

## 题目描述

给你二叉树的根节点 `root`,返回其节点值的**层序遍历**。(即逐层地,从左到右访问所有节点)。

**示例 1:**

```
输入: root = [3,9,20,null,null,15,7]
      3
     / \
    9  20
      /  \
     15   7

输出: [[3],[9,20],[15,7]]
```

**示例 2:**

```
输入: root = [1]
输出: [[1]]
```

**示例 3:**

```
输入: root = []
输出: []
```

---

## 解题思路

### 方法一:BFS 广度优先搜索(推荐)

**核心思想:**

层序遍历就是 BFS(Breadth-First Search,广度优先搜索)。使用队列实现:

1. 将根节点加入队列
2. 每次处理当前队列中的所有节点(一层)
3. 处理节点时,将其子节点加入队列(下一层)
4. 重复步骤 2-3 直到队列为空

**关键点:** 需要知道每层有多少个节点,才能正确分层。在每层开始时记录当前队列的大小即可。

**图解过程:**

```
树结构:
      3
     / \
    9  20
      /  \
     15   7

遍历过程:

初始: queue = [3], result = []

第 1 层(queue size = 1):
  处理 3, 加入 9 和 20
  queue = [9, 20]
  result = [[3]]

第 2 层(queue size = 2):
  处理 9, 无子节点
  处理 20, 加入 15 和 7
  queue = [15, 7]
  result = [[3], [9, 20]]

第 3 层(queue size = 2):
  处理 15, 无子节点
  处理 7, 无子节点
  queue = []
  result = [[3], [9, 20], [15, 7]]
```

**代码实现(Go):**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    result := [][]int{}
    if root == nil {
        return result
    }

    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)  // 当前层的节点数
        currentLevel := []int{}

        // 处理当前层的所有节点
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]  // 出队

            currentLevel = append(currentLevel, node.Val)

            // 将下一层节点加入队列
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, currentLevel)
    }

    return result
}
```

**时间复杂度:** O(n),每个节点访问一次
**空间复杂度:** O(n),队列最多存储一层的节点数,最坏情况下(完全二叉树的最后一层)为 n/2

---

### 方法二:DFS 深度优先搜索+递归

**核心思想:**

使用 DFS 遍历树,但同时记录当前节点所在的层级 `level`。在递归过程中:

1. 如果 `result` 中还没有当前层的列表,创建一个新列表
2. 将当前节点的值加入对应层的列表
3. 递归处理左右子树,层级加 1

**代码实现(Go):**

```go
func levelOrder(root *TreeNode) [][]int {
    result := [][]int{}
    if root == nil {
        return result
    }

    var dfs func(*TreeNode, int)
    dfs = func(node *TreeNode, level int) {
        if node == nil {
            return
        }

        // 如果当前层还没有列表,创建一个
        if len(result) == level {
            result = append(result, []int{})
        }

        // 将当前节点值加入对应层
        result[level] = append(result[level], node.Val)

        // 递归处理左右子树
        dfs(node.Left, level+1)
        dfs(node.Right, level+1)
    }

    dfs(root, 0)
    return result
}
```

**时间复杂度:** O(n),每个节点访问一次
**空间复杂度:** O(h),递归调用栈的深度为树的高度 h,平衡树为 O(log n),最坏情况(链状树)为 O(n)

---

## 关键细节

### 1. 如何正确分层?

**BFS 方法的关键:**

```go
levelSize := len(queue)  // 在外层循环开始时记录当前层的节点数

for i := 0; i < levelSize; i++ {
    // 处理固定数量的节点,确保只处理当前层
}
```

如果不记录 `levelSize`,直接用 `len(queue)` 作为循环条件,会把新加入的下一层节点也处理了。

### 2. Go 语言队列的实现

Go 没有内置队列,常用切片模拟:

```go
// 入队
queue = append(queue, node)

// 出队
node := queue[0]
queue = queue[1:]
```

也可以使用 `container/list` 包的双向链表:

```go
import "container/list"

queue := list.New()
queue.PushBack(root)  // 入队

node := queue.Remove(queue.Front()).(*TreeNode)  // 出队
```

### 3. DFS 方法的层级管理

DFS 方法中,`level` 参数表示当前节点所在的层级(从 0 开始)。关键是:

```go
// 当 result 的长度等于 level 时,说明这是该层第一次被访问
if len(result) == level {
    result = append(result, []int{})
}
```

这样可以保证每层只创建一次列表。

---

## 易错点与注意事项

1. **边界条件:** 空树返回空列表 `[][]int{}`
2. **队列大小记录:** 必须在处理当前层之前记录 `levelSize`,否则会把新加入的节点也算进去
3. **队列出队操作:** Go 中 `queue = queue[1:]` 会创建新切片,性能较差。大数据量时可以用双向链表优化
4. **DFS 方法的顺序:** 先处理当前节点,再递归左右子树,确保每层从左到右的顺序

---

## 变体题目

### 1. 自底向上的层序遍历(LeetCode 107)

要求从最底层开始返回层序遍历结果。

**解法:** 使用 BFS,最后将结果数组反转:

```go
// 最后添加这一行
reverse(result)  // 或者用 append 插入到开头
```

### 2. 锯齿形层序遍历(LeetCode 103)

奇数层从左到右,偶数层从右到左。

**解法:** 使用 BFS,根据层级奇偶性决定是否反转当前层:

```go
if level%2 == 1 {
    reverse(currentLevel)
}
```

### 3. 每层的最大值(LeetCode 515)

返回每层的最大值。

**解法:** 使用 BFS,在处理每层时记录最大值:

```go
maxVal := math.MinInt32
for i := 0; i < levelSize; i++ {
    maxVal = max(maxVal, node.Val)
}
result = append(result, maxVal)
```

---

## 面试技巧

**面试官可能的追问:**

1. **BFS 和 DFS 方法的区别?**
   - 答:BFS 使用队列,逐层遍历,空间复杂度为 O(n/2)(最宽层);DFS 使用递归栈,深度优先,空间复杂度为 O(h)(树高)。BFS 更直观,DFS 代码更简洁。

2. **如何实现从右到左的层序遍历?**
   - 答:在 BFS 时,先将右子节点加入队列,再将左子节点加入队列。或者在处理完每层后反转当前层的列表。

3. **如何判断某一层是否是最后一层?**
   - 答:在 BFS 中,如果队列为空,说明已经处理完所有层。或者在加入子节点时检查是否有子节点加入队列。

4. **如何优化空间复杂度?**
   - 答:BFS 的空间复杂度主要由队列决定,无法进一步优化。DFS 的空间复杂度由递归栈决定,可以用迭代+显式栈替代递归,但空间复杂度不变。

5. **如果树非常宽(某一层有百万个节点),如何处理?**
   - 答:队列会占用大量内存。可以考虑用生成器/迭代器按需处理节点,或者分批处理(批量出队和入队)。

6. **如何实现层序遍历的迭代器?**
   - 答:维护一个队列,每次 `next()` 调用时返回下一个节点,并将其子节点加入队列。

---

## 方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| BFS + 队列 | O(n) | O(n/2) | 直观,符合层序遍历定义 | 需要显式队列 |
| DFS + 递归 | O(n) | O(h) | 代码简洁,空间占用小(平衡树) | 不够直观,理解稍难 |

---

## 总结

二叉树的层序遍历是 BFS 的经典应用。推荐使用**队列实现的 BFS 方法**:

**实现要点:**

1. 使用队列存储节点,初始只有根节点
2. 外层循环:当队列不为空时继续
3. 记录当前层的节点数 `levelSize`
4. 内层循环:处理 `levelSize` 个节点(确保只处理当前层)
5. 将每个节点的子节点加入队列(为下一层准备)

**关键代码片段:**

```go
for len(queue) > 0 {
    levelSize := len(queue)  // 记录当前层节点数
    currentLevel := []int{}

    for i := 0; i < levelSize; i++ {
        node := queue[0]
        queue = queue[1:]
        currentLevel = append(currentLevel, node.Val)

        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
    }

    result = append(result, currentLevel)
}
```

这道题是树的遍历问题的基础,掌握后可以轻松应对各种变体题目(自底向上、锯齿形、右视图等)。面试中能清晰解释分层逻辑和边界条件处理,会给面试官留下深刻印象。
