---
title: 子集（LeetCode 78）
tags:
  - 算法
status: robot
class: 算法
slug: subsets-leetcode-78
ref:
---

## 核心要点

**回溯算法生成所有子集（幂集），关键在于每个元素"选或不选"的二叉决策树。可用回溯、迭代、位运算三种方法，时间复杂度 O(n×2^n)，空间复杂度 O(n)。**

---

## 题目描述

给你一个整数数组 `nums`，数组中的元素**互不相同**。返回该数组所有可能的子集（幂集）。

解集**不能**包含重复的子集。你可以按**任意顺序**返回解集。

**示例：**
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

---

## 解题思路

### 1. 问题本质

对于 n 个元素的数组，其子集总数为 **2^n** 个（包括空集），因为每个元素都有"选"或"不选"两种状态。

以 `[1,2,3]` 为例：
```
空集: []
选1: [1]
选2: [2]
选1,2: [1,2]
选3: [3]
选1,3: [1,3]
选2,3: [2,3]
选1,2,3: [1,2,3]
```

### 2. 三种解法思路对比

| 方法 | 核心思想 | 优点 | 缺点 |
|------|---------|------|------|
| **回溯法** | DFS遍历决策树，每层决定是否选择当前元素 | 易于理解，代码清晰 | 递归有栈开销 |
| **迭代法** | 动态构建，每次遍历现有子集并添加新元素 | 无递归开销，直观 | 需要额外复制操作 |
| **位运算法** | 用 0~2^n-1 的二进制表示每个子集 | 代码最简洁 | 不够直观 |

---

## 方法一：回溯法（推荐）

### 决策树（以 [1,2,3] 为例）

```
                          []
                    选1/     \不选1
                  [1]          []
              选2/   \不选2   选2/ \不选2
            [1,2]    [1]    [2]    []
           选3/\不选3 选3/\不选3 选3/\不选3 选3/\不选3
        [1,2,3][1,2][1,3][1][2,3][2][3][]
```

### 代码实现

```go
func subsets(nums []int) [][]int {
    result := [][]int{}
    path := []int{}

    var backtrack func(start int)
    backtrack = func(start int) {
        // 每个节点都是一个有效子集
        temp := make([]int, len(path))
        copy(temp, path)
        result = append(result, temp)

        // 从 start 开始选择元素（避免重复）
        for i := start; i < len(nums); i++ {
            // 做选择：选择 nums[i]
            path = append(path, nums[i])

            // 递归：处理下一个位置
            backtrack(i + 1)

            // 撤销选择：回溯
            path = path[:len(path)-1]
        }
    }

    backtrack(0)
    return result
}
```

### 执行过程详解

```
调用 backtrack(0), path=[]
  加入结果: [[]]

  i=0, 选择1, path=[1]
    调用 backtrack(1), path=[1]
      加入结果: [[],[1]]

      i=1, 选择2, path=[1,2]
        调用 backtrack(2), path=[1,2]
          加入结果: [[],[1],[1,2]]

          i=2, 选择3, path=[1,2,3]
            调用 backtrack(3), path=[1,2,3]
              加入结果: [[],[1],[1,2],[1,2,3]]
            回溯, path=[1,2]
        回溯, path=[1]

      i=2, 选择3, path=[1,3]
        调用 backtrack(3), path=[1,3]
          加入结果: [[],[1],[1,2],[1,2,3],[1,3]]
        回溯, path=[1]
    回溯, path=[]

  i=1, 选择2, path=[2]
    ... (类似过程)

  i=2, 选择3, path=[3]
    ... (类似过程)
```

---

## 方法二：迭代法

### 核心思想

从空集开始，每次遍历一个元素时，将该元素加入到所有已有子集中，生成新的子集。

### 代码实现

```go
func subsets(nums []int) [][]int {
    result := [][]int{{}} // 初始只有空集

    for _, num := range nums {
        // 遍历当前所有子集
        size := len(result)
        for i := 0; i < size; i++ {
            // 复制已有子集
            newSubset := make([]int, len(result[i]))
            copy(newSubset, result[i])

            // 添加当前元素，形成新子集
            newSubset = append(newSubset, num)
            result = append(result, newSubset)
        }
    }

    return result
}
```

### 执行过程详解

```
初始: result = [[]]

处理元素 1:
  现有子集: [[]]
  添加 1: [[1]]
  结果: [[], [1]]

处理元素 2:
  现有子集: [[], [1]]
  添加 2 到 []: [[2]]
  添加 2 到 [1]: [[1,2]]
  结果: [[], [1], [2], [1,2]]

处理元素 3:
  现有子集: [[], [1], [2], [1,2]]
  添加 3 到 []: [[3]]
  添加 3 到 [1]: [[1,3]]
  添加 3 到 [2]: [[2,3]]
  添加 3 到 [1,2]: [[1,2,3]]
  结果: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
```

---

## 方法三：位运算法

### 核心思想

用 n 位二进制数表示每个子集：
- 第 i 位为 1 表示选择 nums[i]
- 第 i 位为 0 表示不选择 nums[i]

例如 `[1,2,3]`：
```
000 (0) -> []
001 (1) -> [3]
010 (2) -> [2]
011 (3) -> [2,3]
100 (4) -> [1]
101 (5) -> [1,3]
110 (6) -> [1,2]
111 (7) -> [1,2,3]
```

### 代码实现

```go
func subsets(nums []int) [][]int {
    n := len(nums)
    result := [][]int{}

    // 遍历 0 到 2^n - 1
    for mask := 0; mask < (1 << n); mask++ {
        subset := []int{}

        // 检查每一位
        for i := 0; i < n; i++ {
            // 如果第 i 位是 1，选择 nums[i]
            if (mask >> i) & 1 == 1 {
                subset = append(subset, nums[i])
            }
        }

        result = append(result, subset)
    }

    return result
}
```

### 位运算解析

```go
// 对于 mask = 5 (二进制 101)，nums = [1,2,3]

i=0: (5 >> 0) & 1 = 101 & 1 = 1 → 选择 nums[0]=1
i=1: (5 >> 1) & 1 = 10 & 1 = 0  → 不选 nums[1]=2
i=2: (5 >> 2) & 1 = 1 & 1 = 1   → 选择 nums[2]=3

结果: [1, 3]
```

---

## 复杂度分析

### 时间复杂度：O(n × 2^n)

- 共有 2^n 个子集
- 每个子集平均长度为 n/2，复制需要 O(n) 时间
- 总时间：O(n × 2^n)

### 空间复杂度：O(n)

- 回溯法：递归栈深度 O(n)
- 迭代法：临时数组 O(n)
- 位运算法：临时数组 O(n)
- 不计算结果存储空间

---

## 关键要点总结

1. **子集数量**：n 个元素的子集总数为 2^n（包括空集和全集）

2. **回溯法要点**：
   - 每个递归节点都是有效子集（不只是叶子节点）
   - 使用 start 参数避免重复（保证组合而非排列）
   - 选择-递归-撤销三部曲

3. **迭代法要点**：
   - 动态扩展，每个元素依次加入已有子集
   - 需要记录当前子集数量，避免无限循环

4. **位运算法要点**：
   - 用二进制位表示元素选择状态
   - 遍历 0 到 2^n-1 的所有整数
   - 通过位运算检查每一位

5. **与全排列的区别**：
   - 子集是组合问题（无序）：`[1,2]` 和 `[2,1]` 视为同一子集
   - 全排列是排列问题（有序）：`[1,2]` 和 `[2,1]` 是不同排列

---

## 面试回答要点

**面试官：如何生成所有子集？**

**回答框架：**

"子集问题本质上是对每个元素做'选或不选'的决策，所以总共有 2^n 个子集。我会优先使用回溯法解决：

1. **回溯框架**：从第一个元素开始，每次决定是否选择当前元素，然后递归处理下一个
2. **关键细节**：使用 start 参数保证只向后选择，避免重复（比如避免既有 [1,2] 又有 [2,1]）
3. **收集结果**：与全排列不同，每个递归节点都是有效子集，不只是叶子节点

时间复杂度 O(n×2^n)，因为有 2^n 个子集，每个需要 O(n) 时间复制。

如果面试官要求非递归解法，我可以用迭代法：从空集开始，每处理一个元素，就将它加入所有已有子集生成新子集。

还有一个巧妙的位运算解法：用 n 位二进制的每一位表示对应元素选或不选，遍历 0 到 2^n-1 即可生成所有子集。"

---

## 扩展问题

### 1. 子集 II（LeetCode 90）- 包含重复元素

如果数组包含重复元素，如 `[1,2,2]`，如何避免重复子集？

**解法：** 先排序，回溯时跳过重复元素

```go
func subsetsWithDup(nums []int) [][]int {
    sort.Ints(nums) // 先排序
    result := [][]int{}
    path := []int{}

    var backtrack func(start int)
    backtrack = func(start int) {
        temp := make([]int, len(path))
        copy(temp, path)
        result = append(result, temp)

        for i := start; i < len(nums); i++ {
            // 跳过同层重复元素
            if i > start && nums[i] == nums[i-1] {
                continue
            }
            path = append(path, nums[i])
            backtrack(i + 1)
            path = path[:len(path)-1]
        }
    }

    backtrack(0)
    return result
}
```

### 2. 子集和问题

给定数组和目标值 target，找出所有和为 target 的子集？

**解法：** 回溯时加入和的判断

```go
func subsetSum(nums []int, target int) [][]int {
    result := [][]int{}
    path := []int{}

    var backtrack func(start, sum int)
    backtrack = func(start, sum int) {
        if sum == target {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        if sum > target {
            return // 剪枝
        }

        for i := start; i < len(nums); i++ {
            path = append(path, nums[i])
            backtrack(i+1, sum+nums[i])
            path = path[:len(path)-1]
        }
    }

    backtrack(0, 0)
    return result
}
```

### 3. 递增子序列（LeetCode 491）

找出数组中所有长度至少为 2 的递增子序列？

**解法：** 回溯 + 同层去重（使用 set）

---

## 三种方法对比总结

| 维度 | 回溯法 | 迭代法 | 位运算法 |
|------|--------|--------|----------|
| **代码复杂度** | 中等（递归逻辑） | 简单（双层循环） | 最简单 |
| **可读性** | 好（符合直觉） | 好（清晰直观） | 一般（需理解位运算） |
| **扩展性** | 强（易添加剪枝条件） | 中等 | 弱 |
| **空间效率** | 中（递归栈） | 好（无递归） | 好（无递归） |
| **适用场景** | 通用，面试推荐 | 教学、演示 | 代码竞赛 |

**面试推荐：** 优先使用回溯法，清晰易懂且便于处理变种问题。
