---
title: 从前序与中序遍历序列构造二叉树（LeetCode 105）
tags:
  - 算法
status: robot
class: 算法
slug: construct-binary-tree-from-preorder-and-inorder-traversal
ref:
---

## 核心要点

**问题本质**：利用前序和中序遍历的性质，递归重建二叉树。

**解题关键**：
1. 前序遍历特点：根节点 → 左子树 → 右子树（第一个元素是根）
2. 中序遍历特点：左子树 → 根节点 → 右子树（根节点分割左右子树）
3. 分治策略：找到根节点 → 划分左右子树 → 递归构造
4. 优化技巧：使用哈希表加速中序数组的查找

---

## 题目描述

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的**前序遍历**，`inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1：**
```
输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]

构造的树：
        3
       / \
      9  20
         / \
        15  7

输出：[3,9,20,null,null,15,7]
```

**示例 2：**
```
输入：preorder = [-1], inorder = [-1]
输出：[-1]
```

**约束条件：**
- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- `preorder` 和 `inorder` 均无重复元素
- `inorder` 均出现在 `preorder`
- `preorder` 保证为二叉树的前序遍历序列
- `inorder` 保证为二叉树的中序遍历序列

---

## 解题思路

### 核心原理

**前序遍历和中序遍历的性质**：

1. **前序遍历**：`[根节点, [左子树的前序遍历], [右子树的前序遍历]]`
   - 第一个元素一定是根节点

2. **中序遍历**：`[[左子树的中序遍历], 根节点, [右子树的中序遍历]]`
   - 根节点左边是左子树，右边是右子树

**算法步骤**：

```
示例：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]

步骤 1: 从前序遍历找到根节点
    preorder[0] = 3 → 根节点是 3

步骤 2: 在中序遍历中找到根节点的位置
    inorder 中 3 的位置是 index = 1
    左子树：inorder[0:1] = [9]
    右子树：inorder[2:5] = [15,20,7]

步骤 3: 根据左子树的大小，划分前序遍历
    左子树大小 = 1
    左子树：preorder[1:2] = [9]
    右子树：preorder[2:5] = [20,15,7]

步骤 4: 递归构造左右子树
    root.Left = buildTree([9], [9])
    root.Right = buildTree([20,15,7], [15,20,7])

步骤 5: 继续递归...
    右子树的根是 20
    在 [15,20,7] 中找到 20 的位置 = 1
    20的左子树 = [15]
    20的右子树 = [7]
```

---

## 代码实现

### 方法一：递归 + 哈希表优化

#### Go 实现

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {
    // 构建中序遍历的值到索引的映射，加速查找
    inorderMap := make(map[int]int)
    for i, val := range inorder {
        inorderMap[val] = i
    }

    return build(preorder, 0, len(preorder)-1, inorder, 0, len(inorder)-1, inorderMap)
}

func build(preorder []int, preStart, preEnd int, inorder []int, inStart, inEnd int, inorderMap map[int]int) *TreeNode {
    // 递归终止条件
    if preStart > preEnd || inStart > inEnd {
        return nil
    }

    // 前序遍历的第一个元素是根节点
    rootVal := preorder[preStart]
    root := &TreeNode{Val: rootVal}

    // 在中序遍历中找到根节点的位置
    inRootIndex := inorderMap[rootVal]

    // 计算左子树的节点数量
    leftSize := inRootIndex - inStart

    // 递归构造左子树
    // 前序：[preStart+1, preStart+leftSize]
    // 中序：[inStart, inRootIndex-1]
    root.Left = build(preorder, preStart+1, preStart+leftSize, inorder, inStart, inRootIndex-1, inorderMap)

    // 递归构造右子树
    // 前序：[preStart+leftSize+1, preEnd]
    // 中序：[inRootIndex+1, inEnd]
    root.Right = build(preorder, preStart+leftSize+1, preEnd, inorder, inRootIndex+1, inEnd, inorderMap)

    return root
}
```

#### Python 实现

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        # 构建中序遍历的值到索引的映射
        inorder_map = {val: i for i, val in enumerate(inorder)}

        def build(pre_start, pre_end, in_start, in_end):
            # 递归终止条件
            if pre_start > pre_end or in_start > in_end:
                return None

            # 前序遍历的第一个元素是根节点
            root_val = preorder[pre_start]
            root = TreeNode(root_val)

            # 在中序遍历中找到根节点的位置
            in_root_index = inorder_map[root_val]

            # 计算左子树的节点数量
            left_size = in_root_index - in_start

            # 递归构造左右子树
            root.left = build(pre_start + 1, pre_start + left_size,
                             in_start, in_root_index - 1)
            root.right = build(pre_start + left_size + 1, pre_end,
                              in_root_index + 1, in_end)

            return root

        return build(0, len(preorder) - 1, 0, len(inorder) - 1)
```

#### Java 实现

```java
class Solution {
    private Map<Integer, Integer> inorderMap;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 构建中序遍历的值到索引的映射
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }

        return build(preorder, 0, preorder.length - 1,
                     inorder, 0, inorder.length - 1);
    }

    private TreeNode build(int[] preorder, int preStart, int preEnd,
                          int[] inorder, int inStart, int inEnd) {
        // 递归终止条件
        if (preStart > preEnd || inStart > inEnd) {
            return null;
        }

        // 前序遍历的第一个元素是根节点
        int rootVal = preorder[preStart];
        TreeNode root = new TreeNode(rootVal);

        // 在中序遍历中找到根节点的位置
        int inRootIndex = inorderMap.get(rootVal);

        // 计算左子树的节点数量
        int leftSize = inRootIndex - inStart;

        // 递归构造左右子树
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                         inorder, inStart, inRootIndex - 1);
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                          inorder, inRootIndex + 1, inEnd);

        return root;
    }
}
```

---

### 方法二：迭代法（栈）

这是一种更优雅但理解难度较高的解法。

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }

    root := &TreeNode{Val: preorder[0]}
    stack := []*TreeNode{root}
    inorderIndex := 0

    for i := 1; i < len(preorder); i++ {
        preorderVal := preorder[i]
        node := stack[len(stack)-1]

        if node.Val != inorder[inorderIndex] {
            // 当前节点的左子树
            node.Left = &TreeNode{Val: preorderVal}
            stack = append(stack, node.Left)
        } else {
            // 找到需要开始构建右子树的节点
            for len(stack) > 0 && stack[len(stack)-1].Val == inorder[inorderIndex] {
                node = stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                inorderIndex++
            }
            // 构建右子树
            node.Right = &TreeNode{Val: preorderVal}
            stack = append(stack, node.Right)
        }
    }

    return root
}
```

---

## 复杂度分析

### 方法一：递归 + 哈希表
- **时间复杂度**：O(n)
  - 每个节点访问一次
  - 哈希表查找 O(1)

- **空间复杂度**：O(n)
  - 哈希表存储 n 个元素：O(n)
  - 递归栈深度：O(h)，最坏 O(n)

### 方法二：迭代法
- **时间复杂度**：O(n)
  - 每个节点访问一次

- **空间复杂度**：O(n)
  - 栈的最大深度为树的高度

---

## 关键细节与易错点

### 1. 索引划分是核心难点

**关键变量**：
- `inRootIndex`：根节点在中序数组中的位置
- `leftSize`：左子树的节点数量 = `inRootIndex - inStart`

**左子树的划分**：
```
前序：[preStart+1, preStart+leftSize]
中序：[inStart, inRootIndex-1]
```

**右子树的划分**：
```
前序：[preStart+leftSize+1, preEnd]
中序：[inRootIndex+1, inEnd]
```

**图解**：
```
preorder = [3, 9, 20, 15, 7]
            ↑  ↑   ↑
            根 左  右子树起点

inorder = [9, 3, 15, 20, 7]
           ↑  ↑   ↑
          左  根  右子树起点

左子树大小 = 1（inRootIndex - inStart = 1 - 0）
```

### 2. 为什么需要哈希表？

**不使用哈希表**：
```go
// 每次都要遍历中序数组找根节点
for i := inStart; i <= inEnd; i++ {
    if inorder[i] == rootVal {
        inRootIndex = i
        break
    }
}
// 时间复杂度：O(n²)
```

**使用哈希表**：
```go
inRootIndex := inorderMap[rootVal] // O(1)
// 时间复杂度：O(n)
```

### 3. 边界条件检查

```go
// 正确的终止条件
if preStart > preEnd || inStart > inEnd {
    return nil
}

// 错误示例：
if preStart >= preEnd {  // ❌ 单节点时 preStart == preEnd 也要处理
    return nil
}
```

---

## 变体题目

### 变体 1：从中序与后序遍历序列构造二叉树（LeetCode 106）

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
    inorderMap := make(map[int]int)
    for i, val := range inorder {
        inorderMap[val] = i
    }

    return build(inorder, 0, len(inorder)-1, postorder, 0, len(postorder)-1, inorderMap)
}

func build(inorder []int, inStart, inEnd int, postorder []int, postStart, postEnd int, inorderMap map[int]int) *TreeNode {
    if inStart > inEnd || postStart > postEnd {
        return nil
    }

    // 后序遍历的最后一个元素是根节点
    rootVal := postorder[postEnd]
    root := &TreeNode{Val: rootVal}

    inRootIndex := inorderMap[rootVal]
    leftSize := inRootIndex - inStart

    // 左子树
    root.Left = build(inorder, inStart, inRootIndex-1,
                     postorder, postStart, postStart+leftSize-1, inorderMap)

    // 右子树
    root.Right = build(inorder, inRootIndex+1, inEnd,
                      postorder, postStart+leftSize, postEnd-1, inorderMap)

    return root
}
```

### 变体 2：验证前序和中序是否匹配

```go
func isValid(preorder []int, inorder []int) bool {
    if len(preorder) != len(inorder) {
        return false
    }

    // 构建哈希表检查元素是否一致
    inorderSet := make(map[int]bool)
    for _, val := range inorder {
        inorderSet[val] = true
    }

    for _, val := range preorder {
        if !inorderSet[val] {
            return false
        }
    }

    return true
}
```

### 变体 3：只通过前序和后序构造二叉树

**注意**：前序 + 后序**无法唯一确定**一棵二叉树（除非是满二叉树）。

```go
// LeetCode 889：只能构造所有可能的树之一
func constructFromPrePost(preorder []int, postorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }

    root := &TreeNode{Val: preorder[0]}
    if len(preorder) == 1 {
        return root
    }

    // 前序的第二个元素是左子树的根
    leftRootVal := preorder[1]

    // 在后序中找到左子树根的位置
    var leftSize int
    for i := 0; i < len(postorder); i++ {
        if postorder[i] == leftRootVal {
            leftSize = i + 1
            break
        }
    }

    root.Left = constructFromPrePost(preorder[1:1+leftSize], postorder[:leftSize])
    root.Right = constructFromPrePost(preorder[1+leftSize:], postorder[leftSize:len(postorder)-1])

    return root
}
```

---

## 面试技巧

### 1. 思路表达

"这道题的核心是利用**前序和中序遍历的性质**：

1. **前序遍历的第一个元素是根节点**
2. **在中序遍历中找到根节点，可以划分左右子树**
3. **根据左子树的大小，再划分前序数组**
4. **递归构造左右子树**

为了优化查找速度，我会用**哈希表**存储中序数组的值到索引的映射，将时间复杂度从 O(n²) 降到 O(n)。"

### 2. 画图说明

面试时建议画图：
```
preorder = [3, 9, 20, 15, 7]
            ↑  ←左→ ←--右--→

inorder = [9, 3, 15, 20, 7]
          ←左→ ↑ ←---右---→

步骤：
1. preorder[0] = 3 → 根节点
2. 在 inorder 中找到 3 的位置 = 1
3. 左子树大小 = 1，右子树大小 = 3
4. 递归处理 [9] 和 [20,15,7]
```

### 3. 追问准备

**面试官可能问**：

Q: "如果是中序 + 后序呢？"
A: "后序遍历的**最后一个元素**是根节点，其余逻辑类似。"

Q: "如果数组中有重复元素呢？"
A: "题目保证无重复。如果有重复，需要额外信息（如节点 ID）才能唯一确定树。"

Q: "能否不用哈希表？"
A: "可以，但每次都要遍历中序数组找根节点，时间复杂度变为 O(n²)。"

---

## 典型错误示例

### 错误 1：索引计算错误

```go
// ❌ 错误：右子树的起点计算错误
root.Right = build(preorder, preStart+leftSize, preEnd, ...)
// 应该是 preStart+leftSize+1（跳过根节点和左子树）
```

### 错误 2：忘记边界检查

```go
// ❌ 错误：没有检查边界
func build(...) *TreeNode {
    rootVal := preorder[preStart] // 可能越界
    ...
}

// ✅ 正确
func build(...) *TreeNode {
    if preStart > preEnd {
        return nil
    }
    ...
}
```

### 错误 3：哈希表没有预处理

```go
// ❌ 错误：每次递归都重新构建哈希表
func build(...) *TreeNode {
    inorderMap := make(map[int]int) // 重复构建
    for i, val := range inorder {
        inorderMap[val] = i
    }
    ...
}

// ✅ 正确：在外层函数构建一次，传入递归函数
```

---

## 调试技巧

如果结果不对，检查以下几点：

1. **打印每次递归的区间**：
```go
fmt.Printf("preorder[%d:%d] = %v\n", preStart, preEnd+1, preorder[preStart:preEnd+1])
fmt.Printf("inorder[%d:%d] = %v\n", inStart, inEnd+1, inorder[inStart:inEnd+1])
```

2. **检查 leftSize 的计算**：
```go
fmt.Printf("rootVal=%d, inRootIndex=%d, leftSize=%d\n", rootVal, inRootIndex, leftSize)
```

3. **验证递归边界**：
```go
if preStart > preEnd {
    fmt.Println("Empty range, returning nil")
    return nil
}
```

---

## 总结

这道题是**分治算法 + 递归**的经典应用，考察：

1. **遍历性质理解**：前序、中序、后序的定义和特点
2. **索引计算能力**：如何正确划分数组区间
3. **优化意识**：使用哈希表优化查找
4. **递归思维**：将大问题分解为小问题

**记忆口诀**：
- 前序找根在最前，中序切分左右边
- 左子大小是关键，递归构造莫等闲

掌握这道题后，可以轻松应对中序+后序、前序+后序等变体问题。核心都是**利用遍历的性质找到根节点和划分子树**。
