---
title: 括号生成（LeetCode 22）
tags:
  - 算法
status: robot
class: 算法
slug: generate-parentheses
ref:
---

## 核心要点

**回溯算法 + 剪枝**：通过左右括号计数器控制生成过程，左括号优先，右括号数量不超过左括号，时间复杂度 O(4^n / √n)

---

## 题目描述

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且**有效的**括号组合。

**示例：**
```
输入: n = 3
输出: ["((()))","(()())","(())()","()(())","()()()"]

输入: n = 1
输出: ["()"]

输入: n = 2
输出: ["(())","()()"]
```

---

## 解题思路

### 思路分析

这是一道经典的**回溯算法**问题，核心在于理解括号的合法性规则：

1. **合法条件**：
   - 任意前缀中，左括号数量 ≥ 右括号数量
   - 最终左右括号数量相等（都是 n 个）

2. **回溯策略**：
   - 优先添加左括号（只要左括号数 < n）
   - 当右括号数 < 左括号数时，才能添加右括号

3. **剪枝优化**：
   - 左括号数超过 n → 剪枝
   - 右括号数超过左括号数 → 剪枝（会导致非法组合）

### 决策树示例（n = 2）

```
                    ""
                 /      \
              "("         X（右括号无法先放）
            /     \
         "(("      "()"
         /          /  \
      "(()"      "()("  X（右括号数不能超过左括号数）
       /           /
    "(())"      "()()"
```

---

## 代码实现

### 方法一：回溯（推荐）

```go
func generateParenthesis(n int) []string {
    result := []string{}

    // 回溯函数
    // current: 当前构建的括号字符串
    // left: 已使用的左括号数量
    // right: 已使用的右括号数量
    var backtrack func(current string, left, right int)
    backtrack = func(current string, left, right int) {
        // 终止条件：左右括号都用完
        if left == n && right == n {
            result = append(result, current)
            return
        }

        // 选择1：添加左括号（只要还没用完）
        if left < n {
            backtrack(current+"(", left+1, right)
        }

        // 选择2：添加右括号（前提：右括号数 < 左括号数）
        if right < left {
            backtrack(current+")", left, right+1)
        }
    }

    backtrack("", 0, 0)
    return result
}
```

### 方法二：回溯（使用 StringBuilder 优化）

```go
func generateParenthesis(n int) []string {
    result := []string{}
    path := make([]byte, 0, 2*n) // 预分配空间

    var backtrack func(left, right int)
    backtrack = func(left, right int) {
        // 终止条件
        if left == n && right == n {
            result = append(result, string(path))
            return
        }

        // 添加左括号
        if left < n {
            path = append(path, '(')
            backtrack(left+1, right)
            path = path[:len(path)-1] // 回溯
        }

        // 添加右括号
        if right < left {
            path = append(path, ')')
            backtrack(left, right+1)
            path = path[:len(path)-1] // 回溯
        }
    }

    backtrack(0, 0)
    return result
}
```

### 方法三：动态规划（高级）

```go
func generateParenthesis(n int) []string {
    if n == 0 {
        return []string{""}
    }

    // dp[i] 表示 i 对括号的所有组合
    dp := make([][]string, n+1)
    dp[0] = []string{""}

    // 状态转移：dp[i] = "(" + dp[j] + ")" + dp[i-1-j]
    // 其中 j 表示第一对括号内包含的对数
    for i := 1; i <= n; i++ {
        dp[i] = []string{}
        for j := 0; j < i; j++ {
            // 第一对括号内有 j 对，外部剩余 i-1-j 对
            for _, left := range dp[j] {
                for _, right := range dp[i-1-j] {
                    dp[i] = append(dp[i], "("+left+")"+right)
                }
            }
        }
    }

    return dp[n]
}
```

---

## 关键代码说明

### 回溯方法

1. **参数设计**（第5-7行）：
   - `current`：当前构建的字符串
   - `left`：已添加的左括号数量
   - `right`：已添加的右括号数量

2. **终止条件**（第10-13行）：
   - `left == n && right == n`：所有括号都已使用

3. **剪枝条件**：
   - 第16行：`left < n` 才能添加左括号
   - 第21行：`right < left` 才能添加右括号（保证合法性）

4. **回溯过程**：
   - 递归调用时传入新的状态（字符串 + 计数器）
   - 方法一中字符串拼接会创建新对象，自动回溯
   - 方法二显式回溯（删除最后一个字符）

### 动态规划方法

**核心思想**：将问题分解为子问题
- `dp[i]` = 所有 i 对括号的组合
- 对于每个 `i`，枚举第一对括号内包含的对数 `j`：
  - 第一对括号内：`dp[j]`
  - 第一对括号外：`dp[i-1-j]`
  - 组合形式：`"(" + dp[j] + ")" + dp[i-1-j]`

**示例（n = 3）**：
```
dp[0] = [""]
dp[1] = ["()"]
dp[2] = ["()()", "(())"]
dp[3] = ["()()()", "()(())", "(())()", "(()())", "((()))"]
```

---

## 复杂度分析

### 回溯方法
- **时间复杂度**：O(4^n / √n)
  - 这是卡特兰数 C(n) = (2n)! / ((n+1)! * n!) 的渐进上界
  - 有效括号组合数量为第 n 个卡特兰数
  - 每个组合需要 O(n) 时间构建字符串

- **空间复杂度**：O(n)
  - 递归栈深度：O(n)（最多递归 2n 层）
  - 不计结果集的空间

### 动态规划方法
- **时间复杂度**：O(4^n / √n)
  - 需要生成所有卡特兰数个组合
  - 每个组合的构建是 O(n)

- **空间复杂度**：O(4^n / √n)
  - 需要存储所有中间状态的 dp 数组

---

## 测试用例

```go
func main() {
    // 测试用例1: n = 1
    fmt.Println(generateParenthesis(1))
    // 输出: ["()"]

    // 测试用例2: n = 2
    fmt.Println(generateParenthesis(2))
    // 输出: ["(())", "()()"]

    // 测试用例3: n = 3
    fmt.Println(generateParenthesis(3))
    // 输出: ["((()))", "(()())", "(())()", "()(())", "()()()"]

    // 测试用例4: n = 0
    fmt.Println(generateParenthesis(0))
    // 输出: [""]

    // 测试用例5: n = 4（验证算法效率）
    result := generateParenthesis(4)
    fmt.Printf("n=4 生成 %d 种组合\n", len(result))
    // 输出: n=4 生成 14 种组合（卡特兰数）
}
```

---

## 面试要点

1. **如何保证括号的合法性？**
   - 核心规则：任意时刻，右括号数量不能超过左括号数量
   - 实现方式：在添加右括号前检查 `right < left`

2. **为什么可以剪枝？**
   - 左括号超过 n：后续无法形成合法组合
   - 右括号超过左括号：违反合法性规则

3. **回溯和动态规划如何选择？**
   - 回溯：代码简洁，空间复杂度低，面试首选
   - 动态规划：适合需要缓存中间结果的场景

4. **时间复杂度为什么是 O(4^n / √n)？**
   - 卡特兰数 C(n) ≈ 4^n / (n^(3/2) * √π)
   - 生成每个组合需要 O(n) 时间
   - 总复杂度为 C(n) * O(n)

5. **卡特兰数的应用场景？**
   - 有效括号组合数
   - 出栈序列数
   - 二叉搜索树的数量
   - 凸多边形三角剖分数

6. **如何优化字符串拼接？**
   - 方法一：直接拼接（Go 会自动优化）
   - 方法二：使用 `[]byte` 手动管理，显式回溯

---

## 算法原理详解

### 回溯的本质

回溯算法是一种**试探性搜索**：
1. **做选择**：添加左括号或右括号
2. **递归**：处理剩余部分
3. **撤销选择**：回到选择前的状态（显式或隐式）

### 决策树剪枝

```
n = 2 的完整决策树：

                    (left=0, right=0)
                    /               \
         (left=1, right=0)         (left=0, right=1) [剪枝]
         /                \
(left=2, right=0)   (left=1, right=1)
      /                    \
(left=2, right=1)     (left=2, right=1)
      |                     |
(left=2, right=2)     (left=2, right=2)
   "(())"                 "()()"
```

### 卡特兰数递推公式

```
C(0) = 1
C(n) = C(0)*C(n-1) + C(1)*C(n-2) + ... + C(n-1)*C(0)
```

对应动态规划的状态转移方程。

---

## 相关题目

- LeetCode 20: 有效的括号（用栈验证合法性）
- LeetCode 32: 最长有效括号（动态规划/栈）
- LeetCode 301: 删除无效的括号（BFS/回溯）
- LeetCode 241: 为运算表达式设计优先级（分治 + 卡特兰数）
- LeetCode 96: 不同的二叉搜索树（卡特兰数应用）
