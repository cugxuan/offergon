---
title: LRU 缓存(LeetCode 146)
tags:
  - 算法
  - 缓存策略
status: robot
class: 算法
slug: lru-cache-leetcode-146
ref:
---

## 核心要点

**哈希表+双向链表实现 O(1) 操作**：哈希表提供 O(1) 查找,双向链表维护访问顺序(头部最新,尾部最旧)。get 和 put 操作都需要先查找节点,然后移动到链表头部,淘汰时删除尾部节点。

---

## 题目描述

请你设计并实现一个满足 LRU (Least Recently Used,最近最少使用) 缓存约束的数据结构。

实现 `LRUCache` 类:

- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中,则返回关键字的值,否则返回 `-1`
- `void put(int key, int value)` 如果关键字 `key` 已经存在,则变更其数据值 `value`;如果不存在,则向缓存中插入该组 `key-value`。如果插入操作导致关键字数量超过 `capacity`,则应该**逐出**最久未使用的关键字

**要求:**

函数 `get` 和 `put` 必须以 O(1) 的平均时间复杂度运行。

**示例:**

```
输入:
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

输出:
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释:
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废,缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废,缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

---

## 解题思路

### 核心思想

LRU 缓存需要同时满足两个要求:

1. **O(1) 查找:** 需要快速判断 key 是否存在并获取 value
2. **O(1) 更新顺序:** 需要快速移动节点到最前面,以及删除最久未使用的节点

这两个要求分别对应:
- **哈希表:** 提供 O(1) 的 key 到节点的映射
- **双向链表:** 维护访问顺序,支持 O(1) 的插入、删除和移动

**数据结构设计:**

```
哈希表: key -> 链表节点
双向链表: dummy_head ⇄ node1 ⇄ node2 ⇄ ... ⇄ dummy_tail

链表顺序: 头部(最新访问) -> 尾部(最久未访问)
```

**关键操作:**

1. **get(key):**
   - 在哈希表中查找节点
   - 如果存在,将节点移到链表头部(标记为最近使用)
   - 返回节点的 value

2. **put(key, value):**
   - 如果 key 已存在,更新 value,并移到链表头部
   - 如果 key 不存在:
     - 创建新节点,插入到链表头部
     - 如果超过容量,删除链表尾部节点(最久未使用)
     - 更新哈希表

---

## 代码实现

### Go 实现

```go
// 双向链表节点
type DLinkedNode struct {
    key, value int
    prev, next *DLinkedNode
}

type LRUCache struct {
    capacity   int
    size       int
    cache      map[int]*DLinkedNode
    head, tail *DLinkedNode
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*DLinkedNode),
        head:     &DLinkedNode{}, // 虚拟头节点
        tail:     &DLinkedNode{}, // 虚拟尾节点
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        // 节点存在,移到头部
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        // 节点已存在,更新值并移到头部
        node.value = value
        this.moveToHead(node)
    } else {
        // 节点不存在,创建新节点
        newNode := &DLinkedNode{key: key, value: value}
        this.cache[key] = newNode
        this.addToHead(newNode)
        this.size++

        // 检查是否超过容量
        if this.size > this.capacity {
            // 删除尾部节点
            removed := this.removeTail()
            delete(this.cache, removed.key)
            this.size--
        }
    }
}

// 将节点添加到头部(head 之后)
func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

// 删除节点
func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

// 将节点移到头部
func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

// 删除尾部节点(tail 之前的节点)
func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
```

**时间复杂度:**
- `get`: O(1) - 哈希表查找 + 链表操作
- `put`: O(1) - 哈希表操作 + 链表操作

**空间复杂度:** O(capacity) - 哈希表和链表存储最多 capacity 个节点

---

## 关键细节

### 1. 为什么使用虚拟头尾节点?

虚拟节点(dummy node)简化了边界条件处理:

```go
// 不使用虚拟节点:需要处理头尾为空的情况
if head == nil {
    head = newNode
    tail = newNode
} else {
    // 插入逻辑
}

// 使用虚拟节点:统一处理,无需特判
head.next = newNode
newNode.prev = head
```

### 2. 双向链表的操作顺序

**添加到头部的正确顺序:**

```go
// 错误顺序可能导致链表断裂
node.prev = this.head
node.next = this.head.next
this.head.next.prev = node  // 必须在修改 head.next 之前
this.head.next = node
```

**删除节点的操作:**

```go
// 同时修改前后节点的指针
node.prev.next = node.next
node.next.prev = node.prev
```

### 3. 哈希表存储的是节点指针

哈希表存储的是 `*DLinkedNode` 指针,而不是值:

```go
cache map[int]*DLinkedNode  // 正确:存储指针
// cache map[int]DLinkedNode  // 错误:存储值会导致无法修改链表
```

### 4. moveToHead 的实现

移动节点到头部分为两步:
1. 从当前位置删除节点
2. 添加到头部

```go
func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)  // 先删除
    this.addToHead(node)   // 再添加
}
```

---

## 图解示例

假设 capacity = 2,执行以下操作:

```
初始状态:
head ⇄ tail
cache = {}

put(1, 1):
head ⇄ [1:1] ⇄ tail
cache = {1: node1}

put(2, 2):
head ⇄ [2:2] ⇄ [1:1] ⇄ tail
cache = {1: node1, 2: node2}

get(1): 返回 1,将 node1 移到头部
head ⇄ [1:1] ⇄ [2:2] ⇄ tail
cache = {1: node1, 2: node2}

put(3, 3): 容量已满,删除尾部的 node2,添加 node3
head ⇄ [3:3] ⇄ [1:1] ⇄ tail
cache = {1: node1, 3: node3}

get(2): 返回 -1 (不存在)
```

---

## 易错点与注意事项

1. **忘记更新哈希表:** put 操作删除节点时,必须同时从哈希表中删除
2. **链表操作顺序错误:** 修改指针时顺序不对会导致链表断裂
3. **移动节点时忘记删除:** moveToHead 必须先删除节点再添加,否则形成环
4. **size 计数错误:** 需要正确维护 size,尤其是删除节点时要减少计数
5. **虚拟节点的初始化:** head.next = tail 和 tail.prev = head 不能忘记

---

## 面试技巧

**面试官可能的追问:**

1. **为什么不用单向链表?**
   - 答:单向链表无法 O(1) 删除节点。删除节点需要找到前驱节点,需要 O(n) 时间。双向链表的 prev 指针解决了这个问题。

2. **能否用 OrderedDict 或内置的数据结构?**
   - 答:某些语言(如 Python)提供了 OrderedDict,可以简化实现。但面试中通常要求手动实现底层数据结构。

3. **如果需要支持 TTL(过期时间)怎么办?**
   - 答:可以在节点中增加 expireTime 字段,在 get 和 put 时检查是否过期。可以用额外的小顶堆或定时器清理过期节点。

4. **如何实现 LFU(Least Frequently Used) 缓存?**
   - 答:需要维护频率计数。可以用哈希表 + 多个双向链表(按频率分组),或用哈希表 + 小顶堆。

5. **并发环境下如何保证线程安全?**
   - 答:需要加锁(mutex)保护 get 和 put 操作。可以使用读写锁优化读操作的并发性能。

6. **内存占用优化?**
   - 答:双向链表每个节点需要存储 prev 和 next 指针。如果 value 很小,指针开销会很大。可以考虑用数组实现循环队列 + 哈希表,减少指针开销。

---

## 方法对比

| 实现方式 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|----------|------------|------------|------|------|
| 哈希表+双向链表 | O(1) | O(n) | 最优解,符合要求 | 实现较复杂 |
| 数组+线性查找 | O(n) | O(n) | 实现简单 | 不满足 O(1) 要求 |
| 单链表+哈希表 | O(n) 删除 | O(n) | 较简单 | 删除操作不是 O(1) |

---

## 总结

LRU 缓存是考察**数据结构组合设计能力**的经典题目。最优解法是**哈希表 + 双向链表**:

- **哈希表:** 提供 O(1) 的 key 查找
- **双向链表:** 维护访问顺序,支持 O(1) 的插入、删除、移动
- **虚拟头尾节点:** 简化边界条件处理

**实现要点:**

1. 双向链表节点包含 key、value、prev、next
2. 头部存储最近访问的节点,尾部存储最久未访问的节点
3. get 操作:查找节点,移到头部,返回 value
4. put 操作:更新或插入节点,超过容量时删除尾部节点

这道题在面试中经常出现,能够完整实现并处理好所有细节(虚拟节点、指针操作顺序、哈希表同步更新)会给面试官留下深刻印象。建议多次手写实现,熟练掌握链表操作和边界条件处理。
