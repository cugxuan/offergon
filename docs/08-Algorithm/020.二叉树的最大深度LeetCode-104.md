---
title: 二叉树的最大深度（LeetCode 104）
tags:
  - 算法
status: robot
class: 算法
slug: binary-tree-maximum-depth
ref:
---

## 核心要点

**递归求解:深度 = 1 + max(左子树深度, 右子树深度)**：这是最简洁优雅的解法。空节点深度为 0,非空节点深度为左右子树最大深度加 1。也可用 BFS 层序遍历计数层数。

---

## 题目描述

给定一个二叉树,找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3
```

---

## 解题思路

### 方法一:递归 DFS(推荐)

**核心思想:**

二叉树的深度可以递归定义:

- 空节点的深度为 0
- 非空节点的深度 = 1(当前节点) + max(左子树深度, 右子树深度)

这是典型的**自底向上**的递归思路:先计算子问题(左右子树深度),再根据子问题结果计算当前问题。

**图解过程:**

```
    3           深度 3
   / \
  9  20         深度 2
    /  \
   15   7       深度 1

递归过程:
1. maxDepth(3) = 1 + max(maxDepth(9), maxDepth(20))
2. maxDepth(9) = 1 + max(0, 0) = 1
3. maxDepth(20) = 1 + max(maxDepth(15), maxDepth(7))
4. maxDepth(15) = 1 + max(0, 0) = 1
5. maxDepth(7) = 1 + max(0, 0) = 1
6. maxDepth(20) = 1 + max(1, 1) = 2
7. maxDepth(3) = 1 + max(1, 2) = 3
```

**代码实现(Go):**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    // 基础情况:空节点深度为 0
    if root == nil {
        return 0
    }

    // 递归计算左右子树深度
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)

    // 当前节点深度 = 1 + 左右子树最大深度
    return 1 + max(leftDepth, rightDepth)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**简化版本:**

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))
}
```

**时间复杂度:** O(n),每个节点访问一次
**空间复杂度:** O(h),递归调用栈的深度,h 为树的高度。平衡树为 O(log n),最坏情况(链状树)为 O(n)

---

### 方法二:BFS 层序遍历

**核心思想:**

使用 BFS 层序遍历,统计总共有多少层,层数就是最大深度。

**代码实现(Go):**

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    queue := []*TreeNode{root}
    depth := 0

    for len(queue) > 0 {
        levelSize := len(queue)
        depth++  // 处理一层,深度加 1

        // 处理当前层的所有节点
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            // 将下一层节点加入队列
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }

    return depth
}
```

**时间复杂度:** O(n),每个节点访问一次
**空间复杂度:** O(n),队列最多存储一层的节点数,完全二叉树的最后一层约为 n/2

---

### 方法三:DFS 迭代(使用栈)

**核心思想:**

使用栈模拟递归过程,同时记录每个节点的深度。

**代码实现(Go):**

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    // 栈中存储 (节点, 深度) 对
    type pair struct {
        node  *TreeNode
        depth int
    }

    stack := []pair{{root, 1}}
    maxDepth := 0

    for len(stack) > 0 {
        // 出栈
        p := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        node, depth := p.node, p.depth

        // 更新最大深度
        if depth > maxDepth {
            maxDepth = depth
        }

        // 将子节点及其深度入栈
        if node.Left != nil {
            stack = append(stack, pair{node.Left, depth + 1})
        }
        if node.Right != nil {
            stack = append(stack, pair{node.Right, depth + 1})
        }
    }

    return maxDepth
}
```

**时间复杂度:** O(n)
**空间复杂度:** O(n),栈的大小

---

## 关键细节

### 1. 递归终止条件

```go
if root == nil {
    return 0
}
```

空节点的深度为 0,这是递归的基础情况。不要写成 `return -1` 或其他值。

### 2. 深度 vs 高度

- **深度(Depth):** 从根节点到当前节点的路径长度(边数)或节点数
- **高度(Height):** 从当前节点到最远叶子节点的路径长度

对于根节点:
- 按边数计算:深度 = 高度
- 按节点数计算:深度 = 高度

**本题定义:** 深度是节点数,所以单个根节点的深度为 1。

### 3. 最大深度 vs 最小深度

- **最大深度:** 根节点到最远叶子节点的路径节点数
- **最小深度(LeetCode 111):** 根节点到最近叶子节点的路径节点数

最小深度的递归式有所不同:

```go
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    // 关键:如果一侧为空,不能取 min,而是取非空的一侧
    if root.Left == nil {
        return 1 + minDepth(root.Right)
    }
    if root.Right == nil {
        return 1 + minDepth(root.Left)
    }

    return 1 + min(minDepth(root.Left), minDepth(root.Right))
}
```

---

## 易错点与注意事项

1. **空树处理:** 空树深度为 0,不是 -1 或 1
2. **递归返回值:** 确保返回 `1 + max(...)`,不要忘记加 1(当前节点)
3. **最小深度的陷阱:** 最小深度不能简单地将 max 改为 min,需要特判单侧为空的情况
4. **深度定义:** 确认题目要求的是节点数还是边数(本题是节点数)

---

## 相关题目

### 1. 二叉树的最小深度(LeetCode 111)

找到最近的叶子节点的深度。

**关键区别:** 需要特判单侧子树为空的情况,不能简单取 min。

### 2. 平衡二叉树(LeetCode 110)

判断二叉树是否平衡(任意节点的左右子树高度差不超过 1)。

**思路:** 在计算深度的同时,检查左右子树高度差。

```go
func isBalanced(root *TreeNode) bool {
    var check func(*TreeNode) int
    check = func(node *TreeNode) int {
        if node == nil {
            return 0
        }

        leftHeight := check(node.Left)
        if leftHeight == -1 {
            return -1  // 左子树不平衡
        }

        rightHeight := check(node.Right)
        if rightHeight == -1 {
            return -1  // 右子树不平衡
        }

        // 检查当前节点是否平衡
        if abs(leftHeight-rightHeight) > 1 {
            return -1
        }

        return 1 + max(leftHeight, rightHeight)
    }

    return check(root) != -1
}
```

### 3. N 叉树的最大深度(LeetCode 559)

N 叉树的深度。

**思路:** 遍历所有子节点,取最大深度加 1。

```go
func maxDepth(root *Node) int {
    if root == nil {
        return 0
    }

    maxChildDepth := 0
    for _, child := range root.Children {
        childDepth := maxDepth(child)
        if childDepth > maxChildDepth {
            maxChildDepth = childDepth
        }
    }

    return 1 + maxChildDepth
}
```

---

## 面试技巧

**面试官可能的追问:**

1. **能否不用递归实现?**
   - 答:可以,使用 BFS 层序遍历统计层数,或用 DFS 迭代(栈)记录每个节点的深度。

2. **时间和空间复杂度?**
   - 答:递归方法时间 O(n),空间 O(h)(递归栈);BFS 方法时间 O(n),空间 O(n)(队列)。

3. **如果树非常深(百万层),递归会不会栈溢出?**
   - 答:会。可以用 BFS 或 DFS 迭代方法避免递归栈溢出。

4. **如何求最小深度?**
   - 答:需要特判单侧子树为空的情况。如果只有一侧子树,必须走非空的一侧;如果两侧都有子树,才取 min。

5. **如何判断是否平衡二叉树?**
   - 答:在计算深度的同时,检查每个节点的左右子树高度差是否不超过 1。如果不平衡,用特殊值(-1)提前返回。

6. **递归和 BFS 哪个更好?**
   - 答:递归代码最简洁,适合面试;BFS 更直观,空间占用可能更大。如果树很深,BFS 更安全(避免栈溢出)。

---

## 方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 递归 DFS | O(n) | O(h) | 代码简洁,优雅 | 深树可能栈溢出 |
| BFS 层序遍历 | O(n) | O(n) | 直观,不会栈溢出 | 空间占用大 |
| DFS 迭代 | O(n) | O(n) | 不会栈溢出 | 代码稍复杂 |

---

## 总结

二叉树的最大深度是递归的经典入门题。**递归解法**是最佳答案:

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))
}
```

**核心理解:**

1. **递归定义:** 树的深度 = 1 + 左右子树最大深度
2. **基础情况:** 空节点深度为 0
3. **递归关系:** 当前问题依赖子问题(左右子树深度)

这道题体现了递归思想的精髓:**将复杂问题分解为相同结构的子问题**。掌握这道题后,可以轻松应对最小深度、N 叉树深度、平衡二叉树等变体题目。

**面试建议:**

1. 先给出递归解法(最简洁)
2. 分析时间和空间复杂度
3. 如果面试官追问,可以给出 BFS 或迭代 DFS 解法
4. 讨论递归栈溢出的风险和解决方案

这道题虽然简单,但能体现对树结构和递归思想的理解深度。在面试中清晰表达递归思路,会给面试官留下良好印象。
