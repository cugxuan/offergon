---
title: 单词搜索（LeetCode 79）
tags:
  - 算法
status: robot
class: 算法
slug: word-search
ref:
---

## 核心要点

**二维回溯（DFS）的经典应用，在矩阵中搜索单词路径。关键在于四向遍历、访问标记、状态恢复。通过剪枝优化（提前终止、字符预判）提升效率。时间复杂度 O(m×n×4^L)，空间复杂度 O(L)。**

---

## 题目描述

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`。

单词必须按照字母顺序，通过**相邻的单元格**内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。**同一个单元格内的字母不允许被重复使用。**

**示例 1：**

```
输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]],
     word = "ABCCED"
输出：true

路径示意:
A → B → C → C → E → D
```

**示例 2：**

```
输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]],
     word = "SEE"
输出：true

路径: S → E → E
```

**示例 3：**

```
输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]],
     word = "ABCB"
输出：false

解释：B 不能重复使用
```

---

## 解题思路

### 1. 问题分析

**核心特征：**
- 需要在二维网格中找路径（不是简单的字符查找）
- 路径必须连续（相邻单元格）
- 同一单元格不能重复访问
- 只需要找到一条路径即可（不需要所有路径）

**搜索策略：**
- 遍历网格找到起点（首字母匹配）
- 从起点开始 DFS 搜索下一个字符
- 每次向上下左右四个方向扩展
- 标记已访问的单元格，避免重复
- 回溯时恢复访问标记

### 2. 回溯框架

```
def backtrack(row, col, index):
    if index == len(word):
        return True  # 找到完整单词

    if 越界 or 字符不匹配 or 已访问:
        return False  # 剪枝

    标记当前单元格为已访问

    # 尝试四个方向
    if backtrack(row-1, col, index+1): return True  # 上
    if backtrack(row+1, col, index+1): return True  # 下
    if backtrack(row, col-1, index+1): return True  # 左
    if backtrack(row, col+1, index+1): return True  # 右

    恢复当前单元格为未访问  # 回溯
    return False
```

### 3. 访问标记技巧

**方法一：使用额外的 visited 数组**
```go
visited := make([][]bool, m)
```

**方法二：原地修改（节省空间，推荐）**
```go
// 标记为已访问
temp := board[row][col]
board[row][col] = '#'

// 回溯恢复
board[row][col] = temp
```

---

## 代码实现

### 标准实现（原地标记）

```go
func exist(board [][]byte, word string) bool {
    if len(board) == 0 || len(board[0]) == 0 {
        return false
    }

    m, n := len(board), len(board[0])

    var backtrack func(row, col, index int) bool
    backtrack = func(row, col, index int) bool {
        // 找到完整单词
        if index == len(word) {
            return true
        }

        // 边界检查
        if row < 0 || row >= m || col < 0 || col >= n {
            return false
        }

        // 字符不匹配或已访问（标记为 '#'）
        if board[row][col] != word[index] {
            return false
        }

        // 标记当前单元格为已访问
        temp := board[row][col]
        board[row][col] = '#'

        // 向四个方向搜索
        found := backtrack(row-1, col, index+1) || // 上
            backtrack(row+1, col, index+1) ||      // 下
            backtrack(row, col-1, index+1) ||      // 左
            backtrack(row, col+1, index+1)         // 右

        // 回溯：恢复当前单元格
        board[row][col] = temp

        return found
    }

    // 遍历网格，找到起点
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if board[i][j] == word[0] {
                if backtrack(i, j, 0) {
                    return true
                }
            }
        }
    }

    return false
}
```

### 优化版本（方向数组）

使用方向数组使代码更简洁：

```go
func exist(board [][]byte, word string) bool {
    if len(board) == 0 || len(board[0]) == 0 {
        return false
    }

    m, n := len(board), len(board[0])
    // 方向数组：上、下、左、右
    directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}

    var backtrack func(row, col, index int) bool
    backtrack = func(row, col, index int) bool {
        if index == len(word) {
            return true
        }

        if row < 0 || row >= m || col < 0 || col >= n ||
           board[row][col] != word[index] {
            return false
        }

        temp := board[row][col]
        board[row][col] = '#'

        // 遍历四个方向
        for _, dir := range directions {
            newRow, newCol := row+dir[0], col+dir[1]
            if backtrack(newRow, newCol, index+1) {
                board[row][col] = temp
                return true
            }
        }

        board[row][col] = temp
        return false
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if backtrack(i, j, 0) {
                return true
            }
        }
    }

    return false
}
```

### 使用 visited 数组版本

```go
func exist(board [][]byte, word string) bool {
    if len(board) == 0 || len(board[0]) == 0 {
        return false
    }

    m, n := len(board), len(board[0])
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }

    var backtrack func(row, col, index int) bool
    backtrack = func(row, col, index int) bool {
        if index == len(word) {
            return true
        }

        if row < 0 || row >= m || col < 0 || col >= n ||
           visited[row][col] || board[row][col] != word[index] {
            return false
        }

        visited[row][col] = true

        found := backtrack(row-1, col, index+1) ||
            backtrack(row+1, col, index+1) ||
            backtrack(row, col-1, index+1) ||
            backtrack(row, col+1, index+1)

        visited[row][col] = false  // 回溯

        return found
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if backtrack(i, j, 0) {
                return true
            }
        }
    }

    return false
}
```

---

## 详细执行过程

以 `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`, `word = "ABCCED"` 为例：

```
初始网格:
A B C E
S F C S
A D E E

搜索 "ABCCED"

第1步: 遍历网格，找到起点 'A'
  位置 (0,0): A 匹配，开始搜索

第2步: 从 (0,0) 搜索 'B' (index=1)
  标记 (0,0) 为 '#'
  网格变为:
  # B C E
  S F C S
  A D E E

  尝试四个方向:
    上 (-1,0): 越界 ❌
    下 (1,0): S != B ❌
    左 (0,-1): 越界 ❌
    右 (0,1): B == B ✓ 继续搜索

第3步: 从 (0,1) 搜索 'C' (index=2)
  标记 (0,1) 为 '#'
  网格变为:
  # # C E
  S F C S
  A D E E

  尝试四个方向:
    上 (-1,1): 越界 ❌
    下 (1,1): F != C ❌
    左 (0,0): # != C ❌ (已访问)
    右 (0,2): C == C ✓ 继续搜索

第4步: 从 (0,2) 搜索 'C' (index=3)
  标记 (0,2) 为 '#'
  网格变为:
  # # # E
  S F C S
  A D E E

  尝试四个方向:
    上 (-1,2): 越界 ❌
    下 (1,2): C == C ✓ 继续搜索

第5步: 从 (1,2) 搜索 'E' (index=4)
  标记 (1,2) 为 '#'
  网格变为:
  # # # E
  S F # S
  A D E E

  尝试四个方向:
    上 (0,2): # != E ❌
    下 (2,2): E == E ✓ 继续搜索

第6步: 从 (2,2) 搜索 'D' (index=5)
  标记 (2,2) 为 '#'
  网格变为:
  # # # E
  S F # S
  A D # E

  尝试四个方向:
    上 (1,2): # != D ❌
    下 (3,2): 越界 ❌
    左 (2,1): D == D ✓ 继续搜索

第7步: 从 (2,1) 搜索完毕 (index=6 == len(word))
  找到完整路径！返回 true

路径: (0,0)A → (0,1)B → (0,2)C → (1,2)C → (2,2)E → (2,1)D
```

---

## 复杂度分析

### 时间复杂度：O(m × n × 4^L)

- m × n：遍历所有单元格寻找起点
- 4^L：每个位置最多向四个方向搜索，递归深度为单词长度 L
- 实际运行中由于剪枝，远小于理论上界

### 空间复杂度：O(L)

- 递归调用栈深度为单词长度 L
- 原地标记不需要额外空间
- 使用 visited 数组则为 O(m×n)

---

## 关键要点总结

1. **DFS + 回溯框架**：标准的二维网格搜索模板

2. **访问标记技巧**：
   - 原地修改：`board[row][col] = '#'`（推荐，节省空间）
   - visited 数组：`visited[row][col] = true`（更清晰）

3. **剪枝优化**：
   - 边界检查：避免越界
   - 字符匹配：不匹配立即返回
   - 访问检查：避免重复访问
   - 提前返回：找到一条路径即可返回 true

4. **状态恢复**：回溯时必须恢复 board 或 visited 状态

5. **起点优化**：只从首字母匹配的单元格开始搜索

---

## 面试回答要点

**面试官：如何在二维网格中搜索单词？**

**回答框架：**

"单词搜索是 DFS + 回溯的经典应用。核心思路是：

1. **找起点**：遍历网格，找到与单词首字母匹配的单元格作为起点

2. **DFS 搜索**：
   - 从起点开始，检查当前字符是否匹配
   - 向上下左右四个方向递归搜索下一个字符
   - 标记当前单元格为已访问，避免重复使用

3. **回溯**：
   - 如果四个方向都搜索失败，恢复当前单元格状态
   - 返回 false，让上层尝试其他路径

4. **终止条件**：
   - 成功：index == len(word)，找到完整单词
   - 失败：越界、字符不匹配、已访问

**优化技巧：**
- 使用原地标记（修改 board 为 '#'）节省空间
- 提前剪枝：字符不匹配立即返回
- 找到一条路径即可返回 true

时间复杂度 O(m×n×4^L)，空间复杂度 O(L)（递归栈）。"

---

## 扩展问题

### 1. 单词搜索 II（LeetCode 212）

**变化：** 在网格中搜索多个单词

**优化：** 使用 Trie（前缀树）避免重复搜索

```go
// Trie 节点
type TrieNode struct {
    children map[byte]*TrieNode
    word     string  // 如果是单词结尾，存储完整单词
}

func findWords(board [][]byte, words []string) []string {
    // 构建 Trie
    root := &TrieNode{children: make(map[byte]*TrieNode)}
    for _, word := range words {
        node := root
        for i := 0; i < len(word); i++ {
            c := word[i]
            if node.children[c] == nil {
                node.children[c] = &TrieNode{children: make(map[byte]*TrieNode)}
            }
            node = node.children[c]
        }
        node.word = word
    }

    result := []string{}
    m, n := len(board), len(board[0])

    var backtrack func(row, col int, node *TrieNode)
    backtrack = func(row, col int, node *TrieNode) {
        if row < 0 || row >= m || col < 0 || col >= n {
            return
        }

        c := board[row][col]
        if c == '#' || node.children[c] == nil {
            return
        }

        node = node.children[c]
        if node.word != "" {
            result = append(result, node.word)
            node.word = ""  // 避免重复添加
        }

        board[row][col] = '#'
        backtrack(row-1, col, node)
        backtrack(row+1, col, node)
        backtrack(row, col-1, node)
        backtrack(row, col+1, node)
        board[row][col] = c
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            backtrack(i, j, root)
        }
    }

    return result
}
```

### 2. 最长递增路径（LeetCode 329）

**变化：** 找网格中最长的递增路径

**优化：** DFS + 记忆化搜索

```go
func longestIncreasingPath(matrix [][]int) int {
    if len(matrix) == 0 {
        return 0
    }

    m, n := len(matrix), len(matrix[0])
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
    }

    directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}

    var dfs func(row, col int) int
    dfs = func(row, col int) int {
        if memo[row][col] != 0 {
            return memo[row][col]
        }

        maxLen := 1
        for _, dir := range directions {
            newRow, newCol := row+dir[0], col+dir[1]
            if newRow >= 0 && newRow < m && newCol >= 0 && newCol < n &&
               matrix[newRow][newCol] > matrix[row][col] {
                maxLen = max(maxLen, 1+dfs(newRow, newCol))
            }
        }

        memo[row][col] = maxLen
        return maxLen
    }

    result := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            result = max(result, dfs(i, j))
        }
    }

    return result
}
```

---

## 常见错误与注意事项

### 错误 1：忘记恢复状态

```go
// ❌ 错误：没有回溯恢复
temp := board[row][col]
board[row][col] = '#'
return backtrack(row-1, col, index+1) ||
       backtrack(row+1, col, index+1)
// 缺少：board[row][col] = temp

// ✅ 正确：必须恢复
temp := board[row][col]
board[row][col] = '#'
found := backtrack(row-1, col, index+1) ||
         backtrack(row+1, col, index+1)
board[row][col] = temp  // 恢复
return found
```

### 错误 2：边界检查顺序错误

```go
// ❌ 错误：可能越界访问
if board[row][col] != word[index] {  // 可能越界！
    return false
}
if row < 0 || row >= m || col < 0 || col >= n {
    return false
}

// ✅ 正确：先检查边界
if row < 0 || row >= m || col < 0 || col >= n {
    return false
}
if board[row][col] != word[index] {
    return false
}
```

### 错误 3：起点优化缺失

```go
// ⚠️ 低效：从所有单元格开始搜索
for i := 0; i < m; i++ {
    for j := 0; j < n; j++ {
        if backtrack(i, j, 0) {
            return true
        }
    }
}

// ✅ 优化：只从首字母匹配的单元格开始
for i := 0; i < m; i++ {
    for j := 0; j < n; j++ {
        if board[i][j] == word[0] {  // 预判首字母
            if backtrack(i, j, 0) {
                return true
            }
        }
    }
}
```

### 错误 4：使用 || 短路时状态未恢复

```go
// ❌ 错误：找到路径后直接返回，未恢复状态
board[row][col] = '#'
if backtrack(row-1, col, index+1) {
    return true  // 直接返回，未恢复！
}
// ...

// ✅ 正确方法1：保存结果再恢复
board[row][col] = '#'
found := backtrack(row-1, col, index+1) ||
         backtrack(row+1, col, index+1) ||
         backtrack(row, col-1, index+1) ||
         backtrack(row, col+1, index+1)
board[row][col] = temp
return found

// ✅ 正确方法2：找到后也恢复
board[row][col] = '#'
if backtrack(row-1, col, index+1) {
    board[row][col] = temp
    return true
}
// ...
board[row][col] = temp
return false
```

---

## 问题对比总结

| 问题 | 搜索目标 | 关键技巧 | 时间复杂度 |
|------|---------|---------|-----------|
| **单词搜索（79）** | 单个单词路径 | DFS + 回溯 | O(m×n×4^L) |
| **单词搜索 II（212）** | 多个单词 | DFS + Trie | O(m×n×4^L) |
| **岛屿数量（200）** | 连通块计数 | DFS/BFS | O(m×n) |
| **最长递增路径（329）** | 最长路径 | DFS + 记忆化 | O(m×n) |

---

## 总结

单词搜索问题是二维回溯的经典题目，掌握它需要理解：

1. **DFS 搜索框架**：四向遍历 + 递归
2. **访问标记技巧**：原地修改 vs visited 数组
3. **回溯状态恢复**：搜索失败后必须恢复
4. **剪枝优化**：边界、字符匹配、提前返回

面试建议：
- 先画图说明搜索路径
- 写出清晰的原地标记版本
- 讨论时间空间复杂度
- 提及可能的优化（起点预判、提前返回）

这道题能很好地考察你对回溯算法和网格搜索的理解深度。
