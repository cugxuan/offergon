---
title: 编辑距离（LeetCode 72）
tags:
  - 算法
status: robot
class: 算法
slug: edit-distance
ref:
---

## 核心要点

- **问题本质**: 求将一个字符串转换成另一个字符串的最少编辑操作次数
- **三种操作**: 插入、删除、替换一个字符
- **经典二维 DP**: `dp[i][j]` 表示 word1 的前 i 个字符转换为 word2 的前 j 个字符的最少操作数
- **状态转移核心**:
  - 字符相同: `dp[i][j] = dp[i-1][j-1]`
  - 字符不同: `dp[i][j] = min(插入, 删除, 替换) + 1`
- **应用场景**: 拼写检查、DNA 序列比对、文本相似度计算

## 题目描述

给你两个单词 `word1` 和 `word2`,请返回将 `word1` 转换成 `word2` 所使用的最少操作数。

你可以对一个单词进行如下三种操作:
- **插入**一个字符
- **删除**一个字符
- **替换**一个字符

**示例 1:**
```
输入: word1 = "horse", word2 = "ros"
输出: 3
解释:
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2:**
```
输入: word1 = "intention", word2 = "execution"
输出: 5
解释:
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示:**
- 0 ≤ word1.length, word2.length ≤ 500
- word1 和 word2 由小写英文字母组成

## 解题思路

### 问题分析

编辑距离(Edit Distance),又称 **Levenshtein 距离**,是经典的动态规划问题。

**关键洞察:**
- 这是一个**最优子结构**问题: 要转换两个字符串,可以先转换它们的前缀,然后处理最后一个字符
- 需要同时考虑两个字符串的状态,所以用**二维 DP**

### 动态规划解法

#### 状态定义

`dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符所需的最少操作数。

**说明:**
- `word1[0...i-1]` 转换为 `word2[0...j-1]`
- `dp[0][0] = 0`: 两个空字符串的编辑距离为 0

#### 状态转移方程

对于 `dp[i][j]`,考虑 `word1[i-1]` 和 `word2[j-1]` (注意索引从 0 开始):

**情况 1: 字符相同** (`word1[i-1] == word2[j-1]`)
```
dp[i][j] = dp[i-1][j-1]
```
不需要任何操作,直接继承前面的结果。

**情况 2: 字符不同** (`word1[i-1] != word2[j-1]`)

有三种选择,取最小值:

1. **替换操作**: 将 `word1[i-1]` 替换为 `word2[j-1]`
   ```
   dp[i][j] = dp[i-1][j-1] + 1
   ```
   先转换前缀,然后替换最后一个字符

2. **删除操作**: 删除 `word1[i-1]`
   ```
   dp[i][j] = dp[i-1][j] + 1
   ```
   先将 `word1[0...i-2]` 转换为 `word2[0...j-1]`,然后删除 `word1[i-1]`

3. **插入操作**: 在 `word1[i]` 位置插入 `word2[j-1]`
   ```
   dp[i][j] = dp[i][j-1] + 1
   ```
   先将 `word1[0...i-1]` 转换为 `word2[0...j-2]`,然后插入 `word2[j-1]`

**综合:**
```
dp[i][j] = min(
    dp[i-1][j-1] + 1,  // 替换
    dp[i-1][j] + 1,    // 删除
    dp[i][j-1] + 1     // 插入
)
```

#### 初始化

**第一行**: `dp[0][j]` 表示空字符串转换为 `word2[0...j-1]`
- 需要插入 j 个字符
- `dp[0][j] = j`

**第一列**: `dp[i][0]` 表示 `word1[0...i-1]` 转换为空字符串
- 需要删除 i 个字符
- `dp[i][0] = i`

### 详细推导示例

```
word1 = "horse", word2 = "ros"

构建 DP 表格 (行表示 word1,列表示 word2):

       ""  r  o  s
    "" 0   1  2  3
    h  1   ?  ?  ?
    o  2   ?  ?  ?
    r  3   ?  ?  ?
    s  4   ?  ?  ?
    e  5   ?  ?  ?

逐步填充:

dp[1][1]: 'h' vs 'r' (不同)
  = min(
      dp[0][0] + 1 = 1,  // 替换 h -> r
      dp[0][1] + 1 = 2,  // 删除 h
      dp[1][0] + 1 = 2   // 插入 r
    ) = 1

dp[1][2]: 'h' vs 'ro' (h != o)
  = min(
      dp[0][1] + 1 = 2,  // 替换
      dp[0][2] + 1 = 3,  // 删除
      dp[1][1] + 1 = 2   // 插入
    ) = 2

... 继续填充 ...

最终 DP 表格:

       ""  r  o  s
    "" 0   1  2  3
    h  1   1  2  3
    o  2   2  1  2
    r  3   2  2  2
    s  4   3  3  2
    e  5   4  4  3

答案: dp[5][3] = 3
```

**转换路径解读:**
- dp[5][3] = 3 来自 dp[4][2] + 1 (删除 'e')
- dp[4][2] = 3 来自 dp[3][1] + 1 (删除 's')
- dp[3][1] = 2 来自 dp[2][0] + 1 (删除 'r')
- ...

实际操作: horse -> rorse (替换 h->r) -> rose (删除 r) -> ros (删除 e)

### 为什么这样设计?

**理解三种操作:**

1. **替换**: `dp[i-1][j-1] + 1`
   - 已经处理了 `word1[0...i-2]` 和 `word2[0...j-2]`
   - 现在把 `word1[i-1]` 替换成 `word2[j-1]`

2. **删除**: `dp[i-1][j] + 1`
   - 已经处理了 `word1[0...i-2]` 转换为 `word2[0...j-1]`
   - 现在删除 `word1[i-1]`
   - 等价于: 把更长的 word1 删除一个字符

3. **插入**: `dp[i][j-1] + 1`
   - 已经处理了 `word1[0...i-1]` 转换为 `word2[0...j-2]`
   - 现在插入 `word2[j-1]`
   - 等价于: word2 多了一个字符需要匹配

## 代码实现

### Go 实现 - 二维 DP

```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)

    // dp[i][j] 表示 word1[0...i-1] 转换为 word2[0...j-1] 的最少操作数
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    // 初始化第一行和第一列
    for i := 0; i <= m; i++ {
        dp[i][0] = i  // word1[0...i-1] 转为空串,需要删除 i 个字符
    }

    for j := 0; j <= n; j++ {
        dp[0][j] = j  // 空串转为 word2[0...j-1],需要插入 j 个字符
    }

    // 状态转移
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if word1[i-1] == word2[j-1] {
                // 字符相同,不需要操作
                dp[i][j] = dp[i-1][j-1]
            } else {
                // 字符不同,取三种操作的最小值
                dp[i][j] = min(
                    dp[i-1][j-1] + 1,  // 替换
                    min(
                        dp[i-1][j] + 1,  // 删除
                        dp[i][j-1] + 1,  // 插入
                    ),
                )
            }
        }
    }

    return dp[m][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 空间优化: 一维 DP

由于 `dp[i][j]` 只依赖于 `dp[i-1][j-1]`, `dp[i-1][j]`, `dp[i][j-1]`,可以用滚动数组优化空间。

```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)

    // 使用一维数组,只保存上一行的结果
    dp := make([]int, n+1)

    // 初始化第一行
    for j := 0; j <= n; j++ {
        dp[j] = j
    }

    // 逐行更新
    for i := 1; i <= m; i++ {
        prev := dp[0]  // 保存左上角的值 (对应二维的 dp[i-1][j-1])
        dp[0] = i      // 更新第一列

        for j := 1; j <= n; j++ {
            temp := dp[j]  // 保存当前值,下次迭代时作为左上角

            if word1[i-1] == word2[j-1] {
                dp[j] = prev
            } else {
                dp[j] = min(
                    prev + 1,        // 替换 (左上)
                    min(
                        dp[j] + 1,   // 删除 (上)
                        dp[j-1] + 1, // 插入 (左)
                    ),
                )
            }

            prev = temp  // 更新左上角的值
        }
    }

    return dp[n]
}
```

## 复杂度分析

### 二维 DP
- **时间复杂度**: O(m × n),其中 m 和 n 分别是两个字符串的长度
- **空间复杂度**: O(m × n),二维 DP 数组

### 一维 DP
- **时间复杂度**: O(m × n)
- **空间复杂度**: O(n),一维滚动数组

## 常见变形

### 1. 只允许删除操作

如果只能删除,不能插入和替换:
- 问题变为求**最长公共子序列 (LCS)**
- 答案 = m + n - 2 × LCS

### 2. 不同操作有不同代价

```go
// 替换代价为 c1,插入代价为 c2,删除代价为 c3
if word1[i-1] != word2[j-1] {
    dp[i][j] = min(
        dp[i-1][j-1] + c1,  // 替换
        dp[i-1][j] + c3,    // 删除
        dp[i][j-1] + c2,    // 插入
    )
}
```

### 3. 记录具体操作序列

在 DP 的同时,用一个数组记录每步的选择,最后回溯构造操作序列。

## 相关题目

1. **最长公共子序列**(LeetCode 1143): 只允许删除的编辑距离
2. **删除操作的两个字符串的距离**(LeetCode 583): 只允许删除
3. **一次编辑**(LeetCode 161): 判断是否只需一次编辑
4. **通配符匹配**(LeetCode 44): 带通配符的字符串匹配

## 面试技巧

1. **先画表格**: 在白板上画出 DP 表格,标注行列含义,帮助理解
2. **讲清楚状态定义**: 强调 `dp[i][j]` 的含义是前 i 个字符和前 j 个字符
3. **分情况讨论**: 先讨论字符相同的情况,再讨论不同的三种操作
4. **举例说明**: 用简单的例子(如 "horse" 和 "ros")手动填充几个格子
5. **优化空间**: 如果面试官追问,可以讨论如何用一维数组优化
6. **实际应用**: 提到拼写检查、DNA 序列比对、模糊搜索等应用场景
7. **边界情况**:
   - 一个或两个字符串为空
   - 两个字符串完全相同
   - 两个字符串完全不同

## 扩展知识

### DNA 序列比对

在生物信息学中,编辑距离用于比对 DNA 序列,找到相似的基因片段。

### 拼写检查

拼写检查器使用编辑距离找到与错误单词最接近的正确单词:
- 计算输入单词与字典中每个单词的编辑距离
- 返回距离最小的几个单词作为建议

### 版本控制

Git 等版本控制系统使用类似的算法计算文件的 diff,找到最少的修改操作。
