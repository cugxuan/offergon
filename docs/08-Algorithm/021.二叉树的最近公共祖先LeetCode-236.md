---
title: 二叉树的最近公共祖先（LeetCode 236）
tags:
  - 算法
status: robot
class: 算法
slug: lowest-common-ancestor-binary-tree
ref:
---

## 核心要点

**最近公共祖先（LCA）定义**：对于树中两个节点 p 和 q，最近公共祖先是指同时包含 p 和 q 的最低层级节点。

**解题关键**：
1. 递归思想：利用后序遍历（左右根）自底向上返回信息
2. 分治策略：当前节点的 LCA 由左右子树的查找结果决定
3. 三种情况判断：①两节点分别在左右子树 ②其中一个节点是另一个的祖先 ③都不在当前子树

---

## 题目描述

给定一个二叉树，找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为："对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。"

**示例 1：**
```
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4
```
- 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
- 输出：3
- 解释：节点 5 和节点 1 的最近公共祖先是节点 3

**示例 2：**
- 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
- 输出：5
- 解释：节点 5 和节点 4 的最近公共祖先是节点 5（一个节点可以是它自己的祖先）

---

## 解题思路

### 方法一：递归（后序遍历）

这是最优雅的解法，利用递归的自底向上特性。

**核心思想**：
1. **递归终止条件**：遇到空节点返回 null；遇到 p 或 q 节点直接返回该节点
2. **递归搜索**：分别在左右子树中查找 p 和 q
3. **结果判断**：
   - 如果左右子树都返回非空，说明 p 和 q 分别在左右子树，当前节点就是 LCA
   - 如果只有左子树返回非空，说明 p 和 q 都在左子树，返回左子树的结果
   - 如果只有右子树返回非空，说明 p 和 q 都在右子树，返回右子树的结果

**为什么后序遍历**？
- 需要先处理子树，再根据子树的返回结果判断当前节点
- 信息从叶子节点向根节点传递

### 算法流程图解

以示例 1 为例（查找节点 5 和节点 1 的 LCA）：

```
步骤 1: 从根节点 3 开始递归
    递归左子树(5) 和 右子树(1)

步骤 2: 左子树递归
    节点 5 == p，直接返回节点 5

步骤 3: 右子树递归
    节点 1 == q，直接返回节点 1

步骤 4: 回到根节点 3
    left = 节点 5（非空）
    right = 节点 1（非空）
    因为左右都非空，返回当前节点 3 ✓
```

---

## 代码实现

### Go 语言实现

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // 递归终止条件
    // 1. 遇到空节点，返回 nil
    // 2. 遇到 p 或 q 节点，直接返回该节点
    if root == nil || root == p || root == q {
        return root
    }

    // 递归搜索左右子树
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)

    // 根据左右子树的返回结果判断
    // 情况 1: 左右子树都找到了节点，说明 p 和 q 分别在左右子树
    if left != nil && right != nil {
        return root
    }

    // 情况 2: 只在左子树找到，返回左子树的结果
    if left != nil {
        return left
    }

    // 情况 3: 只在右子树找到，返回右子树的结果
    return right
}
```

### Python 实现

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 递归终止条件
        if not root or root == p or root == q:
            return root

        # 递归搜索左右子树
        left = self.lowestCommonAncestor(root.Left, p, q)
        right = self.lowestCommonAncestor(root.Right, p, q)

        # 左右子树都找到，当前节点是 LCA
        if left and right:
            return root

        # 返回非空的那个子树结果
        return left if left else right
```

### Java 实现

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 递归终止条件
        if (root == null || root == p || root == q) {
            return root;
        }

        // 递归搜索左右子树
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 左右子树都找到，当前节点是 LCA
        if (left != null && right != null) {
            return root;
        }

        // 返回非空的子树结果
        return left != null ? left : right;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 需要遍历二叉树的所有节点，最坏情况下访问所有 n 个节点

- **空间复杂度**：O(n)
  - 递归调用栈的深度，最坏情况下（树退化成链表）深度为 n
  - 平衡树情况下为 O(log n)

---

## 关键细节与易错点

### 1. 为什么遇到 p 或 q 就返回？

这是算法的巧妙之处：
- 如果 p 是 q 的祖先，当递归到 p 时直接返回 p，后续不会再向下找 q
- 这样返回的 p 就是正确答案（p 既是自己的祖先，也是 q 的祖先）

### 2. 三种情况的本质

```
情况 1: left != nil && right != nil
       p 和 q 分别在左右子树 → 当前节点是 LCA

情况 2: left != nil && right == nil
       两种可能：
       ① p 和 q 都在左子树
       ② p（或 q）在左子树，另一个节点不存在（但题目保证都存在）

情况 3: left == nil && right != nil
       对称于情况 2
```

### 3. 与二叉搜索树的区别

- **BST 的 LCA**：可以利用值的大小关系，O(log n) 时间找到
- **普通二叉树**：没有值的顺序性，必须递归搜索，O(n) 时间

---

## 变体题目

### 变体 1：求节点到 LCA 的路径

```go
func getPath(root, target *TreeNode) []*TreeNode {
    if root == nil {
        return nil
    }
    if root == target {
        return []*TreeNode{root}
    }

    left := getPath(root.Left, target)
    if left != nil {
        return append([]*TreeNode{root}, left...)
    }

    right := getPath(root.Right, target)
    if right != nil {
        return append([]*TreeNode{root}, right...)
    }

    return nil
}
```

### 变体 2：多个节点的 LCA

```go
func lowestCommonAncestorMultiple(root *TreeNode, nodes []*TreeNode) *TreeNode {
    if root == nil || len(nodes) == 0 {
        return nil
    }

    // 将 nodes 转换为 map 加速查找
    nodeSet := make(map[*TreeNode]bool)
    for _, node := range nodes {
        nodeSet[node] = true
    }

    return lcaHelper(root, nodeSet)
}

func lcaHelper(root *TreeNode, nodeSet map[*TreeNode]bool) *TreeNode {
    if root == nil || nodeSet[root] {
        return root
    }

    left := lcaHelper(root.Left, nodeSet)
    right := lcaHelper(root.Right, nodeSet)

    if left != nil && right != nil {
        return root
    }

    if left != nil {
        return left
    }
    return right
}
```

---

## 面试技巧

### 1. 思路表达

"这道题我会用**后序遍历的递归**来解决。核心思想是：
- 如果当前节点是 p 或 q，直接返回当前节点
- 否则分别在左右子树递归查找
- 根据左右子树的返回结果判断：如果左右都找到了，说明当前节点就是 LCA；如果只有一边找到，说明两个节点都在那一边"

### 2. 优化讨论

**面试官可能问**："能否优化时间复杂度？"

**回答**：
- 对于普通二叉树，O(n) 已经是最优，因为最坏情况必须访问所有节点
- 如果是 BST，可以利用值的大小关系优化到 O(log n)
- 如果需要多次查询 LCA，可以用 **Tarjan 算法**（离线算法）或 **倍增法**（在线算法）预处理

### 3. 边界情况

面试时要主动提及：
- p 和 q 都存在于树中（题目保证）
- p 或 q 可以是对方的祖先
- 树不为空（题目保证）

---

## 总结

这道题是**二叉树递归**的经典题目，考察：
1. **递归思维**：如何设计递归终止条件和递归逻辑
2. **分治思想**：将问题分解为子问题，根据子问题结果合并
3. **后序遍历**：需要先处理子树再判断当前节点

**记忆口诀**：
- 遇到目标直接返，左右递归分两边
- 左右都有当前返，只有一边那边传

掌握这道题的思路后，可以轻松应对 BST 的 LCA、多节点 LCA 等变体问题。
