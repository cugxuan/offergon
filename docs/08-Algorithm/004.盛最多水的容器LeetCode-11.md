---
title: 盛最多水的容器（LeetCode 11）
tags:
  - 算法
status: robot
class: 算法
slug: container-with-most-water
ref:
---

## 核心要点

**一句话总结**：双指针从两端向中间移动,每次移动较短的那条边，贪心地寻找最大面积，时间复杂度 O(n)。

**关键技巧**：容器面积由短板决定，移动短板才有可能增大面积，移动长板只会减小面积。

---

## 问题分析

给定 n 个非负整数 `height[i]`，每个数代表坐标 `(i, 0)` 到 `(i, height[i])` 的一条垂直线段。找出其中的两条线段，与 x 轴共同构成的容器能够容纳最多的水。

**约束条件**：
- 不能倾斜容器
- 面积 = 两线段的水平距离 × 两线段高度的最小值
- 需要找到最大面积

**示例**：
```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：最大面积在索引 1 和 8 之间，宽度为 7，高度为 min(8, 7) = 7
面积 = 7 × 7 = 49
```

**视觉理解**：
```
高度:  1  8  6  2  5  4  8  3  7
索引:  0  1  2  3  4  5  6  7  8

最大容器：索引 1 (高度8) 和索引 8 (高度7)
宽度 = 8 - 1 = 7
高度 = min(8, 7) = 7
面积 = 7 × 7 = 49
```

---

## 解法思路

### 核心思路：双指针 + 贪心

**为什么双指针有效？**

关键洞察：**面积由短板决定**
- 面积 = `宽度 × min(左高度, 右高度)`
- 移动指针时，宽度一定减小
- 要增大面积，只能尝试增大高度
- 移动短板：可能找到更高的板，有机会增大面积
- 移动长板：高度由短板决定，面积一定减小（宽度减小，高度不变或更小）

**算法流程**：
1. 左指针 `left` 从最左端开始，右指针 `right` 从最右端开始
2. 计算当前面积：`area = (right - left) × min(height[left], height[right])`
3. 更新最大面积
4. **关键**：移动高度较小的指针
   - 如果 `height[left] < height[right]`：`left++`
   - 否则：`right--`
5. 重复 2-4 直到 `left >= right`

**正确性证明**（反证法）：
- 假设最优解是 `(i, j)`，其中 `i < j`
- 从 `(0, n-1)` 开始移动指针
- 当指针到达 `i` 或 `j` 时，另一个指针还没到达对应位置
- 由于我们总是移动短板，不会错过最优解
- 如果移动长板，相当于跳过了可能的最优解

---

## 代码实现

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0

    for left < right {
        // 计算当前面积
        width := right - left
        h := min(height[left], height[right])
        area := width * h

        // 更新最大面积
        if area > maxArea {
            maxArea = area
        }

        // 移动短板
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }

    return maxArea
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**简化版本**：

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0

    for left < right {
        // 计算当前面积
        h := height[left]
        if height[right] < h {
            h = height[right]
        }
        area := (right - left) * h

        // 更新最大值
        if area > maxArea {
            maxArea = area
        }

        // 移动短板
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }

    return maxArea
}
```

**执行过程示例**（height = [1,8,6,2,5,4,8,3,7]）：

| left | right | height[left] | height[right] | 宽度 | 高度 | 面积 | maxArea | 移动 |
|------|-------|--------------|---------------|------|------|------|---------|------|
| 0 | 8 | 1 | 7 | 8 | 1 | 8 | 8 | left++ (1 < 7) |
| 1 | 8 | 8 | 7 | 7 | 7 | 49 | 49 | right-- (8 > 7) |
| 1 | 7 | 8 | 3 | 6 | 3 | 18 | 49 | right-- (8 > 3) |
| 1 | 6 | 8 | 8 | 5 | 8 | 40 | 49 | left++ (8 = 8) |
| 2 | 6 | 6 | 8 | 4 | 6 | 24 | 49 | left++ (6 < 8) |
| 3 | 6 | 2 | 8 | 3 | 2 | 6 | 49 | left++ (2 < 8) |
| 4 | 6 | 5 | 8 | 2 | 5 | 10 | 49 | left++ (5 < 8) |
| 5 | 6 | 4 | 8 | 1 | 4 | 4 | 49 | left++ (4 < 8) |
| 6 | 6 | - | - | - | - | - | 49 | 结束 |

最终答案：**49**

---

## 复杂度分析

**时间复杂度**：O(n)
- 两个指针各遍历一次数组，每次移动一个指针
- 总共最多移动 n 次

**空间复杂度**：O(1)
- 只使用了常数个变量

---

## 注意事项与易错点

### 1. **为什么移动短板而不是长板？**

这是最核心的问题！

**移动短板的逻辑**：
- 当前面积由短板决定
- 宽度必然减小（指针向中间移动）
- 移动短板：可能遇到更高的板，面积可能增大
- 移动长板：高度仍由短板决定，面积必然减小

**错误示例**：
```go
// 错误：总是移动左指针
left++  // 会错过很多可能的解

// 错误：总是移动右指针
right--  // 会错过很多可能的解

// 错误：移动长板
if height[left] > height[right] {
    left++  // 错误！
} else {
    right--
}
```

### 2. **相等高度时的处理**

当 `height[left] == height[right]` 时，移动任意一个指针都可以：

```go
// 方案1：移动左指针
if height[left] < height[right] {
    left++
} else {
    right--  // 包含相等的情况
}

// 方案2：移动右指针
if height[left] <= height[right] {
    left++
} else {
    right--
}

// 方案3：同时移动（也可以，但没必要）
if height[left] == height[right] {
    left++
    right--
}
```

### 3. **边界条件**

```go
// 少于两个元素
if len(height) < 2 {
    return 0
}

// 循环终止条件
for left < right {  // 注意是 <，不是 <=
    // ...
}
```

### 4. **整数溢出**

对于极大数据，`宽度 × 高度` 可能溢出：

```go
// Go 语言中 int 通常是 64 位，一般不会溢出
// 如果担心溢出，使用 int64
area := int64(right - left) * int64(h)
```

### 5. **与接雨水问题的区别**

很多人容易混淆：
- **盛水容器**：选两条边，面积 = 宽度 × 短板
- **接雨水（LeetCode 42）**：所有柱子之间的积水，需要累加每个位置的水量

---

## 面试要点

**面试时的回答流程**：
1. 理解题意：两条边构成容器，求最大面积
2. 暴力法：两层循环枚举所有配对 O(n²)
3. 优化方向：能否用双指针？O(n)
4. 关键洞察：**面积由短板决定，移动短板才有可能增大面积**
5. 实现细节：左右指针，移动短板
6. 复杂度分析：O(n) 时间，O(1) 空间

**可能的追问**：

- **Q: 为什么双指针是最优解？**
  - A: 暴力法需要 O(n²) 枚举所有配对。双指针从最大宽度开始，通过移动短板贪心地搜索，不会错过最优解，O(n) 时间复杂度。

- **Q: 如何证明不会错过最优解？**
  - A: 反证法。假设最优解是 `(i, j)`，其中 `height[i] < height[j]`。从 `(0, n-1)` 开始，当到达 `j` 时，如果 `i` 还没被遍历到，说明左指针还在 `i` 的左边。由于我们总是移动短板，左指针会继续移动直到 `i`，不会跳过 `(i, j)`。

- **Q: 能否用动态规划？**
  - A: 不适合。DP 通常用于有最优子结构的问题，这里没有明显的子问题关系。双指针贪心更高效。

- **Q: 如果可以倾斜容器呢？**
  - A: 问题变得复杂，需要考虑角度。但题目明确不能倾斜。

- **Q: 如果要找第二大的面积呢？**
  - A: 需要记录所有访问过的面积，排序后取第二大。或者用优先队列维护 top-k。

- **Q: 移动短板后，新的高度可能更小，为什么还要移动？**
  - A: 虽然可能更小，但也可能更大。移动短板至少有**可能**找到更大面积，而移动长板**一定**会减小面积（因为宽度减小，高度不变或更小）。

**类似问题**：
- 接雨水（LeetCode 42）：需要计算所有位置的积水总和
- 最大矩形（LeetCode 84）：柱状图中的最大矩形面积

---

## 扩展：为什么贪心策略有效？

**贪心选择性质**：每次选择移动短板，是局部最优选择。

**证明**（数学归纳）：
1. 初始状态：`(0, n-1)` 是宽度最大的配对
2. 归纳假设：当前状态 `(i, j)` 之前的所有可能的最优解都已考虑
3. 归纳步骤：
   - 如果 `height[i] < height[j]`，移动 `i` 到 `i+1`
   - 对于所有 `k > i` 和 `j`，`(i, j)` 的面积已经计算
   - 对于 `(i, j')` 其中 `j' < j`，宽度更小，高度 `≤ height[i]`，面积 `≤ (j-i) × height[i]`，不会更优
   - 因此移动 `i` 不会错过最优解

**直观理解**：
- 想象水倒入容器，水的高度由短板决定
- 要装更多水，必须找更高的短板
- 长板再高也没用，水会从短板溢出
