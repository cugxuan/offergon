---
title: 路径总和 III（LeetCode 437）
tags:
  - 算法
status: robot
class: 算法
slug: path-sum-iii
ref:
---

## 核心要点

**问题本质**：统计二叉树中路径和等于目标值的路径数量（路径不必从根节点开始，也不必到叶子节点结束）。

**解题关键**：
1. 路径定义：从任意节点向下延伸的连续路径（不能跨越父节点向上）
2. 前缀和技巧：利用 `currSum - targetSum` 查找符合条件的路径起点
3. 哈希表优化：存储前缀和出现的次数，O(1) 时间查找
4. 回溯处理：DFS 返回时要清除当前路径的前缀和（避免污染其他分支）

---

## 题目描述

给定一个二叉树的根节点 `root`，和一个整数 `targetSum`，求该二叉树里节点值之和等于 `targetSum` 的**路径**的数目。

**路径**不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**
```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8

树结构：
         10
        /  \
       5   -3
      / \    \
     3   2   11
    / \   \
   3  -2   1

输出：3
解释：符合条件的路径有：
1. 5 -> 3
2. 5 -> 2 -> 1
3. -3 -> 11
```

**示例 2：**
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

**约束条件：**
- 树中节点数目范围：[0, 1000]
- -10^9 <= Node.val <= 10^9
- -1000 <= targetSum <= 1000

---

## 解题思路

### 方法一：前缀和 + 哈希表（最优解）

这是最高效的解法，时间复杂度 O(n)。

**核心思想**：
类似于「数组中和为 k 的子数组」问题，利用**前缀和**的性质：

```
如果从根节点到当前节点的路径和为 currSum，
要找路径和为 targetSum 的路径，
就是找之前是否存在某个节点，其路径和为 currSum - targetSum
```

**为什么这样做有效**？

```
假设从根节点 root 到当前节点 node 的路径和为 currSum
如果存在某个祖先节点 ancestor，从 root 到 ancestor 的路径和为 prefixSum
那么从 ancestor 的下一个节点到 node 的路径和就是：
    currSum - prefixSum

如果 currSum - prefixSum == targetSum，
即 prefixSum == currSum - targetSum
说明从 ancestor 的下一个节点到 node 这段路径的和为 targetSum ✓
```

**算法步骤**：

1. 使用哈希表 `prefixSumCount` 记录**从根到当前节点路径上**各个前缀和出现的次数
2. 初始化：`prefixSumCount[0] = 1`（表示空路径，和为 0）
3. DFS 遍历：
   - 累加当前节点值到 `currSum`
   - 查找 `currSum - targetSum` 在哈希表中出现的次数，加入结果
   - 将 `currSum` 加入哈希表
   - 递归处理左右子树
   - **回溯**：从哈希表中移除 `currSum`（避免影响其他分支）

**图解示例**：

```
树：    10
       /  \
      5   -3
     / \    \
    3   2   11

targetSum = 8

DFS 过程（假设先走左子树）：

节点 10：currSum = 10
    查找 10 - 8 = 2，不存在
    prefixSumCount = {0: 1, 10: 1}
    count = 0

节点 5：currSum = 15
    查找 15 - 8 = 7，不存在
    prefixSumCount = {0: 1, 10: 1, 15: 1}
    count = 0

节点 3：currSum = 18
    查找 18 - 8 = 10，存在！(10 -> 5 -> 3 的路径和 = 18 - 10 = 8)
    prefixSumCount = {0: 1, 10: 1, 15: 1, 18: 1}
    count = 1

回溯到节点 5，处理右子树...
节点 2：currSum = 17
    查找 17 - 8 = 9，不存在
    prefixSumCount = {0: 1, 10: 1, 15: 1, 17: 1}
    count = 1

节点 1：currSum = 18
    查找 18 - 8 = 10，存在！(10 -> 5 -> 2 -> 1 的路径和 = 18 - 10 = 8)
    prefixSumCount = {0: 1, 10: 1, 15: 1, 17: 1, 18: 1}
    count = 2

...继续处理右子树，找到 -3 -> 11 = 8
最终 count = 3
```

---

### 方法二：双重递归（暴力解法）

这是最直观但效率较低的解法。

**核心思想**：
1. 对每个节点，计算以该节点为起点的路径中有多少符合条件
2. 递归处理左右子树

**两层递归**：
- 外层递归：遍历所有节点作为路径起点
- 内层递归：从当前起点向下查找符合条件的路径

---

## 代码实现

### 方法一：前缀和 + 哈希表

#### Go 实现

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) int {
    // 前缀和计数器：key 为前缀和，value 为出现次数
    prefixSumCount := make(map[int64]int)
    // 初始化：空路径的和为 0，出现 1 次
    prefixSumCount[0] = 1

    return dfs(root, 0, int64(targetSum), prefixSumCount)
}

func dfs(node *TreeNode, currSum int64, targetSum int64, prefixSumCount map[int64]int) int {
    if node == nil {
        return 0
    }

    // 累加当前节点值
    currSum += int64(node.Val)

    // 查找 currSum - targetSum 出现的次数
    // 这就是以当前节点为终点、和为 targetSum 的路径数量
    count := prefixSumCount[currSum-targetSum]

    // 将当前前缀和加入哈希表
    prefixSumCount[currSum]++

    // 递归处理左右子树
    count += dfs(node.Left, currSum, targetSum, prefixSumCount)
    count += dfs(node.Right, currSum, targetSum, prefixSumCount)

    // 回溯：移除当前节点的前缀和（避免影响其他分支）
    prefixSumCount[currSum]--

    return count
}
```

#### Python 实现

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        # 前缀和计数器
        prefix_sum_count = {0: 1}  # 空路径

        def dfs(node, curr_sum):
            if not node:
                return 0

            # 累加当前节点值
            curr_sum += node.val

            # 查找符合条件的路径数量
            count = prefix_sum_count.get(curr_sum - targetSum, 0)

            # 更新前缀和计数
            prefix_sum_count[curr_sum] = prefix_sum_count.get(curr_sum, 0) + 1

            # 递归处理左右子树
            count += dfs(node.left, curr_sum)
            count += dfs(node.right, curr_sum)

            # 回溯
            prefix_sum_count[curr_sum] -= 1

            return count

        return dfs(root, 0)
```

#### Java 实现

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> prefixSumCount = new HashMap<>();
        prefixSumCount.put(0L, 1); // 空路径

        return dfs(root, 0L, targetSum, prefixSumCount);
    }

    private int dfs(TreeNode node, long currSum, int targetSum,
                    Map<Long, Integer> prefixSumCount) {
        if (node == null) {
            return 0;
        }

        // 累加当前节点值
        currSum += node.val;

        // 查找符合条件的路径数量
        int count = prefixSumCount.getOrDefault(currSum - targetSum, 0);

        // 更新前缀和计数
        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, 0) + 1);

        // 递归处理左右子树
        count += dfs(node.left, currSum, targetSum, prefixSumCount);
        count += dfs(node.right, currSum, targetSum, prefixSumCount);

        // 回溯
        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - 1);

        return count;
    }
}
```

---

### 方法二：双重递归

#### Go 实现

```go
func pathSum(root *TreeNode, targetSum int) int {
    if root == nil {
        return 0
    }

    // 以当前节点为起点的路径数 + 左子树的路径数 + 右子树的路径数
    return pathSumFrom(root, int64(targetSum)) +
           pathSum(root.Left, targetSum) +
           pathSum(root.Right, targetSum)
}

// 计算以 node 为起点，向下延伸的路径中有多少符合条件
func pathSumFrom(node *TreeNode, targetSum int64) int {
    if node == nil {
        return 0
    }

    count := 0
    if int64(node.Val) == targetSum {
        count++
    }

    // 继续向下查找（目标和减去当前节点值）
    count += pathSumFrom(node.Left, targetSum-int64(node.Val))
    count += pathSumFrom(node.Right, targetSum-int64(node.Val))

    return count
}
```

#### Python 实现

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        if not root:
            return 0

        # 以当前节点为起点 + 左子树 + 右子树
        return (self.pathSumFrom(root, targetSum) +
                self.pathSum(root.left, targetSum) +
                self.pathSum(root.right, targetSum))

    def pathSumFrom(self, node, targetSum):
        """计算以 node 为起点的符合条件的路径数"""
        if not node:
            return 0

        count = 1 if node.val == targetSum else 0

        # 继续向下查找
        count += self.pathSumFrom(node.left, targetSum - node.val)
        count += self.pathSumFrom(node.right, targetSum - node.val)

        return count
```

---

## 复杂度分析

### 方法一：前缀和 + 哈希表
- **时间复杂度**：O(n)
  - 每个节点访问一次
  - 哈希表操作 O(1)

- **空间复杂度**：O(n)
  - 哈希表最多存储路径上的所有节点（树的高度）
  - 递归栈深度 O(h)

### 方法二：双重递归
- **时间复杂度**：O(n²)
  - 最坏情况下（链表），每个节点都要作为起点遍历一次
  - 对于平衡树：O(n log n)

- **空间复杂度**：O(h)
  - 递归栈深度

---

## 关键细节与易错点

### 1. 为什么要初始化 `prefixSumCount[0] = 1`？

**场景**：如果从根节点到当前节点的路径和刚好等于 `targetSum`

```
示例：
      5
     /
    3

targetSum = 8

当遍历到节点 3 时：
currSum = 5 + 3 = 8
查找 currSum - targetSum = 8 - 8 = 0
如果没有初始化 prefixSumCount[0] = 1，会漏掉这条路径！
```

初始化 `prefixSumCount[0] = 1` 表示**空路径**（从根节点开始的路径）。

### 2. 回溯为什么重要？

**错误示例**（不回溯）：

```
树：    1
       / \
      2   3

targetSum = 3

不回溯的情况：
节点 1：prefixSumCount = {0: 1, 1: 1}
节点 2：prefixSumCount = {0: 1, 1: 1, 3: 1}
回到节点 1，访问节点 3：
    currSum = 4
    查找 4 - 3 = 1，找到了！
    但 {0: 1, 1: 1, 3: 1} 中的 3 是左子树的路径，不应该影响右子树
```

**正确做法**（回溯）：
```
节点 2 处理完后，将 prefixSumCount[3]--
prefixSumCount 恢复为 {0: 1, 1: 1}
这样访问节点 3 时，不会受左子树影响
```

### 3. 使用 `int64` 避免溢出

题目约束：
- -10^9 <= Node.val <= 10^9
- 树最多 1000 个节点

最坏情况：1000 个节点值都是 10^9，累加会超过 `int32` 的范围。

---

## 变体题目

### 变体 1：路径总和 I（LeetCode 112）

```go
// 判断是否存在从根到叶子的路径，和为 targetSum
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }

    // 叶子节点
    if root.Left == nil && root.Right == nil {
        return root.Val == targetSum
    }

    // 递归左右子树
    return hasPathSum(root.Left, targetSum-root.Val) ||
           hasPathSum(root.Right, targetSum-root.Val)
}
```

### 变体 2：路径总和 II（LeetCode 113）

```go
// 返回所有从根到叶子、和为 targetSum 的路径
func pathSum(root *TreeNode, targetSum int) [][]int {
    result := [][]int{}
    path := []int{}
    dfs(root, targetSum, path, &result)
    return result
}

func dfs(node *TreeNode, targetSum int, path []int, result *[][]int) {
    if node == nil {
        return
    }

    path = append(path, node.Val)

    // 叶子节点且和为 targetSum
    if node.Left == nil && node.Right == nil && node.Val == targetSum {
        // 复制路径（避免引用问题）
        pathCopy := make([]int, len(path))
        copy(pathCopy, path)
        *result = append(*result, pathCopy)
    }

    // 递归左右子树
    dfs(node.Left, targetSum-node.Val, path, result)
    dfs(node.Right, targetSum-node.Val, path, result)
}
```

### 变体 3：二叉树的最大路径和（LeetCode 124）

```go
// 路径可以从任意节点开始，任意节点结束（可以向上）
func maxPathSum(root *TreeNode) int {
    maxSum := math.MinInt32

    var dfs func(*TreeNode) int
    dfs = func(node *TreeNode) int {
        if node == nil {
            return 0
        }

        // 只取正数（负数不如不选）
        left := max(0, dfs(node.Left))
        right := max(0, dfs(node.Right))

        // 更新最大路径和（左 + 根 + 右）
        maxSum = max(maxSum, node.Val+left+right)

        // 返回经过当前节点的单边最大路径
        return node.Val + max(left, right)
    }

    dfs(root)
    return maxSum
}
```

---

## 面试技巧

### 1. 思路表达

"这道题有两种解法：

**方法一：前缀和 + 哈希表**（推荐）
- 类似于'和为 k 的子数组'问题
- 用哈希表记录从根到当前节点路径上的前缀和
- 查找 `currSum - targetSum` 的出现次数
- 时间 O(n)，空间 O(n)

**方法二：双重递归**
- 对每个节点，计算以它为起点的符合条件的路径数
- 时间 O(n²)，但代码更简洁

我倾向于使用方法一，因为效率更高。"

### 2. 画图说明

面试时建议画出前缀和的计算过程：

```
树：  10
     /
    5
   /
  3

targetSum = 8

节点 10：currSum = 10, prefixSumCount = {0: 1, 10: 1}
         查找 10 - 8 = 2，不存在

节点 5： currSum = 15, prefixSumCount = {0: 1, 10: 1, 15: 1}
         查找 15 - 8 = 7，不存在

节点 3： currSum = 18, prefixSumCount = {0: 1, 10: 1, 15: 1, 18: 1}
         查找 18 - 8 = 10，存在 1 次 ✓
         → 路径 5 -> 3（和 = 18 - 10 = 8）
```

### 3. 追问准备

**面试官可能问**：

Q: "如果路径可以向上走呢？"
A: "那就是 LeetCode 124（二叉树的最大路径和），需要考虑左子树+根+右子树的情况。"

Q: "如果要返回所有符合条件的路径呢？"
A: "需要额外维护路径数组，在找到符合条件时记录下来。"

Q: "为什么要回溯？"
A: "因为哈希表存储的是当前路径上的前缀和，回溯到父节点时，子节点的前缀和不应该保留，否则会影响兄弟节点的计算。"

---

## 典型错误示例

### 错误 1：忘记回溯

```go
// ❌ 错误：没有回溯
count += dfs(node.Left, currSum, targetSum, prefixSumCount)
count += dfs(node.Right, currSum, targetSum, prefixSumCount)
return count  // 错误！应该在这之前回溯
```

### 错误 2：没有初始化 prefixSumCount[0]

```go
// ❌ 错误
prefixSumCount := make(map[int64]int) // 没有初始化 [0] = 1
// 会漏掉从根节点开始的符合条件的路径
```

### 错误 3：数据溢出

```go
// ❌ 错误：使用 int
func dfs(node *TreeNode, currSum int, ...) int {
    currSum += node.Val  // 可能溢出
}

// ✅ 正确：使用 int64
func dfs(node *TreeNode, currSum int64, ...) int {
    currSum += int64(node.Val)
}
```

---

## 总结

这道题是**前缀和**思想在树结构上的经典应用，考察：

1. **前缀和理解**：如何利用前缀和快速计算子数组和
2. **哈希表优化**：空间换时间，O(1) 查找
3. **回溯思维**：处理完子树后要恢复状态
4. **树的遍历**：DFS 在二叉树上的应用

**记忆口诀**：
- 前缀和，哈希表，O(n) 时间跑得快
- 回溯清理很关键，避免污染兄弟来

掌握这道题后，可以轻松应对路径总和系列、子数组和系列等问题。核心都是**前缀和 + 哈希表**的组合技巧。
