---
title: 零钱兑换(LeetCode 322)
tags:
  - 算法
status: robot
class: 算法
slug: coin-change
ref:
---

## 核心要点

- **问题本质**: 完全背包问题的变种,求凑成目标金额所需的最少硬币个数
- **核心思路**: 动态规划,定义 dp[i] 表示凑成金额 i 所需的最少硬币数
- **状态转移**: `dp[i] = min(dp[i], dp[i - coin] + 1)` 遍历所有面额的硬币
- **初始化技巧**: dp[0] = 0,其他设为无穷大(表示无法凑成)
- **关键优化**: 完全背包可以用一维数组优化空间

## 题目描述

给你一个整数数组 `coins` 表示不同面额的硬币,以及一个整数 `amount` 表示总金额。

计算并返回可以凑成总金额所需的**最少的硬币个数**。如果没有任何一种硬币组合能组成总金额,返回 `-1`。

你可以认为每种硬币的数量是无限的。

**示例 1:**
```
输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1
```

**示例 2:**
```
输入: coins = [2], amount = 3
输出: -1
```

**示例 3:**
```
输入: coins = [1], amount = 0
输出: 0
```

**提示:**
- 1 ≤ coins.length ≤ 12
- 1 ≤ coins[i] ≤ 2³¹ - 1
- 0 ≤ amount ≤ 10⁴

## 解题思路

### 核心分析

这是一道经典的**完全背包问题**:
- **背包容量**: amount(总金额)
- **物品**: 硬币,每个硬币有面额(重量),价值都为 1(用一个硬币)
- **目标**: 装满背包所需的最少物品数

**为什么是完全背包?**
- 每种硬币可以使用**无限次**,这是完全背包的特征
- 与 0-1 背包(每个物品只能用一次)不同

### 动态规划解法

**状态定义:**
- `dp[i]` 表示凑成金额 `i` 所需的**最少硬币数**

**状态转移方程:**

对于金额 `i`,我们枚举每种硬币 `coin`:
- 如果 `i >= coin`,可以选择使用这个硬币
- 转移方程: `dp[i] = min(dp[i], dp[i - coin] + 1)`
  - `dp[i - coin]` 表示凑成金额 `i - coin` 的最少硬币数
  - `+ 1` 表示再加上当前这个硬币

**初始化:**
- `dp[0] = 0`: 凑成金额 0 需要 0 个硬币
- `dp[1...amount] = +∞`: 初始时认为都无法凑成,用一个很大的数表示

**最终答案:**
- 如果 `dp[amount]` 仍然是无穷大,说明无法凑成,返回 -1
- 否则返回 `dp[amount]`

### 详细推导示例

```
coins = [1, 2, 5], amount = 11

初始化: dp = [0, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
                 0  1  2  3  4  5  6  7  8  9 10 11

使用硬币 1 (coin = 1):
  dp[1] = min(∞, dp[0] + 1) = 1
  dp[2] = min(∞, dp[1] + 1) = 2
  dp[3] = min(∞, dp[2] + 1) = 3
  ...
  dp[11] = min(∞, dp[10] + 1) = 11

  结果: dp = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

使用硬币 2 (coin = 2):
  dp[2] = min(2, dp[0] + 1) = 1
  dp[3] = min(3, dp[1] + 1) = 2
  dp[4] = min(4, dp[2] + 1) = 2
  dp[5] = min(5, dp[3] + 1) = 3
  ...
  dp[11] = min(11, dp[9] + 1) = 6

  结果: dp = [0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6]

使用硬币 5 (coin = 5):
  dp[5] = min(3, dp[0] + 1) = 1
  dp[6] = min(3, dp[1] + 1) = 2
  dp[7] = min(4, dp[2] + 1) = 2
  ...
  dp[10] = min(5, dp[5] + 1) = 2  (5 + 5)
  dp[11] = min(6, dp[6] + 1) = 3  (5 + 5 + 1)

  最终: dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]

答案: dp[11] = 3
```

### 完全背包 vs 0-1 背包的区别

**完全背包**(本题):
```go
// 先遍历物品,再遍历容量(正序)
for coin in coins {
    for i := coin; i <= amount; i++ {
        dp[i] = min(dp[i], dp[i - coin] + 1)
    }
}
```

**0-1 背包**:
```go
// 先遍历物品,再遍历容量(逆序)
for coin in coins {
    for i := amount; i >= coin; i-- {  // 逆序!
        dp[i] = min(dp[i], dp[i - coin] + 1)
    }
}
```

**为什么完全背包要正序?**
- 正序遍历时,`dp[i - coin]` 可能已经在本轮更新过,包含了当前硬币
- 这样就实现了"一个硬币可以用多次"的效果

**为什么 0-1 背包要逆序?**
- 逆序遍历时,`dp[i - coin]` 一定是上一轮的值,不包含当前物品
- 这样就保证了"每个物品只能用一次"

## 代码实现

### Go 实现 - 动态规划

```go
func coinChange(coins []int, amount int) int {
    // dp[i] 表示凑成金额 i 所需的最少硬币数
    dp := make([]int, amount+1)

    // 初始化为一个很大的数(表示无法凑成)
    for i := 1; i <= amount; i++ {
        dp[i] = amount + 1  // 用 amount+1 代替无穷大
    }

    dp[0] = 0  // 凑成金额 0 需要 0 个硬币

    // 完全背包: 先遍历物品(硬币),再遍历容量(金额)
    for _, coin := range coins {
        for i := coin; i <= amount; i++ {
            // 选择使用当前硬币
            dp[i] = min(dp[i], dp[i-coin] + 1)
        }
    }

    // 如果 dp[amount] 仍然是初始值,说明无法凑成
    if dp[amount] > amount {
        return -1
    }

    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 另一种写法: 先遍历金额,再遍历硬币

```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)

    for i := 1; i <= amount; i++ {
        dp[i] = amount + 1
    }

    dp[0] = 0

    // 先遍历金额,再遍历硬币(效果相同)
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if i >= coin {
                dp[i] = min(dp[i], dp[i-coin] + 1)
            }
        }
    }

    if dp[amount] > amount {
        return -1
    }

    return dp[amount]
}
```

**注意**: 对于求**最少硬币数**这类问题,两种遍历顺序结果相同。但对于求**组合数**的问题,遍历顺序会影响结果。

## 复杂度分析

- **时间复杂度**: O(amount × n),其中 n 是硬币种类数
  - 外层循环 n 次(或 amount 次)
  - 内层循环 amount 次(或 n 次)
- **空间复杂度**: O(amount),dp 数组

## 常见错误

### 错误 1: 初始化为 0

```go
dp := make([]int, amount+1)  // 全部初始化为 0
```

**问题**: 这样会导致所有金额都认为可以用 0 个硬币凑成,转移时会出错。

**正确做法**: 初始化为一个大数(如 amount + 1),表示初始时无法凑成。

### 错误 2: 使用 math.MaxInt 作为无穷大

```go
dp[i] = math.MaxInt
```

**问题**: 在计算 `dp[i-coin] + 1` 时可能导致整数溢出。

**正确做法**: 使用 `amount + 1` 作为"无穷大",因为凑成 amount 最多需要 amount 个硬币(全用面额 1)。

### 错误 3: 混淆完全背包和 0-1 背包

```go
// 错误: 逆序遍历(这是 0-1 背包的写法)
for i := amount; i >= coin; i-- {
    dp[i] = min(dp[i], dp[i-coin] + 1)
}
```

**问题**: 这样每个硬币只能用一次,无法得到正确答案。

**正确做法**: 完全背包要正序遍历。

## 相关题目

1. **零钱兑换 II**(LeetCode 518): 求凑成金额的**组合数**
2. **完全平方数**(LeetCode 279): 和最少,硬币面额为完全平方数
3. **组合总和 IV**(LeetCode 377): 求凑成目标的**排列数**

## 面试技巧

1. **快速识别问题类型**: 听到"无限使用",立即想到完全背包
2. **明确目标**: 是求最少数量、组合数还是排列数,不同目标写法略有不同
3. **初始化很重要**: 强调为什么要初始化为 amount + 1 而不是 0 或 MaxInt
4. **优化空间**: 如果面试官追问,可以讨论为什么能用一维数组(因为只依赖前面的状态)
5. **边界情况**:
   - amount = 0 时返回 0
   - 无法凑成时返回 -1
   - coins 中有面额大于 amount 的硬币(不影响结果,自然用不到)
6. **举例说明**: 用一个简单的例子(如 coins=[1,2,5], amount=11)手动推导,展示动态规划的过程
