---
title: 相交链表（LeetCode 160）
tags:
  - 算法
status: robot
class: 算法
slug: intersecting-linked-lists
ref:
---

## 核心要点

**双指针法消除长度差**：两个指针分别从两链表头部出发,走到尾部后跳转到另一链表头部继续走,相遇点即为相交节点。本质是让两指针走过相同长度的路径(a+c+b = b+c+a),从而在相交点同步到达。

---

## 题目描述

给你两个单链表的头节点 `headA` 和 `headB`,请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点,返回 `null`。

**示例:**
```
链表 A: a1 → a2 ↘
                 c1 → c2 → c3
链表 B: b1 → b2 → b3 ↗
```
相交节点为 c1。

**要求:**
- 时间复杂度 O(m+n)
- 空间复杂度 O(1)

---

## 解题思路

### 方法一:双指针法(推荐)

**核心思想:**

假设链表 A 的长度为 a+c,链表 B 的长度为 b+c,其中 c 是公共部分的长度。

- 指针 pA 先走链表 A,走完后从链表 B 的头部开始走
- 指针 pB 先走链表 B,走完后从链表 A 的头部开始走

当两个指针相遇时:
- pA 走过的路径长度: a + c + b
- pB 走过的路径长度: b + c + a
- 两者相等,且相遇点就是相交节点

如果不相交,两个指针最终都会走到 null,此时也会"相遇"。

**图解过程:**

```
第一轮:
pA: a1 → a2 → c1 → c2 → c3 → null → b1 → b2 → b3 → c1
pB: b1 → b2 → b3 → c1 → c2 → c3 → null → a1 → a2 → c1
                                                      ↑
                                                   相遇点
```

**算法步骤:**

1. 初始化两个指针 pA = headA, pB = headB
2. 同时移动两个指针:
   - 如果 pA 到达末尾,则 pA = headB
   - 如果 pB 到达末尾,则 pB = headA
3. 当 pA == pB 时返回相交节点(或 null)

**代码实现(Go):**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }

    pA, pB := headA, headB

    // 两个指针会在相交节点相遇,或者都为 nil 时相遇
    for pA != pB {
        // pA 走完链表 A 后,从链表 B 头部开始
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }

        // pB 走完链表 B 后,从链表 A 头部开始
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }

    return pA  // 相交节点或 nil
}
```

**时间复杂度:** O(m+n),每个指针最多遍历两个链表各一次
**空间复杂度:** O(1),只使用两个指针

---

### 方法二:哈希表法

**思路:**

1. 遍历链表 A,将所有节点存入哈希表
2. 遍历链表 B,检查每个节点是否在哈希表中
3. 第一个在哈希表中的节点即为相交节点

**代码实现(Go):**

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    visited := make(map[*ListNode]bool)

    // 遍历链表 A,记录所有节点
    for node := headA; node != nil; node = node.Next {
        visited[node] = true
    }

    // 遍历链表 B,查找第一个已访问的节点
    for node := headB; node != nil; node = node.Next {
        if visited[node] {
            return node
        }
    }

    return nil
}
```

**时间复杂度:** O(m+n)
**空间复杂度:** O(m),需要哈希表存储链表 A 的所有节点

---

### 方法三:计算长度差

**思路:**

1. 分别计算两个链表的长度 lenA 和 lenB
2. 让较长链表的指针先走 |lenA - lenB| 步
3. 然后两个指针同时移动,第一个相同的节点即为相交节点

**代码实现(Go):**

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    lenA, lenB := getLength(headA), getLength(headB)

    // 让较长的链表先走差值步
    for lenA > lenB {
        headA = headA.Next
        lenA--
    }
    for lenB > lenA {
        headB = headB.Next
        lenB--
    }

    // 同时移动,找到相交节点
    for headA != headB {
        headA = headA.Next
        headB = headB.Next
    }

    return headA
}

func getLength(head *ListNode) int {
    length := 0
    for head != nil {
        length++
        head = head.Next
    }
    return length
}
```

**时间复杂度:** O(m+n)
**空间复杂度:** O(1)

---

## 易错点与注意事项

1. **边界条件处理:** 任一链表为空时直接返回 nil
2. **指针重定向时机:** 在双指针法中,应该在 `pA == nil` 时重定向,而不是 `pA.Next == nil`
3. **不相交的情况:** 两个指针最终都会变为 nil,此时返回 nil
4. **节点比较:** 比较的是节点的地址(引用),而不是节点的值

---

## 面试技巧

**面试官可能的追问:**

1. **为什么双指针法能保证找到相交点?**
   - 答:两个指针走过的总路径长度相同(a+c+b = b+c+a),如果有相交点,必然会在相交点同步到达;如果没有相交点,最终都会走到 null。

2. **如何判断两个链表是否有环且相交?**
   - 答:需要先用快慢指针判断是否有环,如果两个链表都有环,则判断两个环的入口点是否相同。

3. **能否修改链表结构?**
   - 答:可以将链表 A 的尾节点指向 headA 形成环,然后用环形链表的入口点方法(快慢指针)找相交点,但需要恢复原结构。

4. **如果允许使用额外空间,有更快的方法吗?**
   - 答:哈希表法可以只遍历一遍就找到,但空间复杂度为 O(m)。

---

## 总结

相交链表问题的最优解是**双指针法**,它巧妙地通过让两个指针走相同长度的路径来消除链表长度差的影响。核心在于理解:

```
pA 路径: A的独有部分 + 公共部分 + B的独有部分
pB 路径: B的独有部分 + 公共部分 + A的独有部分
```

两者长度相等,因此必然在相交点或 null 处相遇。这种方法既高效(O(m+n)时间,O(1)空间),又优雅,是面试中的最佳答案。
