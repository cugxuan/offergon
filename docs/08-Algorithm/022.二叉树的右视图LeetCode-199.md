---
title: 二叉树的右视图（LeetCode 199）
tags:
  - 算法
status: robot
class: 算法
slug: binary-tree-right-side-view
ref:
---

## 核心要点

**问题本质**：找到二叉树每一层最右边的节点。

**解题关键**：
1. 层序遍历（BFS）：按层遍历，取每层最后一个节点
2. 深度优先搜索（DFS）：优先遍历右子树，记录每层首次访问的节点
3. 核心思想：通过"层级"或"深度"来确定每层的最右节点

---

## 题目描述

给定一个二叉树的根节点 `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**
```
输入：root = [1,2,3,null,5,null,4]

        1         ← 右视图看到：1
       / \
      2   3       ← 右视图看到：3
       \   \
        5   4     ← 右视图看到：4

输出：[1,3,4]
```

**示例 2：**
```
输入：root = [1,null,3]
输出：[1,3]
```

**示例 3：**
```
输入：root = []
输出：[]
```

**约束条件：**
- 树中节点数目范围：[0, 100]
- -100 <= Node.val <= 100

---

## 解题思路

### 方法一：层序遍历（BFS）- 推荐解法

这是最直观的解法，利用队列进行层序遍历。

**核心思想**：
1. 使用队列按层遍历二叉树
2. 对于每一层，记录该层的最后一个节点（最右边的节点）
3. 将每层的最后节点加入结果集

**算法流程**：
```
1. 初始化队列，将根节点入队
2. 循环处理队列：
   - 记录当前层的节点数量 levelSize
   - 遍历当前层的所有节点：
     * 弹出队首节点
     * 如果是当前层的最后一个节点，加入结果
     * 将左右子节点（如果存在）入队
3. 返回结果数组
```

**图解示例**：
```
输入树：    1
          / \
         2   3
          \   \
           5   4

层序遍历过程：
第 1 层：[1]           → 取最后一个：1
第 2 层：[2, 3]        → 取最后一个：3
第 3 层：[5, 4]        → 取最后一个：4

结果：[1, 3, 4]
```

---

### 方法二：深度优先搜索（DFS）

利用 DFS 优先遍历右子树的特性。

**核心思想**：
1. 优先访问右子树，再访问左子树
2. 对于每个深度，第一次访问到的节点就是该层最右边的节点
3. 使用 `depth` 参数记录当前深度

**为什么优先右子树**？
- 因为从右侧看，优先看到的是右子树的节点
- 只有右子树不存在或深度不够时，才能看到左子树的节点

**算法流程**：
```
1. 递归函数 dfs(node, depth):
   - 如果 node 为空，返回
   - 如果 depth == len(result)，说明这是该层第一次访问
     → 将 node.val 加入结果（因为优先访问右子树）
   - 递归右子树：dfs(node.right, depth + 1)
   - 递归左子树：dfs(node.left, depth + 1)
```

---

## 代码实现

### 方法一：层序遍历（BFS）

#### Go 实现

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    result := []int{}
    if root == nil {
        return result
    }

    // 使用队列进行层序遍历
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue) // 当前层的节点数量

        // 遍历当前层的所有节点
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:] // 出队

            // 如果是当前层的最后一个节点，加入结果
            if i == levelSize-1 {
                result = append(result, node.Val)
            }

            // 将子节点入队
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }

    return result
}
```

#### Python 实现

```python
from collections import deque

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)

            for i in range(level_size):
                node = queue.popleft()

                # 当前层的最后一个节点
                if i == level_size - 1:
                    result.append(node.val)

                # 子节点入队
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

        return result
```

#### Java 实现

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // 当前层的最后一个节点
                if (i == levelSize - 1) {
                    result.add(node.val);
                }

                // 子节点入队
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return result;
    }
}
```

---

### 方法二：深度优先搜索（DFS）

#### Go 实现

```go
func rightSideView(root *TreeNode) []int {
    result := []int{}
    dfs(root, 0, &result)
    return result
}

func dfs(node *TreeNode, depth int, result *[]int) {
    if node == nil {
        return
    }

    // 如果是该层第一次访问，加入结果
    if depth == len(*result) {
        *result = append(*result, node.Val)
    }

    // 优先访问右子树，再访问左子树
    dfs(node.Right, depth+1, result)
    dfs(node.Left, depth+1, result)
}
```

#### Python 实现

```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        self.dfs(root, 0, result)
        return result

    def dfs(self, node, depth, result):
        if not node:
            return

        # 该层第一次访问
        if depth == len(result):
            result.append(node.val)

        # 优先右子树
        self.dfs(node.right, depth + 1, result)
        self.dfs(node.left, depth + 1, result)
```

#### Java 实现

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root, 0, result);
        return result;
    }

    private void dfs(TreeNode node, int depth, List<Integer> result) {
        if (node == null) {
            return;
        }

        // 该层第一次访问
        if (depth == result.size()) {
            result.add(node.val);
        }

        // 优先右子树
        dfs(node.right, depth + 1, result);
        dfs(node.left, depth + 1, result);
    }
}
```

---

## 复杂度分析

### 方法一：BFS
- **时间复杂度**：O(n)
  - 需要访问所有 n 个节点

- **空间复杂度**：O(n)
  - 队列最多存储一层的节点
  - 最坏情况（完全二叉树最后一层）：n/2 个节点

### 方法二：DFS
- **时间复杂度**：O(n)
  - 需要访问所有 n 个节点

- **空间复杂度**：O(h)
  - 递归栈深度为树的高度 h
  - 最坏情况（链表）：O(n)
  - 平衡树：O(log n)

---

## 关键细节与易错点

### 1. 为什么 BFS 要记录层的大小？

**错误做法**：
```go
// 错误：无法区分层级，会把所有节点都加入结果
for len(queue) > 0 {
    node := queue[0]
    queue = queue[1:]
    result = append(result, node.Val) // 错误！
}
```

**正确做法**：
```go
// 正确：通过 levelSize 区分每一层
levelSize := len(queue)
for i := 0; i < levelSize; i++ {
    // 只取最后一个节点
    if i == levelSize-1 {
        result = append(result, node.Val)
    }
}
```

### 2. DFS 为什么要判断 `depth == len(result)`？

这是关键的剪枝条件：
- `result` 的长度代表已经记录了多少层
- `depth == len(result)` 意味着这是新的一层
- 因为优先访问右子树，第一次到达新层的节点一定是最右节点

**示例**：
```
       1          depth=0, len(result)=0 → 加入 1
      / \
     2   3        depth=1, len(result)=1 → 先访问 3，加入 3
      \   \       depth=1, len(result)=2 → 访问 2，跳过（len != depth）
       5   4      depth=2, len(result)=2 → 先访问 4，加入 4
                  depth=2, len(result)=3 → 访问 5，跳过
```

### 3. 左视图怎么做？

只需要修改 DFS 的访问顺序：
```go
// 左视图：优先访问左子树
dfs(node.Left, depth+1, result)  // 先左
dfs(node.Right, depth+1, result) // 后右
```

---

## 变体题目

### 变体 1：二叉树的左视图

```go
func leftSideView(root *TreeNode) []int {
    result := []int{}
    dfs(root, 0, &result)
    return result
}

func dfs(node *TreeNode, depth int, result *[]int) {
    if node == nil {
        return
    }
    if depth == len(*result) {
        *result = append(*result, node.Val)
    }
    // 优先左子树
    dfs(node.Left, depth+1, result)
    dfs(node.Right, depth+1, result)
}
```

### 变体 2：二叉树的底部视图

```go
// 底部视图：按水平距离分组，每组取最底层节点
func bottomView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    // map[水平距离] = {深度, 值}
    viewMap := make(map[int]struct{ depth, val int })
    minHD, maxHD := 0, 0

    var dfs func(*TreeNode, int, int)
    dfs = func(node *TreeNode, hd, depth int) {
        if node == nil {
            return
        }

        // 更新该水平距离的最底层节点
        if v, exists := viewMap[hd]; !exists || depth >= v.depth {
            viewMap[hd] = struct{ depth, val int }{depth, node.Val}
        }

        minHD = min(minHD, hd)
        maxHD = max(maxHD, hd)

        dfs(node.Left, hd-1, depth+1)
        dfs(node.Right, hd+1, depth+1)
    }

    dfs(root, 0, 0)

    // 按水平距离从左到右输出
    result := []int{}
    for i := minHD; i <= maxHD; i++ {
        result = append(result, viewMap[i].val)
    }
    return result
}
```

### 变体 3：所有层的右视图（包括中间节点）

```go
// 返回每一层的所有节点（不止最右节点）
func levelOrder(root *TreeNode) [][]int {
    result := [][]int{}
    if root == nil {
        return result
    }

    queue := []*TreeNode{root}
    for len(queue) > 0 {
        levelSize := len(queue)
        level := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            level = append(level, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        result = append(result, level)
    }
    return result
}
```

---

## 面试技巧

### 1. 思路表达

"这道题有两种经典解法：

**BFS 解法**（推荐）：
- 使用队列进行层序遍历
- 对于每一层，记录该层的最后一个节点
- 时间 O(n)，空间 O(n)

**DFS 解法**：
- 优先遍历右子树，利用深度标记每层
- 每层第一次访问到的节点就是最右节点
- 时间 O(n)，空间 O(h)

我倾向于使用 BFS，因为更直观易懂。"

### 2. 优化讨论

**面试官可能问**："能否优化空间复杂度？"

**回答**：
- BFS 的空间复杂度已经是 O(n)，无法优化（队列必须存储一层的节点）
- DFS 的空间复杂度是 O(h)，在平衡树情况下为 O(log n)，比 BFS 更优
- 但对于倾斜树（链表），两者都是 O(n)

### 3. 扩展问题

面试官可能追问：
- "如果要求左视图呢？" → DFS 优先访问左子树
- "如果要求顶部视图呢？" → 按水平距离分组，取深度最小的
- "如果要求底部视图呢？" → 按水平距离分组，取深度最大的

### 4. 边界情况处理

主动提及：
- 空树：返回空数组
- 单节点树：返回 [root.val]
- 只有左子树或右子树的情况

---

## 典型错误示例

### 错误 1：忘记记录层级大小

```go
// ❌ 错误
for len(queue) > 0 {
    node := queue[0]
    queue = queue[1:]
    result = append(result, node.Val) // 所有节点都加入了
}
```

### 错误 2：DFS 访问顺序错误

```go
// ❌ 错误：先访问左子树
dfs(node.Left, depth+1, result)  // 错误顺序
dfs(node.Right, depth+1, result)
// 这样会得到左视图，不是右视图
```

### 错误 3：深度判断错误

```go
// ❌ 错误
if depth > len(*result) {  // 应该是 ==，不是 >
    *result = append(*result, node.Val)
}
```

---

## 总结

这道题是**层序遍历**的经典应用，考察：
1. **BFS 思想**：队列 + 层级遍历
2. **DFS 变体**：利用深度优先搜索的顺序特性
3. **空间优化**：理解不同方法的空间复杂度差异

**记忆口诀**：
- BFS 按层走，取每层最右头
- DFS 右先行，首次访问定乾坤

掌握这道题后，可以轻松应对左视图、顶部视图、底部视图等变体问题。核心都是**层级或深度的理解**。
