---
title: 两数相加（LeetCode 2）
tags:
  - 算法
status: robot
class: 算法
slug: add-two-numbers
ref:
---

## 核心要点

**链表模拟加法**:逐位相加,处理进位carry
**逆序存储优势**:从低位到高位遍历,天然符合加法顺序
**关键细节**:处理链表长度不同、最后的进位、空链表边界
**时间O(max(m,n))、空间O(1)**(不计结果链表)

---

## 详细解答

### 题目理解

给定两个非空链表,表示两个非负整数。数字以逆序方式存储,每个节点存储一位数字。将两数相加并以同样形式返回。

```
示例:
输入: l1 = [2,4,3], l2 = [5,6,4]
解释: 342 + 465 = 807
输出: [7,0,8]

可视化:
    2 -> 4 -> 3   (表示342)
+   5 -> 6 -> 4   (表示465)
-----------------
    7 -> 0 -> 8   (表示807)
```

**关键理解点**:
1. 链表是逆序存储,个位在头节点,方便从低位开始加
2. 每位相加可能产生进位(carry)
3. 两链表长度可能不同
4. 最高位相加可能产生额外进位

### 解法:模拟加法过程

#### 核心思路

模拟小学学的竖式加法:

1. **初始化**:
   - 创建哑节点(dummy)简化边界处理
   - 进位carry初始化为0
2. **逐位相加**:
   - 取两链表当前位的值(若为空则为0)
   - 计算 `sum = val1 + val2 + carry`
   - 当前位结果: `sum % 10`
   - 新的进位: `sum / 10`
3. **处理剩余部分**:
   - 长度较长的链表继续处理
   - 最后检查是否有进位需要新增节点
4. **返回**:哑节点的next

#### 代码实现

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}  // 哑节点,简化边界处理
    curr := dummy
    carry := 0  // 进位

    // 遍历两个链表,直到都为空且无进位
    for l1 != nil || l2 != nil || carry > 0 {
        sum := carry  // 从进位开始累加

        // 加上l1当前位
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }

        // 加上l2当前位
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }

        // 创建新节点存储当前位结果
        carry = sum / 10      // 计算新的进位
        curr.Next = &ListNode{Val: sum % 10}  // 当前位的值
        curr = curr.Next
    }

    return dummy.Next
}
```

#### 复杂度分析

设两链表长度分别为m和n:

- **时间复杂度**: O(max(m, n))
  - 需要遍历较长链表的所有节点
  - 每个节点只处理一次
- **空间复杂度**: O(1)
  - 仅使用常量级额外空间(carry, curr等)
  - 不计算结果链表的空间

#### 图解过程

```
示例: l1=[2,4,3], l2=[5,6,4]

初始: carry=0, dummy->NULL

步骤1: sum=2+5+0=7, carry=0
       dummy -> [7] -> NULL

步骤2: sum=4+6+0=10, carry=1
       dummy -> [7] -> [0] -> NULL

步骤3: sum=3+4+1=8, carry=0
       dummy -> [7] -> [0] -> [8] -> NULL

结果: [7,0,8]
```

```
进位示例: l1=[9,9], l2=[1]

步骤1: sum=9+1+0=10, carry=1
       dummy -> [0] -> NULL

步骤2: sum=9+0+1=10, carry=1
       dummy -> [0] -> [0] -> NULL

步骤3: sum=0+0+1=1, carry=0  (l1和l2都为空,但carry=1)
       dummy -> [0] -> [0] -> [1] -> NULL

结果: [0,0,1] (表示100)
```

### 边界情况处理

1. **链表长度不同**:
   ```
   l1=[9,9,9,9]
   l2=[1]
   结果:[0,0,0,0,1]
   ```

2. **最后有进位**:
   ```
   l1=[5]
   l2=[5]
   sum=10, 结果:[0,1]
   ```

3. **其中一个为空**:
   ```
   l1=[0]
   l2=[]
   按题意两链表都非空,但代码能处理
   ```

4. **两个单节点**:
   ```
   l1=[0]
   l2=[0]
   结果:[0]
   ```

### 常见错误

1. ❌ 忘记处理最后的进位
   ```go
   for l1 != nil || l2 != nil {  // 错误!循环结束时carry可能为1
       // ...
   }
   // 正确:
   for l1 != nil || l2 != nil || carry > 0
   ```

2. ❌ 链表为空时未判断就访问Val
   ```go
   sum := l1.Val + l2.Val + carry  // 错误!l1或l2可能为nil
   // 正确:
   if l1 != nil {
       sum += l1.Val
   }
   ```

3. ❌ 进位计算错误
   ```go
   carry = sum % 10  // 错误!应该是除法
   curr.Next = &ListNode{Val: sum / 10}  // 错误!应该是取模
   // 正确:
   carry = sum / 10
   curr.Next = &ListNode{Val: sum % 10}
   ```

4. ❌ 返回错误的头节点
   ```go
   return dummy  // 错误!应该返回dummy.Next
   ```

### 优化技巧

#### 原地修改版本(不推荐)

可以复用l1或l2的节点,减少内存分配,但会破坏原链表:

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{Next: l1}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        sum := carry

        if l1 != nil {
            sum += l1.Val
            curr = l1
            l1 = l1.Next
        } else if l2 != nil {
            curr.Next = l2  // 复用l2剩余节点
            curr = l2
            sum += l2.Val
            l2 = l2.Next
        } else {
            curr.Next = &ListNode{}  // 最后的进位
            curr = curr.Next
        }

        curr.Val = sum % 10
        carry = sum / 10
    }

    return dummy.Next
}
```

**不推荐原因**:代码复杂度增加,面试中优先保证正确性和可读性。

### 面试要点

1. **思路清晰**:类比竖式加法,面试官易于理解
2. **边界处理完备**:
   - 链表长度不同
   - 最后的进位
   - 空链表(虽然题目说非空)
3. **代码简洁**:使用哑节点避免特殊处理头节点
4. **复杂度分析**:强调时间O(max(m,n)),空间O(1)
5. **扩展讨论**:
   - 如果链表是正序存储怎么办?(先反转链表或用栈)
   - 如果要求不能修改原链表?(默认实现已满足)
   - 如果数字很大超过整型范围?(链表天然支持大数)

### 变体题目

1. **LeetCode 445 - 两数相加 II**:
   - 链表正序存储(高位在前)
   - 解法:反转链表后用本题方法,或使用栈

2. **LeetCode 67 - 二进制求和**:
   - 字符串表示二进制数
   - 解法:类似思路,进位为2

3. **LeetCode 415 - 字符串相加**:
   - 字符串表示十进制数
   - 解法:从后往前遍历,处理进位

### 实战技巧

1. **测试用例准备**:
   ```
   - 相同长度:[2,4,3], [5,6,4]
   - 不同长度:[9,9,9,9], [1]
   - 产生进位:[5], [5]
   - 多位进位:[9,9], [1]
   - 单节点:[0], [0]
   ```

2. **调试技巧**:打印每一步的sum、carry、当前节点值

3. **时间控制**:5-8分钟完成编码+测试

4. **画图辅助**:手写竖式加法过程,标注carry

### 知识扩展

**链表表示大数的优势**:
- 不受整型位数限制(可表示任意大的数)
- 动态长度,节省空间
- 天然支持逐位操作

**实际应用**:
- 高精度计算库(如Python的decimal模块)
- 密码学中的大数运算
- 金融系统的精确计算

**Go语言特性**:
- 结构体指针简化链表操作
- 自动垃圾回收,无需手动释放内存
- 多返回值可优化为返回(result, error)

这道题考察链表基本操作和模拟能力,是链表题中的经典入门题,建议彻底掌握,作为后续复杂链表题的基础。核心在于清晰的逻辑和完备的边界处理,面试时稳中求胜。
