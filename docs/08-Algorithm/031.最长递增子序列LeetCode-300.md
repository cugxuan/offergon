---
title: 最长递增子序列（LeetCode 300）
tags:
  - 算法
status: robot
class: 算法
slug: longest-increasing-subsequence
ref:
---

## 核心要点

- **问题本质**: 在给定数组中找到最长严格递增子序列(不要求连续)的长度
- **解法一**: 动态规划 O(n²) - 定义 dp[i] 表示以第 i 个元素结尾的最长递增子序列长度
- **解法二**: 动态规划+二分查找 O(n log n) - 维护一个递增序列,贪心地保持序列尽可能小
- **关键技巧**: 二分查找优化时,维护的数组含义是"长度为 i+1 的递增子序列末尾元素的最小值"

## 题目描述

给你一个整数数组 `nums`,找到其中最长严格递增子序列的长度。

**子序列**是由数组派生而来的序列,删除(或不删除)数组中的元素而不改变其余元素的顺序。例如,[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

**示例 1:**
```
输入: nums = [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长递增子序列是 [2,3,7,101],因此长度为 4
```

**示例 2:**
```
输入: nums = [0,1,0,3,2,3]
输出: 4
```

**示例 3:**
```
输入: nums = [7,7,7,7,7,7,7]
输出: 1
```

## 解题思路

### 方法一: 动态规划 O(n²)

**思路分析:**

1. **状态定义**: `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度
2. **状态转移**: 对于每个位置 i,需要遍历它前面所有位置 j (0 ≤ j < i)
   - 如果 `nums[i] > nums[j]`,说明 nums[i] 可以接在以 nums[j] 结尾的子序列后面
   - 转移方程: `dp[i] = max(dp[i], dp[j] + 1)`
3. **初始状态**: 每个元素自己都可以构成长度为 1 的递增子序列,所以 `dp[i] = 1`
4. **最终答案**: `max(dp[0], dp[1], ..., dp[n-1])`

**举例说明:**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

dp[0] = 1  (子序列: [10])
dp[1] = 1  (子序列: [9])
dp[2] = 1  (子序列: [2])
dp[3] = 2  (子序列: [2, 5])
dp[4] = 2  (子序列: [2, 3])
dp[5] = 3  (子序列: [2, 3, 7] 或 [2, 5, 7])
dp[6] = 4  (子序列: [2, 3, 7, 101])
dp[7] = 4  (子序列: [2, 3, 7, 18])

答案: max(dp) = 4
```

### 方法二: 动态规划 + 二分查找 O(n log n)

**核心思想**: 贪心 + 维护递增序列

我们维护一个数组 `tails`,其中 `tails[i]` 表示**长度为 i+1 的所有递增子序列中末尾元素的最小值**。

**关键洞察:**
- 要让递增子序列尽可能长,我们希望子序列上升得"尽可能慢"
- 也就是说,对于相同长度的递增子序列,末尾元素越小越好,因为后面更容易接上新元素

**算法流程:**

1. 遍历数组中每个元素 num
2. 如果 num 大于 tails 中所有元素,直接追加到 tails 末尾(找到了更长的递增子序列)
3. 否则,在 tails 中**二分查找**第一个大于等于 num 的位置,用 num 替换它
   - 这样可以让对应长度的递增子序列末尾元素更小,为后续元素创造更多机会

**举例说明:**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

初始: tails = []

处理 10: tails = [10]              (长度为1,末尾最小是10)
处理 9:  tails = [9]               (长度为1,用9替换10,末尾更小)
处理 2:  tails = [2]               (长度为1,用2替换9,末尾更小)
处理 5:  tails = [2, 5]            (5大于所有元素,追加,长度变为2)
处理 3:  tails = [2, 3]            (用3替换5,长度为2的序列末尾更小)
处理 7:  tails = [2, 3, 7]         (7大于所有元素,追加,长度变为3)
处理 101: tails = [2, 3, 7, 101]   (追加,长度变为4)
处理 18: tails = [2, 3, 7, 18]     (用18替换101,长度为4的序列末尾更小)

答案: len(tails) = 4
```

**注意**: tails 数组本身不一定是实际的最长递增子序列,但它的长度就是答案。

## 代码实现

### Go 实现 - 方法一: O(n²)

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    n := len(nums)
    dp := make([]int, n)

    // 初始化: 每个元素自己构成长度为1的子序列
    for i := 0; i < n; i++ {
        dp[i] = 1
    }

    maxLen := 1

    // 状态转移
    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }

    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### Go 实现 - 方法二: O(n log n)

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    // tails[i] 表示长度为 i+1 的递增子序列末尾元素的最小值
    tails := []int{}

    for _, num := range nums {
        // 二分查找第一个大于等于 num 的位置
        left, right := 0, len(tails)
        for left < right {
            mid := left + (right - left) / 2
            if tails[mid] < num {
                left = mid + 1
            } else {
                right = mid
            }
        }

        // 如果 left == len(tails),说明 num 比所有元素都大,追加
        if left == len(tails) {
            tails = append(tails, num)
        } else {
            // 否则用 num 替换 tails[left],使末尾元素更小
            tails[left] = num
        }
    }

    return len(tails)
}
```

## 复杂度分析

### 方法一: 动态规划
- **时间复杂度**: O(n²),两层循环遍历
- **空间复杂度**: O(n),dp 数组

### 方法二: 动态规划 + 二分查找
- **时间复杂度**: O(n log n),n 次遍历,每次二分查找 O(log n)
- **空间复杂度**: O(n),tails 数组

## 相关变形题目

1. **俄罗斯套娃信封问题**(LeetCode 354): 二维版本的 LIS
2. **最长递增子序列的个数**(LeetCode 673): 求有多少个最长递增子序列
3. **最长连续递增序列**(LeetCode 674): 要求子序列必须连续

## 面试技巧

1. **先说 O(n²) 解法**: 动态规划的基本思路容易理解,先讲清楚状态定义和转移方程
2. **再优化到 O(n log n)**: 如果面试官追问能否优化,再讲贪心+二分的思路
3. **强调关键点**: tails 数组的含义是"长度为 i+1 的递增子序列末尾元素的最小值",这是理解算法的关键
4. **画图说明**: 在纸上演示样例的执行过程,让面试官看到 tails 数组的变化
5. **注意边界**: 空数组、单元素数组、全部相同元素等特殊情况
