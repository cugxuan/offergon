---
title: Redis Sentinel（哨兵）如何实现高可用？
tags:
  - 缓存
status: robot
class: 缓存
slug: redis-sentinel-high-availability
ref:
---

## 核心要点

Redis Sentinel 是 Redis 官方的高可用解决方案,通过监控、通知、自动故障转移实现主从架构的高可用。哨兵集群通过 Raft 协议选举 Leader,当检测到 Master 故障时自动将 Slave 提升为 Master。

## 详细回答

### Sentinel 架构

```
  Sentinel1   Sentinel2   Sentinel3
      ↓          ↓          ↓
    监控        监控        监控
      ↓          ↓          ↓
   Master ←→ Slave1 ←→ Slave2
```

**组成**:
- 哨兵集群(通常 3 个或 5 个节点)
- Redis 主从集群
- 客户端

### 核心功能

#### 1. 监控 (Monitoring)
- 哨兵定期 ping Redis 主从节点
- 检查 Master 和 Slave 是否正常运行
- 默认每秒发送一次 PING 命令

#### 2. 通知 (Notification)
- 当 Redis 实例出现故障时通知管理员
- 通过 API 向其他程序发送通知

#### 3. 自动故障转移 (Automatic Failover)
- Master 故障时,自动将某个 Slave 提升为 Master
- 其他 Slave 重新配置,指向新 Master
- 客户端重定向到新 Master

#### 4. 配置提供者 (Configuration Provider)
- 客户端连接哨兵获取当前 Master 地址
- Master 故障转移后,返回新 Master 地址

### 工作原理

#### 故障检测

**主观下线 (Subjectively Down, SDOWN)**:
- 单个哨兵认为 Master 下线
- 超过 `down-after-milliseconds` 毫秒未响应 PING

**客观下线 (Objectively Down, ODOWN)**:
- 多个哨兵(达到 quorum 数量)都认为 Master 下线
- 只有达到 ODOWN 才会触发故障转移

```bash
sentinel monitor mymaster 127.0.0.1 6379 2
# 2 表示 quorum,至少 2 个哨兵同意才是客观下线
```

#### 故障转移流程

```
1. 检测 Master 故障
   ↓
2. 哨兵选举 Leader(Raft 协议)
   ↓
3. Leader 哨兵选择新 Master
   ↓
4. 发送 SLAVEOF NO ONE 提升为 Master
   ↓
5. 其他 Slave 执行 SLAVEOF <new_master>
   ↓
6. 更新配置,通知客户端
```

**详细步骤**:

1. **选举 Leader 哨兵**:
   - 使用 Raft 算法在哨兵集群中选举
   - 获得多数票(n/2+1)的哨兵成为 Leader
   - Leader 负责执行故障转移

2. **选择新 Master**(优先级从高到低):
   - 排除已下线和响应慢的 Slave
   - 优先级最高(replica-priority 配置)
   - 复制偏移量最大(数据最新)
   - runid 最小(字典序)

3. **执行故障转移**:
   ```bash
   # Leader 哨兵向选中的 Slave 发送
   SLAVEOF NO ONE

   # 向其他 Slave 发送
   SLAVEOF <new_master_ip> <new_master_port>
   ```

4. **更新配置**:
   - 哨兵更新自己的配置文件
   - 客户端通过 Pub/Sub 或重新查询获取新 Master

5. **旧 Master 处理**:
   - 旧 Master 恢复后变成 Slave
   - 自动同步新 Master 数据

### 配置示例

#### 哨兵配置 (sentinel.conf)
```bash
# 监控的 Master
sentinel monitor mymaster 127.0.0.1 6379 2

# 30 秒内未响应判定为主观下线
sentinel down-after-milliseconds mymaster 30000

# 故障转移超时时间
sentinel failover-timeout mymaster 180000

# 并行同步的 Slave 数量
sentinel parallel-syncs mymaster 1

# 认证密码
sentinel auth-pass mymaster yourpassword

# 通知脚本
sentinel notification-script mymaster /var/redis/notify.sh

# 客户端重配置脚本
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
```

#### 启动哨兵
```bash
redis-sentinel /path/to/sentinel.conf
# 或
redis-server /path/to/sentinel.conf --sentinel
```

### 客户端使用

#### Go 示例 (go-redis)
```go
import "github.com/go-redis/redis/v8"

// 使用哨兵模式
rdb := redis.NewFailoverClient(&redis.FailoverOptions{
    MasterName:    "mymaster",
    SentinelAddrs: []string{
        "sentinel1:26379",
        "sentinel2:26379",
        "sentinel3:26379",
    },
})

// 客户端会自动发现 Master 并处理故障转移
val, err := rdb.Get(ctx, "key").Result()
```

#### Java 示例 (Jedis)
```java
Set<String> sentinels = new HashSet<>();
sentinels.add("sentinel1:26379");
sentinels.add("sentinel2:26379");
sentinels.add("sentinel3:26379");

JedisSentinelPool pool = new JedisSentinelPool(
    "mymaster",
    sentinels
);

Jedis jedis = pool.getResource();
```

### 关键参数

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| quorum | 判定客观下线的哨兵数量 | 哨兵总数/2+1 |
| down-after-milliseconds | 主观下线判定时间 | 30000 (30秒) |
| failover-timeout | 故障转移超时时间 | 180000 (3分钟) |
| parallel-syncs | 同时向新 Master 同步的 Slave 数 | 1 (避免同时全量同步) |

### 哨兵集群通信

**三个定时任务**:

1. **每 1 秒**: 每个哨兵向 Master、Slave、其他哨兵发送 PING
   - 检测实例是否在线
   - 统计响应时间

2. **每 2 秒**: 哨兵通过 Master 的 `__sentinel__:hello` 频道交换信息
   - 发现其他哨兵
   - 交换对 Master 的判断

3. **每 10 秒**: 哨兵向 Master 和 Slave 发送 INFO 命令
   - 获取主从拓扑信息
   - 发现新的 Slave

### 优缺点

**优点**:
- 自动故障转移,无需人工干预
- 主从切换对客户端透明
- 配置简单,官方支持

**缺点**:
- 无法水平扩展写能力(单 Master)
- 故障转移期间有短暂不可用(通常几秒)
- 异步复制可能丢失少量数据
- 哨兵本身需要奇数个节点

### 与 Cluster 对比

| 特性 | Sentinel | Cluster |
|------|---------|--------|
| 架构 | 主从 + 哨兵 | 分片集群 |
| 扩展性 | 不支持水平扩展 | 支持水平扩展 |
| 高可用 | 支持 | 支持 |
| 数据分片 | 不支持 | 支持(16384 槽位) |
| 适用场景 | 数据量小,读多写少 | 数据量大,需要扩展 |

### 最佳实践

1. **哨兵数量**:
   - 至少 3 个(奇数个)
   - 部署在不同机器/机房

2. **quorum 设置**:
   - 设为哨兵总数的一半+1
   - 避免脑裂

3. **网络隔离**:
   - 哨兵应部署在多个可用区
   - 防止单点故障

4. **客户端重试**:
   - 故障转移期间客户端要有重试机制
   - 使用支持 Sentinel 的客户端库

5. **监控告警**:
   - 监控 +sdown、+odown 事件
   - 监控 +failover-triggered 事件
   - 使用 `SENTINEL masters` 命令检查状态
