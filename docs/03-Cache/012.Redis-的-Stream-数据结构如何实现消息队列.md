---
title: Redis 的 Stream 数据结构如何实现消息队列？
tags:
  - 缓存
status: robot
class: 缓存
slug: redis-stream-message-queue-implementation
ref:
---

## 核心要点

Redis Stream 是 Redis 5.0 引入的消息队列数据结构,支持消息持久化、消费组、ACK 确认机制。相比 Pub/Sub 提供了更可靠的消息队列功能,支持消息积压、重复消费、消费者组协作,适合实现可靠的任务队列和事件流处理。

## 详细回答

### Stream 基础

#### 什么是 Stream?

Stream 是一个**仅追加**(append-only)的日志型数据结构,类似 Kafka 的 topic。

```
Stream: mystream
┌────────────────────────────────────────┐
│ 1609459200000-0 → {user: "alice", action: "login"}  │
│ 1609459201000-0 → {user: "bob", action: "logout"}   │
│ 1609459202000-0 → {user: "carol", action: "purchase"}│
└────────────────────────────────────────┘
                 ↑
            消息 ID (时间戳-序号)
```

**核心概念**:
- **Message ID**: 唯一标识,格式为 `时间戳毫秒-序号`
- **Entry**: 消息条目,包含多个 field-value 对
- **Consumer Group**: 消费者组,支持多个消费者协作
- **Pending List**: 待确认消息列表

#### 基本命令

| 命令 | 说明 | 示例 |
|------|------|------|
| XADD | 添加消息 | XADD stream * field value |
| XLEN | 获取消息数量 | XLEN stream |
| XREAD | 读取消息 | XREAD COUNT 10 STREAMS stream 0 |
| XRANGE | 范围查询 | XRANGE stream - + |
| XDEL | 删除消息 | XDEL stream msg_id |
| XTRIM | 裁剪消息 | XTRIM stream MAXLEN 1000 |

**消费组命令**:

| 命令 | 说明 |
|------|------|
| XGROUP CREATE | 创建消费组 |
| XREADGROUP | 消费组读取 |
| XACK | 确认消息 |
| XPENDING | 查看待确认消息 |
| XCLAIM | 转移消息所有权 |

### 生产者: 发送消息

#### XADD 添加消息

```bash
# 自动生成消息 ID (* 表示自动生成)
XADD mystream * user alice action login
# "1609459200000-0"

XADD mystream * user bob action logout
# "1609459201000-0"

# 指定消息 ID
XADD mystream 1609459202000-0 user carol action purchase
# "1609459202000-0"

# 限制长度 (MAXLEN)
XADD mystream MAXLEN 1000 * user david action signup
# 保留最新 1000 条消息,自动删除旧消息
```

**Go 代码**:
```go
import "github.com/go-redis/redis/v8"

func ProduceMessage(ctx context.Context, rdb *redis.Client) {
    // 发送消息
    id, err := rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: "mystream",
        Values: map[string]interface{}{
            "user":   "alice",
            "action": "login",
        },
    }).Result()

    fmt.Printf("Message ID: %s\n", id)
}

// 带长度限制
func ProduceWithLimit(ctx context.Context, rdb *redis.Client) {
    rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: "mystream",
        MaxLen: 1000,  // 最多保留 1000 条
        Approx: true,  // 近似裁剪(性能更好)
        Values: map[string]interface{}{
            "user": "bob",
        },
    })
}
```

### 消费者: 读取消息

#### XREAD 简单读取

```bash
# 从头开始读取
XREAD COUNT 2 STREAMS mystream 0
# 1) 1) "mystream"
#    2) 1) 1) "1609459200000-0"
#          2) 1) "user"
#             2) "alice"
#             3) "action"
#             4) "login"
#       2) 1) "1609459201000-0"
#          2) 1) "user"
#             2) "bob"

# 从指定 ID 之后读取
XREAD COUNT 10 STREAMS mystream 1609459200000-0

# 阻塞读取(类似 BLPOP)
XREAD BLOCK 5000 STREAMS mystream $
# 阻塞 5 秒,等待新消息 ($ 表示只读取新消息)
```

**Go 代码**:
```go
func SimpleConsumer(ctx context.Context, rdb *redis.Client) {
    // 从头开始读取
    streams, err := rdb.XRead(ctx, &redis.XReadArgs{
        Streams: []string{"mystream", "0"},
        Count:   10,
        Block:   0,  // 非阻塞
    }).Result()

    for _, stream := range streams {
        for _, msg := range stream.Messages {
            fmt.Printf("ID: %s, Data: %v\n", msg.ID, msg.Values)
        }
    }
}

// 阻塞读取新消息
func BlockingConsumer(ctx context.Context, rdb *redis.Client) {
    for {
        streams, err := rdb.XRead(ctx, &redis.XReadArgs{
            Streams: []string{"mystream", "$"},
            Block:   5 * time.Second,  // 阻塞 5 秒
        }).Result()

        if err != nil {
            continue
        }

        for _, stream := range streams {
            for _, msg := range stream.Messages {
                processMessage(msg)
            }
        }
    }
}
```

### 消费组 (Consumer Group)

#### 为什么需要消费组?

**问题**: 多个消费者使用 XREAD,每个都会读到相同消息。

**解决**: 消费组确保每条消息只被组内一个消费者消费。

```
Stream: mystream
    ↓
┌────────────────────────────┐
│    Consumer Group: group1  │
│  ┌──────────────────────┐  │
│  │ Consumer1 → Msg1     │  │
│  │ Consumer2 → Msg2     │  │
│  │ Consumer3 → Msg3     │  │
│  └──────────────────────┘  │
└────────────────────────────┘

特点:
- 每条消息只被组内一个消费者消费
- 支持多个消费者并行处理
- 支持消息确认 (ACK)
- 支持故障转移
```

#### 创建消费组

```bash
# 创建消费组
XGROUP CREATE mystream group1 0
# OK

# 从最新消息开始
XGROUP CREATE mystream group2 $
# OK

# 删除消费组
XGROUP DESTROY mystream group1
```

**Go 代码**:
```go
func CreateConsumerGroup(ctx context.Context, rdb *redis.Client) {
    // 创建消费组 (从头开始)
    err := rdb.XGroupCreate(ctx, "mystream", "group1", "0").Err()
    if err != nil {
        log.Printf("Group already exists: %v", err)
    }

    // 从最新消息开始
    rdb.XGroupCreateMkStream(ctx, "mystream", "group2", "$")
}
```

#### 消费组读取消息

```bash
# 消费组读取
XREADGROUP GROUP group1 consumer1 COUNT 1 STREAMS mystream >
# 1) 1) "mystream"
#    2) 1) 1) "1609459200000-0"
#          2) 1) "user"
#             2) "alice"

# > 表示读取未消费的消息

# 读取待确认消息
XREADGROUP GROUP group1 consumer1 STREAMS mystream 0
```

**Go 代码**:
```go
func ConsumeWithGroup(ctx context.Context, rdb *redis.Client) {
    consumerName := "consumer1"

    for {
        streams, err := rdb.XReadGroup(ctx, &redis.XReadGroupArgs{
            Group:    "group1",
            Consumer: consumerName,
            Streams:  []string{"mystream", ">"},
            Count:    10,
            Block:    5 * time.Second,
        }).Result()

        if err != nil {
            continue
        }

        for _, stream := range streams {
            for _, msg := range stream.Messages {
                // 处理消息
                if err := processMessage(msg); err != nil {
                    log.Printf("Process failed: %v", err)
                    continue
                }

                // 确认消息
                rdb.XAck(ctx, stream.Stream, "group1", msg.ID)
            }
        }
    }
}
```

#### 消息确认 (ACK)

```bash
# 确认消息
XACK mystream group1 1609459200000-0
# (integer) 1

# 批量确认
XACK mystream group1 1609459200000-0 1609459201000-0
# (integer) 2
```

### 待确认消息 (Pending List)

#### 查看待确认消息

```bash
# 查看所有待确认消息
XPENDING mystream group1
# 1) (integer) 3                    # 待确认消息数量
# 2) "1609459200000-0"               # 最小消息 ID
# 3) "1609459202000-0"               # 最大消息 ID
# 4) 1) 1) "consumer1"
#       2) "2"                       # consumer1 有 2 条待确认
#    2) 1) "consumer2"
#       2) "1"

# 查看详细信息
XPENDING mystream group1 - + 10 consumer1
# 1) 1) "1609459200000-0"
#    2) "consumer1"
#    3) (integer) 1000               # 空闲时间 (毫秒)
#    4) (integer) 1                  # 投递次数
```

**Go 代码**:
```go
func CheckPending(ctx context.Context, rdb *redis.Client) {
    // 获取待确认消息
    pending, err := rdb.XPending(ctx, "mystream", "group1").Result()
    if err != nil {
        return
    }

    fmt.Printf("Pending: %d messages\n", pending.Count)

    // 获取详细信息
    pendingExt, err := rdb.XPendingExt(ctx, &redis.XPendingExtArgs{
        Stream: "mystream",
        Group:  "group1",
        Start:  "-",
        End:    "+",
        Count:  10,
    }).Result()

    for _, msg := range pendingExt {
        fmt.Printf("ID: %s, Consumer: %s, Idle: %v\n",
            msg.ID, msg.Consumer, msg.Idle)
    }
}
```

#### 转移消息所有权 (XCLAIM)

**场景**: Consumer1 崩溃,需要将其待确认消息转移给 Consumer2。

```bash
# 转移空闲超过 60 秒的消息
XCLAIM mystream group1 consumer2 60000 1609459200000-0
# 将消息 1609459200000-0 从原消费者转移给 consumer2
```

**Go 代码**:
```go
func ClaimStaleMessages(ctx context.Context, rdb *redis.Client) {
    // 查找空闲超过 60 秒的消息
    pendingExt, _ := rdb.XPendingExt(ctx, &redis.XPendingExtArgs{
        Stream: "mystream",
        Group:  "group1",
        Start:  "-",
        End:    "+",
        Count:  100,
    }).Result()

    for _, msg := range pendingExt {
        if msg.Idle > 60*time.Second {
            // 转移消息
            rdb.XClaim(ctx, &redis.XClaimArgs{
                Stream:   "mystream",
                Group:    "group1",
                Consumer: "consumer2",
                MinIdle:  60 * time.Second,
                Messages: []string{msg.ID},
            })
        }
    }
}
```

### 管理命令

```bash
# 查看 Stream 长度
XLEN mystream
# (integer) 100

# 范围查询
XRANGE mystream - +
# 查询所有消息

XRANGE mystream 1609459200000-0 1609459300000-0
# 查询指定范围

# 反向查询
XREVRANGE mystream + - COUNT 10
# 最新 10 条消息

# 删除消息
XDEL mystream 1609459200000-0
# (integer) 1

# 裁剪消息
XTRIM mystream MAXLEN 1000
# 保留最新 1000 条

XTRIM mystream MAXLEN ~ 1000
# 近似裁剪 (性能更好)
```

### 实战示例

#### 任务队列

```go
type TaskQueue struct {
    rdb    *redis.Client
    stream string
    group  string
}

// 生产者: 添加任务
func (q *TaskQueue) AddTask(ctx context.Context, task map[string]interface{}) error {
    return q.rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: q.stream,
        MaxLen: 10000,
        Approx: true,
        Values: task,
    }).Err()
}

// 消费者: 处理任务
func (q *TaskQueue) Worker(ctx context.Context, consumerName string) {
    // 创建消费组
    q.rdb.XGroupCreateMkStream(ctx, q.stream, q.group, "0")

    for {
        streams, err := q.rdb.XReadGroup(ctx, &redis.XReadGroupArgs{
            Group:    q.group,
            Consumer: consumerName,
            Streams:  []string{q.stream, ">"},
            Count:    1,
            Block:    5 * time.Second,
        }).Result()

        if err != nil {
            continue
        }

        for _, stream := range streams {
            for _, msg := range stream.Messages {
                // 处理任务
                if err := q.processTask(msg.Values); err != nil {
                    log.Printf("Task failed: %v", err)
                    continue
                }

                // 确认任务完成
                q.rdb.XAck(ctx, q.stream, q.group, msg.ID)
            }
        }
    }
}

func (q *TaskQueue) processTask(task map[string]interface{}) error {
    // 业务逻辑
    fmt.Printf("Processing task: %v\n", task)
    return nil
}

// 使用示例
func main() {
    ctx := context.Background()
    rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})

    taskQueue := &TaskQueue{
        rdb:    rdb,
        stream: "tasks",
        group:  "workers",
    }

    // 启动多个 worker
    for i := 0; i < 3; i++ {
        go taskQueue.Worker(ctx, fmt.Sprintf("worker-%d", i))
    }

    // 添加任务
    taskQueue.AddTask(ctx, map[string]interface{}{
        "type": "email",
        "to":   "user@example.com",
    })
}
```

#### 事件溯源

```go
type EventStore struct {
    rdb    *redis.Client
    stream string
}

// 存储事件
func (es *EventStore) AppendEvent(ctx context.Context, event map[string]interface{}) (string, error) {
    return es.rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: es.stream,
        Values: event,
    }).Result()
}

// 读取事件流
func (es *EventStore) ReadEvents(ctx context.Context, fromID string) ([]map[string]interface{}, error) {
    streams, err := es.rdb.XRead(ctx, &redis.XReadArgs{
        Streams: []string{es.stream, fromID},
        Count:   100,
    }).Result()

    if err != nil {
        return nil, err
    }

    var events []map[string]interface{}
    for _, stream := range streams {
        for _, msg := range stream.Messages {
            events = append(events, msg.Values)
        }
    }

    return events, nil
}
```

### Stream vs 其他方案

| 特性 | Stream | Pub/Sub | List (LPUSH/BRPOP) |
|------|--------|---------|-------------------|
| 持久化 | 支持 | 不支持 | 支持 |
| 消息确认 | 支持 (ACK) | 不支持 | 不支持 |
| 消费组 | 支持 | 不支持 | 不支持 |
| 广播 | 支持 (多消费组) | 支持 | 不支持 |
| 消息积压 | 支持 | 不支持 | 支持 |
| 重复消费 | 支持 | 不支持 | 不支持 |
| 时间范围查询 | 支持 (XRANGE) | 不支持 | 不支持 |
| 适用场景 | 消息队列、事件流 | 实时通知 | 简单队列 |

### 最佳实践

#### 1. 合理设置 MAXLEN

```go
// 防止 Stream 无限增长
rdb.XAdd(ctx, &redis.XAddArgs{
    Stream: "mystream",
    MaxLen: 10000,    // 保留最新 1 万条
    Approx: true,     // 近似裁剪,性能更好
    Values: data,
})
```

#### 2. 定期清理待确认消息

```go
func CleanupPending(ctx context.Context, rdb *redis.Client) {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    for range ticker.C {
        // 转移空闲超过 5 分钟的消息
        ClaimStaleMessages(ctx, rdb)
    }
}
```

#### 3. 监控消费延迟

```go
func MonitorLag(ctx context.Context, rdb *redis.Client) {
    pending, _ := rdb.XPending(ctx, "mystream", "group1").Result()
    if pending.Count > 1000 {
        log.Printf("WARNING: Pending messages: %d", pending.Count)
    }
}
```

#### 4. 使用消费组实现负载均衡

```go
// 启动多个 consumer 并行处理
for i := 0; i < 10; i++ {
    go func(id int) {
        consumerName := fmt.Sprintf("consumer-%d", id)
        ConsumeWithGroup(ctx, rdb, consumerName)
    }(i)
}
```

### 总结

**Redis Stream 特点**:
1. 支持消息持久化
2. 支持消费组和 ACK
3. 支持消息积压和重复消费
4. 支持时间范围查询
5. 自动生成唯一消息 ID

**适用场景**:
- 可靠的任务队列
- 事件溯源
- 日志收集
- 消息流处理
- 需要消息确认的场景

**vs Pub/Sub**:
- Pub/Sub: 实时性强,无持久化
- Stream: 可靠性高,支持积压

**vs 专业消息队列**:
- Kafka/RabbitMQ: 企业级,功能丰富
- Stream: 轻量级,适合中小规模
