---
title: 什么是缓存穿透、缓存击穿、缓存雪崩？如何解决？
tags:
  - 缓存
  - 缓存策略
status: robot
class: 缓存
slug: cache-penetration-breakdown-avalanche-solutions
ref:
---

## 核心要点

缓存穿透(查询不存在的数据)、缓存击穿(热点 key 过期)、缓存雪崩(大量 key 同时过期)是缓存系统的三大经典问题。分别使用布隆过滤器/空值缓存、互斥锁/逻辑过期、过期时间打散/多级缓存来解决。

## 详细回答

### 1. 缓存穿透 (Cache Penetration)

**问题描述**:
- 查询一个数据库中不存在的数据
- 缓存中没有,数据库中也没有
- 每次请求都打到数据库,缓存失去意义
- 可能被恶意攻击利用(查询大量不存在的 key)

**解决方案**:

#### 方案 1: 布隆过滤器 (推荐)
```
请求 → 布隆过滤器 → 缓存 → 数据库
       ↓ 不存在
      直接返回
```
- 在缓存之前增加布隆过滤器
- 将所有可能存在的 key 放入布隆过滤器
- 不存在的 key 直接拒绝,不查询缓存和数据库
- 注意: 布隆过滤器有误判率(可能存在但实际不存在)

#### 方案 2: 缓存空值
```go
// 查询不到数据时,缓存空值
if data == nil {
    redis.Set(key, "", 5*time.Minute) // 短过期时间
    return nil
}
```
- 将空结果也缓存起来,设置较短过期时间(如 5 分钟)
- 缺点: 占用缓存空间,且时效性差

#### 方案 3: 接口层增加校验
- 参数合法性校验
- 用户权限校验
- ID 基础校验(如 ID <= 0 直接返回)

### 2. 缓存击穿 (Cache Breakdown / Hotspot Invalid)

**问题描述**:
- 某个热点 key 在缓存中过期
- 大量并发请求同时访问这个 key
- 所有请求都打到数据库,可能压垮数据库
- 典型场景: 秒杀商品、热门新闻

**解决方案**:

#### 方案 1: 互斥锁 (Mutex Lock)
```go
func GetData(key string) (data string, err error) {
    // 1. 查缓存
    data, _ = redis.Get(key)
    if data != "" {
        return data, nil
    }

    // 2. 获取分布式锁
    lockKey := "lock:" + key
    if redis.SetNX(lockKey, "1", 10*time.Second) {
        defer redis.Del(lockKey)

        // 3. 查数据库
        data = db.Query(key)

        // 4. 写缓存
        redis.Set(key, data, 30*time.Minute)
        return data, nil
    } else {
        // 5. 等待后重试
        time.Sleep(50 * time.Millisecond)
        return GetData(key) // 递归重试
    }
}
```
- 只有一个线程能获取锁并查询数据库
- 其他线程等待后重试
- 缺点: 性能较差,有等待时间

#### 方案 2: 逻辑过期 (推荐)
```go
type CacheData struct {
    Data      string
    ExpireTime time.Time
}

func GetData(key string) string {
    // 1. 查缓存
    cacheData := redis.Get(key)

    // 2. 判断是否逻辑过期
    if cacheData.ExpireTime.After(time.Now()) {
        return cacheData.Data // 未过期,直接返回
    }

    // 3. 已过期,尝试获取锁
    lockKey := "lock:" + key
    if redis.SetNX(lockKey, "1", 10*time.Second) {
        // 4. 开启独立线程重建缓存
        go func() {
            defer redis.Del(lockKey)
            data := db.Query(key)
            redis.Set(key, CacheData{
                Data: data,
                ExpireTime: time.Now().Add(30 * time.Minute),
            }, 0) // 物理永不过期
        }()
    }

    // 5. 返回过期数据
    return cacheData.Data
}
```
- 热点 key 物理永不过期
- 逻辑过期时间存储在缓存值中
- 过期后返回旧数据,异步更新
- 优点: 性能好,无等待

#### 方案 3: 热点数据永不过期
- 对于确定的热点数据,设置永不过期
- 通过后台任务定期更新

### 3. 缓存雪崩 (Cache Avalanche)

**问题描述**:
- 大量缓存 key 在同一时间过期
- 或者 Redis 实例宕机
- 导致大量请求打到数据库
- 数据库压力骤增,可能崩溃

**解决方案**:

#### 方案 1: 过期时间打散 (推荐)
```go
// 不要设置相同的过期时间
expireTime := 30*time.Minute + time.Duration(rand.Intn(300))*time.Second
redis.Set(key, value, expireTime)
```
- 在基础过期时间上加随机值
- 避免大量 key 同时过期

#### 方案 2: 多级缓存
```
请求 → 本地缓存(Caffeine) → Redis → 数据库
```
- 使用 Nginx 本地缓存 + Redis
- 或者应用本地缓存(Guava/Caffeine) + Redis
- 即使 Redis 挂了,本地缓存还能扛一段时间

#### 方案 3: 服务降级
- 使用 Hystrix 等熔断降级组件
- Redis 挂了返回默认值或错误提示
- 保护数据库不被压垮

#### 方案 4: Redis 高可用
- 主从 + 哨兵
- Redis Cluster 集群
- 降低 Redis 实例宕机概率

#### 方案 5: 请求限流
- 使用令牌桶、漏桶算法限流
- 防止瞬时大量请求打到数据库

### 对比总结

| 问题 | 原因 | 影响 | 解决方案 |
|------|------|------|---------|
| 缓存穿透 | 查询不存在的数据 | 缓存失效,DB 压力大 | 布隆过滤器、缓存空值 |
| 缓存击穿 | 热点 key 过期 | 瞬时 DB 压力大 | 互斥锁、逻辑过期 |
| 缓存雪崩 | 大量 key 同时过期/Redis 宕机 | DB 压力骤增,可能崩溃 | 过期时间打散、多级缓存、高可用 |
