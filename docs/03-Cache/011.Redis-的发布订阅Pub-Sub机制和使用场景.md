---
title: Redis 的发布订阅（Pub/Sub）机制和使用场景
tags:
  - 缓存
  - 缓存
status: robot
class: 缓存
slug: redis-pub-sub-mechanism-use-cases
ref:
---

## 核心要点

Redis Pub/Sub 是一种消息通信模式,发布者(Publisher)发送消息到频道(Channel),订阅者(Subscriber)接收该频道的消息。特点是实时推送、解耦、广播,但不保证消息可靠性(无持久化、订阅者离线则丢失消息),适合实时通知、聊天室等场景。

## 详细回答

### Pub/Sub 基础

#### 核心概念

```
Publisher (发布者)
    ↓ PUBLISH
Channel (频道)
    ↓ 广播
Subscriber1, Subscriber2, Subscriber3 (订阅者)
```

**三个角色**:
- **Publisher**: 发布消息到频道
- **Channel**: 消息传输的频道
- **Subscriber**: 订阅频道,接收消息

#### 基本命令

| 命令 | 说明 | 示例 |
|------|------|------|
| SUBSCRIBE | 订阅频道 | SUBSCRIBE news sports |
| UNSUBSCRIBE | 取消订阅 | UNSUBSCRIBE news |
| PUBLISH | 发布消息 | PUBLISH news "Hello" |
| PSUBSCRIBE | 订阅模式匹配的频道 | PSUBSCRIBE news.* |
| PUNSUBSCRIBE | 取消模式订阅 | PUNSUBSCRIBE news.* |
| PUBSUB CHANNELS | 查看活跃频道 | PUBSUB CHANNELS |
| PUBSUB NUMSUB | 查看频道订阅数 | PUBSUB NUMSUB news |
| PUBSUB NUMPAT | 查看模式订阅数 | PUBSUB NUMPAT |

### 基本使用

#### 订阅和发布

**订阅者**:
```bash
# 订阅单个频道
SUBSCRIBE news
# 1) "subscribe"
# 2) "news"
# 3) (integer) 1  # 当前订阅频道数

# 订阅多个频道
SUBSCRIBE news sports tech
```

**发布者**:
```bash
# 发布消息到频道
PUBLISH news "Breaking: Redis 7.0 released"
# (integer) 2  # 收到消息的订阅者数量

PUBLISH sports "Lakers won the game"
# (integer) 1
```

**订阅者收到消息**:
```bash
# 1) "message"       # 消息类型
# 2) "news"          # 频道名
# 3) "Breaking: Redis 7.0 released"  # 消息内容
```

#### 模式订阅 (Pattern Subscribe)

**使用通配符订阅多个频道**:

```bash
# 订阅所有以 "news." 开头的频道
PSUBSCRIBE news.*

# 订阅所有频道
PSUBSCRIBE *

# 订阅匹配模式
PSUBSCRIBE user:*:notifications
```

**发布消息**:
```bash
PUBLISH news.tech "AI breakthrough"
PUBLISH news.sports "World Cup final"
PUBLISH news.finance "Stock market update"

# 订阅 "news.*" 的订阅者会收到所有消息
```

**模式订阅消息格式**:
```bash
# 1) "pmessage"           # 模式消息类型
# 2) "news.*"             # 匹配的模式
# 3) "news.tech"          # 实际频道名
# 4) "AI breakthrough"    # 消息内容
```

### Go 客户端实现

#### 订阅者

```go
import (
    "context"
    "fmt"
    "github.com/go-redis/redis/v8"
)

func Subscriber(ctx context.Context, rdb *redis.Client) {
    // 订阅频道
    pubsub := rdb.Subscribe(ctx, "news", "sports")
    defer pubsub.Close()

    // 等待订阅确认
    _, err := pubsub.Receive(ctx)
    if err != nil {
        panic(err)
    }

    // 获取消息通道
    ch := pubsub.Channel()

    // 接收消息
    for msg := range ch {
        fmt.Printf("Channel: %s, Message: %s\n", msg.Channel, msg.Payload)
    }
}

// 模式订阅
func PatternSubscriber(ctx context.Context, rdb *redis.Client) {
    pubsub := rdb.PSubscribe(ctx, "news.*")
    defer pubsub.Close()

    ch := pubsub.Channel()

    for msg := range ch {
        fmt.Printf("Pattern: %s, Channel: %s, Message: %s\n",
            msg.Pattern, msg.Channel, msg.Payload)
    }
}
```

#### 发布者

```go
func Publisher(ctx context.Context, rdb *redis.Client) {
    // 发布消息
    err := rdb.Publish(ctx, "news", "Hello, Redis!").Err()
    if err != nil {
        panic(err)
    }

    // 查看收到消息的订阅者数量
    receivers, err := rdb.Publish(ctx, "sports", "Game started").Result()
    fmt.Printf("Message received by %d subscribers\n", receivers)
}
```

#### 实战示例: 实时聊天室

```go
type ChatRoom struct {
    rdb    *redis.Client
    pubsub *redis.PubSub
}

// 加入聊天室
func (c *ChatRoom) Join(ctx context.Context, roomID string) error {
    channel := fmt.Sprintf("chat:room:%s", roomID)
    c.pubsub = c.rdb.Subscribe(ctx, channel)

    // 等待订阅确认
    _, err := c.pubsub.Receive(ctx)
    return err
}

// 发送消息
func (c *ChatRoom) SendMessage(ctx context.Context, roomID, message string) error {
    channel := fmt.Sprintf("chat:room:%s", roomID)
    return c.rdb.Publish(ctx, channel, message).Err()
}

// 接收消息
func (c *ChatRoom) ReceiveMessages(ctx context.Context) <-chan *redis.Message {
    return c.pubsub.Channel()
}

// 离开聊天室
func (c *ChatRoom) Leave() error {
    return c.pubsub.Close()
}

// 使用示例
func main() {
    ctx := context.Background()
    rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})

    chatRoom := &ChatRoom{rdb: rdb}

    // 加入聊天室
    chatRoom.Join(ctx, "1000")

    // 接收消息 (goroutine)
    go func() {
        for msg := range chatRoom.ReceiveMessages(ctx) {
            fmt.Printf("Received: %s\n", msg.Payload)
        }
    }()

    // 发送消息
    chatRoom.SendMessage(ctx, "1000", "Hello everyone!")
}
```

### 工作原理

#### 内部数据结构

```c
// Redis 内部维护的数据结构
struct redisServer {
    dict *pubsub_channels;  // 频道订阅字典
    list *pubsub_patterns;  // 模式订阅列表
};

// 频道订阅字典
pubsub_channels = {
    "news": [client1, client2, client3],
    "sports": [client2, client4],
}

// 模式订阅列表
pubsub_patterns = [
    {pattern: "news.*", client: client5},
    {pattern: "user:*", client: client6},
]
```

#### 消息发布流程

```
1. PUBLISH news "message"
    ↓
2. 查找 pubsub_channels["news"]
    ↓
3. 遍历订阅者列表 [client1, client2, client3]
    ↓
4. 向每个客户端发送消息
    ↓
5. 遍历 pubsub_patterns
    ↓
6. 匹配模式 "news.*"
    ↓
7. 向匹配的客户端发送消息
    ↓
8. 返回收到消息的订阅者总数
```

### 特性和限制

#### 优点

| 优点 | 说明 |
|------|------|
| 实时性 | 消息即时推送,低延迟 |
| 解耦 | 发布者和订阅者互不知道对方 |
| 广播 | 一条消息可以发送给多个订阅者 |
| 简单 | API 简单,易于使用 |
| 模式匹配 | 支持通配符订阅 |

#### 缺点

| 缺点 | 说明 | 影响 |
|------|------|------|
| **无持久化** | 消息不存储,发送即丢弃 | 订阅者离线则丢失消息 |
| **无 ACK** | 没有消息确认机制 | 不知道消息是否被消费 |
| **阻塞订阅** | SUBSCRIBE 后客户端阻塞 | 只能接收消息,不能执行其他命令 |
| **无消息队列** | 不支持消息积压 | 消费速度慢会丢失消息 |
| **无重试** | 发送失败不会重试 | 网络问题导致消息丢失 |

#### 消息可靠性问题

**场景 1: 订阅者离线**
```
1. 发布者: PUBLISH news "message1"
2. 订阅者: (离线)
3. 消息丢失! ❌

解决方案:
- 使用 Redis Stream (支持持久化)
- 使用专业消息队列 (RabbitMQ, Kafka)
```

**场景 2: 订阅者消费慢**
```
1. 发布者: 每秒发布 1000 条消息
2. 订阅者: 每秒只能处理 100 条
3. Redis 输出缓冲区满
4. 客户端被强制断开 ❌

redis.conf 配置:
client-output-buffer-limit pubsub 32mb 8mb 60
# 硬限制 32MB, 软限制 8MB 持续 60 秒
```

### 使用场景

#### 1. 实时通知系统

```go
// 用户消息通知
func NotifyUser(ctx context.Context, rdb *redis.Client, userID int, message string) {
    channel := fmt.Sprintf("user:%d:notifications", userID)
    rdb.Publish(ctx, channel, message)
}

// 用户订阅自己的通知
func SubscribeNotifications(ctx context.Context, rdb *redis.Client, userID int) {
    channel := fmt.Sprintf("user:%d:notifications", userID)
    pubsub := rdb.Subscribe(ctx, channel)
    defer pubsub.Close()

    for msg := range pubsub.Channel() {
        fmt.Printf("Notification: %s\n", msg.Payload)
    }
}
```

#### 2. 实时聊天

```go
// 聊天室消息
func SendChatMessage(ctx context.Context, rdb *redis.Client, roomID, username, message string) {
    channel := fmt.Sprintf("chat:room:%s", roomID)
    payload := fmt.Sprintf("%s: %s", username, message)
    rdb.Publish(ctx, channel, payload)
}
```

#### 3. 系统监控和日志

```bash
# 发布系统日志
PUBLISH log:error "Database connection failed"
PUBLISH log:warning "High memory usage"
PUBLISH log:info "User logged in"

# 监控订阅所有日志
PSUBSCRIBE log:*

# 只订阅错误日志
SUBSCRIBE log:error
```

#### 4. 分布式系统事件通知

```go
// 缓存失效通知
func InvalidateCache(ctx context.Context, rdb *redis.Client, key string) {
    rdb.Publish(ctx, "cache:invalidate", key)
}

// 各个服务订阅缓存失效事件
func SubscribeCacheInvalidation(ctx context.Context, rdb *redis.Client, localCache *Cache) {
    pubsub := rdb.Subscribe(ctx, "cache:invalidate")
    defer pubsub.Close()

    for msg := range pubsub.Channel() {
        key := msg.Payload
        localCache.Delete(key)  // 删除本地缓存
    }
}
```

#### 5. 实时数据推送

```go
// 股票价格推送
func PublishStockPrice(ctx context.Context, rdb *redis.Client, symbol string, price float64) {
    channel := fmt.Sprintf("stock:%s", symbol)
    rdb.Publish(ctx, channel, fmt.Sprintf("%.2f", price))
}

// 客户端订阅股票价格
func SubscribeStock(ctx context.Context, rdb *redis.Client, symbols []string) {
    channels := make([]string, len(symbols))
    for i, symbol := range symbols {
        channels[i] = fmt.Sprintf("stock:%s", symbol)
    }

    pubsub := rdb.Subscribe(ctx, channels...)
    defer pubsub.Close()

    for msg := range pubsub.Channel() {
        fmt.Printf("%s: %s\n", msg.Channel, msg.Payload)
    }
}
```

### Pub/Sub vs Stream vs 消息队列

| 特性 | Pub/Sub | Stream | 消息队列 (RabbitMQ/Kafka) |
|------|---------|--------|-------------------------|
| 持久化 | 不支持 | 支持 | 支持 |
| 消息积压 | 不支持 | 支持 | 支持 |
| 消息确认 | 不支持 | 支持 (ACK) | 支持 (ACK) |
| 广播 | 支持 | 支持 (消费组) | 支持 |
| 顺序保证 | 不保证 | 保证 | 保证 (分区内) |
| 重复消费 | 不支持 | 支持 | 支持 |
| 适用场景 | 实时通知 | 消息队列 | 企业级消息队列 |
| 可靠性 | 低 | 中 | 高 |
| 复杂度 | 低 | 中 | 高 |

### 管理命令

```bash
# 查看所有活跃频道
PUBSUB CHANNELS
# 1) "news"
# 2) "sports"

# 查看匹配的频道
PUBSUB CHANNELS news*
# 1) "news"
# 2) "news.tech"

# 查看频道订阅者数量
PUBSUB NUMSUB news sports
# 1) "news"
# 2) (integer) 3
# 3) "sports"
# 4) (integer) 1

# 查看模式订阅数量
PUBSUB NUMPAT
# (integer) 2
```

### 最佳实践

#### 1. 合理使用模式订阅

```bash
# 好例子: 精确匹配
PSUBSCRIBE user:1000:*  # 只订阅用户 1000 的消息

# 坏例子: 过于宽泛
PSUBSCRIBE *  # 订阅所有频道,性能差
```

#### 2. 处理订阅者慢消费

```go
// 使用 goroutine + 缓冲 channel
func SafeSubscribe(ctx context.Context, rdb *redis.Client, channel string) {
    pubsub := rdb.Subscribe(ctx, channel)
    defer pubsub.Close()

    // 缓冲 channel 避免阻塞
    msgChan := make(chan *redis.Message, 1000)

    // 接收消息
    go func() {
        for msg := range pubsub.Channel() {
            select {
            case msgChan <- msg:
            default:
                // 缓冲满,丢弃消息或记录日志
                log.Printf("Message dropped: %s", msg.Payload)
            }
        }
    }()

    // 处理消息
    for msg := range msgChan {
        processMessage(msg)  // 可能很慢
    }
}
```

#### 3. 监控订阅者数量

```go
func CheckSubscribers(ctx context.Context, rdb *redis.Client, channel string) int {
    result, err := rdb.PubSubNumSub(ctx, channel).Result()
    if err != nil {
        return 0
    }

    for ch, count := range result {
        if ch == channel {
            return int(count)
        }
    }
    return 0
}

// 只在有订阅者时发布
func PublishIfSubscribed(ctx context.Context, rdb *redis.Client, channel, message string) {
    if CheckSubscribers(ctx, rdb, channel) > 0 {
        rdb.Publish(ctx, channel, message)
    }
}
```

#### 4. 使用 Stream 替代 Pub/Sub (需要可靠性)

```go
// 如果需要消息持久化和重试,使用 Stream
func PublishToStream(ctx context.Context, rdb *redis.Client, stream, message string) {
    rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: stream,
        Values: map[string]interface{}{
            "message": message,
        },
    })
}
```

### 常见问题

**Q: Pub/Sub 消息会持久化吗?**
A: 不会。消息发送后立即丢弃,订阅者离线则收不到消息。

**Q: 如何保证消息不丢失?**
A:
- 使用 Redis Stream (支持持久化和消费组)
- 使用专业消息队列 (RabbitMQ, Kafka)
- 应用层实现确认机制

**Q: SUBSCRIBE 后能执行其他命令吗?**
A: 不能。订阅模式下,客户端只能执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE、PING、QUIT 命令。

**Q: 如何实现消息去重?**
A: Pub/Sub 不支持。可以在应用层使用消息 ID + Set 去重。

### 总结

**Redis Pub/Sub 特点**:
1. 实时推送,低延迟
2. 解耦发布者和订阅者
3. 支持广播和模式匹配
4. 不支持持久化和消息确认

**适用场景**:
- 实时通知 (可以容忍消息丢失)
- 聊天室、弹幕
- 系统监控日志
- 缓存失效通知
- 实时数据推送

**不适用场景**:
- 需要消息持久化
- 需要消息确认 (ACK)
- 需要消息积压和重试
- 任务队列 (推荐使用 Stream)

**替代方案**:
- 需要可靠性: Redis Stream
- 企业级场景: RabbitMQ、Kafka
- 简单任务队列: List (LPUSH/BRPOP)
