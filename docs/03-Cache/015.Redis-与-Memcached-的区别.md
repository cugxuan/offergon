---
title: Redis 与 Memcached 的区别
tags:
  - 缓存
status: robot
class: 缓存
slug: redis-vs-memcached-difference
ref:
---

## 核心要点

Redis 和 Memcached 都是高性能内存缓存系统,但 Redis 支持丰富的数据类型、持久化、主从复制、事务等功能,而 Memcached 只支持简单的 key-value 存储,更轻量级。Redis 适合需要数据持久化和复杂数据结构的场景,Memcached 适合纯缓存、简单 key-value 存储的场景。

## 详细回答

### 核心功能对比

| 特性 | Redis | Memcached |
|------|-------|-----------|
| **数据类型** | String, List, Hash, Set, ZSet, Bitmap, HyperLogLog, Stream | 仅支持 String |
| **持久化** | 支持 (RDB, AOF) | 不支持 |
| **主从复制** | 支持 | 不支持 |
| **集群** | 支持 (Redis Cluster, Sentinel) | 客户端分片 |
| **事务** | 支持 (MULTI/EXEC) | 不支持 |
| **Lua 脚本** | 支持 | 不支持 |
| **过期策略** | 惰性删除 + 定期删除 | 惰性删除 + LRU |
| **内存淘汰** | 8 种策略 (LRU, LFU, TTL) | LRU |
| **多线程** | 6.0+ 支持 I/O 多线程 | 多线程 |
| **发布订阅** | 支持 | 不支持 |
| **性能** | ~100k QPS (单实例) | ~100k QPS (单实例) |

### 数据类型

#### Redis: 丰富的数据类型

```bash
# String
SET name "Alice"

# List (列表)
LPUSH tasks "task1" "task2" "task3"

# Hash (哈希)
HSET user:1000 name "Alice" age 25

# Set (集合)
SADD tags "redis" "cache" "nosql"

# ZSet (有序集合)
ZADD leaderboard 100 "player1" 200 "player2"

# Bitmap
SETBIT online_users 1000 1

# HyperLogLog (基数统计)
PFADD unique_visitors "user1" "user2"

# Stream (消息队列)
XADD events * action "login" user "alice"
```

#### Memcached: 仅支持 String

```bash
# 只支持简单的 key-value
set name 0 3600 5
Alice

# 不支持 List, Hash, Set 等复杂类型
# 需要在应用层序列化/反序列化
```

**Go 代码对比**:

```go
// Redis: 原生支持 Hash
rdb.HSet(ctx, "user:1000", map[string]interface{}{
    "name": "Alice",
    "age":  25,
})
rdb.HGet(ctx, "user:1000", "name")  // "Alice"

// Memcached: 需要序列化
data := map[string]interface{}{
    "name": "Alice",
    "age":  25,
}
json, _ := json.Marshal(data)
mc.Set(&memcache.Item{Key: "user:1000", Value: json})

// 读取时需要反序列化
item, _ := mc.Get("user:1000")
json.Unmarshal(item.Value, &data)
```

### 持久化

#### Redis: 支持持久化

**RDB (快照)**:
```bash
# redis.conf
save 900 1      # 900 秒内至少 1 次修改
save 300 10     # 300 秒内至少 10 次修改
save 60 10000   # 60 秒内至少 10000 次修改
```

**AOF (追加日志)**:
```bash
# redis.conf
appendonly yes
appendfsync everysec  # 每秒同步
```

**优点**:
- 重启后数据不丢失
- 支持备份和恢复
- 支持主从复制

#### Memcached: 不支持持久化

- 重启后数据全部丢失
- 纯内存缓存
- 不支持备份

**使用场景对比**:

| 场景 | Redis | Memcached |
|------|-------|-----------|
| Session 存储 | 支持 (持久化) | 不推荐 (重启丢失) |
| 临时缓存 | 支持 | 支持 |
| 热点数据 | 支持 (可持久化) | 支持 (不持久化) |
| 计数器 | 支持 (INCR, 持久化) | 支持 (incr, 不持久化) |

### 高可用

#### Redis: 多种高可用方案

**1. 主从复制**:
```bash
# Slave 配置
replicaof 127.0.0.1 6379
```

**2. Sentinel (哨兵)**:
```bash
# 自动故障转移
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 30000
```

**3. Cluster (集群)**:
```bash
# 分片 + 高可用
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 ...
```

#### Memcached: 无内置高可用

- 依赖客户端分片
- 无主从复制
- 无自动故障转移
- 节点故障需要手动处理

**客户端分片**:
```go
// Memcached 客户端分片
mc := memcache.New("server1:11211", "server2:11211", "server3:11211")

// 客户端自动选择节点 (一致性哈希)
mc.Set(&memcache.Item{Key: "key1", Value: []byte("value")})
```

### 内存管理

#### Redis: 丰富的淘汰策略

```bash
# 8 种淘汰策略
maxmemory-policy allkeys-lru   # 所有 key LRU
maxmemory-policy allkeys-lfu   # 所有 key LFU (Redis 4.0+)
maxmemory-policy volatile-lru  # 有过期时间的 key LRU
maxmemory-policy volatile-lfu  # 有过期时间的 key LFU
maxmemory-policy volatile-ttl  # 优先淘汰即将过期的 key
maxmemory-policy allkeys-random
maxmemory-policy volatile-random
maxmemory-policy noeviction    # 不淘汰,写入失败
```

**过期删除**:
- 惰性删除: 访问时检查
- 定期删除: 每 100ms 随机检查

#### Memcached: 仅支持 LRU

```bash
# 仅支持 LRU 淘汰
# 内存满时自动淘汰最久未使用的数据
```

**过期删除**:
- 惰性删除: 访问时检查
- LRU 淘汰: 内存满时淘汰

### 性能对比

#### 单线程 vs 多线程

**Redis**:
- 命令执行: 单线程
- I/O 处理: 6.0+ 支持多线程
- 避免锁竞争,简单高效

**Memcached**:
- 完全多线程
- 利用多核 CPU
- 高并发性能好

**性能测试**:

| 操作 | Redis | Memcached |
|------|-------|-----------|
| GET (单线程) | 100,000 QPS | 80,000 QPS |
| SET (单线程) | 80,000 QPS | 70,000 QPS |
| GET (多线程) | 200,000 QPS (6.0+) | 300,000 QPS |
| SET (多线程) | 150,000 QPS (6.0+) | 250,000 QPS |

**Go 代码对比**:

```go
// Redis 性能测试
func BenchmarkRedis(b *testing.B) {
    rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
    ctx := context.Background()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        rdb.Set(ctx, "key", "value", 0)
        rdb.Get(ctx, "key")
    }
}

// Memcached 性能测试
func BenchmarkMemcached(b *testing.B) {
    mc := memcache.New("localhost:11211")

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        mc.Set(&memcache.Item{Key: "key", Value: []byte("value")})
        mc.Get("key")
    }
}
```

### 高级功能

#### Redis 独有功能

**1. 事务**:
```bash
MULTI
SET key1 value1
SET key2 value2
EXEC
```

**2. Lua 脚本**:
```bash
EVAL "return redis.call('GET', KEYS[1])" 1 mykey
```

**3. 发布订阅**:
```bash
SUBSCRIBE news
PUBLISH news "Breaking news"
```

**4. Stream (消息队列)**:
```bash
XADD mystream * field value
XREADGROUP GROUP group1 consumer1 STREAMS mystream >
```

**5. GEO (地理位置)**:
```bash
GEOADD locations 116.4 39.9 "Beijing"
GEORADIUS locations 116.4 39.9 100 km
```

**6. Bitmap**:
```bash
SETBIT online_users 1000 1
BITCOUNT online_users
```

#### Memcached: 无高级功能

- 仅支持 get/set/delete/incr/decr
- 无事务、脚本、发布订阅

### 协议对比

#### Redis: RESP 协议

```
# 命令
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n

# 响应
+OK\r\n
```

**特点**:
- 支持多种数据类型
- 二进制安全
- 易于解析

#### Memcached: 文本协议

```
# 命令
set key 0 3600 5\r\n
value\r\n

# 响应
STORED\r\n
```

**特点**:
- 简单文本协议
- 只支持字符串
- 易于调试

### 使用场景

#### Redis 适用场景

| 场景 | 原因 |
|------|------|
| **Session 存储** | 持久化,不丢失 |
| **排行榜** | ZSet 有序集合 |
| **计数器** | INCR 原子操作 + 持久化 |
| **消息队列** | List/Stream |
| **分布式锁** | SETNX + Lua 脚本 |
| **实时统计** | HyperLogLog |
| **地理位置** | GEO 命令 |
| **复杂数据结构** | Hash, Set, ZSet |
| **需要持久化** | RDB/AOF |
| **高可用** | Sentinel/Cluster |

**示例**:
```go
// 排行榜
rdb.ZAdd(ctx, "leaderboard", &redis.Z{Score: 100, Member: "player1"})
rdb.ZRevRange(ctx, "leaderboard", 0, 9)  // Top 10

// 分布式锁
lock := rdb.SetNX(ctx, "lock:resource", "owner", 10*time.Second)

// 消息队列
rdb.XAdd(ctx, &redis.XAddArgs{Stream: "tasks", Values: map[string]interface{}{"job": "data"}})
```

#### Memcached 适用场景

| 场景 | 原因 |
|------|------|
| **纯缓存** | 轻量级,性能高 |
| **简单 key-value** | 不需要复杂数据类型 |
| **临时数据** | 不需要持久化 |
| **多核服务器** | 多线程,利用多核 |
| **对象缓存** | 序列化存储 |

**示例**:
```go
// 对象缓存
type User struct {
    Name string
    Age  int
}

user := User{Name: "Alice", Age: 25}
data, _ := json.Marshal(user)
mc.Set(&memcache.Item{Key: "user:1000", Value: data, Expiration: 3600})

// 读取
item, _ := mc.Get("user:1000")
json.Unmarshal(item.Value, &user)
```

### 客户端库对比

#### Redis 客户端

**Go**:
```go
import "github.com/go-redis/redis/v8"

rdb := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
    Password: "",
    DB: 0,
    PoolSize: 100,
})

// 丰富的 API
rdb.Set(ctx, "key", "value", 0)
rdb.HSet(ctx, "hash", "field", "value")
rdb.LPush(ctx, "list", "item")
```

**特点**:
- API 丰富
- 支持 Pipeline, 事务, Lua 脚本
- 支持 Cluster, Sentinel

#### Memcached 客户端

**Go**:
```go
import "github.com/bradfitz/gomemcache/memcache"

mc := memcache.New("localhost:11211")

// 简单的 API
mc.Set(&memcache.Item{Key: "key", Value: []byte("value")})
mc.Get("key")
mc.Delete("key")
```

**特点**:
- API 简单
- 仅支持基本操作
- 客户端分片

### 内存消耗对比

**相同数据存储**:

| 存储方式 | Redis | Memcached |
|---------|-------|-----------|
| 1 万个 String key | ~10 MB | ~8 MB |
| 1 万个 Hash (10 字段) | ~15 MB | N/A (需序列化) |
| 1 万个 List (100 元素) | ~20 MB | N/A |

**Redis 内存开销更大原因**:
- 丰富的数据结构元数据
- 支持持久化的额外开销
- 过期时间字典

**Memcached 内存效率更高**:
- 简单的 Slab 分配
- 无持久化开销
- 仅存储 key-value

### 部署运维对比

#### Redis

**优点**:
- 丰富的监控工具 (INFO, SLOWLOG)
- 支持主从、哨兵、集群
- 持久化,数据安全

**缺点**:
- 配置复杂
- 运维成本高
- 内存消耗大

#### Memcached

**优点**:
- 部署简单
- 配置少
- 内存效率高

**缺点**:
- 无持久化
- 无内置高可用
- 监控工具少

### 总结

**选择 Redis 的场景**:
1. 需要持久化 (Session, 用户数据)
2. 需要复杂数据结构 (排行榜, 计数器)
3. 需要事务和脚本
4. 需要高可用 (主从, 集群)
5. 需要发布订阅
6. 需要消息队列

**选择 Memcached 的场景**:
1. 纯缓存,不需要持久化
2. 简单 key-value 存储
3. 对性能要求极高 (多线程)
4. 多核服务器
5. 内存敏感 (效率更高)
6. 部署简单

**性能对比**:
- **单线程**: Redis 略优
- **多线程**: Memcached 优势明显
- **复杂操作**: Redis 独有

**功能对比**:
- **数据类型**: Redis 完胜
- **持久化**: Redis 独有
- **高可用**: Redis 内置支持

**推荐**:
- **现代应用**: 推荐 Redis (功能丰富, 生态完善)
- **纯缓存**: 可以选择 Memcached (更轻量)
- **混合使用**: Redis 存储重要数据, Memcached 缓存临时数据
