---
title: 如何实现分布式锁？基于 Redis 的分布式锁有哪些坑？
tags:
  - 分布式
  - 缓存
status: robot
class: 缓存
slug: redis-distributed-lock-implementation-pitfalls
ref:
---

## 核心要点

分布式锁基于 Redis 的 SETNX + 过期时间实现,需要保证原子性、防误删、可重入。常见坑点包括锁过期时间设置、删除他人的锁、主从切换导致锁失效。生产环境推荐使用 Redlock 算法或 Redisson 库。

## 详细回答

### 基本实现

#### 最简单版本 (有问题)
```bash
# 加锁
SETNX lock_key "client_id"
EXPIRE lock_key 30

# 解锁
DEL lock_key
```
**问题**: SETNX 和 EXPIRE 不是原子操作,进程崩溃会导致死锁

#### 改进版本 1: 原子加锁
```bash
# Redis 2.6.12+ 支持
SET lock_key "client_id" EX 30 NX
```
**改进**: 加锁和设置过期时间原子化

**仍存在问题**:
1. 可能删除其他客户端的锁
2. 锁过期时间难以设置
3. 不可重入

#### 改进版本 2: 防误删
```lua
-- 加锁
SET lock_key "unique_client_id" EX 30 NX

-- 解锁 (Lua 脚本保证原子性)
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

Go 实现:
```go
type RedisLock struct {
    client *redis.Client
    key    string
    value  string // UUID
}

// 加锁
func (l *RedisLock) Lock(expireSeconds int) bool {
    l.value = uuid.New().String()
    result := l.client.SetNX(l.key, l.value, time.Duration(expireSeconds)*time.Second)
    return result.Val()
}

// 解锁
func (l *RedisLock) Unlock() bool {
    script := `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
    `
    result := l.client.Eval(script, []string{l.key}, l.value)
    return result.Val().(int64) == 1
}
```

### 常见问题与解决方案

#### 问题 1: 锁过期时间设置

**问题**: 业务执行时间超过锁过期时间,导致锁提前释放

**解决方案**:

1. **看门狗机制 (Watchdog)**
```go
// Redisson 实现方式
// 开启后台线程,每 10 秒自动续期
func (l *RedisLock) startWatchdog() {
    ticker := time.NewTicker(10 * time.Second)
    go func() {
        for range ticker.C {
            l.client.Expire(l.key, 30*time.Second)
        }
    }()
}
```

2. **设置较长过期时间**
- 评估业务最长执行时间
- 设置为业务时间的 2-3 倍

#### 问题 2: 主从切换导致锁失效

**场景**:
```
1. 客户端 A 在 Master 获取锁
2. Master 宕机,锁未同步到 Slave
3. Slave 升级为 Master
4. 客户端 B 在新 Master 获取到相同的锁
5. A 和 B 同时持有锁
```

**解决方案: Redlock 算法**

#### 问题 3: 不可重入

**问题**: 同一线程无法再次获取已持有的锁

**解决方案**: 使用 Hash 结构记录重入次数
```lua
-- 加锁
if redis.call("EXISTS", KEYS[1]) == 0 then
    redis.call("HSET", KEYS[1], ARGV[1], 1)
    redis.call("EXPIRE", KEYS[1], ARGV[2])
    return 1
elseif redis.call("HEXISTS", KEYS[1], ARGV[1]) == 1 then
    redis.call("HINCRBY", KEYS[1], ARGV[1], 1)
    redis.call("EXPIRE", KEYS[1], ARGV[2])
    return 1
else
    return 0
end

-- 解锁
if redis.call("HEXISTS", KEYS[1], ARGV[1]) == 0 then
    return nil
elseif redis.call("HINCRBY", KEYS[1], ARGV[1], -1) == 0 then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

### Redlock 算法 (多节点)

**原理**: 在多个独立的 Redis 实例上获取锁

**步骤**:
1. 获取当前时间戳 T1
2. 依次在 N 个 Redis 实例上尝试获取锁(设置较短超时时间)
3. 计算获取锁消耗的时间 T2 - T1
4. 如果在**过半节点**(N/2+1)获取成功,且总耗时 < 锁有效期,则认为获取锁成功
5. 锁的真实有效期 = 初始有效期 - 获取锁消耗时间
6. 如果获取锁失败,向所有实例发送释放锁请求

**优点**:
- 容忍部分节点故障
- 解决主从切换问题

**缺点**:
- 实现复杂
- 性能开销大
- 时钟漂移可能导致问题

### 生产环境推荐方案

#### 1. 使用 Redisson (Java)
```java
RLock lock = redisson.getLock("myLock");
lock.lock(30, TimeUnit.SECONDS); // 自动续期
try {
    // 业务逻辑
} finally {
    lock.unlock();
}
```

特性:
- 自动续期(看门狗)
- 可重入
- 公平锁支持
- Redlock 支持

#### 2. 使用 Redsync (Go)
```go
pools := []redsync.Pool{pool1, pool2, pool3}
rs := redsync.New(pools)
mutex := rs.NewMutex("my-lock")

if err := mutex.Lock(); err != nil {
    panic(err)
}
defer mutex.Unlock()
```

### 对比其他分布式锁

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| Redis | 性能高,实现简单 | AP 模型,可能丢失锁 | 高性能,可容忍小概率失败 |
| Zookeeper | CP 模型,强一致性 | 性能较低,依赖 ZK 集群 | 强一致性要求 |
| etcd | CP 模型,现代化 | 相对较新 | 云原生场景 |
| 数据库 | 简单,无额外依赖 | 性能差,数据库压力大 | 低并发场景 |

### 使用建议

1. **简单场景**: Redis 单实例 + SET NX EX + Lua 解锁
2. **高可用场景**: Redis Cluster + Redisson/Redsync
3. **强一致性场景**: Zookeeper 或 etcd
4. **避免长时间持有锁**: 尽量缩短临界区
5. **监控告警**: 监控锁等待时间和持有时间
