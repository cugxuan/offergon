---
title: Redis 的缓存淘汰策略有哪些？如何选择合适的策略？
tags:
  - 缓存
  - 缓存策略
status: robot
class: 缓存
slug: redis-cache-eviction-policies-selection-guide
ref:
---

## 核心要点

Redis 提供 8 种缓存淘汰策略,分为 noeviction、针对所有 key 的淘汰(allkeys-lru/lfu/random)、针对设置过期时间 key 的淘汰(volatile-lru/lfu/random/ttl)。最常用的是 allkeys-lru 和 volatile-lru,根据业务场景选择。

## 详细回答

### 8 种淘汰策略

#### 1. noeviction (默认)
- **行为**: 内存不足时,新写入操作会报错,不淘汰任何 key
- **适用场景**: 不希望丢失任何数据,需要手动清理

#### 2. allkeys-lru
- **行为**: 从所有 key 中,淘汰最近最少使用(Least Recently Used)的 key
- **适用场景**: **最常用策略**,适合热点数据访问模式,符合二八定律

#### 3. allkeys-lfu (Redis 4.0+)
- **行为**: 从所有 key 中,淘汰最不经常使用(Least Frequently Used)的 key
- **适用场景**: 访问频率差异明显的场景,比 LRU 更精确

#### 4. allkeys-random
- **行为**: 从所有 key 中随机淘汰
- **适用场景**: 所有 key 访问概率相近,或对数据一致性要求不高

#### 5. volatile-lru
- **行为**: 从设置了过期时间的 key 中,淘汰最近最少使用的
- **适用场景**: 希望保留永久数据,只淘汰临时数据

#### 6. volatile-lfu (Redis 4.0+)
- **行为**: 从设置了过期时间的 key 中,淘汰最不经常使用的
- **适用场景**: 临时数据中有明显访问频率差异

#### 7. volatile-random
- **行为**: 从设置了过期时间的 key 中随机淘汰
- **适用场景**: 需要保留永久数据,临时数据可随机清理

#### 8. volatile-ttl
- **行为**: 从设置了过期时间的 key 中,淘汰即将过期的(TTL 最小的)
- **适用场景**: 希望优先清理快过期的数据

### LRU vs LFU

**LRU (Least Recently Used)**:
- 关注时间维度,最近访问过的保留
- 实现: Redis 使用近似 LRU(采样算法),而非严格 LRU
- 缺点: 偶尔访问一次的数据可能驱逐频繁访问的旧数据

**LFU (Least Frequently Used)**:
- 关注频率维度,访问次数多的保留
- 实现: 记录访问计数,但会衰减(避免旧的高频数据一直占用)
- 优点: 更符合真实的热点数据

### 选择建议

| 场景 | 推荐策略 |
|------|---------|
| 通用缓存,热点明显 | `allkeys-lru` |
| 访问频率差异大 | `allkeys-lfu` |
| 有永久数据+临时缓存 | `volatile-lru` 或 `volatile-lfu` |
| 数据不能丢失 | `noeviction` + 手动扩容 |
| Session 存储 | `volatile-lru` 配合过期时间 |
| 验证码等短期数据 | `volatile-ttl` |

### 配置方式

```bash
# redis.conf 配置
maxmemory 2gb
maxmemory-policy allkeys-lru

# 运行时修改
CONFIG SET maxmemory-policy allkeys-lru
```

### 注意事项

1. **volatile-* 策略前提**: 必须有 key 设置了过期时间,否则会返回错误
2. **采样精度**: Redis LRU 使用采样算法,可通过 `maxmemory-samples` 调整采样数量(默认 5)
3. **性能**: LFU 比 LRU 稍慢,但更精确
4. **监控**: 使用 `INFO stats` 查看 `evicted_keys` 监控淘汰情况
