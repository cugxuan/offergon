---
title: Redis Cluster 的分片原理，哈希槽（Hash Slot）是什么？
tags:
  - 缓存
  - 缓存
status: robot
class: 缓存
slug: redis-cluster-sharding-hash-slot
ref:
---

## 核心要点

Redis Cluster 通过哈希槽(Hash Slot)实现数据分片,将 16384 个槽位分配给不同节点。每个 key 通过 CRC16 算法计算后对 16384 取模得到槽位,客户端通过槽位映射找到对应节点,支持水平扩展和高可用。

## 详细回答

### Redis Cluster 架构

```
Client
  ↓
Cluster Proxy / Smart Client
  ↓
┌──────────────────────────────────┐
│  Master1     Master2     Master3 │
│  (0-5460)   (5461-10922) (10923-16383)│
│     ↓           ↓           ↓     │
│  Slave1      Slave2      Slave3  │
└──────────────────────────────────┘
```

**特点**:
- 去中心化架构,无需代理
- 自动数据分片
- 支持水平扩展
- 支持主从复制和故障转移

### 哈希槽 (Hash Slot) 原理

#### 1. 槽位分配

Redis Cluster 将整个数据集划分为 **16384 个哈希槽** (0-16383)。

**为什么是 16384?**
- CRC16 算法产生 16bit 结果,理论上应该是 65536 个槽
- Redis 作者在设计时考虑:
  - 心跳包大小: 槽位信息用 bitmap 传输, 16384÷8=2KB, 65536÷8=8KB
  - 集群规模: Redis Cluster 建议节点数不超过 1000 个, 16384 足够
  - 槽位迁移: 槽位数量越少,迁移速度越快

#### 2. Key 到槽位的映射

**计算公式**:
```
HASH_SLOT = CRC16(key) mod 16384
```

**示例**:
```bash
# 计算 key 对应的槽位
CLUSTER KEYSLOT "user:1000"
# 返回: 12345

CLUSTER KEYSLOT "user:2000"
# 返回: 8901
```

**Go 代码实现**:
```go
import "github.com/go-redis/redis/v8"

func getHashSlot(key string) int {
    // go-redis 内部实现
    // 使用 CRC16 算法计算
    return int(crc16.ChecksumIEEE([]byte(key)) % 16384)
}

// 使用 Hash Tag 控制分片
func main() {
    // {user}:1000 和 {user}:2000 会分配到同一槽位
    // 因为只对 {} 内的部分计算哈希
    key1 := "{user}:1000:profile"
    key2 := "{user}:1000:orders"

    // 两个 key 会在同一节点,支持事务
}
```

#### 3. Hash Tag (哈希标签)

用于将多个相关 key 分配到同一槽位:

```bash
# 只对 {} 内的内容计算哈希
# 以下 key 都会分配到同一槽位
user:{1000}:profile
user:{1000}:orders
user:{1000}:cart

# 查看槽位
CLUSTER KEYSLOT "user:{1000}:profile"   # 返回: 2515
CLUSTER KEYSLOT "user:{1000}:orders"    # 返回: 2515
CLUSTER KEYSLOT "user:{1000}:cart"      # 返回: 2515
```

**应用场景**:
- 同一用户的多个数据需要在同一节点
- 支持 MGET、MSET 等批量操作
- 支持事务操作(MULTI/EXEC)

### 槽位分配策略

#### 初始分配

**三节点集群示例**:
```bash
# 创建集群时自动分配
redis-cli --cluster create \
  127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \
  127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
  --cluster-replicas 1

# 分配结果:
# Master1 (7000): slots 0-5460     (5461 slots)
# Master2 (7001): slots 5461-10922 (5462 slots)
# Master3 (7002): slots 10923-16383 (5461 slots)
```

#### 手动分配

```bash
# 分配槽位给节点
CLUSTER ADDSLOTS 0 1 2 3 4 5 ...

# 查看节点槽位
CLUSTER NODES

# 查看某个槽位属于哪个节点
CLUSTER SLOTS
```

**输出示例**:
```
1) 1) (integer) 0        # 起始槽位
   2) (integer) 5460     # 结束槽位
   3) 1) "127.0.0.1"     # Master IP
      2) (integer) 7000  # Master 端口
      3) "node-id-1"     # 节点 ID
   4) 1) "127.0.0.1"     # Slave IP
      2) (integer) 7003  # Slave 端口
      3) "node-id-4"     # 节点 ID
```

### 数据读写流程

#### 1. 写入数据

```
Client 发送: SET user:1000 "data"
    ↓
计算槽位: CRC16("user:1000") % 16384 = 12345
    ↓
查找节点: 槽位 12345 属于 Master2
    ↓
重定向: MOVED 12345 127.0.0.1:7001
    ↓
客户端连接 Master2 执行 SET
```

#### 2. MOVED 重定向

客户端首次访问可能连接到错误节点:

```bash
# 客户端连接到 Master1
redis-cli -c -p 7000
> SET user:1000 "data"

# 返回重定向
(error) MOVED 12345 127.0.0.1:7001

# 智能客户端自动重定向到正确节点
```

**Go 客户端自动处理**:
```go
import "github.com/go-redis/redis/v8"

// 配置集群客户端
rdb := redis.NewClusterClient(&redis.ClusterOptions{
    Addrs: []string{
        "127.0.0.1:7000",
        "127.0.0.1:7001",
        "127.0.0.1:7002",
    },
})

// 客户端自动处理 MOVED 重定向
err := rdb.Set(ctx, "user:1000", "data", 0).Err()
```

#### 3. ASK 重定向

槽位迁移过程中的临时重定向:

```bash
# 槽位正在从 Master1 迁移到 Master2
> GET key_in_migrating_slot

# 返回 ASK 重定向(临时)
(error) ASK 12345 127.0.0.1:7001

# 客户端需要:
# 1. 连接到目标节点
# 2. 发送 ASKING 命令
# 3. 重新执行原命令
```

### 槽位迁移

#### 扩容流程

```bash
# 1. 添加新节点
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000

# 2. 重新分配槽位
redis-cli --cluster reshard 127.0.0.1:7000

# 会提示:
# How many slots do you want to move? 4096
# What is the receiving node ID? <新节点 ID>
# Source node #1: all (从所有节点平均分配)

# 3. 迁移完成后槽位分布:
# Master1: 0-4095       (4096 slots)
# Master2: 4096-8191    (4096 slots)
# Master3: 8192-12287   (4096 slots)
# Master4: 12288-16383  (4096 slots)
```

#### 迁移原理

```
源节点                        目标节点
   ↓                            ↓
1. CLUSTER SETSLOT <slot> MIGRATING <target>
                              ↓
2.                  CLUSTER SETSLOT <slot> IMPORTING <source>
   ↓
3. CLUSTER GETKEYSINSLOT <slot> <count>
   ↓
4. MIGRATE <target> <port> <key> 0 5000
   (将 key 迁移到目标节点)
   ↓
5. 重复步骤 3-4 直到槽位为空
   ↓
6. CLUSTER SETSLOT <slot> NODE <target>
                              ↓
7.                  CLUSTER SETSLOT <slot> NODE <target>
```

**特点**:
- 在线迁移,不停服
- 迁移过程中使用 ASK 重定向
- 原子性迁移单个 key

### 故障转移

#### 1. 故障检测

```
Master1 故障
    ↓
半数以上节点标记为 PFAIL (主观下线)
    ↓
半数以上节点标记为 FAIL (客观下线)
    ↓
触发故障转移
```

#### 2. 选举新 Master

**选举条件**:
- Slave 数据最新 (复制偏移量最大)
- 所有 Slave 参与选举
- 获得多数 Master 投票

**流程**:
```bash
# Master1 故障
# Slave1 发起选举
CLUSTER FAILOVER

# 选举成功后:
# 1. Slave1 提升为 Master
# 2. 接管 Master1 的槽位
# 3. 其他节点更新路由表
# 4. 客户端更新连接
```

### 集群管理命令

```bash
# 查看集群信息
CLUSTER INFO

# 查看节点列表
CLUSTER NODES

# 查看槽位分配
CLUSTER SLOTS

# 查看 key 所在槽位
CLUSTER KEYSLOT <key>

# 查看槽位中的 key 数量
CLUSTER COUNTKEYSINSLOT <slot>

# 获取槽位中的 key
CLUSTER GETKEYSINSLOT <slot> <count>

# 手动故障转移
CLUSTER FAILOVER [FORCE|TAKEOVER]

# 忘记节点(下线)
CLUSTER FORGET <node-id>

# 重置节点
CLUSTER RESET [HARD|SOFT]
```

### 集群配置

**redis.conf**:
```bash
# 启用集群模式
cluster-enabled yes

# 集群配置文件
cluster-config-file nodes-7000.conf

# 节点超时时间
cluster-node-timeout 15000

# 主节点故障后,从节点等待时间
cluster-replica-validity-factor 10

# 主节点至少有一个从节点才能提供服务
cluster-require-full-coverage no

# 从节点迁移屏障
cluster-migration-barrier 1

# 允许从节点读
replica-read-only yes
```

### 客户端使用

#### Go (go-redis)
```go
import "github.com/go-redis/redis/v8"

rdb := redis.NewClusterClient(&redis.ClusterOptions{
    Addrs: []string{
        "node1:7000",
        "node2:7001",
        "node3:7002",
    },
    Password: "password",

    // 最大重定向次数
    MaxRedirects: 8,

    // 只读命令路由到从节点
    ReadOnly: true,
    RouteByLatency: true,
})

// 使用 Hash Tag 确保多个 key 在同一节点
err := rdb.MSet(ctx,
    "{user:1000}:name", "Alice",
    "{user:1000}:age", "25",
).Err()
```

#### Java (Jedis)
```java
Set<HostAndPort> nodes = new HashSet<>();
nodes.add(new HostAndPort("node1", 7000));
nodes.add(new HostAndPort("node2", 7001));
nodes.add(new HostAndPort("node3", 7002));

JedisCluster cluster = new JedisCluster(nodes);

// 使用 Hash Tag
cluster.set("{user:1000}:name", "Alice");
cluster.set("{user:1000}:age", "25");
```

### 优缺点对比

| 对比项 | Redis Cluster | Sentinel | 单机 |
|-------|--------------|----------|------|
| 数据分片 | 支持(16384槽) | 不支持 | 不支持 |
| 水平扩展 | 支持 | 不支持 | 不支持 |
| 高可用 | 支持 | 支持 | 不支持 |
| 最大内存 | 节点数×单机内存 | 单机内存 | 单机内存 |
| 写性能 | 节点数×单机写性能 | 单机写性能 | 单机写性能 |
| 复杂度 | 高 | 中 | 低 |
| 运维成本 | 高 | 中 | 低 |
| 事务支持 | 仅同节点(Hash Tag) | 完全支持 | 完全支持 |
| 批量操作 | 仅同节点(Hash Tag) | 完全支持 | 完全支持 |

### 限制和注意事项

**1. 多 key 操作限制**:
```bash
# 错误: key 不在同一槽位
MGET user:1000 user:2000
# (error) CROSSSLOT Keys in request don't hash to the same slot

# 正确: 使用 Hash Tag
MGET {user}:1000 {user}:2000
```

**2. 事务限制**:
```bash
# 只支持同一槽位的事务
MULTI
SET {user:1000}:name "Alice"
SET {user:1000}:age "25"
EXEC

# 不支持跨槽位事务
MULTI
SET user:1000 "data1"  # 槽位 12345
SET user:2000 "data2"  # 槽位 8901
EXEC
# (error) CROSSSLOT
```

**3. 数据库切换**:
- Cluster 模式只支持 db0
- 不支持 SELECT 命令

**4. 复制结构**:
- 只支持一层主从复制
- 不支持级联复制

### 最佳实践

**1. 节点规划**:
- Master 节点建议 3-5 个(奇数)
- 每个 Master 至少 1 个 Slave
- 部署在不同机器/机房

**2. Hash Tag 使用**:
- 合理使用 Hash Tag 减少跨节点操作
- 避免热点数据集中在单个节点

**3. 槽位分配**:
- 保持槽位均匀分布
- 扩容时提前规划

**4. 监控指标**:
- 槽位分布是否均匀
- 节点间数据迁移状态
- 集群健康状态 (CLUSTER INFO)
- 各节点 QPS 和内存使用

**5. 客户端配置**:
- 使用智能客户端自动处理重定向
- 配置合理的超时和重试策略
- 开启从节点读取降低主节点压力

### 总结

Redis Cluster 通过哈希槽实现数据分片和水平扩展:

1. **16384 个槽位**均匀分配到不同节点
2. **CRC16 算法**将 key 映射到槽位
3. **MOVED/ASK 重定向**路由请求到正确节点
4. **在线扩容**支持槽位迁移
5. **自动故障转移**保证高可用
6. **Hash Tag** 支持多 key 操作和事务

适用场景:大数据量、高并发、需要水平扩展的场景。
