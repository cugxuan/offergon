---
title: Redis 的慢查询日志和性能监控方法
tags:
  - 缓存
status: robot
class: 缓存
slug: redis-slow-query-log-performance-monitoring
ref:
---

## 核心要点

Redis 慢查询日志记录执行时间超过阈值的命令,通过 SLOWLOG 命令查看和管理。性能监控包括 INFO 命令查看实时状态、MONITOR 实时监控命令流、benchmark 压测工具,以及第三方工具(Prometheus、Grafana、Redis Exporter)实现可视化监控和告警。

## 详细回答

### 慢查询日志

#### 配置慢查询

**redis.conf**:
```bash
# 慢查询阈值 (微秒), 超过此时间的命令会被记录
slowlog-log-slower-than 10000  # 10ms = 10000 微秒

# 慢查询日志最大长度 (FIFO 队列)
slowlog-max-len 128

# 运行时修改
CONFIG SET slowlog-log-slower-than 10000
CONFIG SET slowlog-max-len 128
```

**时间单位**:
- **1 秒 = 1,000,000 微秒**
- 10000 微秒 = 10 毫秒
- 100000 微秒 = 100 毫秒

**推荐配置**:
```bash
# 开发环境: 记录所有命令
slowlog-log-slower-than 0

# 测试环境: 记录 >1ms 的命令
slowlog-log-slower-than 1000

# 生产环境: 记录 >10ms 的命令
slowlog-log-slower-than 10000
```

#### 查看慢查询日志

```bash
# 查看最近的慢查询 (默认 10 条)
SLOWLOG GET
# 1) 1) (integer) 6           # 日志 ID
#    2) (integer) 1609459200  # 时间戳
#    3) (integer) 12000        # 执行时间 (微秒)
#    4) 1) "KEYS"              # 命令
#       2) "user:*"
#    5) "127.0.0.1:56231"      # 客户端地址
#    6) ""                     # 客户端名称

# 查看指定数量
SLOWLOG GET 20

# 查看慢查询日志长度
SLOWLOG LEN
# (integer) 15

# 清空慢查询日志
SLOWLOG RESET
# OK
```

**Go 代码示例**:
```go
import "github.com/go-redis/redis/v8"

func GetSlowLog(ctx context.Context, rdb *redis.Client) {
    // 获取慢查询日志
    logs, err := rdb.SlowLogGet(ctx, 10).Result()
    if err != nil {
        log.Printf("Error: %v", err)
        return
    }

    for _, log := range logs {
        fmt.Printf("ID: %d, Duration: %d μs, Cmd: %v, Client: %s\n",
            log.ID, log.Duration.Microseconds(), log.Args, log.ClientAddr)
    }
}

// 监控慢查询
func MonitorSlowLog(ctx context.Context, rdb *redis.Client) {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    lastID := int64(0)

    for range ticker.C {
        logs, _ := rdb.SlowLogGet(ctx, 100).Result()

        for _, log := range logs {
            if log.ID > lastID {
                // 新的慢查询
                fmt.Printf("New slow query: %v, duration: %d μs\n",
                    log.Args, log.Duration.Microseconds())

                // 发送告警
                if log.Duration > 100*time.Millisecond {
                    sendAlert(log)
                }
            }
        }

        if len(logs) > 0 {
            lastID = logs[0].ID
        }
    }
}
```

#### 分析慢查询

**常见慢命令**:

| 命令 | 时间复杂度 | 优化建议 |
|------|-----------|---------|
| KEYS * | O(n) | 使用 SCAN 代替 |
| HGETALL big_hash | O(n) | 使用 HSCAN 或拆分 Hash |
| SMEMBERS big_set | O(n) | 使用 SSCAN |
| SORT big_list | O(n*log(n)) | 在应用层排序 |
| LRANGE list 0 -1 | O(n) | 分页查询 |
| SUNION/SINTER big_sets | O(n*m) | 减少集合大小 |

**优化示例**:
```bash
# 慢命令
KEYS user:*       # O(n), 阻塞所有操作

# 优化: 使用 SCAN
SCAN 0 MATCH user:* COUNT 100
# 渐进式遍历,不阻塞
```

```go
// 优化前: KEYS 命令
keys, err := rdb.Keys(ctx, "user:*").Result()
// 阻塞 100ms+

// 优化后: SCAN 命令
var cursor uint64
var keys []string
for {
    var batch []string
    batch, cursor, err = rdb.Scan(ctx, cursor, "user:*", 100).Result()
    keys = append(keys, batch...)

    if cursor == 0 {
        break
    }
}
// 每次只扫描 100 个, 不阻塞
```

### INFO 命令监控

#### INFO 命令分类

```bash
# 查看所有信息
INFO

# 查看特定分类
INFO server      # 服务器信息
INFO clients     # 客户端连接
INFO memory      # 内存使用
INFO persistence # 持久化
INFO stats       # 统计信息
INFO replication # 主从复制
INFO cpu         # CPU 使用
INFO keyspace    # 键空间统计
INFO cluster     # 集群信息
INFO commandstats # 命令统计
```

#### 关键监控指标

**1. Server 信息**:
```bash
INFO server

redis_version:7.0.0         # Redis 版本
process_id:12345            # 进程 ID
uptime_in_seconds:86400     # 运行时间 (秒)
uptime_in_days:1            # 运行时间 (天)
```

**2. Clients 信息**:
```bash
INFO clients

connected_clients:100       # 当前连接数
blocked_clients:5           # 阻塞的客户端数 (BLPOP, BRPOP)
client_recent_max_input_buffer:8192   # 输入缓冲区最大值
client_recent_max_output_buffer:16384 # 输出缓冲区最大值
```

**监控告警**:
- connected_clients > 10000: 连接数过高
- blocked_clients 持续增长: 可能有死锁

**3. Memory 信息**:
```bash
INFO memory

used_memory:1073741824      # 1GB
used_memory_human:1.00G
used_memory_rss:1200000000  # 实际物理内存
mem_fragmentation_ratio:1.12 # 碎片率
evicted_keys:1000           # 淘汰的 key 数量
```

**监控告警**:
- mem_fragmentation_ratio > 1.5: 碎片严重
- evicted_keys 快速增长: 内存不足

**4. Stats 统计**:
```bash
INFO stats

total_connections_received:10000  # 总连接数
total_commands_processed:1000000  # 总命令数
instantaneous_ops_per_sec:1000    # 当前 QPS
keyspace_hits:900000              # 命中次数
keyspace_misses:100000            # 未命中次数
```

**关键指标**:
- **QPS**: instantaneous_ops_per_sec
- **命中率**: keyspace_hits / (keyspace_hits + keyspace_misses)

```
命中率 = 900000 / (900000 + 100000) = 90%
```

**5. Commandstats 命令统计**:
```bash
INFO commandstats

cmdstat_get:calls=10000,usec=50000,usec_per_call=5.00
cmdstat_set:calls=5000,usec=25000,usec_per_call=5.00
cmdstat_keys:calls=10,usec=100000,usec_per_call=10000.00
```

**分析**:
- calls: 调用次数
- usec: 总耗时 (微秒)
- usec_per_call: 平均耗时

**Go 解析 INFO**:
```go
func ParseInfo(ctx context.Context, rdb *redis.Client) {
    info, err := rdb.Info(ctx, "stats").Result()
    if err != nil {
        return
    }

    lines := strings.Split(info, "\r\n")
    stats := make(map[string]string)

    for _, line := range lines {
        if strings.Contains(line, ":") {
            parts := strings.SplitN(line, ":", 2)
            stats[parts[0]] = parts[1]
        }
    }

    // 计算命中率
    hits, _ := strconv.ParseInt(stats["keyspace_hits"], 10, 64)
    misses, _ := strconv.ParseInt(stats["keyspace_misses"], 10, 64)
    hitRate := float64(hits) / float64(hits+misses) * 100

    fmt.Printf("Hit rate: %.2f%%\n", hitRate)
}
```

### MONITOR 实时监控

#### 使用 MONITOR

```bash
# 实时查看所有命令
MONITOR
# OK
# 1609459200.123456 [0 127.0.0.1:56231] "GET" "user:1000"
# 1609459200.234567 [0 127.0.0.1:56232] "SET" "user:2000" "data"
```

**格式**:
```
时间戳 [数据库 客户端地址] "命令" "参数1" "参数2" ...
```

**注意**:
- MONITOR 会降低 Redis 性能 (10-20%)
- 仅用于调试,不要在生产环境长时间开启
- 可以在从节点上使用 MONITOR

**Go 代码**:
```go
func MonitorCommands(ctx context.Context, rdb *redis.Client, duration time.Duration) {
    // 创建单独的连接用于 MONITOR
    conn := rdb.Conn(ctx)
    defer conn.Close()

    // 开启监控
    err := conn.Do(ctx, "MONITOR").Err()
    if err != nil {
        log.Fatal(err)
    }

    // 设置超时
    ctx, cancel := context.WithTimeout(ctx, duration)
    defer cancel()

    // 接收命令
    for {
        select {
        case <-ctx.Done():
            return
        default:
            msg, err := conn.Receive(ctx)
            if err != nil {
                return
            }
            fmt.Println(msg)
        }
    }
}

// 使用示例
func main() {
    ctx := context.Background()
    rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})

    // 监控 10 秒
    MonitorCommands(ctx, rdb, 10*time.Second)
}
```

### Redis Benchmark

#### 基本使用

```bash
# 默认测试 (50 个并发, 10000 个请求)
redis-benchmark

# 指定主机和端口
redis-benchmark -h 127.0.0.1 -p 6379

# 指定并发数和请求数
redis-benchmark -c 100 -n 100000

# 只测试特定命令
redis-benchmark -t set,get -n 100000

# 使用 pipeline
redis-benchmark -P 10 -n 100000
```

**完整示例**:
```bash
# 100 个并发, 10 万个请求, pipeline 10 条命令
redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 -P 10 -t get,set
```

**输出示例**:
```
====== SET ======
  100000 requests completed in 1.25 seconds
  100 parallel clients
  3 bytes payload
  keep alive: 1

99.00% <= 1 milliseconds
99.90% <= 2 milliseconds
100.00% <= 3 milliseconds
80000.00 requests per second
```

#### 性能基准

**单机 Redis (2核 4GB)**:

| 操作 | QPS | 说明 |
|------|-----|------|
| GET | 100,000+ | 纯内存读取 |
| SET | 80,000+ | 纯内存写入 |
| INCR | 100,000+ | 原子递增 |
| LPUSH | 80,000+ | 列表头部插入 |
| HSET | 80,000+ | Hash 字段设置 |
| SADD | 80,000+ | 集合添加 |

### CLIENT 命令

```bash
# 查看所有客户端连接
CLIENT LIST
# id=3 addr=127.0.0.1:56231 fd=8 name= age=10 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get

# 杀死指定客户端
CLIENT KILL 127.0.0.1:56231

# 设置客户端名称
CLIENT SETNAME "web-server-1"

# 获取当前客户端名称
CLIENT GETNAME

# 暂停所有客户端
CLIENT PAUSE 1000  # 暂停 1 秒
```

**Go 代码**:
```go
func ListClients(ctx context.Context, rdb *redis.Client) {
    // 获取客户端列表
    list, err := rdb.ClientList(ctx).Result()
    if err != nil {
        return
    }

    // 解析客户端信息
    lines := strings.Split(list, "\n")
    for _, line := range lines {
        if line == "" {
            continue
        }
        fmt.Println(line)
    }
}
```

### 第三方监控工具

#### Prometheus + Grafana

**1. Redis Exporter**:
```bash
# 安装 Redis Exporter
docker run -d --name redis_exporter \
  -p 9121:9121 \
  oliver006/redis_exporter \
  --redis.addr=redis://localhost:6379
```

**2. Prometheus 配置**:
```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'redis'
    static_configs:
      - targets: ['localhost:9121']
```

**3. Grafana 仪表盘**:
- 导入 Redis Dashboard (ID: 763)
- 查看 QPS、内存、连接数、命中率等指标

**监控指标**:
- redis_connected_clients: 连接数
- redis_used_memory_bytes: 内存使用
- redis_keyspace_hits_total: 命中次数
- redis_keyspace_misses_total: 未命中次数
- redis_commands_processed_total: 命令总数

#### RedisInsight

官方提供的 GUI 工具:
- 实时监控 QPS、内存、连接数
- 慢查询日志分析
- 命令统计
- 内存分析

下载: https://redis.com/redis-enterprise/redis-insight/

### 性能监控最佳实践

#### 1. 设置合理的慢查询阈值

```bash
# 根据业务需求调整
slowlog-log-slower-than 10000  # 10ms

# 记录足够多的日志
slowlog-max-len 1000
```

#### 2. 定期分析慢查询

```go
func AnalyzeSlowLog(ctx context.Context, rdb *redis.Client) {
    logs, _ := rdb.SlowLogGet(ctx, 100).Result()

    // 统计慢命令
    cmdCount := make(map[string]int)
    for _, log := range logs {
        cmd := fmt.Sprintf("%v", log.Args[0])
        cmdCount[cmd]++
    }

    // 输出 Top 10
    type cmdStat struct {
        cmd   string
        count int
    }
    var stats []cmdStat
    for cmd, count := range cmdCount {
        stats = append(stats, cmdStat{cmd, count})
    }
    sort.Slice(stats, func(i, j int) bool {
        return stats[i].count > stats[j].count
    })

    for i := 0; i < 10 && i < len(stats); i++ {
        fmt.Printf("%s: %d\n", stats[i].cmd, stats[i].count)
    }
}
```

#### 3. 监控关键指标

```go
type RedisMetrics struct {
    QPS           int64
    HitRate       float64
    MemoryUsage   int64
    ConnectedClients int64
    SlowLogCount  int64
}

func CollectMetrics(ctx context.Context, rdb *redis.Client) *RedisMetrics {
    info, _ := rdb.Info(ctx, "stats", "clients", "memory").Result()

    metrics := &RedisMetrics{}
    // 解析 INFO 输出并填充 metrics...

    return metrics
}

// 定期收集并上报
func MonitorMetrics(ctx context.Context, rdb *redis.Client) {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        metrics := CollectMetrics(ctx, rdb)

        // 上报到监控系统
        reportToPrometheus(metrics)

        // 检查告警
        if metrics.HitRate < 0.8 {
            sendAlert("Low hit rate: %.2f%%", metrics.HitRate*100)
        }
    }
}
```

#### 4. 告警规则

| 指标 | 阈值 | 说明 |
|------|------|------|
| QPS | 超过容量的 80% | 需要扩容 |
| 命中率 | < 80% | 缓存效果差 |
| 内存使用 | > 80% | 内存不足 |
| 连接数 | > 80% maxclients | 连接数过高 |
| 慢查询数 | > 100/分钟 | 有性能问题 |
| 内存碎片率 | > 1.5 | 内存碎片严重 |

### 总结

**慢查询日志**:
1. 配置合理阈值 (生产环境 10ms)
2. 定期分析慢命令
3. 优化慢命令 (KEYS → SCAN)

**性能监控**:
1. INFO 命令查看实时状态
2. MONITOR 实时监控命令流 (仅调试用)
3. Benchmark 压力测试
4. Prometheus + Grafana 可视化监控

**关键指标**:
- QPS: 每秒查询数
- 命中率: keyspace_hits / (hits + misses)
- 内存使用: used_memory / maxmemory
- 连接数: connected_clients
- 慢查询数: SLOWLOG LEN
