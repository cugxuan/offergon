---
title: Redis 的事务机制（MULTI/EXEC），与关系型数据库事务的区别
tags:
  - 缓存
status: robot
class: 缓存
slug: redis-transactions-vs-relational-db-difference
ref:
---

## 核心要点

Redis 事务通过 MULTI/EXEC 命令将多个命令打包执行,保证原子性和隔离性,但不支持回滚。与关系型数据库相比,Redis 事务不支持 ACID 中的持久性和一致性,适用于简单的原子操作场景,复杂事务需要使用 Lua 脚本。

## 详细回答

### Redis 事务基础

#### 事务命令

| 命令 | 说明 |
|------|------|
| MULTI | 开启事务,后续命令进入队列 |
| EXEC | 执行事务队列中的所有命令 |
| DISCARD | 取消事务,清空命令队列 |
| WATCH | 监视 key,如果 key 被修改则事务失败 (乐观锁) |
| UNWATCH | 取消监视所有 key |

#### 基本用法

```bash
# 开启事务
MULTI
OK

# 后续命令进入队列 (不会立即执行)
SET account:1000 100
QUEUED

SET account:2000 200
QUEUED

INCR account:1000
QUEUED

# 执行事务
EXEC
1) OK
2) OK
3) (integer) 101
```

**Go 代码示例**:
```go
import "github.com/go-redis/redis/v8"

func Transfer(ctx context.Context, rdb *redis.Client) error {
    // 开启事务
    pipe := rdb.TxPipeline()

    // 添加命令到队列
    pipe.DecrBy(ctx, "account:1000", 100)
    pipe.IncrBy(ctx, "account:2000", 100)

    // 执行事务
    _, err := pipe.Exec(ctx)
    return err
}
```

### Redis 事务特性

#### 1. 原子性 (Atomicity)

**队列中的命令要么全部执行,要么全部不执行**。

```bash
MULTI
SET key1 "value1"
SET key2 "value2"
SET key3 "value3"
EXEC
# 三个命令要么全部成功,要么全部不执行
```

**但是**,Redis 事务的原子性是**弱原子性**:
- 命令语法错误: 整个事务不执行
- 命令运行错误: 其他命令继续执行,不会回滚

```bash
# 示例 1: 语法错误 - 整个事务不执行
MULTI
SET key1 "value1"
INVALID_COMMAND      # 语法错误
SET key2 "value2"
EXEC
# (error) EXECABORT Transaction discarded
# 所有命令都不执行

# 示例 2: 运行错误 - 不会回滚
MULTI
SET key1 "value1"
INCR key1            # 运行错误: 对字符串执行 INCR
SET key2 "value2"
EXEC
1) OK
2) (error) value is not an integer
3) OK
# key1 和 key2 都被设置了,不会回滚!
```

#### 2. 隔离性 (Isolation)

**事务执行期间,其他客户端的命令不会插入**。

```bash
# 客户端 1
MULTI
SET key "value1"
# ... 其他命令
EXEC

# 客户端 2
SET key "value2"  # 等待客户端 1 的 EXEC 完成后才执行
```

**原因**: Redis 是单线程执行命令,事务中的命令会连续执行。

#### 3. 不支持持久性 (Durability)

**事务执行后不保证立即持久化**。

- 默认情况下,事务执行后数据在内存中
- 需要配合 AOF 或 RDB 持久化
- 即使配置了 AOF,也可能丢失数据 (appendfsync everysec)

#### 4. 不支持一致性 (Consistency)

**没有约束检查,没有回滚机制**。

```bash
# 转账示例: 余额可能为负数
MULTI
DECRBY account:1000 100  # 即使余额不足,也会执行
INCRBY account:2000 100
EXEC
# 没有检查 account:1000 余额是否足够
# 执行后 account:1000 可能为负数
```

### WATCH 乐观锁

#### 原理

**WATCH 监视 key,如果 key 被其他客户端修改,事务失败**。

```bash
# 客户端 1
WATCH balance:1000
balance = GET balance:1000  # 读取余额

MULTI
SET balance:1000 <new_value>
EXEC
# 如果 EXEC 前 balance:1000 被修改,EXEC 返回 nil
```

#### 使用示例

**秒杀场景: 库存扣减**:
```go
func DecrStock(ctx context.Context, rdb *redis.Client, productID string) error {
    key := fmt.Sprintf("stock:%s", productID)

    // 最多重试 10 次
    for i := 0; i < 10; i++ {
        // 监视库存
        err := rdb.Watch(ctx, func(tx *redis.Tx) error {
            // 读取当前库存
            stock, err := tx.Get(ctx, key).Int()
            if err != nil {
                return err
            }

            // 检查库存是否足够
            if stock <= 0 {
                return errors.New("out of stock")
            }

            // 开启事务
            _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
                pipe.Decr(ctx, key)
                return nil
            })
            return err
        }, key)

        // 成功或非 TxFailedErr 错误
        if err != redis.TxFailedErr {
            return err
        }
        // TxFailedErr: 重试
    }

    return errors.New("max retries exceeded")
}
```

**CAS (Compare-And-Swap) 模式**:
```bash
# 伪代码
WATCH mykey
val = GET mykey
val = val + 1

MULTI
SET mykey $val
result = EXEC

if result == nil:
    # 被其他客户端修改,重试
    retry()
```

### DISCARD 取消事务

```bash
MULTI
SET key1 "value1"
SET key2 "value2"
DISCARD      # 取消事务,清空队列
# OK

# 队列中的命令不会执行
```

### Redis vs 关系型数据库事务

#### ACID 对比

| 特性 | Redis 事务 | MySQL 事务 |
|------|-----------|-----------|
| **原子性 (A)** | 弱原子性,无回滚 | 强原子性,支持回滚 |
| **一致性 (C)** | 不支持,无约束检查 | 支持,外键/约束检查 |
| **隔离性 (I)** | 单线程,完全隔离 | 多种隔离级别 |
| **持久性 (D)** | 依赖 AOF/RDB | WAL,崩溃恢复 |

#### 功能对比

| 功能 | Redis 事务 | MySQL 事务 |
|------|-----------|-----------|
| **回滚** | 不支持 | 支持 (ROLLBACK) |
| **保存点** | 不支持 | 支持 (SAVEPOINT) |
| **嵌套事务** | 不支持 | 支持 (部分) |
| **条件判断** | 不支持 | 支持 (SQL 逻辑) |
| **跨表操作** | 不支持 (无表概念) | 支持 |
| **锁机制** | 乐观锁 (WATCH) | 悲观锁 + 乐观锁 |
| **并发控制** | 单线程,无并发 | MVCC, 锁 |

#### 使用场景对比

**Redis 事务适用场景**:
```bash
# 1. 简单原子操作
MULTI
INCR page_view:article:1000
INCR page_view:total
EXEC

# 2. 批量操作
MULTI
SET user:1000:name "Alice"
SET user:1000:age "25"
SET user:1000:city "Beijing"
EXEC

# 3. 计数器
MULTI
INCR success_count
DECR retry_count
EXEC
```

**MySQL 事务适用场景**:
```sql
-- 复杂业务逻辑,需要回滚
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1000;

-- 检查余额
SELECT balance FROM accounts WHERE id = 1000;
-- 如果余额 < 0, ROLLBACK

UPDATE accounts SET balance = balance + 100 WHERE id = 2000;

COMMIT;
```

### Lua 脚本 (推荐方案)

**Redis 事务的局限性可以通过 Lua 脚本解决**。

#### Lua 脚本优势

| 特性 | Redis 事务 | Lua 脚本 |
|------|-----------|---------|
| 原子性 | 弱 | 强 (真正原子) |
| 条件判断 | 不支持 | 支持 |
| 回滚 | 不支持 | 可自行控制 |
| 性能 | 需要网络往返 | 服务端执行,更快 |
| 复杂度 | 简单 | 支持复杂逻辑 |

#### Lua 脚本示例

**安全的库存扣减**:
```lua
-- decrstock.lua
local key = KEYS[1]
local decrby = tonumber(ARGV[1])

-- 获取当前库存
local stock = tonumber(redis.call('GET', key) or "0")

-- 检查库存是否足够
if stock < decrby then
    return -1  -- 库存不足
end

-- 扣减库存
redis.call('DECRBY', key, decrby)
return stock - decrby  -- 返回剩余库存
```

**Go 调用 Lua 脚本**:
```go
var decrStockScript = redis.NewScript(`
local key = KEYS[1]
local decrby = tonumber(ARGV[1])

local stock = tonumber(redis.call('GET', key) or "0")
if stock < decrby then
    return -1
end

redis.call('DECRBY', key, decrby)
return stock - decrby
`)

func DecrStockLua(ctx context.Context, rdb *redis.Client, productID string, count int) (int, error) {
    key := fmt.Sprintf("stock:%s", productID)

    result, err := decrStockScript.Run(ctx, rdb, []string{key}, count).Int()
    if err != nil {
        return 0, err
    }

    if result == -1 {
        return 0, errors.New("out of stock")
    }

    return result, nil
}
```

**转账示例 (带余额检查)**:
```lua
-- transfer.lua
local from_key = KEYS[1]
local to_key = KEYS[2]
local amount = tonumber(ARGV[1])

-- 检查余额
local balance = tonumber(redis.call('GET', from_key) or "0")
if balance < amount then
    return {err = "insufficient balance"}
end

-- 转账
redis.call('DECRBY', from_key, amount)
redis.call('INCRBY', to_key, amount)

return {ok = "success"}
```

### Pipeline vs 事务

#### 区别

| 特性 | Pipeline | 事务 (MULTI/EXEC) |
|------|---------|------------------|
| 原子性 | 不保证 | 保证 |
| 网络往返 | 1 次 | 1 次 |
| 命令顺序 | 保证 | 保证 |
| 条件执行 | 不支持 | 支持 (WATCH) |
| 回滚 | 不支持 | 不支持 |
| 使用场景 | 批量操作 | 原子操作 |

#### Pipeline 示例

```go
// Pipeline: 不保证原子性,但减少网络往返
pipe := rdb.Pipeline()

pipe.Set(ctx, "key1", "value1", 0)
pipe.Set(ctx, "key2", "value2", 0)
pipe.Set(ctx, "key3", "value3", 0)

// 执行 (3 个命令 1 次网络往返)
cmds, err := pipe.Exec(ctx)
// 如果某个命令失败,其他命令仍然执行
```

#### 事务 + Pipeline

```go
// 结合使用: 原子性 + 减少网络往返
pipe := rdb.TxPipeline()  // 事务 Pipeline

pipe.Multi(ctx)
pipe.Set(ctx, "key1", "value1", 0)
pipe.Set(ctx, "key2", "value2", 0)
pipe.Exec(ctx)

// 执行
cmds, err := pipe.Exec(ctx)
```

### 事务失败场景

#### 1. 语法错误

```bash
MULTI
SET key1 "value1"
INVALID COMMAND       # 语法错误
EXEC
# (error) EXECABORT Transaction discarded
# 所有命令都不执行
```

#### 2. WATCH 监视的 key 被修改

```bash
# 客户端 1
WATCH balance
MULTI
SET balance 100
EXEC
# (nil) - 事务失败

# 客户端 2 (在客户端 1 EXEC 前)
SET balance 200  # 修改了被监视的 key
```

#### 3. 运行时错误 (不会中断事务)

```bash
MULTI
SET key1 "value1"
INCR key1           # 运行错误
SET key2 "value2"
EXEC
1) OK
2) (error) ERR value is not an integer
3) OK
# key1 和 key2 都被设置,不会回滚!
```

### 最佳实践

#### 1. 简单场景使用事务

```go
// 适合: 简单的批量操作
func BatchSet(ctx context.Context, rdb *redis.Client) error {
    pipe := rdb.TxPipeline()

    pipe.Set(ctx, "key1", "value1", 0)
    pipe.Set(ctx, "key2", "value2", 0)
    pipe.Set(ctx, "key3", "value3", 0)

    _, err := pipe.Exec(ctx)
    return err
}
```

#### 2. 复杂场景使用 Lua 脚本

```go
// 推荐: 需要条件判断、余额检查等
var transferScript = redis.NewScript(`
    local from = KEYS[1]
    local to = KEYS[2]
    local amount = tonumber(ARGV[1])

    local balance = tonumber(redis.call('GET', from) or "0")
    if balance < amount then
        return {err = "insufficient balance"}
    end

    redis.call('DECRBY', from, amount)
    redis.call('INCRBY', to, amount)
    return {ok = "success"}
`)

func Transfer(ctx context.Context, rdb *redis.Client, from, to string, amount int) error {
    result, err := transferScript.Run(ctx, rdb, []string{from, to}, amount).Result()
    // 处理结果...
}
```

#### 3. 使用 WATCH 实现 CAS

```go
// 适合: 乐观锁场景 (秒杀、计数器)
func CASUpdate(ctx context.Context, rdb *redis.Client, key string) error {
    return rdb.Watch(ctx, func(tx *redis.Tx) error {
        val, err := tx.Get(ctx, key).Int()
        if err != nil && err != redis.Nil {
            return err
        }

        // 业务逻辑
        newVal := val + 1

        // 执行事务
        _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
            pipe.Set(ctx, key, newVal, 0)
            return nil
        })
        return err
    }, key)
}
```

#### 4. 避免长事务

```bash
# 坏例子: 事务中执行慢命令
MULTI
KEYS *          # O(n) 慢命令
SORT big_list   # 慢命令
SET key value
EXEC

# 好例子: 只包含简单命令
MULTI
SET key1 value1
SET key2 value2
INCR counter
EXEC
```

### 常见问题

**Q: Redis 事务为什么不支持回滚?**
A: Redis 作者认为:
- 回滚增加复杂度,影响性能
- Redis 命令失败通常是编程错误,不是运行时错误
- 使用 Lua 脚本可以实现复杂逻辑

**Q: 如何保证 Redis 事务的一致性?**
A: 使用 Lua 脚本:
- 在脚本中检查条件
- 不满足条件时不执行修改操作
- 返回错误给客户端

**Q: WATCH 监视多个 key 怎么办?**
A:
```bash
# 监视多个 key
WATCH key1 key2 key3

MULTI
SET key1 value1
SET key2 value2
EXEC
# 任何一个 key 被修改,事务都会失败
```

### 总结

#### Redis 事务特点
1. **弱原子性**: 不支持回滚,运行错误继续执行
2. **隔离性**: 单线程,完全隔离
3. **无持久性**: 依赖 AOF/RDB
4. **无一致性**: 无约束检查

#### 与关系型数据库区别
1. 不支持 ACID 完整特性
2. 不支持回滚
3. 不支持复杂逻辑 (条件判断)
4. 通过 Lua 脚本弥补不足

#### 使用建议
- 简单批量操作: 使用 MULTI/EXEC
- 需要条件判断: 使用 Lua 脚本
- 乐观锁场景: 使用 WATCH
- 仅需减少网络往返: 使用 Pipeline
