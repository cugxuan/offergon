---
title: Cookie、Session、Token 的区别，JWT 的工作原理
tags:
  - 计算机网络
status: robot
class: 计算机网络
slug: cookie-session-token-difference-jwt-workflow
ref:
---

## 核心要点

**Cookie**:浏览器存储的小型数据,HTTP头部自动携带;**Session**:服务器端存储,通过SessionID关联;**Token**:无状态凭证,客户端存储自验证。

**JWT**:Base64编码的Header.Payload.Signature,无需服务器存储会话,通过签名验证真实性,适合分布式系统和跨域场景。

---

## Cookie、Session、Token对比

| 特性 | Cookie | Session | Token |
|------|--------|---------|-------|
| **存储位置** | 客户端(浏览器) | 服务器端 | 客户端 |
| **容量限制** | ~4KB | 受服务器内存限制 | 无限制(通常几KB) |
| **安全性** | 易被窃取/篡改 | 较安全(ID在客户端) | 签名防篡改 |
| **跨域** | 受同源策略限制 | 依赖Cookie,受限 | 支持跨域 |
| **扩展性** | 无影响 | 难以水平扩展 | 易于扩展 |
| **状态** | 无状态 | 有状态 | 无状态 |

## Cookie详解

### 定义
服务器发送到浏览器并保存在本地的小型数据,浏览器在后续请求中自动携带。

### 工作流程
```
1. 服务器响应: Set-Cookie: sessionid=abc123; Path=/; HttpOnly
2. 浏览器存储Cookie
3. 后续请求自动携带: Cookie: sessionid=abc123
```

### Cookie属性

#### 1. Domain和Path
```
Set-Cookie: key=value; Domain=.example.com; Path=/api
```
- **Domain**:指定Cookie发送到哪些域名
- **Path**:指定Cookie发送到哪些路径

#### 2. Expires和Max-Age
```
Set-Cookie: key=value; Expires=Wed, 21 Oct 2025 07:28:00 GMT
Set-Cookie: key=value; Max-Age=3600
```
- **Expires**:过期时间(绝对时间)
- **Max-Age**:有效期(秒数,相对时间)
- 不设置则为**会话Cookie**(关闭浏览器即失效)

#### 3. Secure
```
Set-Cookie: key=value; Secure
```
- 仅通过HTTPS发送
- 防止中间人窃取

#### 4. HttpOnly
```
Set-Cookie: key=value; HttpOnly
```
- JavaScript无法访问(`document.cookie`读取不到)
- 防止XSS攻击窃取Cookie

#### 5. SameSite
```
Set-Cookie: key=value; SameSite=Strict
```
- **Strict**:完全禁止第三方请求携带Cookie
- **Lax**:部分允许(如GET链接跳转)
- **None**:允许跨站携带(需配合Secure)
- 防止CSRF攻击

### 安全最佳实践
```
Set-Cookie: sessionid=xyz; Secure; HttpOnly; SameSite=Strict; Max-Age=3600
```

## Session详解

### 定义
服务器端存储用户状态数据,通过**SessionID**与客户端关联。

### 工作流程
```
1. 用户登录成功
2. 服务器创建Session,生成SessionID,存储用户信息
3. 将SessionID通过Cookie发送给客户端: Set-Cookie: JSESSIONID=abc123
4. 客户端后续请求携带SessionID
5. 服务器通过SessionID查找Session数据
```

### Session存储方式

#### 1. 内存存储
- **优点**:速度快
- **缺点**:服务器重启丢失,无法水平扩展

#### 2. Redis/Memcached
- **优点**:高性能,支持分布式,持久化
- **缺点**:需要额外组件
- **适用**:生产环境首选

#### 3. 数据库
- **优点**:持久化,可靠
- **缺点**:性能较差
- **适用**:小型应用

### Session的问题

#### 1. 扩展性差
分布式环境下需要:
- **Session复制**:所有服务器同步Session(网络开销大)
- **Session粘性**(Sticky Session):同一用户固定到一台服务器(负载不均)
- **集中式存储**:Redis等(最佳方案)

#### 2. 服务器资源消耗
大量用户时Session占用内存

#### 3. 跨域问题
Cookie不跨域,无法共享Session

## Token详解

### 定义
自包含的**无状态凭证**,包含用户信息和签名,服务器不存储。

### 工作流程
```
1. 用户登录成功
2. 服务器生成Token(包含用户ID等信息),用密钥签名
3. 返回Token给客户端
4. 客户端存储Token(localStorage/Cookie)
5. 后续请求在Header中携带: Authorization: Bearer <token>
6. 服务器验证签名,解析用户信息
```

### 存储方式

#### 1. LocalStorage
```javascript
localStorage.setItem('token', 'eyJhbGci...')
// 请求时手动添加Header
fetch('/api', {
  headers: { 'Authorization': 'Bearer ' + localStorage.getItem('token') }
})
```
- **优点**:容量大(~5MB),不自动发送
- **缺点**:易受XSS攻击,不跨标签页自动更新

#### 2. SessionStorage
- 仅当前标签页有效
- 关闭标签页即清除

#### 3. Cookie(httpOnly)
```
Set-Cookie: token=eyJhbGci...; HttpOnly; Secure; SameSite=Strict
```
- **优点**:防XSS,自动携带
- **缺点**:受同源策略限制

### 优势
1. **无状态**:服务器不存储,易于扩展
2. **跨域支持**:可在Header中传递
3. **移动友好**:适合原生App
4. **去中心化**:微服务间传递

### 劣势
1. **无法主动失效**:Token一旦签发,在过期前无法撤销(除非维护黑名单)
2. **安全风险**:Token泄露在有效期内可被滥用
3. **负载较大**:每次请求携带完整Token

## JWT(JSON Web Token)详解

### 结构
JWT由三部分组成,用`.`分隔:
```
Header.Payload.Signature
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywicm9sZSI6ImFkbWluIiwiZXhwIjoxNzE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### 1. Header(头部)
```json
{
  "alg": "HS256",  // 签名算法
  "typ": "JWT"     // Token类型
}
```
Base64编码后得到第一部分。

### 2. Payload(载荷)
包含用户信息和元数据:
```json
{
  "userId": 123,
  "username": "alice",
  "role": "admin",
  "iat": 1716235422,  // 签发时间(Issued At)
  "exp": 1716239022   // 过期时间(Expiration Time)
}
```

**标准声明**(可选):
- **iss**(Issuer):签发者
- **sub**(Subject):主题
- **aud**(Audience):受众
- **exp**(Expiration):过期时间
- **nbf**(Not Before):生效时间
- **iat**(Issued At):签发时间
- **jti**(JWT ID):唯一标识

Base64编码后得到第二部分。

### 3. Signature(签名)
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret  // 服务器密钥
)
```

作用:
- 防止Payload被篡改
- 验证Token真实性

### JWT工作流程

#### 签发Token
```go
// Go示例
token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
    "userId": 123,
    "exp":    time.Now().Add(7 * 24 * time.Hour).Unix(),
})
tokenString, _ := token.SignedString([]byte("my-secret-key"))
// 返回: eyJhbGci...
```

#### 验证Token
```go
token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
    return []byte("my-secret-key"), nil
})

if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
    userId := claims["userId"].(float64)
    // 验证成功,获取用户ID
}
```

### JWT最佳实践

#### 1. 设置合理过期时间
```json
{
  "exp": 1716239022  // 短期Token: 15分钟-1小时
}
```
配合**Refresh Token**机制:
- **Access Token**:短期(15分钟),用于API访问
- **Refresh Token**:长期(7天-30天),用于刷新Access Token

#### 2. 不存储敏感信息
Payload是Base64编码(非加密),任何人都可以解码:
```javascript
// 浏览器中可直接解码
atob('eyJ1c2VySWQiOjEyM30=')  // {"userId":123}
```
**不要存储**:密码、信用卡号、私钥等

#### 3. 使用HTTPS
防止Token在传输中被窃取

#### 4. Token刷新机制
```
1. Access Token过期
2. 客户端使用Refresh Token请求新Access Token
3. 服务器验证Refresh Token,签发新Access Token
4. 如果Refresh Token也过期,要求重新登录
```

#### 5. 实现Token黑名单(可选)
用于主动注销:
```
1. 用户登出时,将Token加入Redis黑名单
2. 验证Token时检查黑名单
3. Token过期后自动从黑名单移除
```

### JWT vs Session

| 场景 | 推荐方案 |
|------|----------|
| 单体应用,用户量小 | Session(简单) |
| 分布式/微服务 | JWT(无状态) |
| 需要主动注销 | Session或JWT+黑名单 |
| 移动App | JWT |
| 高安全性要求 | Session+Redis |
| 跨域API | JWT |

## 实际应用示例(本项目)

### 当前项目使用JWT
参考`internal/utility/jwt/jwt.go`:

```go
// 生成Token
token, _ := GenerateToken(UserInfo{
    UserID:   123,
    Username: "alice",
    Role:     "user",
})

// 验证Token
userInfo, _ := ParseToken(token)
```

### 配置(manifest/config/config.yaml)
```yaml
jwt:
  signingKey: "your-secret-key"  # 签名密钥
  expireTime: 168h               # 7天过期
```

### 中间件自动刷新(internal/middleware/middleware_auth.go)
```go
// Token在3天内过期时自动刷新
if timeRemaining < 72*time.Hour {
    newToken, _ := jwt.GenerateToken(userInfo)
    // 返回新Token给客户端
}
```

### 公开路径配置
无需Token即可访问:
- `/wechat/*`:微信回调
- `/wechat/tempcodeLogin`:临时码登录
- `/q/info`,`/q/list`:题目接口

## 总结

1. **Cookie**:简单但受限于浏览器,适合传统Web应用
2. **Session**:成熟可靠,但扩展性差,适合单体应用
3. **Token/JWT**:无状态、可扩展,适合分布式和移动应用

**选择建议**:
- 单体应用→Session
- 分布式/微服务→JWT
- 需要兼容→Cookie+Session
- 移动App→JWT
