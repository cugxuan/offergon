---
title: 负载均衡的常见算法（轮询、加权轮询、一致性哈希）
tags:
  - 计算机网络
status: robot
class: 计算机网络
slug: load-balancing-algorithms
ref:
---

## 核心要点

**轮询（Round Robin）**：按顺序依次分配请求到每个服务器，简单公平，适合服务器性能相同的场景。

**加权轮询（Weighted Round Robin）**：根据服务器权重分配请求，权重高的服务器处理更多请求，适合服务器性能不同的场景。

**一致性哈希（Consistent Hashing）**：通过哈希环算法将请求映射到服务器，增删节点时只影响部分数据，适合分布式缓存等需要数据亲和性的场景。

---

## 负载均衡基础

### 什么是负载均衡

负载均衡（Load Balancing）是将网络流量分配到多个服务器的技术，目的是提高系统的可用性、可靠性和吞吐量。

### 负载均衡的作用

- **提高性能**：分散请求到多个服务器，避免单点过载
- **高可用性**：服务器故障时自动切换到其他服务器
- **扩展性**：通过添加服务器水平扩展系统容量
- **灵活性**：动态调整流量分配策略

---

## 1. 轮询算法（Round Robin）

### 原理

按顺序依次将请求分配给每个服务器，循环往复。

### 流程图

```
请求序列: 1 → 2 → 3 → 4 → 5 → 6
服务器:   A   B   C   A   B   C

服务器列表: [A, B, C]
当前索引: 0 → 1 → 2 → 0 → 1 → 2
```

### Go 实现

```go
package loadbalancer

import (
    "sync"
)

// 轮询负载均衡器
type RoundRobinBalancer struct {
    servers []string
    current int
    mu      sync.Mutex
}

func NewRoundRobinBalancer(servers []string) *RoundRobinBalancer {
    return &RoundRobinBalancer{
        servers: servers,
        current: 0,
    }
}

func (rb *RoundRobinBalancer) Next() string {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    if len(rb.servers) == 0 {
        return ""
    }

    // 获取当前服务器
    server := rb.servers[rb.current]

    // 移动到下一个服务器
    rb.current = (rb.current + 1) % len(rb.servers)

    return server
}

// 使用示例
func main() {
    servers := []string{"server1:8001", "server2:8002", "server3:8003"}
    lb := NewRoundRobinBalancer(servers)

    for i := 0; i < 6; i++ {
        server := lb.Next()
        fmt.Printf("请求 %d -> %s\n", i+1, server)
    }
}

// 输出:
// 请求 1 -> server1:8001
// 请求 2 -> server2:8002
// 请求 3 -> server3:8003
// 请求 4 -> server1:8001
// 请求 5 -> server2:8002
// 请求 6 -> server3:8003
```

### 优缺点

| 优点 | 缺点 |
|-----|-----|
| 实现简单 | 不考虑服务器负载差异 |
| 分配公平 | 不考虑服务器性能差异 |
| 无需额外配置 | 可能导致负载不均衡 |

---

## 2. 加权轮询算法（Weighted Round Robin）

### 原理

根据服务器的权重值分配请求，权重越高的服务器获得更多请求。

### 示例

```
服务器A (权重=5): 处理5个请求
服务器B (权重=3): 处理3个请求
服务器C (权重=2): 处理2个请求

请求分配序列: A A A A A B B B C C
```

### Go 实现（平滑加权轮询）

```go
package loadbalancer

import (
    "sync"
)

type Server struct {
    Addr            string
    Weight          int // 配置的权重
    CurrentWeight   int // 当前权重（动态变化）
    EffectiveWeight int // 有效权重（用于故障降权）
}

type WeightedRoundRobinBalancer struct {
    servers []*Server
    mu      sync.Mutex
}

func NewWeightedRoundRobinBalancer(servers []*Server) *WeightedRoundRobinBalancer {
    for _, s := range servers {
        s.CurrentWeight = 0
        s.EffectiveWeight = s.Weight
    }
    return &WeightedRoundRobinBalancer{
        servers: servers,
    }
}

// 平滑加权轮询算法（Nginx使用的算法）
func (wrb *WeightedRoundRobinBalancer) Next() string {
    wrb.mu.Lock()
    defer wrb.mu.Unlock()

    if len(wrb.servers) == 0 {
        return ""
    }

    var best *Server
    totalWeight := 0

    for _, s := range wrb.servers {
        // 累加当前权重
        s.CurrentWeight += s.EffectiveWeight
        totalWeight += s.EffectiveWeight

        // 选择当前权重最大的服务器
        if best == nil || s.CurrentWeight > best.CurrentWeight {
            best = s
        }
    }

    if best == nil {
        return ""
    }

    // 被选中的服务器减去总权重
    best.CurrentWeight -= totalWeight

    return best.Addr
}

// 使用示例
func main() {
    servers := []*Server{
        {Addr: "serverA:8001", Weight: 5},
        {Addr: "serverB:8002", Weight: 3},
        {Addr: "serverC:8003", Weight: 2},
    }

    lb := NewWeightedRoundRobinBalancer(servers)

    for i := 0; i < 10; i++ {
        server := lb.Next()
        fmt.Printf("请求 %d -> %s\n", i+1, server)
    }
}

// 输出（平滑分布）:
// 请求 1 -> serverA:8001
// 请求 2 -> serverA:8001
// 请求 3 -> serverB:8002
// 请求 4 -> serverA:8001
// 请求 5 -> serverB:8002
// 请求 6 -> serverA:8001
// 请求 7 -> serverC:8003
// 请求 8 -> serverA:8001
// 请求 9 -> serverB:8002
// 请求 10 -> serverC:8003
```

### 算法详解

**平滑加权轮询算法步骤**：

1. 每次选择前，所有服务器的 `CurrentWeight` 加上自己的 `EffectiveWeight`
2. 选择 `CurrentWeight` 最大的服务器
3. 被选中的服务器的 `CurrentWeight` 减去所有服务器的 `EffectiveWeight` 之和

**示例计算**（权重A=5, B=3, C=2）：

| 轮次 | A.Current | B.Current | C.Current | 选中 | 减去总权重后 |
|-----|-----------|-----------|-----------|------|------------|
| 初始 | 0 | 0 | 0 | - | - |
| 1 | 5 | 3 | 2 | A | 5-10=-5 |
| 2 | 0 | 6 | 4 | B | 6-10=-4 |
| 3 | 5 | -1 | 6 | C | 6-10=-4 |
| 4 | 10 | 2 | -2 | A | 10-10=0 |
| ... | ... | ... | ... | ... | ... |

---

## 3. 一致性哈希算法（Consistent Hashing）

### 原理

将服务器和请求键值都映射到一个哈希环上，请求顺时针找到第一个服务器节点。

### 哈希环示意图

```
        0°
         |
     C --|-- A
        \|/
 270° ---●--- 90° (哈希环)
        /|\
     B --|--
         |
        180°

请求hash(key) = 45° → 顺时针找到 A (90°)
请求hash(key) = 200° → 顺时针找到 B (270°)
请求hash(key) = 350° → 顺时针找到 C (10°)
```

### Go 实现（带虚拟节点）

```go
package loadbalancer

import (
    "hash/crc32"
    "sort"
    "strconv"
    "sync"
)

type ConsistentHash struct {
    circle       map[uint32]string // 哈希环：hash值 -> 服务器地址
    sortedHashes []uint32          // 排序的hash值列表
    replicas     int               // 虚拟节点数量
    mu           sync.RWMutex
}

func NewConsistentHash(replicas int) *ConsistentHash {
    return &ConsistentHash{
        circle:   make(map[uint32]string),
        replicas: replicas,
    }
}

// 添加服务器
func (ch *ConsistentHash) Add(server string) {
    ch.mu.Lock()
    defer ch.mu.Unlock()

    // 为每个真实服务器创建多个虚拟节点
    for i := 0; i < ch.replicas; i++ {
        // 虚拟节点名称：server-0, server-1, ...
        virtualNode := server + "-" + strconv.Itoa(i)
        hash := ch.hashKey(virtualNode)

        ch.circle[hash] = server
        ch.sortedHashes = append(ch.sortedHashes, hash)
    }

    // 对哈希值排序
    sort.Slice(ch.sortedHashes, func(i, j int) bool {
        return ch.sortedHashes[i] < ch.sortedHashes[j]
    })
}

// 删除服务器
func (ch *ConsistentHash) Remove(server string) {
    ch.mu.Lock()
    defer ch.mu.Unlock()

    for i := 0; i < ch.replicas; i++ {
        virtualNode := server + "-" + strconv.Itoa(i)
        hash := ch.hashKey(virtualNode)

        delete(ch.circle, hash)

        // 从排序列表中删除
        idx := ch.search(hash)
        ch.sortedHashes = append(ch.sortedHashes[:idx], ch.sortedHashes[idx+1:]...)
    }
}

// 获取请求对应的服务器
func (ch *ConsistentHash) Get(key string) string {
    ch.mu.RLock()
    defer ch.mu.RUnlock()

    if len(ch.circle) == 0 {
        return ""
    }

    hash := ch.hashKey(key)

    // 顺时针找到第一个节点
    idx := ch.search(hash)
    if idx >= len(ch.sortedHashes) {
        idx = 0 // 环形，回到起点
    }

    return ch.circle[ch.sortedHashes[idx]]
}

// 二分查找：找到第一个 >= hash 的位置
func (ch *ConsistentHash) search(hash uint32) int {
    return sort.Search(len(ch.sortedHashes), func(i int) bool {
        return ch.sortedHashes[i] >= hash
    })
}

// 计算哈希值
func (ch *ConsistentHash) hashKey(key string) uint32 {
    return crc32.ChecksumIEEE([]byte(key))
}

// 使用示例
func main() {
    ch := NewConsistentHash(150) // 每个服务器150个虚拟节点

    // 添加服务器
    ch.Add("server1:8001")
    ch.Add("server2:8002")
    ch.Add("server3:8003")

    // 测试请求分配
    keys := []string{"user:1001", "user:1002", "user:1003", "user:1004"}

    for _, key := range keys {
        server := ch.Get(key)
        fmt.Printf("%s -> %s\n", key, server)
    }

    // 输出:
    // user:1001 -> server2:8002
    // user:1002 -> server1:8001
    // user:1003 -> server3:8003
    // user:1004 -> server2:8002

    // 删除一个服务器
    fmt.Println("\n删除 server2 后:")
    ch.Remove("server2:8002")

    for _, key := range keys {
        server := ch.Get(key)
        fmt.Printf("%s -> %s\n", key, server)
    }

    // 输出:
    // user:1001 -> server3:8003  (从server2迁移)
    // user:1002 -> server1:8001  (不变)
    // user:1003 -> server3:8003  (不变)
    // user:1004 -> server1:8001  (从server2迁移)
}
```

### 虚拟节点的作用

**没有虚拟节点的问题**：
```
只有3个真实节点，分布可能不均匀：
A (10°), B (120°), C (300°)
→ A负责 300°-10°（70°范围）
→ B负责 10°-120°（110°范围）
→ C负责 120°-300°（180°范围）
负载不均衡！
```

**使用虚拟节点**：
```
每个真实节点创建150个虚拟节点：
A-0, A-1, ..., A-149
B-0, B-1, ..., B-149
C-0, C-1, ..., C-149
共450个节点均匀分布在环上
→ 负载更加均衡
```

### 优缺点

| 优点 | 缺点 |
|-----|-----|
| 增删节点时只影响部分数据 | 实现相对复杂 |
| 数据亲和性好（同一key总是分配到同一节点） | 可能存在数据倾斜 |
| 适合分布式缓存 | 需要虚拟节点保证负载均衡 |

---

## 其他常见负载均衡算法

### 4. 最少连接（Least Connections）

选择当前连接数最少的服务器。

```go
type LeastConnectionsBalancer struct {
    servers     []string
    connections map[string]int
    mu          sync.Mutex
}

func (lcb *LeastConnectionsBalancer) Next() string {
    lcb.mu.Lock()
    defer lcb.mu.Unlock()

    var best string
    minConn := int(^uint(0) >> 1) // 最大int值

    for _, server := range lcb.servers {
        if conn := lcb.connections[server]; conn < minConn {
            minConn = conn
            best = server
        }
    }

    lcb.connections[best]++
    return best
}

func (lcb *LeastConnectionsBalancer) Done(server string) {
    lcb.mu.Lock()
    defer lcb.mu.Unlock()
    lcb.connections[server]--
}
```

### 5. IP哈希（IP Hash）

根据客户端IP计算哈希值，相同IP总是分配到同一服务器。

```go
type IPHashBalancer struct {
    servers []string
}

func (ih *IPHashBalancer) Get(clientIP string) string {
    hash := crc32.ChecksumIEEE([]byte(clientIP))
    idx := int(hash % uint32(len(ih.servers)))
    return ih.servers[idx]
}

// 使用示例
func main() {
    lb := &IPHashBalancer{
        servers: []string{"server1", "server2", "server3"},
    }

    fmt.Println(lb.Get("192.168.1.100")) // 总是返回相同服务器
    fmt.Println(lb.Get("192.168.1.100")) // 总是返回相同服务器
}
```

### 6. 随机算法（Random）

随机选择一个服务器。

```go
type RandomBalancer struct {
    servers []string
    random  *rand.Rand
}

func NewRandomBalancer(servers []string) *RandomBalancer {
    return &RandomBalancer{
        servers: servers,
        random:  rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

func (rb *RandomBalancer) Next() string {
    idx := rb.random.Intn(len(rb.servers))
    return rb.servers[idx]
}
```

---

## 算法对比与选择

| 算法 | 适用场景 | 优点 | 缺点 |
|-----|---------|------|------|
| **轮询** | 服务器性能相同 | 简单、公平 | 不考虑负载和性能差异 |
| **加权轮询** | 服务器性能不同 | 可根据性能分配 | 需要配置权重 |
| **一致性哈希** | 分布式缓存、会话保持 | 增删节点影响小 | 实现复杂、可能数据倾斜 |
| **最少连接** | 长连接、处理时间不均 | 动态均衡负载 | 需要维护连接计数 |
| **IP哈希** | 会话保持 | 同一客户端固定服务器 | 可能负载不均 |
| **随机** | 无特殊要求 | 实现简单 | 可能不均衡 |

### 选择建议

```bash
# 1. 服务器性能相同 → 轮询
适用于：无状态应用、服务器配置一致

# 2. 服务器性能不同 → 加权轮询
适用于：新旧服务器混合部署、不同配置机器

# 3. 需要会话保持 → IP哈希 或 一致性哈希
适用于：需要用户会话粘性的应用

# 4. 分布式缓存 → 一致性哈希
适用于：Redis集群、Memcached集群

# 5. 动态负载变化大 → 最少连接
适用于：长连接、处理时间差异大的场景
```

---

## 实战：HTTP 反向代理负载均衡

### 完整示例

```go
package main

import (
    "fmt"
    "net/http"
    "net/http/httputil"
    "net/url"
    "sync"
)

// 负载均衡器接口
type LoadBalancer interface {
    Next() *url.URL
}

// 轮询负载均衡器
type RoundRobinLB struct {
    backends []*url.URL
    current  int
    mu       sync.Mutex
}

func NewRoundRobinLB(backends []string) *RoundRobinLB {
    urls := make([]*url.URL, len(backends))
    for i, backend := range backends {
        urls[i], _ = url.Parse(backend)
    }
    return &RoundRobinLB{backends: urls}
}

func (rb *RoundRobinLB) Next() *url.URL {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    backend := rb.backends[rb.current]
    rb.current = (rb.current + 1) % len(rb.backends)
    return backend
}

// 反向代理处理器
type ReverseProxyHandler struct {
    lb LoadBalancer
}

func (rph *ReverseProxyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    backend := rph.lb.Next()

    // 创建反向代理
    proxy := httputil.NewSingleHostReverseProxy(backend)

    // 修改请求头
    r.Host = backend.Host
    r.URL.Host = backend.Host
    r.URL.Scheme = backend.Scheme

    fmt.Printf("请求 %s 转发到 %s\n", r.URL.Path, backend)

    // 代理请求
    proxy.ServeHTTP(w, r)
}

func main() {
    // 后端服务器列表
    backends := []string{
        "http://localhost:8001",
        "http://localhost:8002",
        "http://localhost:8003",
    }

    lb := NewRoundRobinLB(backends)

    handler := &ReverseProxyHandler{lb: lb}

    fmt.Println("负载均衡器启动在 :8000")
    http.ListenAndServe(":8000", handler)
}
```

### Nginx 配置示例

```nginx
# 轮询
upstream backend {
    server backend1:8001;
    server backend2:8002;
    server backend3:8003;
}

# 加权轮询
upstream backend_weighted {
    server backend1:8001 weight=5;
    server backend2:8002 weight=3;
    server backend3:8003 weight=2;
}

# IP哈希
upstream backend_iphash {
    ip_hash;
    server backend1:8001;
    server backend2:8002;
    server backend3:8003;
}

# 最少连接
upstream backend_leastconn {
    least_conn;
    server backend1:8001;
    server backend2:8002;
    server backend3:8003;
}

server {
    listen 80;
    location / {
        proxy_pass http://backend;
    }
}
```

---

## 健康检查

负载均衡器应定期检查后端服务器健康状态，自动移除故障节点。

```go
type HealthChecker struct {
    backends []*Backend
    mu       sync.RWMutex
}

type Backend struct {
    URL     *url.URL
    Alive   bool
    mu      sync.RWMutex
}

func (b *Backend) SetAlive(alive bool) {
    b.mu.Lock()
    defer b.mu.Unlock()
    b.Alive = alive
}

func (b *Backend) IsAlive() bool {
    b.mu.RLock()
    defer b.mu.RUnlock()
    return b.Alive
}

func (hc *HealthChecker) HealthCheck() {
    for _, backend := range hc.backends {
        go func(b *Backend) {
            // 发送健康检查请求
            resp, err := http.Get(b.URL.String() + "/health")
            if err != nil || resp.StatusCode != 200 {
                b.SetAlive(false)
                fmt.Printf("后端 %s 不健康\n", b.URL)
            } else {
                b.SetAlive(true)
            }
        }(backend)
    }
}

// 定期健康检查
func (hc *HealthChecker) Start(interval time.Duration) {
    ticker := time.NewTicker(interval)
    go func() {
        for range ticker.C {
            hc.HealthCheck()
        }
    }()
}
```
