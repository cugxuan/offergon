---
title: WebSocket 的原理，与 HTTP 长轮询的区别
tags:
  - 计算机网络
  - 应用层协议
status: robot
class: 计算机网络
slug: websocket-vs-http-long-polling-difference
ref:
---

## 核心要点

**WebSocket**：基于TCP的全双工通信协议，通过HTTP握手升级建立持久连接，客户端和服务器可随时互相推送消息，适合实时通信场景。

**HTTP长轮询**：客户端发起HTTP请求后，服务器挂起请求直到有数据或超时才响应，客户端收到响应后立即发起新请求，模拟服务器推送。

**主要区别**：WebSocket是真正的双向通信，一次握手后持久连接；长轮询是单向请求-响应模式，需要频繁建立连接，开销大、延迟高。

---

## WebSocket 原理

### 什么是 WebSocket

WebSocket 是HTML5提供的一种在单个TCP连接上进行全双工通信的协议。它使客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。

### WebSocket 特点

- **全双工通信**：客户端和服务器可以同时发送和接收消息
- **持久连接**：一次握手建立连接后保持通信
- **低开销**：握手后每次传输只需2-10字节头部（HTTP每次至少几百字节）
- **实时性强**：消息即时推送，无需轮询
- **支持二进制**：可传输文本和二进制数据

---

## WebSocket 工作流程

### 1. 握手阶段（HTTP Upgrade）

WebSocket 通过 HTTP/1.1 的 Upgrade 机制从 HTTP 协议升级到 WebSocket 协议。

#### 客户端发起握手请求

```http
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: http://example.com
```

**关键字段**：
- `Upgrade: websocket`：请求升级协议
- `Connection: Upgrade`：表示要升级连接
- `Sec-WebSocket-Key`：客户端生成的随机字符串（Base64编码）
- `Sec-WebSocket-Version`：WebSocket 协议版本（通常是13）
- `Origin`：标识请求来源，用于跨域验证

#### 服务器响应握手

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**关键字段**：
- `101 Switching Protocols`：协议切换成功
- `Sec-WebSocket-Accept`：服务器根据客户端的 Key 计算的响应值

**计算 Sec-WebSocket-Accept**：
```go
// 服务器计算Accept值的算法
func calculateAccept(key string) string {
    const magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
    h := sha1.New()
    h.Write([]byte(key + magic))
    return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

// 示例
key := "dGhlIHNhbXBsZSBub25jZQ=="
accept := calculateAccept(key)
// 输出: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

### 2. 数据传输阶段

握手成功后，双方通过 WebSocket 帧格式传输数据。

#### WebSocket 帧结构

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |                               |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

**字段说明**：
- `FIN`：1位，是否为最后一帧
- `opcode`：4位，操作码（1=文本，2=二进制，8=关闭，9=Ping，10=Pong）
- `MASK`：1位，客户端发送必须为1（掩码），服务器发送为0
- `Payload len`：7位，数据长度

### 3. 关闭连接

任何一方都可以发送关闭帧（opcode=8）来关闭连接。

```
客户端发送关闭帧 → 服务器收到后回复关闭帧 → 双方关闭TCP连接
```

---

## Go 实现 WebSocket

### 使用 gorilla/websocket 库

#### 服务端实现

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    // 检查请求来源（跨域）
    CheckOrigin: func(r *http.Request) bool {
        // 生产环境应验证Origin
        return true
    },
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
    // 升级HTTP连接到WebSocket
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("升级失败: %v", err)
        return
    }
    defer conn.Close()

    log.Printf("客户端已连接: %s", conn.RemoteAddr())

    // 循环读取消息
    for {
        messageType, message, err := conn.ReadMessage()
        if err != nil {
            log.Printf("读取消息失败: %v", err)
            break
        }

        log.Printf("收到消息: %s", message)

        // 回显消息给客户端
        err = conn.WriteMessage(messageType, message)
        if err != nil {
            log.Printf("发送消息失败: %v", err)
            break
        }
    }
}

func main() {
    http.HandleFunc("/ws", wsHandler)
    log.Println("WebSocket服务器启动在 :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 客户端实现（Go）

```go
package main

import (
    "log"
    "time"
    "github.com/gorilla/websocket"
)

func main() {
    url := "ws://localhost:8080/ws"
    conn, _, err := websocket.DefaultDialer.Dial(url, nil)
    if err != nil {
        log.Fatal("连接失败:", err)
    }
    defer conn.Close()

    // 发送消息
    go func() {
        for i := 0; i < 5; i++ {
            msg := fmt.Sprintf("消息 #%d", i)
            err := conn.WriteMessage(websocket.TextMessage, []byte(msg))
            if err != nil {
                log.Printf("发送失败: %v", err)
                return
            }
            time.Sleep(1 * time.Second)
        }

        // 发送关闭帧
        conn.WriteMessage(websocket.CloseMessage,
            websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
    }()

    // 接收消息
    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            log.Printf("接收失败: %v", err)
            return
        }
        log.Printf("收到回复: %s", message)
    }
}
```

#### 客户端实现（JavaScript）

```javascript
// 浏览器端WebSocket
const ws = new WebSocket('ws://localhost:8080/ws');

// 连接建立
ws.onopen = () => {
    console.log('WebSocket连接已建立');
    ws.send('Hello Server!');
};

// 接收消息
ws.onmessage = (event) => {
    console.log('收到消息:', event.data);
};

// 连接关闭
ws.onclose = (event) => {
    console.log('连接已关闭', event.code, event.reason);
};

// 连接错误
ws.onerror = (error) => {
    console.error('WebSocket错误:', error);
};

// 发送消息
function sendMessage(msg) {
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(msg);
    }
}

// 关闭连接
function closeConnection() {
    ws.close(1000, 'Normal Closure');
}
```

### GoFrame 集成 WebSocket

```go
package main

import (
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/os/glog"
)

func main() {
    s := g.Server()

    s.BindHandler("/ws", func(r *ghttp.Request) {
        ws, err := r.WebSocket()
        if err != nil {
            glog.Error(r.Context(), "WebSocket升级失败:", err)
            r.Exit()
        }
        defer ws.Close()

        for {
            msgType, msg, err := ws.ReadMessage()
            if err != nil {
                glog.Error(r.Context(), "读取消息失败:", err)
                break
            }

            glog.Infof(r.Context(), "收到消息: %s", msg)

            // 广播消息给所有客户端（需要自己维护连接池）
            if err = ws.WriteMessage(msgType, msg); err != nil {
                glog.Error(r.Context(), "发送消息失败:", err)
                break
            }
        }
    })

    s.SetPort(8080)
    s.Run()
}
```

---

## HTTP 长轮询（Long Polling）

### 工作原理

客户端发起HTTP请求，服务器不立即响应，而是挂起请求，直到有新数据或超时才返回响应，客户端收到响应后立即发起新的请求。

### 长轮询流程

```
客户端发起请求 → 服务器挂起请求（等待数据）
                       ↓
                   有新数据或超时
                       ↓
                 服务器返回响应
                       ↓
              客户端立即发起新请求（重复循环）
```

### Go 实现长轮询

```go
package main

import (
    "encoding/json"
    "net/http"
    "sync"
    "time"
)

type Message struct {
    ID      int    `json:"id"`
    Content string `json:"content"`
}

var (
    messages     []Message
    messagesMu   sync.RWMutex
    messagesChan = make(chan Message, 100)
)

// 长轮询处理器
func longPollingHandler(w http.ResponseWriter, r *http.Request) {
    // 设置超时（30秒）
    timeout := time.After(30 * time.Second)

    select {
    case msg := <-messagesChan:
        // 有新消息，立即返回
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(msg)

    case <-timeout:
        // 超时，返回空结果
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "status": "timeout",
        })
    }
}

// 发送消息
func sendMessage(w http.ResponseWriter, r *http.Request) {
    var msg Message
    json.NewDecoder(r.Body).Decode(&msg)

    messagesMu.Lock()
    msg.ID = len(messages) + 1
    messages = append(messages, msg)
    messagesMu.Unlock()

    // 通知所有等待的长轮询请求
    select {
    case messagesChan <- msg:
    default:
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "status": "sent",
    })
}

func main() {
    http.HandleFunc("/poll", longPollingHandler)
    http.HandleFunc("/send", sendMessage)
    http.ListenAndServe(":8080", nil)
}
```

### 客户端实现（JavaScript）

```javascript
// 长轮询客户端
function longPoll() {
    fetch('/poll')
        .then(response => response.json())
        .then(data => {
            if (data.status !== 'timeout') {
                console.log('收到消息:', data);
                // 处理消息
            }
            // 立即发起下一次轮询
            longPoll();
        })
        .catch(error => {
            console.error('轮询失败:', error);
            // 延迟后重试
            setTimeout(longPoll, 5000);
        });
}

// 启动轮询
longPoll();

// 发送消息
function sendMessage(content) {
    fetch('/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
    });
}
```

---

## WebSocket vs HTTP 长轮询对比

| 对比项 | WebSocket | HTTP 长轮询 |
|-------|-----------|------------|
| **连接方式** | 持久连接（一次握手） | 频繁建立连接（每次轮询） |
| **通信方式** | 全双工（双向实时） | 半双工（单向请求-响应） |
| **消息延迟** | 极低（毫秒级） | 较高（受轮询间隔影响） |
| **服务器推送** | 原生支持 | 模拟实现（挂起请求） |
| **协议开销** | 低（2-10字节帧头） | 高（每次完整HTTP头部） |
| **网络开销** | 低 | 高（频繁TCP握手） |
| **浏览器支持** | 现代浏览器 | 所有浏览器 |
| **代理/防火墙** | 可能被阻断 | 兼容性好 |
| **实现复杂度** | 中等 | 简单 |
| **适用场景** | 实时聊天、游戏、协同编辑 | 通知推送、简单实时更新 |

### 详细对比

#### 1. 连接开销

```bash
# WebSocket（一次握手后持久连接）
客户端 → 服务器: HTTP Upgrade (一次)
客户端 ←→ 服务器: WebSocket数据帧（持续通信）

# HTTP长轮询（每次都建立新连接）
客户端 → 服务器: HTTP请求 (第1次)
客户端 ← 服务器: HTTP响应
客户端 → 服务器: HTTP请求 (第2次)
客户端 ← 服务器: HTTP响应
... (不断重复)
```

#### 2. 消息头开销

```bash
# WebSocket 数据帧（2-10字节）
FIN + opcode + MASK + payload length + masking key = 2-10字节
+ 实际数据

# HTTP 请求/响应（至少几百字节）
GET /poll HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0...
Cookie: session=...
... (其他头部)
+ 实际数据
```

#### 3. 实时性对比

```javascript
// WebSocket: 服务器可立即推送
ws.send(message); // 客户端收到延迟 < 10ms

// 长轮询: 需要等待客户端发起请求
// 如果消息在两次轮询之间到达，延迟 = 轮询间隔 (可能几秒)
```

---

## 其他实时通信方案

### 1. Server-Sent Events (SSE)

单向服务器推送，基于HTTP。

```javascript
// 客户端
const eventSource = new EventSource('/events');

eventSource.onmessage = (event) => {
    console.log('新消息:', event.data);
};

eventSource.addEventListener('custom-event', (event) => {
    console.log('自定义事件:', event.data);
});
```

```go
// 服务端（Go）
func sseHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    flusher, _ := w.(http.Flusher)

    for i := 0; i < 10; i++ {
        fmt.Fprintf(w, "data: 消息 #%d\n\n", i)
        flusher.Flush()
        time.Sleep(1 * time.Second)
    }
}
```

### 2. 短轮询（Short Polling）

客户端定时发送请求查询新数据。

```javascript
// 每3秒轮询一次
setInterval(() => {
    fetch('/api/messages')
        .then(res => res.json())
        .then(data => {
            if (data.length > 0) {
                console.log('新消息:', data);
            }
        });
}, 3000);
```

### 3. 各方案对比

| 方案 | 双向通信 | 实时性 | 开销 | 浏览器支持 | 适用场景 |
|-----|---------|-------|------|-----------|---------|
| **WebSocket** | ✅ | 极高 | 低 | 现代浏览器 | 聊天、游戏、协同编辑 |
| **SSE** | ❌(仅服务器→客户端) | 高 | 中 | 现代浏览器(IE不支持) | 实时通知、股票行情 |
| **长轮询** | ❌ | 中 | 高 | 所有浏览器 | 兼容性要求高的场景 |
| **短轮询** | ❌ | 低 | 很高 | 所有浏览器 | 数据更新不频繁 |

---

## WebSocket 最佳实践

### 1. 连接管理

```go
// 连接池管理
type Hub struct {
    clients    map[*websocket.Conn]bool
    broadcast  chan []byte
    register   chan *websocket.Conn
    unregister chan *websocket.Conn
    mu         sync.RWMutex
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*websocket.Conn]bool),
        broadcast:  make(chan []byte, 256),
        register:   make(chan *websocket.Conn),
        unregister: make(chan *websocket.Conn),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case conn := <-h.register:
            h.mu.Lock()
            h.clients[conn] = true
            h.mu.Unlock()

        case conn := <-h.unregister:
            h.mu.Lock()
            if _, ok := h.clients[conn]; ok {
                delete(h.clients, conn)
                conn.Close()
            }
            h.mu.Unlock()

        case message := <-h.broadcast:
            h.mu.RLock()
            for conn := range h.clients {
                if err := conn.WriteMessage(websocket.TextMessage, message); err != nil {
                    h.unregister <- conn
                }
            }
            h.mu.RUnlock()
        }
    }
}
```

### 2. 心跳检测

```go
// 服务端心跳
const (
    writeWait  = 10 * time.Second
    pongWait   = 60 * time.Second
    pingPeriod = (pongWait * 9) / 10
)

func writePump(conn *websocket.Conn, messages <-chan []byte) {
    ticker := time.NewTicker(pingPeriod)
    defer ticker.Stop()

    for {
        select {
        case message := <-messages:
            conn.SetWriteDeadline(time.Now().Add(writeWait))
            conn.WriteMessage(websocket.TextMessage, message)

        case <-ticker.C:
            conn.SetWriteDeadline(time.Now().Add(writeWait))
            if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}

func readPump(conn *websocket.Conn) {
    conn.SetReadDeadline(time.Now().Add(pongWait))
    conn.SetPongHandler(func(string) error {
        conn.SetReadDeadline(time.Now().Add(pongWait))
        return nil
    })

    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            break
        }
        // 处理消息
    }
}
```

### 3. 错误处理与重连

```javascript
// 客户端自动重连
class WebSocketClient {
    constructor(url) {
        this.url = url;
        this.reconnectDelay = 1000;
        this.maxReconnectDelay = 30000;
        this.connect();
    }

    connect() {
        this.ws = new WebSocket(this.url);

        this.ws.onopen = () => {
            console.log('连接成功');
            this.reconnectDelay = 1000; // 重置延迟
        };

        this.ws.onclose = () => {
            console.log('连接关闭，尝试重连...');
            setTimeout(() => {
                this.reconnectDelay = Math.min(
                    this.reconnectDelay * 2,
                    this.maxReconnectDelay
                );
                this.connect();
            }, this.reconnectDelay);
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket错误:', error);
        };

        this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
        };
    }

    send(data) {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
        }
    }

    handleMessage(data) {
        console.log('收到消息:', data);
    }
}

const wsClient = new WebSocketClient('ws://localhost:8080/ws');
```
