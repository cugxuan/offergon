---
title: DNS 解析的完整过程，递归查询和迭代查询的区别
tags:
  - 计算机网络
status: robot
class: 计算机网络
slug: dns-resolution-process-recursive-iterative-query-diff
ref:
---

## 核心要点

**DNS解析过程**：浏览器缓存 → 操作系统缓存 → 本地DNS服务器 → 根DNS服务器 → 顶级域DNS → 权威DNS，逐级查询直到获取IP地址。

**递归查询**：客户端向本地DNS发起，本地DNS负责完成所有查询并返回最终结果，客户端只发一次请求。

**迭代查询**：本地DNS向根、顶级域、权威DNS逐级查询，每次只返回下一步要查询的服务器地址，本地DNS需要多次查询。

---

## DNS 基础概念

### 什么是 DNS
DNS（Domain Name System）域名系统，是互联网的"电话簿"，将人类可读的域名（如 www.example.com）转换为机器可识别的IP地址（如 93.184.216.34）。

### DNS 服务器层级

```
根DNS服务器 (.)
    ├── 顶级域DNS服务器 (.com, .org, .cn 等)
    │   ├── 权威DNS服务器 (example.com)
    │   │   └── 具体记录 (www.example.com -> IP)
    │   └── 权威DNS服务器 (google.com)
    └── 顶级域DNS服务器 (.net, .edu 等)
```

---

## DNS 解析完整过程

### 解析流程图

```
用户输入 www.example.com
    ↓
1. 浏览器缓存（浏览器DNS缓存）
    ↓ 未命中
2. 操作系统缓存（OS hosts文件 + DNS缓存）
    ↓ 未命中
3. 本地DNS服务器（ISP提供，如 192.168.1.1）
    ↓ 未命中，开始迭代查询
4. 根DNS服务器（返回 .com 顶级域服务器地址）
    ↓
5. 顶级域DNS服务器（返回 example.com 权威服务器地址）
    ↓
6. 权威DNS服务器（返回 www.example.com 的IP地址）
    ↓
7. 本地DNS服务器缓存结果并返回给客户端
    ↓
8. 浏览器获得IP地址，发起HTTP请求
```

### 详细步骤说明

#### 1. 浏览器DNS缓存
浏览器首先检查自身缓存，是否最近访问过该域名。

```javascript
// Chrome 查看DNS缓存：chrome://net-internals/#dns
// 清除浏览器DNS缓存
chrome.dns.clearCache()
```

#### 2. 操作系统缓存
浏览器未命中后，查询操作系统DNS缓存和hosts文件。

```bash
# macOS/Linux 查看DNS缓存
sudo dscacheutil -cachedump -entries Host  # macOS
resolvectl statistics                      # Linux

# Windows 查看/清除DNS缓存
ipconfig /displaydns
ipconfig /flushdns

# hosts文件位置
# Windows: C:\Windows\System32\drivers\etc\hosts
# macOS/Linux: /etc/hosts
```

#### 3. 本地DNS服务器（递归解析器）
操作系统向配置的本地DNS服务器（通常是ISP提供）发起递归查询。

```bash
# 查看本地DNS服务器配置
# macOS/Linux
cat /etc/resolv.conf
# 输出：nameserver 192.168.1.1

# Windows
ipconfig /all
```

#### 4-6. 本地DNS的迭代查询过程

本地DNS服务器依次查询：

**第一步：查询根DNS服务器**
```
本地DNS -> 根DNS服务器 (.)
请求：www.example.com 的IP是多少？
响应：我不知道，但我知道 .com 顶级域服务器地址是 192.5.6.30
```

**第二步：查询顶级域DNS服务器**
```
本地DNS -> 顶级域DNS服务器 (.com)
请求：www.example.com 的IP是多少？
响应：我不知道，但我知道 example.com 权威服务器地址是 ns1.example.com (192.0.2.1)
```

**第三步：查询权威DNS服务器**
```
本地DNS -> 权威DNS服务器 (example.com)
请求：www.example.com 的IP是多少？
响应：www.example.com 的IP地址是 93.184.216.34
```

#### 7. 返回结果并缓存
本地DNS服务器将结果返回给客户端，并根据TTL（Time To Live）缓存记录。

```bash
# 使用 dig 查看DNS解析过程（显示TTL）
dig www.example.com

# 输出示例
;; ANSWER SECTION:
www.example.com.    3600    IN    A    93.184.216.34
#                   ↑TTL(秒)      ↑记录类型  ↑IP地址
```

---

## 递归查询 vs 迭代查询

### 递归查询（Recursive Query）

**定义**：客户端向DNS服务器发起查询，DNS服务器必须返回最终结果（IP地址或查询失败），客户端只需等待。

**特点**：
- 客户端只发一次请求
- DNS服务器负责完成所有查询工作
- 客户端与本地DNS之间通常使用递归查询

```
客户端 → 本地DNS：请给我 www.example.com 的IP
       ← 本地DNS：IP是 93.184.216.34（或查询失败）

# 本地DNS承担了所有查询工作
```

### 迭代查询（Iterative Query）

**定义**：DNS服务器不直接返回最终结果，而是返回下一步应该查询的服务器地址，查询方需要继续查询。

**特点**：
- 需要多次查询
- 每次查询只返回下一步的提示
- 本地DNS与其他DNS服务器之间通常使用迭代查询

```
本地DNS → 根DNS：请给我 www.example.com 的IP
        ← 根DNS：我不知道，去问 .com 服务器 (地址: 192.5.6.30)

本地DNS → .com DNS：请给我 www.example.com 的IP
        ← .com DNS：我不知道，去问 example.com 服务器 (地址: 192.0.2.1)

本地DNS → 权威DNS：请给我 www.example.com 的IP
        ← 权威DNS：IP是 93.184.216.34
```

### 对比表格

| 对比项 | 递归查询 | 迭代查询 |
|-------|---------|---------|
| **查询方** | 客户端 → 本地DNS | 本地DNS → 其他DNS服务器 |
| **查询次数** | 1次 | 多次（逐级查询） |
| **返回结果** | 最终IP地址或失败 | 下一步要查询的服务器地址 |
| **工作负担** | DNS服务器负担重 | 客户端负担重（多次查询） |
| **适用场景** | 用户设备查询本地DNS | DNS服务器之间的查询 |
| **缓存位置** | 本地DNS缓存结果 | 本地DNS缓存所有中间结果 |

---

## DNS 记录类型

### 常见记录类型

```bash
# A记录：域名 → IPv4地址
www.example.com.    3600    IN    A    93.184.216.34

# AAAA记录：域名 → IPv6地址
www.example.com.    3600    IN    AAAA    2606:2800:220:1:248:1893:25c8:1946

# CNAME记录：域名别名
blog.example.com.   3600    IN    CNAME    www.example.com.

# MX记录：邮件服务器
example.com.        3600    IN    MX    10 mail.example.com.

# NS记录：权威DNS服务器
example.com.        3600    IN    NS    ns1.example.com.

# TXT记录：文本信息（常用于验证、SPF等）
example.com.        3600    IN    TXT    "v=spf1 include:_spf.google.com ~all"
```

### Go 代码示例：查询不同类型的DNS记录

```go
package main

import (
    "context"
    "fmt"
    "net"
    "time"
)

func main() {
    domain := "www.example.com"

    // 1. 查询A记录（IPv4地址）
    ips, err := net.LookupIP(domain)
    if err != nil {
        fmt.Printf("A记录查询失败: %v\n", err)
    } else {
        fmt.Printf("A记录: %s -> %v\n", domain, ips)
    }

    // 2. 查询CNAME记录
    cname, err := net.LookupCNAME(domain)
    if err != nil {
        fmt.Printf("CNAME记录查询失败: %v\n", err)
    } else {
        fmt.Printf("CNAME记录: %s -> %s\n", domain, cname)
    }

    // 3. 查询MX记录（邮件服务器）
    mxRecords, err := net.LookupMX("example.com")
    if err != nil {
        fmt.Printf("MX记录查询失败: %v\n", err)
    } else {
        fmt.Println("MX记录:")
        for _, mx := range mxRecords {
            fmt.Printf("  优先级:%d 主机:%s\n", mx.Pref, mx.Host)
        }
    }

    // 4. 查询NS记录（权威DNS服务器）
    nsRecords, err := net.LookupNS("example.com")
    if err != nil {
        fmt.Printf("NS记录查询失败: %v\n", err)
    } else {
        fmt.Println("NS记录:")
        for _, ns := range nsRecords {
            fmt.Printf("  %s\n", ns.Host)
        }
    }

    // 5. 查询TXT记录
    txtRecords, err := net.LookupTXT("example.com")
    if err != nil {
        fmt.Printf("TXT记录查询失败: %v\n", err)
    } else {
        fmt.Printf("TXT记录: %v\n", txtRecords)
    }
}
```

### 使用自定义DNS解析器（带超时和缓存）

```go
package main

import (
    "context"
    "fmt"
    "net"
    "sync"
    "time"
)

// DNS缓存结构
type DNSCache struct {
    mu    sync.RWMutex
    cache map[string]cacheEntry
}

type cacheEntry struct {
    ips       []net.IP
    expiresAt time.Time
}

func NewDNSCache() *DNSCache {
    return &DNSCache{
        cache: make(map[string]cacheEntry),
    }
}

func (c *DNSCache) Get(domain string) ([]net.IP, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    entry, exists := c.cache[domain]
    if !exists || time.Now().After(entry.expiresAt) {
        return nil, false
    }
    return entry.ips, true
}

func (c *DNSCache) Set(domain string, ips []net.IP, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()

    c.cache[domain] = cacheEntry{
        ips:       ips,
        expiresAt: time.Now().Add(ttl),
    }
}

// 自定义DNS解析器
type CustomResolver struct {
    resolver *net.Resolver
    cache    *DNSCache
}

func NewCustomResolver(dnsServer string) *CustomResolver {
    return &CustomResolver{
        resolver: &net.Resolver{
            PreferGo: true,
            Dial: func(ctx context.Context, network, address string) (net.Conn, error) {
                dialer := net.Dialer{
                    Timeout: 5 * time.Second,
                }
                // 使用自定义DNS服务器
                return dialer.DialContext(ctx, network, dnsServer+":53")
            },
        },
        cache: NewDNSCache(),
    }
}

func (r *CustomResolver) LookupIP(domain string) ([]net.IP, error) {
    // 1. 检查缓存
    if ips, hit := r.cache.Get(domain); hit {
        fmt.Printf("缓存命中: %s\n", domain)
        return ips, nil
    }

    // 2. 执行DNS查询（带超时）
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    ips, err := r.resolver.LookupIP(ctx, "ip4", domain)
    if err != nil {
        return nil, err
    }

    // 3. 缓存结果（TTL 5分钟）
    r.cache.Set(domain, ips, 5*time.Minute)

    return ips, nil
}

func main() {
    // 使用Google公共DNS 8.8.8.8
    resolver := NewCustomResolver("8.8.8.8")

    domains := []string{
        "www.google.com",
        "www.github.com",
        "www.example.com",
    }

    for _, domain := range domains {
        ips, err := resolver.LookupIP(domain)
        if err != nil {
            fmt.Printf("解析失败 %s: %v\n", domain, err)
            continue
        }
        fmt.Printf("解析成功 %s: %v\n", domain, ips)
    }

    // 第二次查询，命中缓存
    fmt.Println("\n第二次查询（命中缓存）:")
    for _, domain := range domains {
        ips, _ := resolver.LookupIP(domain)
        fmt.Printf("%s: %v\n", domain, ips)
    }
}
```

---

## DNS 优化与性能

### 1. DNS 预解析

```html
<!-- HTML中预解析域名，减少DNS查询延迟 -->
<link rel="dns-prefetch" href="//api.example.com">
<link rel="dns-prefetch" href="//cdn.example.com">
<link rel="preconnect" href="//api.example.com">
```

### 2. 减少DNS查询

```javascript
// 使用相同域名的资源，避免多域名导致多次DNS查询
// ❌ 不好：多个域名
<img src="http://img1.example.com/photo.jpg">
<script src="http://js.example.com/app.js"></script>
<link href="http://css.example.com/style.css">

// ✅ 更好：使用CDN合并域名
<img src="http://cdn.example.com/photo.jpg">
<script src="http://cdn.example.com/app.js"></script>
<link href="http://cdn.example.com/style.css">
```

### 3. 合理设置TTL

```bash
# 短TTL（300秒=5分钟）：适用于频繁变更的服务
www.example.com.    300    IN    A    93.184.216.34

# 长TTL（86400秒=24小时）：适用于稳定的服务
cdn.example.com.    86400    IN    A    104.16.1.1
```

### 4. 使用公共DNS服务器

```bash
# Google Public DNS
8.8.8.8, 8.8.4.4

# Cloudflare DNS
1.1.1.1, 1.0.0.1

# 阿里DNS
223.5.5.5, 223.6.6.6
```

---

## DNS 常见问题与调试

### 使用 dig 调试 DNS

```bash
# 完整的DNS解析过程（显示递归查询）
dig +trace www.example.com

# 指定DNS服务器查询
dig @8.8.8.8 www.example.com

# 查询特定记录类型
dig www.example.com A      # IPv4地址
dig www.example.com AAAA   # IPv6地址
dig example.com MX         # 邮件服务器
dig example.com NS         # 权威DNS服务器

# 查看详细信息（包括查询时间）
dig www.example.com +stats
```

### 使用 nslookup 调试

```bash
# 基本查询
nslookup www.example.com

# 指定DNS服务器
nslookup www.example.com 8.8.8.8

# 查询特定记录类型
nslookup -type=MX example.com
nslookup -type=NS example.com
```

### Go 代码调试DNS

```go
// 查看DNS解析的详细信息
package main

import (
    "context"
    "fmt"
    "net"
    "time"
)

func debugDNS(domain string) {
    start := time.Now()

    // 解析IP地址
    ips, err := net.LookupIP(domain)
    elapsed := time.Since(start)

    if err != nil {
        fmt.Printf("DNS解析失败: %v (耗时: %v)\n", err, elapsed)
        return
    }

    fmt.Printf("域名: %s\n", domain)
    fmt.Printf("解析时间: %v\n", elapsed)
    fmt.Printf("IP地址:\n")
    for _, ip := range ips {
        if ip.To4() != nil {
            fmt.Printf("  IPv4: %s\n", ip)
        } else {
            fmt.Printf("  IPv6: %s\n", ip)
        }
    }
}

func main() {
    debugDNS("www.google.com")
}
```
