---
title: TCP 与 UDP 的区别，UDP 适用的场景
tags:
  - 网络协议
  - 计算机网络
status: robot
class: 计算机网络
slug: tcp-vs-udp-difference-udp-use-cases
ref:
---

## 核心要点

**TCP（传输控制协议）**：面向连接、可靠传输、有序到达、流量控制、拥塞控制，适合对数据准确性要求高的场景（HTTP、FTP、邮件）。

**UDP（用户数据报协议）**：无连接、不可靠传输、无序到达、无流量控制，但开销小、延迟低，适合实时性要求高的场景（视频直播、在线游戏、DNS查询）。

**主要区别**：TCP保证可靠性牺牲效率，UDP追求效率牺牲可靠性。TCP有三次握手建立连接，UDP直接发送数据。

---

## TCP 与 UDP 基础

### 传输层协议作用

传输层（Transport Layer）位于OSI七层模型的第4层，负责端到端的数据传输，为应用层提供通信服务。

### 端口号的作用

端口号用于标识主机上的不同应用程序，实现进程间通信。

```
IP地址: 标识网络中的主机（如 192.168.1.100）
端口号: 标识主机上的应用程序（如 80端口=HTTP, 443端口=HTTPS）

完整地址 = IP地址:端口号
例如: 192.168.1.100:8080
```

---

## TCP（Transmission Control Protocol）

### TCP 特点

1. **面向连接**：通信前需建立连接（三次握手）
2. **可靠传输**：保证数据无差错、不丢失、不重复、按序到达
3. **面向字节流**：数据以字节流形式传输
4. **全双工通信**：双方可同时收发数据
5. **流量控制**：通过滑动窗口控制发送速率
6. **拥塞控制**：避免网络拥塞（慢启动、拥塞避免、快速重传）

### TCP 报文格式

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**关键字段**：
- **序列号（Sequence Number）**：用于排序和去重
- **确认号（ACK Number）**：期望接收的下一个字节序号
- **窗口大小（Window）**：接收窗口大小，用于流量控制
- **标志位（Flags）**：SYN、ACK、FIN、RST等控制位
- **校验和（Checksum）**：检测数据是否损坏

---

## UDP（User Datagram Protocol）

### UDP 特点

1. **无连接**：无需建立连接，直接发送数据
2. **不可靠传输**：不保证数据到达，不保证顺序
3. **面向数据报**：每个数据报独立传输
4. **无流量控制**：不管接收方是否能处理
5. **无拥塞控制**：不管网络是否拥塞
6. **开销小**：报文头部仅8字节（TCP至少20字节）
7. **支持广播和多播**：可一对多通信

### UDP 报文格式

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |           Checksum            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**字段说明**：
- **源端口/目标端口**：标识发送和接收应用程序（各2字节）
- **长度**：UDP数据报总长度（2字节）
- **校验和**：检测数据是否损坏（2字节）

---

## TCP vs UDP 详细对比

| 对比项 | TCP | UDP |
|-------|-----|-----|
| **连接方式** | 面向连接（三次握手） | 无连接 |
| **可靠性** | 可靠（确认重传机制） | 不可靠（尽最大努力交付） |
| **数据顺序** | 保证顺序 | 不保证顺序 |
| **流量控制** | 有（滑动窗口） | 无 |
| **拥塞控制** | 有 | 无 |
| **传输方式** | 面向字节流 | 面向数据报 |
| **报文头部** | 20-60字节 | 8字节 |
| **传输速度** | 慢（需确认） | 快 |
| **资源消耗** | 高（需维护连接状态） | 低 |
| **通信方式** | 一对一 | 一对一、一对多、多对多 |
| **适用场景** | 可靠性要求高 | 实时性要求高 |

---

## Go 实现 TCP 和 UDP

### TCP 服务端和客户端

#### TCP 服务端

```go
package main

import (
    "bufio"
    "fmt"
    "net"
)

func main() {
    // 监听TCP端口
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        panic(err)
    }
    defer listener.Close()

    fmt.Println("TCP服务器启动在 :8080")

    for {
        // 接受客户端连接
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("接受连接失败:", err)
            continue
        }

        // 处理连接（并发处理多个客户端）
        go handleTCPConnection(conn)
    }
}

func handleTCPConnection(conn net.Conn) {
    defer conn.Close()

    fmt.Println("客户端已连接:", conn.RemoteAddr())

    reader := bufio.NewReader(conn)

    for {
        // 读取数据（以换行符分隔）
        message, err := reader.ReadString('\n')
        if err != nil {
            fmt.Println("读取失败:", err)
            return
        }

        fmt.Printf("收到消息: %s", message)

        // 回显消息
        conn.Write([]byte("Echo: " + message))
    }
}
```

#### TCP 客户端

```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
)

func main() {
    // 连接到TCP服务器
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        panic(err)
    }
    defer conn.Close()

    fmt.Println("已连接到服务器")

    // 从控制台读取输入并发送
    scanner := bufio.NewScanner(os.Stdin)
    reader := bufio.NewReader(conn)

    for {
        fmt.Print("输入消息: ")
        if !scanner.Scan() {
            break
        }

        message := scanner.Text() + "\n"

        // 发送数据
        _, err := conn.Write([]byte(message))
        if err != nil {
            fmt.Println("发送失败:", err)
            return
        }

        // 接收响应
        response, err := reader.ReadString('\n')
        if err != nil {
            fmt.Println("接收失败:", err)
            return
        }

        fmt.Printf("服务器响应: %s", response)
    }
}
```

### UDP 服务端和客户端

#### UDP 服务端

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    // 监听UDP端口
    addr, err := net.ResolveUDPAddr("udp", ":8080")
    if err != nil {
        panic(err)
    }

    conn, err := net.ListenUDP("udp", addr)
    if err != nil {
        panic(err)
    }
    defer conn.Close()

    fmt.Println("UDP服务器启动在 :8080")

    buffer := make([]byte, 1024)

    for {
        // 接收数据
        n, clientAddr, err := conn.ReadFromUDP(buffer)
        if err != nil {
            fmt.Println("接收失败:", err)
            continue
        }

        message := string(buffer[:n])
        fmt.Printf("收到来自 %s 的消息: %s\n", clientAddr, message)

        // 回复数据
        response := "Echo: " + message
        conn.WriteToUDP([]byte(response), clientAddr)
    }
}
```

#### UDP 客户端

```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
)

func main() {
    // 连接到UDP服务器
    addr, err := net.ResolveUDPAddr("udp", "localhost:8080")
    if err != nil {
        panic(err)
    }

    conn, err := net.DialUDP("udp", nil, addr)
    if err != nil {
        panic(err)
    }
    defer conn.Close()

    fmt.Println("已连接到UDP服务器")

    scanner := bufio.NewScanner(os.Stdin)
    buffer := make([]byte, 1024)

    for {
        fmt.Print("输入消息: ")
        if !scanner.Scan() {
            break
        }

        message := scanner.Text()

        // 发送数据
        _, err := conn.Write([]byte(message))
        if err != nil {
            fmt.Println("发送失败:", err)
            return
        }

        // 接收响应
        n, err := conn.Read(buffer)
        if err != nil {
            fmt.Println("接收失败:", err)
            return
        }

        fmt.Printf("服务器响应: %s\n", string(buffer[:n]))
    }
}
```

---

## UDP 适用场景

### 1. 实时视频/音频传输

**原因**：
- 丢失少量数据包可接受（人眼/耳无法察觉）
- 低延迟比完整性更重要
- 支持多播，可一对多传输

```go
// UDP视频流发送示例
func streamVideo(conn *net.UDPConn, clientAddr *net.UDPAddr) {
    videoData := readVideoFrame() // 读取视频帧

    // 直接发送，不等待确认
    conn.WriteToUDP(videoData, clientAddr)

    // 即使丢包，继续发送下一帧
    // 不会阻塞或重传
}
```

**应用场景**：
- 直播平台（抖音、快手）
- 视频会议（Zoom、腾讯会议）
- 语音通话（微信语音、VoIP）

### 2. 在线游戏

**原因**：
- 实时性至关重要
- 游戏状态频繁更新，旧数据无价值
- 丢失少量位置数据可由客户端插值

```go
// 游戏状态同步
type PlayerPosition struct {
    PlayerID int
    X, Y     float64
    Timestamp int64
}

func sendPlayerPosition(conn *net.UDPConn, pos PlayerPosition) {
    data, _ := json.Marshal(pos)
    conn.Write(data)

    // 不等待确认，立即发送下一帧位置
    // 如果丢包，下一帧会更新位置
}
```

**应用场景**：
- 第一人称射击游戏（CS:GO、PUBG）
- 多人在线战术竞技游戏（LOL、王者荣耀）
- 实时策略游戏

### 3. DNS 查询

**原因**：
- 查询数据量小（通常<512字节）
- 对速度要求高
- 查询失败可重试，无需TCP可靠性

```go
// DNS查询示例
func queryDNS(domain string) (string, error) {
    // DNS使用UDP端口53
    conn, _ := net.DialUDP("udp", nil, &net.UDPAddr{
        IP:   net.ParseIP("8.8.8.8"),
        Port: 53,
    })
    defer conn.Close()

    // 发送DNS查询
    query := buildDNSQuery(domain)
    conn.Write(query)

    // 接收响应（设置超时）
    conn.SetReadDeadline(time.Now().Add(3 * time.Second))
    buffer := make([]byte, 512)
    n, _ := conn.Read(buffer)

    return parseDNSResponse(buffer[:n])
}
```

### 4. IoT 设备通信

**原因**：
- 设备资源受限（内存、电量）
- UDP开销小，节省电量
- 传感器数据频繁更新，旧数据价值低

```go
// 温度传感器上报数据
type SensorData struct {
    DeviceID    string
    Temperature float64
    Timestamp   int64
}

func reportSensorData(conn *net.UDPConn, data SensorData) {
    payload, _ := json.Marshal(data)
    conn.Write(payload)

    // 不需要确认，节省电量
    // 每10秒上报一次，丢失一次无关紧要
}
```

### 5. 广播和多播

UDP支持一对多通信，TCP只能一对一。

```go
// UDP广播示例（局域网设备发现）
func broadcastDeviceInfo() {
    addr, _ := net.ResolveUDPAddr("udp", "255.255.255.255:9999")
    conn, _ := net.DialUDP("udp", nil, addr)
    defer conn.Close()

    message := "DEVICE_DISCOVERY:MyDevice"
    conn.Write([]byte(message))

    // 所有监听9999端口的设备都会收到
}

// UDP多播示例（视频会议）
func multicastVideo() {
    addr, _ := net.ResolveUDPAddr("udp", "224.0.0.1:5000")
    conn, _ := net.DialUDP("udp", nil, addr)
    defer conn.Close()

    videoFrame := readVideoFrame()
    conn.Write(videoFrame)

    // 所有订阅该多播组的客户端都会收到
}
```

---

## TCP 适用场景

### 1. 文件传输

**原因**：必须保证数据完整性

**应用场景**：
- FTP（文件传输协议）
- HTTP文件下载
- 文件同步（Dropbox、OneDrive）

### 2. 网页浏览

**原因**：网页内容必须完整、有序

**应用场景**：
- HTTP/HTTPS
- 图片、CSS、JS 资源加载

### 3. 邮件传输

**原因**：邮件内容不能丢失或乱序

**应用场景**：
- SMTP（发送邮件）
- POP3、IMAP（接收邮件）

### 4. 远程登录

**原因**：命令执行顺序必须正确

**应用场景**：
- SSH
- Telnet

---

## 性能对比实验

### Go 代码：测试 TCP vs UDP 性能

```go
package main

import (
    "fmt"
    "net"
    "time"
)

// 测试TCP性能
func benchmarkTCP(count int) time.Duration {
    // 启动TCP服务器
    listener, _ := net.Listen("tcp", ":8081")
    go func() {
        conn, _ := listener.Accept()
        buffer := make([]byte, 1024)
        for i := 0; i < count; i++ {
            n, _ := conn.Read(buffer)
            conn.Write(buffer[:n]) // 回显
        }
        conn.Close()
    }()

    time.Sleep(100 * time.Millisecond) // 等待服务器启动

    // 客户端发送数据
    conn, _ := net.Dial("tcp", "localhost:8081")
    defer conn.Close()

    message := []byte("Hello, TCP!")
    buffer := make([]byte, 1024)

    start := time.Now()

    for i := 0; i < count; i++ {
        conn.Write(message)
        conn.Read(buffer)
    }

    elapsed := time.Since(start)
    listener.Close()

    return elapsed
}

// 测试UDP性能
func benchmarkUDP(count int) time.Duration {
    // 启动UDP服务器
    serverAddr, _ := net.ResolveUDPAddr("udp", ":8082")
    serverConn, _ := net.ListenUDP("udp", serverAddr)

    go func() {
        buffer := make([]byte, 1024)
        for i := 0; i < count; i++ {
            n, addr, _ := serverConn.ReadFromUDP(buffer)
            serverConn.WriteToUDP(buffer[:n], addr) // 回显
        }
        serverConn.Close()
    }()

    time.Sleep(100 * time.Millisecond) // 等待服务器启动

    // 客户端发送数据
    clientAddr, _ := net.ResolveUDPAddr("udp", "localhost:8082")
    clientConn, _ := net.DialUDP("udp", nil, clientAddr)
    defer clientConn.Close()

    message := []byte("Hello, UDP!")
    buffer := make([]byte, 1024)

    start := time.Now()

    for i := 0; i < count; i++ {
        clientConn.Write(message)
        clientConn.Read(buffer)
    }

    elapsed := time.Since(start)

    return elapsed
}

func main() {
    count := 10000

    tcpTime := benchmarkTCP(count)
    udpTime := benchmarkUDP(count)

    fmt.Printf("发送 %d 次消息：\n", count)
    fmt.Printf("TCP 耗时: %v\n", tcpTime)
    fmt.Printf("UDP 耗时: %v\n", udpTime)
    fmt.Printf("UDP 比 TCP 快 %.2f%%\n", float64(tcpTime-udpTime)/float64(tcpTime)*100)
}

// 输出示例：
// 发送 10000 次消息：
// TCP 耗时: 256ms
// UDP 耗时: 89ms
// UDP 比 TCP 快 65.23%
```

---

## 如何选择 TCP 还是 UDP

### 决策流程图

```
开始
  ↓
是否需要保证数据完整性和顺序？
  ├── 是 → 使用 TCP
  │         (文件传输、网页浏览、邮件、数据库连接)
  │
  └── 否 → 是否对实时性要求极高？
            ├── 是 → 使用 UDP
            │         (视频直播、在线游戏、语音通话)
            │
            └── 否 → 是否需要广播/多播？
                      ├── 是 → 使用 UDP
                      │         (设备发现、视频会议)
                      │
                      └── 否 → 综合考虑，通常选择 TCP
```

### 选择建议

| 需求 | 推荐协议 | 原因 |
|-----|---------|------|
| 数据完整性重要 | TCP | 可靠传输保证 |
| 实时性重要 | UDP | 低延迟 |
| 需要顺序保证 | TCP | 有序到达 |
| 数据量大 | TCP | 流量控制避免丢包 |
| 数据量小、频繁发送 | UDP | 低开销 |
| 一对多通信 | UDP | 支持广播多播 |
| 资源受限（IoT） | UDP | 开销小 |

---

## 混合使用：可靠UDP（RUDP）

某些场景需要UDP的低延迟，但又需要一定可靠性，可在应用层实现可靠UDP。

### 简单的可靠UDP实现

```go
package main

import (
    "encoding/json"
    "net"
    "time"
)

type Packet struct {
    SeqNum  int
    Data    []byte
    Ack     bool
    AckNum  int
}

// 可靠UDP发送
func reliableUDPSend(conn *net.UDPConn, data []byte, addr *net.UDPAddr) error {
    packet := Packet{
        SeqNum: 1,
        Data:   data,
    }

    payload, _ := json.Marshal(packet)

    // 发送并等待ACK
    for retries := 0; retries < 3; retries++ {
        conn.WriteToUDP(payload, addr)

        // 设置超时等待ACK
        conn.SetReadDeadline(time.Now().Add(1 * time.Second))

        buffer := make([]byte, 1024)
        n, _, err := conn.ReadFromUDP(buffer)
        if err == nil {
            var ack Packet
            json.Unmarshal(buffer[:n], &ack)

            if ack.Ack && ack.AckNum == packet.SeqNum {
                return nil // ACK收到，发送成功
            }
        }

        // 超时或ACK错误，重传
    }

    return fmt.Errorf("发送失败，超过重传次数")
}
```

**应用场景**：
- QUIC协议（HTTP/3基础）
- 游戏中的关键事件（击杀、得分）
- 实时通信的重要消息
