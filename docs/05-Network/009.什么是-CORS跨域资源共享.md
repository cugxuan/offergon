---
title: 什么是 CORS（跨域资源共享）？如何解决跨域问题？
tags:
  - 计算机网络
status: robot
class: 计算机网络
slug: cors-cross-origin-resource-sharing-solution
ref:
---

## 核心要点

**CORS（Cross-Origin Resource Sharing）跨域资源共享**：浏览器安全机制，限制一个源的文档或脚本访问另一个源的资源。通过HTTP响应头（Access-Control-Allow-Origin等）实现跨域授权，分为简单请求和预检请求（OPTIONS）。

**解决方案**：服务端设置CORS响应头、JSONP（仅GET）、代理服务器、Nginx反向代理、WebSocket（不受同源策略限制）。

---

## 什么是跨域问题

### 同源策略（Same-Origin Policy）
浏览器的安全机制，限制一个源（origin）的文档或脚本如何与另一个源的资源进行交互。

**同源定义**：协议（protocol）、域名（domain）、端口（port）三者完全相同。

```
示例：http://example.com:80/path

同源：
✅ http://example.com:80/other
✅ http://example.com/path

非同源（跨域）：
❌ https://example.com/path        (协议不同)
❌ http://www.example.com/path     (域名不同)
❌ http://example.com:8080/path    (端口不同)
```

### 跨域限制的影响范围

```javascript
// 1. Ajax请求跨域被阻止
fetch('http://api.other-domain.com/data')
  .then(res => res.json())
  .catch(err => console.error('CORS error'));

// 2. DOM访问跨域iframe被阻止
const iframe = document.getElementById('cross-origin-iframe');
const iframeDoc = iframe.contentDocument; // 报错：Blocked by CORS

// 3. Cookie、LocalStorage、IndexedDB 无法跨域访问
```

**不受跨域限制的资源**：
- `<img>` 图片
- `<link>` CSS样式
- `<script>` JavaScript脚本
- `<video>` `<audio>` 媒体资源
- `<iframe>` 嵌入页面（但无法操作DOM）

---

## CORS 工作原理

CORS通过在HTTP响应头中添加特定字段，告诉浏览器允许跨域访问。

### 简单请求（Simple Request）

满足以下所有条件的为简单请求：
1. 请求方法：`GET`、`HEAD`、`POST` 之一
2. HTTP头仅包含安全字段：`Accept`、`Accept-Language`、`Content-Language`、`Content-Type`
3. `Content-Type` 仅限：`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`

**流程**：
```
客户端发送请求 → 服务器返回响应（带CORS头） → 浏览器检查头 → 允许/拒绝访问
```

```javascript
// 客户端请求
fetch('http://api.example.com/data', {
  method: 'GET'
})

// 服务器响应头
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://client.example.com
Access-Control-Allow-Credentials: true
Content-Type: application/json
```

### 预检请求（Preflight Request）

不满足简单请求条件时，浏览器先发送OPTIONS预检请求，询问服务器是否允许实际请求。

**触发条件**：
- 使用 `PUT`、`DELETE`、`PATCH` 等方法
- 设置自定义HTTP头（如 `Authorization`、`X-Custom-Header`）
- `Content-Type` 为 `application/json`

**流程**：
```
客户端发送OPTIONS预检 → 服务器返回允许的方法/头 → 浏览器发送实际请求 → 服务器响应
```

```javascript
// 客户端请求
fetch('http://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({name: 'test'})
})

// 1. 浏览器自动发送OPTIONS预检请求
OPTIONS /data HTTP/1.1
Origin: http://client.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, Authorization

// 2. 服务器响应预检
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: http://client.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400  // 预检结果缓存24小时

// 3. 浏览器发送实际POST请求
POST /data HTTP/1.1
Content-Type: application/json
Authorization: Bearer token123

// 4. 服务器响应实际请求
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://client.example.com
Access-Control-Allow-Credentials: true
```

---

## CORS 响应头详解

| 响应头 | 说明 | 示例 |
|-------|------|------|
| `Access-Control-Allow-Origin` | 允许的源（`*` 或具体域名） | `http://example.com` |
| `Access-Control-Allow-Methods` | 允许的HTTP方法 | `GET, POST, PUT, DELETE` |
| `Access-Control-Allow-Headers` | 允许的自定义请求头 | `Content-Type, Authorization` |
| `Access-Control-Allow-Credentials` | 是否允许发送Cookie | `true` |
| `Access-Control-Max-Age` | 预检请求结果缓存时间（秒） | `86400` |
| `Access-Control-Expose-Headers` | 允许客户端访问的响应头 | `X-Total-Count` |

---

## 服务端 CORS 配置

### Go 标准库实现

```go
func enableCORS(w http.ResponseWriter, r *http.Request) {
    // 允许的源（生产环境应设置具体域名）
    w.Header().Set("Access-Control-Allow-Origin", "http://localhost:3000")

    // 允许携带Cookie
    w.Header().Set("Access-Control-Allow-Credentials", "true")

    // 允许的HTTP方法
    w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")

    // 允许的自定义请求头
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")

    // 预检请求缓存时间
    w.Header().Set("Access-Control-Max-Age", "86400")

    // 处理OPTIONS预检请求
    if r.Method == "OPTIONS" {
        w.WriteHeader(http.StatusNoContent)
        return
    }
}

func handler(w http.ResponseWriter, r *http.Request) {
    enableCORS(w, r)

    // 实际业务逻辑
    w.Header().Set("Content-Type", "application/json")
    w.Write([]byte(`{"message": "success"}`))
}
```

### GoFrame 中间件实现

```go
// 在 internal/cmd/cmd.go 中注册CORS中间件
func middlewareCORS(r *ghttp.Request) {
    // 动态设置允许的源
    origin := r.Header.Get("Origin")
    allowedOrigins := []string{
        "http://localhost:3000",
        "https://example.com",
    }

    // 验证源是否在白名单中
    isAllowed := false
    for _, allowed := range allowedOrigins {
        if origin == allowed {
            isAllowed = true
            break
        }
    }

    if isAllowed {
        r.Response.Header().Set("Access-Control-Allow-Origin", origin)
        r.Response.Header().Set("Access-Control-Allow-Credentials", "true")
    } else {
        // 使用通配符（不能与Credentials同时使用）
        // r.Response.Header().Set("Access-Control-Allow-Origin", "*")
    }

    r.Response.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    r.Response.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
    r.Response.Header().Set("Access-Control-Max-Age", "86400")

    // OPTIONS请求直接返回
    if r.Method == "OPTIONS" {
        r.Response.WriteStatus(http.StatusNoContent)
        return
    }

    r.Middleware.Next()
}

// 在路由中应用
s := g.Server()
s.Use(middlewareCORS)
```

### Nginx 反向代理配置

```nginx
server {
    listen 80;
    server_name example.com;

    location /api/ {
        # 代理到后端服务
        proxy_pass http://localhost:8000/;

        # CORS配置
        add_header 'Access-Control-Allow-Origin' 'http://localhost:3000' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, X-Requested-With' always;

        # 处理OPTIONS预检请求
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Max-Age' 86400;
            add_header 'Content-Length' 0;
            add_header 'Content-Type' 'text/plain';
            return 204;
        }
    }
}
```

---

## 其他跨域解决方案

### 1. JSONP（仅支持GET）

利用 `<script>` 标签不受同源策略限制的特性。

```javascript
// 客户端
function handleResponse(data) {
    console.log(data);
}

const script = document.createElement('script');
script.src = 'http://api.example.com/data?callback=handleResponse';
document.body.appendChild(script);

// 服务端返回
handleResponse({"name": "test", "value": 123})
```

```go
// Go 服务端实现
func jsonpHandler(w http.ResponseWriter, r *http.Request) {
    callback := r.URL.Query().Get("callback")
    data := `{"name": "test", "value": 123}`

    w.Header().Set("Content-Type", "application/javascript")
    fmt.Fprintf(w, "%s(%s)", callback, data)
}
```

**局限性**：
- 仅支持GET请求
- 无法获取详细的错误信息
- 安全性较差，容易受到XSS攻击

### 2. 代理服务器

前端请求同源的代理服务器，代理服务器转发到目标API（服务器间通信不受同源策略限制）。

```javascript
// Webpack Dev Server 代理配置
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {'^/api': ''}
      }
    }
  }
}

// 前端请求
fetch('/api/data') // 实际请求 http://api.example.com/data
```

### 3. PostMessage（iframe 跨域通信）

```javascript
// 父页面 (http://parent.com)
const iframe = document.getElementById('child-iframe');
iframe.contentWindow.postMessage('Hello from parent', 'http://child.com');

window.addEventListener('message', (event) => {
    if (event.origin === 'http://child.com') {
        console.log('Received:', event.data);
    }
});

// 子页面 (http://child.com)
window.addEventListener('message', (event) => {
    if (event.origin === 'http://parent.com') {
        console.log('Received:', event.data);
        event.source.postMessage('Hello from child', event.origin);
    }
});
```

### 4. WebSocket

WebSocket 协议不受同源策略限制。

```javascript
// 客户端
const ws = new WebSocket('ws://api.example.com/socket');
ws.onmessage = (event) => {
    console.log(event.data);
};
```

---

## 常见问题与安全注意事项

### 1. 通配符 `*` 的限制

```go
// ❌ 错误：不能同时使用通配符和 Credentials
w.Header().Set("Access-Control-Allow-Origin", "*")
w.Header().Set("Access-Control-Allow-Credentials", "true")
// 浏览器会报错

// ✅ 正确：动态设置具体源
origin := r.Header.Get("Origin")
if isAllowedOrigin(origin) {
    w.Header().Set("Access-Control-Allow-Origin", origin)
    w.Header().Set("Access-Control-Allow-Credentials", "true")
}
```

### 2. 预检请求缓存优化

```go
// 设置较长的缓存时间，减少OPTIONS请求
w.Header().Set("Access-Control-Max-Age", "86400") // 24小时
```

### 3. 安全的源验证

```go
// 使用白名单验证源
func isAllowedOrigin(origin string) bool {
    allowedOrigins := map[string]bool{
        "http://localhost:3000":  true,
        "https://example.com":    true,
        "https://www.example.com": true,
    }
    return allowedOrigins[origin]
}

func corsMiddleware(w http.ResponseWriter, r *http.Request) {
    origin := r.Header.Get("Origin")

    if isAllowedOrigin(origin) {
        w.Header().Set("Access-Control-Allow-Origin", origin)
    } else {
        // 拒绝不在白名单中的源
        http.Error(w, "Origin not allowed", http.StatusForbidden)
        return
    }
}
```

### 4. 敏感操作的额外验证

```go
// 对于敏感操作，CORS之外还需要其他验证
func sensitiveOperation(w http.ResponseWriter, r *http.Request) {
    // 1. CORS验证（浏览器自动完成）
    // 2. CSRF Token验证
    if !validateCSRFToken(r) {
        http.Error(w, "Invalid CSRF token", 403)
        return
    }

    // 3. JWT身份验证
    token := r.Header.Get("Authorization")
    if !validateJWT(token) {
        http.Error(w, "Unauthorized", 401)
        return
    }

    // 执行敏感操作
}
```

---

## 完整的 CORS 最佳实践

```go
package middleware

import (
    "net/http"
    "strings"
)

type CORSConfig struct {
    AllowedOrigins   []string
    AllowedMethods   []string
    AllowedHeaders   []string
    ExposedHeaders   []string
    AllowCredentials bool
    MaxAge           int
}

func NewCORSMiddleware(config CORSConfig) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            origin := r.Header.Get("Origin")

            // 验证源
            if !isOriginAllowed(origin, config.AllowedOrigins) {
                http.Error(w, "Origin not allowed", http.StatusForbidden)
                return
            }

            // 设置CORS响应头
            w.Header().Set("Access-Control-Allow-Origin", origin)

            if config.AllowCredentials {
                w.Header().Set("Access-Control-Allow-Credentials", "true")
            }

            if len(config.AllowedMethods) > 0 {
                w.Header().Set("Access-Control-Allow-Methods",
                    strings.Join(config.AllowedMethods, ", "))
            }

            if len(config.AllowedHeaders) > 0 {
                w.Header().Set("Access-Control-Allow-Headers",
                    strings.Join(config.AllowedHeaders, ", "))
            }

            if len(config.ExposedHeaders) > 0 {
                w.Header().Set("Access-Control-Expose-Headers",
                    strings.Join(config.ExposedHeaders, ", "))
            }

            if config.MaxAge > 0 {
                w.Header().Set("Access-Control-Max-Age",
                    fmt.Sprintf("%d", config.MaxAge))
            }

            // 处理OPTIONS预检请求
            if r.Method == "OPTIONS" {
                w.WriteHeader(http.StatusNoContent)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}

func isOriginAllowed(origin string, allowedOrigins []string) bool {
    for _, allowed := range allowedOrigins {
        if allowed == "*" || allowed == origin {
            return true
        }
        // 支持通配符子域名，如 *.example.com
        if strings.HasPrefix(allowed, "*.") {
            suffix := allowed[1:] // .example.com
            if strings.HasSuffix(origin, suffix) {
                return true
            }
        }
    }
    return false
}

// 使用示例
func main() {
    corsConfig := CORSConfig{
        AllowedOrigins:   []string{"http://localhost:3000", "https://example.com"},
        AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowedHeaders:   []string{"Content-Type", "Authorization", "X-Requested-With"},
        ExposedHeaders:   []string{"X-Total-Count"},
        AllowCredentials: true,
        MaxAge:           86400,
    }

    handler := NewCORSMiddleware(corsConfig)(yourHandler)
    http.ListenAndServe(":8000", handler)
}
```
