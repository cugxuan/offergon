---
title: Python 的描述符（descriptor）协议
tags:
  - Python
status: robot
class: Python
slug: python-descriptor-protocol
ref:
---

## 核心要点

**描述符本质**：实现了 `__get__`、`__set__`、`__delete__` 中任意一个方法的对象,用于**控制属性访问**。是 Python 属性系统的底层机制,`property`、`classmethod`、`staticmethod` 都基于描述符实现。

**关键机制**：
- **数据描述符**：同时定义 `__get__` 和 `__set__`（优先级高于实例字典）
- **非数据描述符**：仅定义 `__get__`（优先级低于实例字典）
- 属性查找顺序：数据描述符 > 实例字典 > 非数据描述符 > 类字典 > `__getattr__`
- 典型应用：类型检查、延迟计算、ORM 字段、缓存、日志记录

---

## 详细回答

### 一、描述符协议

#### 1. 三个核心方法

描述符通过以下三个方法控制属性访问：

```python
class Descriptor:
    def __get__(self, instance, owner):
        """
        读取属性时调用
        instance: 访问属性的实例（类访问时为 None）
        owner: 实例所属的类
        """
        pass

    def __set__(self, instance, value):
        """
        设置属性时调用
        instance: 访问属性的实例
        value: 要设置的值
        """
        pass

    def __delete__(self, instance):
        """
        删除属性时调用
        instance: 访问属性的实例
        """
        pass
```

#### 2. 基础示例

```python
class LoggedAccess:
    def __init__(self, name):
        self.name = name
        self.storage_name = f'_{name}'

    def __get__(self, instance, owner):
        if instance is None:
            return self  # 类访问时返回描述符本身
        value = getattr(instance, self.storage_name, None)
        print(f"[GET] {self.name} = {value}")
        return value

    def __set__(self, instance, value):
        print(f"[SET] {self.name} = {value}")
        setattr(instance, self.storage_name, value)

class Person:
    name = LoggedAccess('name')  # 描述符必须是类属性

    def __init__(self, name):
        self.name = name  # 触发 __set__

p = Person("Alice")
# 输出: [SET] name = Alice

print(p.name)
# 输出: [GET] name = Alice
# 返回: Alice

p.name = "Bob"
# 输出: [SET] name = Bob
```

---

### 二、数据描述符 vs 非数据描述符

#### 1. 两种类型的区别

```python
# 数据描述符（同时定义 __get__ 和 __set__）
class DataDescriptor:
    def __get__(self, instance, owner):
        return "data descriptor"

    def __set__(self, instance, value):
        print(f"Setting: {value}")

# 非数据描述符（仅定义 __get__）
class NonDataDescriptor:
    def __get__(self, instance, owner):
        return "non-data descriptor"

class MyClass:
    data_attr = DataDescriptor()
    nondata_attr = NonDataDescriptor()

obj = MyClass()

# 测试数据描述符（优先级高于实例字典）
print(obj.data_attr)  # data descriptor
obj.__dict__['data_attr'] = "instance value"
print(obj.data_attr)  # 仍然是 data descriptor（描述符优先）

# 测试非数据描述符（优先级低于实例字典）
print(obj.nondata_attr)  # non-data descriptor
obj.__dict__['nondata_attr'] = "instance value"
print(obj.nondata_attr)  # instance value（实例字典优先）
```

#### 2. 属性查找顺序（MRO）

Python 属性访问的完整查找链：

```
obj.attr 查找顺序:
1. 调用 type(obj).__dict__['attr'].__get__(obj, type(obj))
   （如果 attr 是数据描述符）
2. 查找 obj.__dict__['attr']
   （实例字典）
3. 调用 type(obj).__dict__['attr'].__get__(obj, type(obj))
   （如果 attr 是非数据描述符）
4. 查找 type(obj).__dict__['attr']
   （类字典）
5. 查找父类链（MRO）
6. 调用 __getattr__（如果定义）
7. 抛出 AttributeError
```

**关键点**：
- **数据描述符**覆盖实例字典（用于强制验证场景）
- **非数据描述符**被实例字典覆盖（用于延迟计算、可缓存场景）

---

### 三、典型应用场景

#### 1. 类型验证

自动进行类型检查和数据验证：

```python
class TypedProperty:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
        self.storage_name = f'_{name}'

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return getattr(instance, self.storage_name, None)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(
                f"{self.name} 必须是 {self.expected_type.__name__}, "
                f"得到 {type(value).__name__}"
            )
        setattr(instance, self.storage_name, value)

class Person:
    name = TypedProperty('name', str)
    age = TypedProperty('age', int)

    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Alice", 25)
print(p.name, p.age)  # Alice 25

# p.age = "thirty"  # TypeError: age 必须是 int
```

#### 2. 延迟计算（Lazy Evaluation）

首次访问时计算,后续使用缓存值：

```python
class LazyProperty:
    def __init__(self, func):
        self.func = func
        self.name = func.__name__

    def __get__(self, instance, owner):
        if instance is None:
            return self

        # 首次计算后存入实例字典（利用非数据描述符特性）
        value = self.func(instance)
        setattr(instance, self.name, value)
        return value

class Circle:
    def __init__(self, radius):
        self.radius = radius

    @LazyProperty
    def area(self):
        print("计算面积...")
        return 3.14159 * self.radius ** 2

c = Circle(5)
print(c.area)  # 计算面积... 78.53975
print(c.area)  # 78.53975（直接从实例字典读取,不再计算）
```

#### 3. ORM 字段定义（Django 风格）

模拟 Django Model 字段：

```python
class Field:
    def __init__(self, field_type, default=None):
        self.field_type = field_type
        self.default = default
        self.name = None  # 由元类自动设置

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name, self.default)

    def __set__(self, instance, value):
        if value is not None and not isinstance(value, self.field_type):
            raise TypeError(f"期望 {self.field_type}, 得到 {type(value)}")
        instance.__dict__[self.name] = value

class ModelMeta(type):
    """配合描述符自动设置字段名"""
    def __new__(mcs, name, bases, attrs):
        for key, value in attrs.items():
            if isinstance(value, Field):
                value.name = key  # 设置描述符的 name 属性
        return super().__new__(mcs, name, bases, attrs)

class Model(metaclass=ModelMeta):
    pass

class User(Model):
    name = Field(str, default="匿名")
    age = Field(int, default=0)

    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)

user = User(name="Alice", age=25)
print(user.name, user.age)  # Alice 25

user2 = User()
print(user2.name, user2.age)  # 匿名 0
```

#### 4. 属性访问日志

记录属性访问历史：

```python
import time

class AuditedProperty:
    def __init__(self, name):
        self.name = name
        self.storage_name = f'_{name}'
        self.log = []

    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = getattr(instance, self.storage_name, None)
        self.log.append(('get', time.time(), value))
        return value

    def __set__(self, instance, value):
        old_value = getattr(instance, self.storage_name, None)
        setattr(instance, self.storage_name, value)
        self.log.append(('set', time.time(), old_value, value))

class BankAccount:
    balance = AuditedProperty('balance')

    def __init__(self, initial_balance):
        self.balance = initial_balance

account = BankAccount(1000)
account.balance = 1500
account.balance = 1200
_ = account.balance

# 查看审计日志
for entry in BankAccount.balance.log:
    print(entry)
# ('set', 1704825600.0, None, 1000)
# ('set', 1704825601.0, 1000, 1500)
# ('set', 1704825602.0, 1500, 1200)
# ('get', 1704825603.0, 1200)
```

#### 5. 只读属性

创建不可修改的属性：

```python
class ReadOnly:
    def __init__(self, value):
        self.value = value

    def __get__(self, instance, owner):
        return self.value

    def __set__(self, instance, value):
        raise AttributeError("该属性为只读")

class Config:
    API_KEY = ReadOnly("secret_key_12345")

config = Config()
print(config.API_KEY)  # secret_key_12345
# config.API_KEY = "new_key"  # AttributeError: 该属性为只读
```

#### 6. 自动类型转换

读取时自动转换数据类型：

```python
class String:
    def __init__(self, name):
        self.name = name
        self.storage_name = f'_{name}'

    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = getattr(instance, self.storage_name, None)
        return str(value) if value is not None else ""

    def __set__(self, instance, value):
        setattr(instance, self.storage_name, value)

class Product:
    price = String('price')

    def __init__(self, price):
        self.price = price

p = Product(99.99)
print(p.price)  # "99.99"（自动转为字符串）
print(type(p.price))  # <class 'str'>
```

---

### 四、内置描述符示例

Python 的许多内置功能都是基于描述符实现的：

#### 1. `@property` 的描述符实现

```python
class Property:
    """简化版 property 实现"""
    def __init__(self, fget=None, fset=None, fdel=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel

    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.fget is None:
            raise AttributeError("不可读属性")
        return self.fget(instance)

    def __set__(self, instance, value):
        if self.fset is None:
            raise AttributeError("不可写属性")
        self.fset(instance, value)

    def __delete__(self, instance):
        if self.fdel is None:
            raise AttributeError("不可删除属性")
        self.fdel(instance)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel)

class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @Property
    def fahrenheit(self):
        return self._celsius * 9/5 + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        self._celsius = (value - 32) * 5/9

t = Temperature(0)
print(t.fahrenheit)  # 32.0
t.fahrenheit = 212
print(t._celsius)    # 100.0
```

#### 2. `@classmethod` 和 `@staticmethod`

```python
class ClassMethod:
    """简化版 classmethod"""
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        # 绑定类而非实例
        def wrapper(*args, **kwargs):
            return self.func(owner, *args, **kwargs)
        return wrapper

class StaticMethod:
    """简化版 staticmethod"""
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        # 不绑定任何对象
        return self.func

class MyClass:
    @ClassMethod
    def class_method(cls):
        print(f"类方法: {cls.__name__}")

    @StaticMethod
    def static_method():
        print("静态方法")

MyClass.class_method()  # 类方法: MyClass
MyClass.static_method()  # 静态方法
```

#### 3. 实例方法的绑定

普通函数作为类属性时,会通过函数描述符自动绑定 `self`：

```python
class Function:
    """简化版函数描述符"""
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        if instance is None:
            return self.func  # 类访问返回原函数
        # 实例访问返回绑定方法
        def bound_method(*args, **kwargs):
            return self.func(instance, *args, **kwargs)
        return bound_method

class MyClass:
    @Function
    def method(self, x):
        return f"self={self}, x={x}"

obj = MyClass()
print(obj.method(10))  # 自动传入 self
```

---

### 五、描述符 vs 其他机制

| 特性 | 描述符 | `@property` | `__getattr__` | 元类 |
|------|--------|------------|---------------|------|
| **粒度** | 单个属性 | 单个属性 | 所有未找到的属性 | 整个类 |
| **复用性** | 高（可多次使用） | 低（每个属性需单独定义） | 低 | 中 |
| **优先级** | 高（数据描述符最高） | 高（基于描述符） | 最低 | 类创建时 |
| **适用场景** | 属性验证、ORM、延迟计算 | 计算属性、只读属性 | 动态属性、代理模式 | 类结构修改 |

**选择建议**：
- 需要**复用属性逻辑** → 描述符
- **单个计算属性** → `@property`
- **动态属性或属性代理** → `__getattr__`/`__getattribute__`
- **修改类创建行为** → 元类

---

### 六、高级技巧

#### 1. 描述符与 `__set_name__`（Python 3.6+）

自动获取属性名,无需手动传递：

```python
class TypedProperty:
    def __init__(self, expected_type):
        self.expected_type = expected_type

    def __set_name__(self, owner, name):
        """Python 3.6+ 自动调用,获取属性名"""
        self.name = name
        self.storage_name = f'_{name}'

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return getattr(instance, self.storage_name, None)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"{self.name} 需要 {self.expected_type}")
        setattr(instance, self.storage_name, value)

class Person:
    name = TypedProperty(str)  # 无需传递名称
    age = TypedProperty(int)

p = Person()
p.name = "Alice"
p.age = 25
```

#### 2. 描述符实现 Validator 链

组合多个验证器：

```python
class Validator:
    def __init__(self, *validators):
        self.validators = validators

    def __set_name__(self, owner, name):
        self.name = name
        self.storage_name = f'_{name}'

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return getattr(instance, self.storage_name, None)

    def __set__(self, instance, value):
        for validator in self.validators:
            validator(value)
        setattr(instance, self.storage_name, value)

# 验证函数
def not_empty(value):
    if not value:
        raise ValueError("不能为空")

def min_length(n):
    def validator(value):
        if len(value) < n:
            raise ValueError(f"长度至少为 {n}")
    return validator

def max_value(n):
    def validator(value):
        if value > n:
            raise ValueError(f"最大值为 {n}")
    return validator

class User:
    username = Validator(not_empty, min_length(3))
    age = Validator(max_value(150))

user = User()
user.username = "Alice"
user.age = 25
# user.username = "AB"  # ValueError: 长度至少为 3
# user.age = 200  # ValueError: 最大值为 150
```

---

### 七、注意事项

1. **描述符必须定义为类属性**（不是实例属性）
2. **数据存储位置**：通常存储在 `instance.__dict__` 中（避免无限递归）
3. **类访问时 instance 为 None**：需要处理这种情况
4. **避免命名冲突**：描述符属性名和存储名应不同（如 `name` vs `_name`）
5. **性能开销**：每次属性访问都会调用描述符方法,频繁访问时考虑缓存

---

### 八、总结

描述符是 Python 属性系统的基石,理解它有助于深入掌握：

**核心概念**：
- **描述符 = 控制属性访问的协议**（`__get__`/`__set__`/`__delete__`）
- **数据描述符优先于实例字典**,用于强制验证
- **非数据描述符可被实例字典覆盖**,用于延迟计算

**实际应用**：
- **框架开发**：ORM 字段、表单验证、配置管理
- **代码优化**：延迟加载、缓存计算结果
- **设计模式**：代理模式、观察者模式

**与其他机制的关系**：
```
装饰器（函数级） → 元类（类级） → 描述符（属性级） → property（单属性）
```

掌握描述符后,能更好地理解 `@property`、`@classmethod`、`@staticmethod` 等内置装饰器的工作原理,也能设计出更灵活、可复用的属性管理方案。
