---
title: Python 的装饰器实现原理和应用
tags:
  - Python
status: robot
class: Python
slug: python-decorator-implementation-and-application
ref:
---

## 核心要点

**装饰器本质**：利用闭包和高阶函数,在不修改原函数代码的前提下动态扩展功能。核心是**函数替换** —— `@decorator` 等价于 `func = decorator(func)`。

**关键机制**：
- 支持多层嵌套、带参数装饰器
- 类装饰器通过 `__call__` 方法实现
- `functools.wraps` 保留元信息
- 常见应用：日志记录、权限校验、性能监控、缓存、重试机制

---

## 详细回答

### 一、实现原理

#### 1. 基础装饰器（无参数）

装饰器是一个**接受函数作为参数并返回新函数**的高阶函数：

```python
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"[LOG] 调用函数: {func.__name__}")
        result = func(*args, **kwargs)
        print(f"[LOG] 返回结果: {result}")
        return result
    return wrapper

@log_decorator
def add(a, b):
    return a + b

# 等价于: add = log_decorator(add)
```

**执行流程**：
1. Python 解释器遇到 `@log_decorator` 时,将 `add` 函数作为参数传入 `log_decorator`
2. `log_decorator` 返回内部的 `wrapper` 函数
3. 原来的 `add` 名称被重新绑定到 `wrapper` 函数上
4. 调用 `add(1, 2)` 实际执行的是 `wrapper(1, 2)`

**核心概念**：
- **闭包**：`wrapper` 函数引用了外层作用域的 `func` 变量,形成闭包
- **函数替换**：装饰后的函数名指向新函数,但通过闭包保持对原函数的引用

#### 2. 带参数的装饰器

需要**三层嵌套函数**来接收装饰器参数：

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

# 等价于: greet = repeat(times=3)(greet)
```

**执行流程**：
1. `repeat(times=3)` 先执行,返回真正的装饰器函数 `decorator`
2. `decorator(greet)` 返回 `wrapper`
3. `greet` 被替换为 `wrapper`

#### 3. 类装饰器

利用类的 `__call__` 方法实现装饰器：

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"调用次数: {self.count}")
        return self.func(*args, **kwargs)

@CountCalls
def process():
    print("Processing...")

# 等价于: process = CountCalls(process)
```

**优势**：
- 可以维护状态（如 `self.count`）
- 结构更清晰,适合复杂逻辑

#### 4. 保留函数元信息

装饰后原函数的 `__name__`、`__doc__` 等会丢失,使用 `functools.wraps` 解决：

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # 复制 func 的元信息到 wrapper
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def add(a, b):
    """返回两数之和"""
    return a + b

print(add.__name__)  # 输出: add (而非 wrapper)
print(add.__doc__)   # 输出: 返回两数之和
```

---

### 二、典型应用场景

#### 1. 日志记录

```python
import logging
from functools import wraps

def log_execution(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        logging.info(f"执行 {func.__name__}, 参数: args={args}, kwargs={kwargs}")
        try:
            result = func(*args, **kwargs)
            logging.info(f"{func.__name__} 返回: {result}")
            return result
        except Exception as e:
            logging.error(f"{func.__name__} 异常: {e}")
            raise
    return wrapper

@log_execution
def divide(a, b):
    return a / b
```

#### 2. 权限校验

```python
def require_admin(func):
    @wraps(func)
    def wrapper(user, *args, **kwargs):
        if not user.is_admin:
            raise PermissionError("需要管理员权限")
        return func(user, *args, **kwargs)
    return wrapper

@require_admin
def delete_user(user, target_id):
    print(f"删除用户 {target_id}")
```

#### 3. 性能监控

```python
import time

def timing(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        duration = time.time() - start
        print(f"{func.__name__} 耗时: {duration:.4f}秒")
        return result
    return wrapper

@timing
def slow_operation():
    time.sleep(2)
```

#### 4. 缓存结果

```python
from functools import lru_cache

@lru_cache(maxsize=128)  # Python 标准库提供的缓存装饰器
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

#### 5. 重试机制

```python
import time

def retry(max_attempts=3, delay=1):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"尝试 {attempt+1} 失败: {e}, {delay}秒后重试...")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=3, delay=2)
def unstable_api_call():
    # 模拟不稳定的 API 调用
    import random
    if random.random() < 0.7:
        raise ConnectionError("网络错误")
    return "成功"
```

#### 6. 参数验证

```python
def validate_types(*arg_types, **kwarg_types):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 验证位置参数
            for arg, expected_type in zip(args, arg_types):
                if not isinstance(arg, expected_type):
                    raise TypeError(f"期望 {expected_type}, 得到 {type(arg)}")
            # 验证关键字参数
            for key, value in kwargs.items():
                if key in kwarg_types and not isinstance(value, kwarg_types[key]):
                    raise TypeError(f"参数 {key} 期望 {kwarg_types[key]}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(int, int)
def add(a, b):
    return a + b
```

---

### 三、高级技巧

#### 1. 装饰器链（多个装饰器叠加）

```python
@decorator1
@decorator2
@decorator3
def func():
    pass

# 等价于: func = decorator1(decorator2(decorator3(func)))
# 执行顺序: decorator3 -> decorator2 -> decorator1 (从下往上)
```

#### 2. 类方法装饰器

装饰类方法时需注意 `self` 参数：

```python
def method_decorator(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):  # 第一个参数是 self
        print(f"调用 {self.__class__.__name__}.{func.__name__}")
        return func(self, *args, **kwargs)
    return wrapper

class MyClass:
    @method_decorator
    def method(self):
        print("执行方法")
```

#### 3. 装饰器工厂模式

结合配置文件动态生成装饰器：

```python
def create_auth_decorator(required_role):
    def decorator(func):
        @wraps(func)
        def wrapper(user, *args, **kwargs):
            if user.role != required_role:
                raise PermissionError(f"需要角色: {required_role}")
            return func(user, *args, **kwargs)
        return wrapper
    return decorator

# 根据配置动态创建
admin_required = create_auth_decorator("admin")
user_required = create_auth_decorator("user")
```

---

### 四、注意事项

1. **装饰器会增加调用栈深度**,可能影响性能和调试（使用 `wraps` 改善）
2. **装饰器在模块导入时执行**,不是在函数调用时
3. **类装饰器无法直接用于实例方法**,因为 `self` 传递问题（可用 `descriptor` 协议解决）
4. **装饰带有默认参数的函数**时,`wrapper` 应使用 `*args, **kwargs` 保持灵活性

---

### 五、总结

装饰器是 Python 中优雅的元编程工具,核心思想是**函数即对象**和**闭包**。通过装饰器可以：
- 实现横切关注点（日志、监控、权限）的模块化
- 减少重复代码,符合 DRY 原则
- 保持代码清晰,业务逻辑与辅助功能分离

在实际项目中,装饰器广泛用于 Web 框架（如 Flask 的路由、Django 的权限装饰器）、异步编程（`asyncio`）、测试框架（`pytest` 的 fixture）等场景。
