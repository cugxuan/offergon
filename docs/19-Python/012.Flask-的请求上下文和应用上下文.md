---
title: Flask 的请求上下文和应用上下文
tags:
  - Python
status: robot
class: Python
slug: flask-request-context-vs-application-context
ref:
---

## 核心要点

**请求上下文**：每个 HTTP 请求独享，包含 `request` 和 `session`，在请求结束时销毁
**应用上下文**：应用级别共享，包含 `current_app` 和 `g`，生命周期与请求同步但可独立存在
**LocalStack + Local**：通过线程/协程隔离实现上下文管理，让全局对象在多线程环境中表现为请求独立
**应用场景**：请求上下文用于访问请求数据，应用上下文用于存储应用配置和临时变量（如数据库连接）

---

## 详细回答

### 一、为什么需要上下文？

#### 1. 问题背景
在 Web 应用中，通常需要在不同的函数之间共享请求信息（如 `request` 对象），传统方式有两种：

**方案 1：显式传参**（繁琐）
```python
def view_func(request):
    process_data(request)

def process_data(request):
    log_info(request)

def log_info(request):
    print(request.method, request.url)
```

**方案 2：全局变量**（不安全，多线程冲突）
```python
current_request = None  # 全局变量

def view_func(request):
    global current_request
    current_request = request  # 线程 A 可能被线程 B 覆盖！
    process_data()
```

**Flask 的解决方案：上下文 + 线程隔离**
```python
from flask import request

def view_func():
    # 无需传参，直接使用 request
    print(request.method, request.url)
    process_data()

def process_data():
    # 任意深度都能访问 request
    print(request.json)
```

---

### 二、Flask 的两种上下文

#### 1. 请求上下文（Request Context）

**包含对象**：
- `request`：当前 HTTP 请求对象（包含请求方法、URL、参数、表单数据等）
- `session`：当前用户的会话对象（基于 cookie 的加密会话）

**生命周期**：
- 开始：每个 HTTP 请求到达时创建
- 结束：响应返回后销毁

**典型使用**：
```python
from flask import Flask, request, session

app = Flask(__name__)
app.secret_key = 'your-secret-key'

@app.route('/login', methods=['POST'])
def login():
    # 访问请求数据
    username = request.form['username']
    password = request.form['password']

    # 存储会话信息
    session['user_id'] = 123
    session['username'] = username

    return 'Login successful'

@app.route('/profile')
def profile():
    # 读取会话信息
    if 'user_id' in session:
        return f"Welcome, {session['username']}"
    return 'Please login first'
```

#### 2. 应用上下文（Application Context）

**包含对象**：
- `current_app`：当前应用实例（用于访问配置、注册的扩展等）
- `g`：全局临时对象（用于在同一请求中共享数据，如数据库连接）

**生命周期**：
- 默认与请求上下文同步创建和销毁
- 可以在没有请求时手动创建（如后台任务、命令行脚本）

**典型使用**：
```python
from flask import Flask, g, current_app

app = Flask(__name__)
app.config['DATABASE_URI'] = 'mysql://localhost/mydb'

# 使用 g 存储数据库连接
def get_db():
    if 'db' not in g:
        g.db = connect_to_database(current_app.config['DATABASE_URI'])
    return g.db

@app.teardown_appcontext
def close_db(error):
    # 请求结束时关闭数据库连接
    db = g.pop('db', None)
    if db is not None:
        db.close()

@app.route('/users')
def users():
    db = get_db()
    users = db.execute('SELECT * FROM users').fetchall()
    return {'users': users}
```

---

### 三、上下文的工作原理

#### 1. 底层实现：LocalStack + Local

Flask 使用 Werkzeug 提供的 `LocalStack` 和 `Local` 实现线程/协程隔离：

```python
# Flask 内部的简化实现
from werkzeug.local import LocalStack, LocalProxy

# 请求上下文栈
_request_ctx_stack = LocalStack()

# 通过代理访问栈顶的 request 对象
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)

# 应用上下文栈
_app_ctx_stack = LocalStack()

current_app = LocalProxy(lambda: _app_ctx_stack.top.app)
g = LocalProxy(lambda: _app_ctx_stack.top.g)
```

**关键技术**：
- `Local`：类似 `threading.local`，但支持协程（greenlet）
- `LocalStack`：基于 Local 实现的栈结构
- `LocalProxy`：代理对象，访问时动态从栈中获取真实对象

#### 2. 请求处理流程

```python
# Flask 处理请求的伪代码
def handle_request(environ):
    # 1. 创建请求上下文
    request_context = RequestContext(app, environ)
    request_context.push()  # 压入栈

    # 2. 如果应用上下文不存在，自动创建
    if not has_app_context():
        app_context = AppContext(app)
        app_context.push()

    try:
        # 3. 调用视图函数
        response = app.dispatch_request()
        return response
    finally:
        # 4. 弹出上下文（触发 teardown 钩子）
        request_context.pop()
        app_context.pop()
```

**栈结构示意**：
```
请求 A（线程 1）          请求 B（线程 2）
┌────────────────┐      ┌────────────────┐
│ RequestContext │      │ RequestContext │
│  - request A   │      │  - request B   │
│  - session A   │      │  - session B   │
└────────────────┘      └────────────────┘
        ↓                       ↓
┌────────────────┐      ┌────────────────┐
│  AppContext    │      │  AppContext    │
│  - current_app │      │  - current_app │
│  - g (A)       │      │  - g (B)       │
└────────────────┘      └────────────────┘
```

---

### 四、上下文对比与使用场景

#### 1. 请求上下文 vs 应用上下文

| 特性 | 请求上下文 | 应用上下文 |
|------|-----------|-----------|
| 对象 | `request`, `session` | `current_app`, `g` |
| 创建时机 | 每个请求开始时 | 请求开始或手动创建 |
| 销毁时机 | 请求结束时 | 请求结束或手动销毁 |
| 是否可独立 | 必须依赖应用上下文 | 可以独立存在 |
| 典型用途 | 访问请求数据 | 访问应用配置、存储临时数据 |

#### 2. current_app vs app

```python
from flask import Flask, current_app

app = Flask(__name__)

# ❌ 错误：在工厂函数中引用 app 会导致循环导入
def create_app():
    app = Flask(__name__)

    @app.route('/')
    def index():
        # 如果直接引用 app，会引用错误的实例
        print(app.config)  # 可能是外层的 app！
        return 'Hello'

    return app

# ✅ 正确：使用 current_app 总是指向当前应用
def create_app():
    app = Flask(__name__)

    @app.route('/')
    def index():
        # current_app 总是指向正确的应用实例
        print(current_app.config)
        return 'Hello'

    return app
```

#### 3. g 对象的最佳实践

**用途 1：存储数据库连接**
```python
from flask import g
import sqlite3

def get_db():
    if 'db' not in g:
        g.db = sqlite3.connect('database.db')
        g.db.row_factory = sqlite3.Row
    return g.db

@app.teardown_appcontext
def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()
```

**用途 2：存储当前用户**
```python
from flask import g, request

@app.before_request
def load_user():
    user_id = session.get('user_id')
    if user_id:
        g.user = User.query.get(user_id)
    else:
        g.user = None

@app.route('/profile')
def profile():
    if g.user is None:
        return 'Please login'
    return f'Hello, {g.user.username}'
```

**注意**：`g` 在每个请求结束后会被清空，不能用于跨请求存储数据！

---

### 五、在不同场景下使用上下文

#### 1. 在视图函数中（自动激活）
```python
@app.route('/test')
def test():
    # 请求上下文和应用上下文都已激活
    print(request.method)        # 正常工作
    print(current_app.config)    # 正常工作
    return 'OK'
```

#### 2. 在后台任务中（需手动激活）
```python
from flask import current_app

def background_task():
    # ❌ 错误：没有上下文
    print(current_app.config)  # RuntimeError: Working outside of application context

# ✅ 方案 1：手动创建应用上下文
def background_task():
    with app.app_context():
        print(current_app.config)  # 正常工作

# ✅ 方案 2：使用 push/pop
def background_task():
    ctx = app.app_context()
    ctx.push()
    try:
        print(current_app.config)
    finally:
        ctx.pop()
```

#### 3. 在测试中（手动激活请求上下文）
```python
def test_view():
    with app.test_request_context('/test?name=Alice'):
        # 模拟请求上下文
        assert request.path == '/test'
        assert request.args['name'] == 'Alice'

        # 调用视图函数
        response = app.dispatch_request()
        assert response == 'Hello, Alice'
```

#### 4. 在 Flask Shell 中
```bash
$ flask shell
>>> from flask import current_app, g, request
>>> current_app.config['DEBUG']  # 应用上下文自动激活
True
>>> request.method  # ❌ 错误：没有请求上下文
RuntimeError: Working outside of request context

>>> with app.test_request_context():
...     print(request.method)  # ✅ 正确
GET
```

---

### 六、常见错误与解决方案

#### 错误 1：在应用启动时访问 request
```python
# ❌ 错误
app = Flask(__name__)
print(request.method)  # RuntimeError: Working outside of request context

# ✅ 正确：只在视图函数或钩子中访问
@app.route('/')
def index():
    print(request.method)
```

#### 错误 2：在多线程中共享 g 对象
```python
# ❌ 错误：g 在不同线程中是独立的
from threading import Thread

@app.route('/test')
def test():
    g.value = 42

    def worker():
        print(g.value)  # AttributeError: 'value' 不存在（不同上下文）

    Thread(target=worker).start()

# ✅ 正确：传递数据或使用外部存储
@app.route('/test')
def test():
    value = 42

    def worker(val):
        print(val)

    Thread(target=worker, args=(value,)).start()
```

#### 错误 3：在 Celery 任务中直接使用上下文
```python
# ❌ 错误
@celery.task
def send_email(user_id):
    user = User.query.get(user_id)  # 无数据库连接（无应用上下文）

# ✅ 正确
@celery.task
def send_email(user_id):
    with app.app_context():
        user = User.query.get(user_id)
        # 发送邮件
```

---

## 最佳实践总结

### ✅ 推荐做法
1. **视图函数中直接使用**：`request`、`session`、`current_app`、`g` 都可直接访问
2. **使用 g 存储请求级临时数据**：数据库连接、当前用户、请求开始时间等
3. **使用 current_app 而非 app**：特别是在蓝图和工厂函数中
4. **后台任务中手动激活上下文**：使用 `with app.app_context()`
5. **测试时使用 test_request_context**：模拟请求环境

### ❌ 避免的错误
- 在应用启动阶段访问 `request`（无上下文）
- 将 `g` 用于跨请求数据存储（每个请求都会清空）
- 在多线程中共享上下文对象（每个线程有独立上下文）
- 忘记在后台任务中激活应用上下文

### 记忆技巧
- **request/session**：请求相关 → 请求上下文
- **current_app/g**：应用相关 → 应用上下文
- **上下文隔离**：线程/协程独立，不会互相干扰
- **g 的生命周期**：仅限单个请求，类似局部变量

---

## 实战示例：完整的数据库连接管理

```python
from flask import Flask, g, current_app
import sqlite3

app = Flask(__name__)
app.config['DATABASE'] = 'app.db'

# 获取数据库连接（惰性初始化）
def get_db():
    if 'db' not in g:
        g.db = sqlite3.connect(
            current_app.config['DATABASE'],
            detect_types=sqlite3.PARSE_DECLTYPES
        )
        g.db.row_factory = sqlite3.Row
    return g.db

# 执行 SQL 查询
def query_db(query, args=(), one=False):
    cur = get_db().execute(query, args)
    rv = cur.fetchall()
    cur.close()
    return (rv[0] if rv else None) if one else rv

# 请求结束时关闭连接
@app.teardown_appcontext
def close_db(error):
    db = g.pop('db', None)
    if db is not None:
        db.close()

# 使用示例
@app.route('/users/<int:user_id>')
def user_profile(user_id):
    user = query_db('SELECT * FROM users WHERE id = ?', [user_id], one=True)
    if user is None:
        return 'User not found', 404
    return {'username': user['username'], 'email': user['email']}

# 后台任务中使用
def cleanup_task():
    with app.app_context():
        db = get_db()
        db.execute('DELETE FROM sessions WHERE expired < ?', [datetime.now()])
        db.commit()
```

这个示例完美展示了：
- `g` 用于存储请求级的数据库连接
- `current_app` 用于访问应用配置
- `teardown_appcontext` 钩子自动清理资源
- 后台任务中手动激活应用上下文
