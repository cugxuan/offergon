---
title: Python 的生成器（generator）和迭代器
tags:
  - Python
status: robot
class: Python
slug: generator-vs-iterator-python
ref:
---

## 核心要点

- **迭代器协议**：实现了 `__iter__()` 和 `__next__()` 方法的对象,可通过 for 循环遍历
- **生成器本质**：使用 yield 关键字的函数,返回的是一个生成器对象(特殊的迭代器)
- **核心区别**：生成器是迭代器的子集,所有生成器都是迭代器,但并非所有迭代器都是生成器
- **优势**：惰性求值(lazy evaluation)、节省内存、支持无限序列、代码简洁

---

## 详细回答

### 一、迭代器(Iterator)

#### 1.1 什么是迭代器

迭代器是实现了**迭代器协议**的对象,该协议包含两个方法:

```python
class MyIterator:
    def __iter__(self):
        """返回迭代器对象本身"""
        return self

    def __next__(self):
        """返回下一个元素,没有元素时抛出 StopIteration"""
        if self.has_next():
            return self.get_next()
        else:
            raise StopIteration
```

**核心概念**:
- **可迭代对象(Iterable)**: 实现了 `__iter__()` 方法的对象,如 list、tuple、dict、set、str
- **迭代器(Iterator)**: 实现了 `__iter__()` 和 `__next__()` 方法的对象
- 所有迭代器都是可迭代对象,但不是所有可迭代对象都是迭代器

#### 1.2 迭代器的完整示例

```python
class Countdown:
    """倒计时迭代器"""
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        self.current -= 1
        return self.current + 1

# 使用
counter = Countdown(5)
for num in counter:
    print(num)  # 输出: 5 4 3 2 1

# 手动迭代
counter2 = Countdown(3)
print(next(counter2))  # 3
print(next(counter2))  # 2
print(next(counter2))  # 1
# print(next(counter2))  # 抛出 StopIteration
```

#### 1.3 可迭代对象 vs 迭代器

```python
# list 是可迭代对象,但不是迭代器
my_list = [1, 2, 3]
print(hasattr(my_list, '__iter__'))  # True
print(hasattr(my_list, '__next__'))  # False

# 通过 iter() 获取迭代器
iterator = iter(my_list)
print(hasattr(iterator, '__iter__'))  # True
print(hasattr(iterator, '__next__'))  # True

print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
# print(next(iterator))  # StopIteration
```

**关键差异**:
- 可迭代对象可以多次迭代,每次都从头开始
- 迭代器只能迭代一次,遍历完后就耗尽了

```python
my_list = [1, 2, 3]

# 可以多次遍历
for x in my_list:
    print(x)  # 1, 2, 3

for x in my_list:
    print(x)  # 1, 2, 3 (再次从头开始)

# 迭代器只能遍历一次
iterator = iter(my_list)
for x in iterator:
    print(x)  # 1, 2, 3

for x in iterator:
    pass  # 什么也不输出,迭代器已耗尽
```

### 二、生成器(Generator)

#### 2.1 什么是生成器

生成器是一种特殊的迭代器,通过 `yield` 关键字定义,是 Python 实现惰性求值的核心机制。

**两种创建方式**:
1. 生成器函数(使用 yield)
2. 生成器表达式(类似列表推导式)

#### 2.2 生成器函数

```python
def countdown(start):
    """生成器版本的倒计时"""
    while start > 0:
        yield start
        start -= 1

# 使用
gen = countdown(5)
print(type(gen))  # <class 'generator'>

for num in gen:
    print(num)  # 5 4 3 2 1
```

**yield 的工作机制**:
1. 当函数执行到 `yield` 时,函数暂停并返回 yield 的值
2. 函数的状态被保存(局部变量、指令指针等)
3. 下次调用 `next()` 时,从上次暂停的地方继续执行
4. 函数结束或执行到 return 时,抛出 StopIteration

```python
def demo_generator():
    print("开始执行")
    yield 1
    print("第一次恢复")
    yield 2
    print("第二次恢复")
    yield 3
    print("执行结束")

gen = demo_generator()
print("创建生成器")
print(next(gen))  # 开始执行 -> 1
print(next(gen))  # 第一次恢复 -> 2
print(next(gen))  # 第二次恢复 -> 3
# next(gen)  # 执行结束 -> StopIteration
```

#### 2.3 生成器表达式

```python
# 列表推导式 - 立即计算所有元素
squares_list = [x**2 for x in range(10)]
print(type(squares_list))  # <class 'list'>

# 生成器表达式 - 惰性计算
squares_gen = (x**2 for x in range(10))
print(type(squares_gen))  # <class 'generator'>

# 内存对比
import sys
list_size = sys.getsizeof([x for x in range(10000)])
gen_size = sys.getsizeof((x for x in range(10000)))
print(f"列表: {list_size} 字节")  # ~90KB
print(f"生成器: {gen_size} 字节")  # ~200 字节
```

#### 2.4 生成器的高级特性

##### (1) send() 方法 - 向生成器发送值

```python
def echo():
    while True:
        value = yield  # 接收 send() 发送的值
        print(f"接收到: {value}")

gen = echo()
next(gen)  # 必须先启动生成器
gen.send("Hello")  # 接收到: Hello
gen.send("World")  # 接收到: World
```

##### (2) 双向通信示例

```python
def running_average():
    """计算运行平均值"""
    total = 0
    count = 0
    average = None
    while True:
        value = yield average
        total += value
        count += 1
        average = total / count

gen = running_average()
next(gen)  # 启动生成器
print(gen.send(10))  # 10.0
print(gen.send(20))  # 15.0
print(gen.send(30))  # 20.0
```

##### (3) yield from - 委托生成器

```python
def sub_generator():
    yield 1
    yield 2

def main_generator():
    yield "start"
    yield from sub_generator()  # 委托给子生成器
    yield "end"

for value in main_generator():
    print(value)
# 输出: start 1 2 end
```

**yield from 的作用**:
- 简化嵌套生成器的调用
- 自动处理子生成器的异常和返回值
- 建立调用者和子生成器之间的双向通道

```python
# 等价的手动实现
def main_generator_manual():
    yield "start"
    for value in sub_generator():
        yield value
    yield "end"
```

### 三、迭代器 vs 生成器对比

| 特性 | 迭代器 | 生成器 |
|------|--------|--------|
| **定义方式** | 实现 `__iter__` 和 `__next__` | 使用 yield 或生成器表达式 |
| **代码复杂度** | 需要手动管理状态 | 自动管理状态,代码简洁 |
| **是否是迭代器** | 是 | 是(特殊的迭代器) |
| **内存占用** | 取决于实现 | 惰性计算,占用小 |
| **典型用途** | 复杂迭代逻辑 | 序列生成、数据流处理 |

**代码对比**:

```python
# 迭代器实现 - 代码较长
class Fibonacci_Iterator:
    def __init__(self, n):
        self.n = n
        self.a, self.b = 0, 1
        self.count = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.count >= self.n:
            raise StopIteration
        self.count += 1
        result = self.a
        self.a, self.b = self.b, self.a + self.b
        return result

# 生成器实现 - 代码简洁
def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 使用效果相同
for num in Fibonacci_Iterator(10):
    print(num, end=' ')  # 0 1 1 2 3 5 8 13 21 34

print()

for num in fibonacci_generator(10):
    print(num, end=' ')  # 0 1 1 2 3 5 8 13 21 34
```

### 四、实际应用场景

#### 4.1 读取大文件

```python
def read_large_file(file_path):
    """逐行读取大文件,避免一次性加载到内存"""
    with open(file_path, 'r') as f:
        for line in f:  # 文件对象本身就是迭代器
            yield line.strip()

# 处理 GB 级文件也不会内存溢出
for line in read_large_file('huge_log.txt'):
    if 'ERROR' in line:
        print(line)
```

#### 4.2 无限序列

```python
def infinite_sequence():
    """生成无限自然数序列"""
    num = 0
    while True:
        yield num
        num += 1

# 结合 itertools 使用
import itertools
for num in itertools.islice(infinite_sequence(), 10):
    print(num, end=' ')  # 0 1 2 3 4 5 6 7 8 9
```

#### 4.3 数据管道(Pipeline)

```python
def read_data():
    """读取数据"""
    for i in range(100):
        yield i

def filter_even(numbers):
    """过滤偶数"""
    for num in numbers:
        if num % 2 == 0:
            yield num

def square(numbers):
    """平方"""
    for num in numbers:
        yield num ** 2

# 构建管道 - 惰性求值,内存高效
pipeline = square(filter_even(read_data()))
result = list(itertools.islice(pipeline, 5))
print(result)  # [0, 4, 16, 36, 64]
```

#### 4.4 数据库批量查询

```python
def batch_query(query, batch_size=1000):
    """分批查询数据库,避免一次性加载大量数据"""
    offset = 0
    while True:
        results = db.execute(
            f"{query} LIMIT {batch_size} OFFSET {offset}"
        )
        if not results:
            break
        for row in results:
            yield row
        offset += batch_size

# 使用
for user in batch_query("SELECT * FROM users"):
    process_user(user)
```

### 五、常见面试考点

#### Q1: 为什么生成器比列表更节省内存?

**答**: 生成器采用**惰性求值**,只在需要时才计算下一个值,不会一次性将所有元素存储在内存中。

```python
# 列表 - 一次性生成 1000 万个元素
import sys
big_list = [x for x in range(10_000_000)]
print(sys.getsizeof(big_list) / 1024 / 1024)  # ~85 MB

# 生成器 - 只存储生成逻辑
big_gen = (x for x in range(10_000_000))
print(sys.getsizeof(big_gen) / 1024)  # ~0.1 KB
```

#### Q2: 生成器的 send()、throw()、close() 方法有什么用?

**答**:
- `send(value)`: 向生成器发送值,恢复执行并将值传给 yield 表达式
- `throw(exception)`: 在生成器暂停处抛出异常
- `close()`: 关闭生成器,后续调用 next() 会抛出 StopIteration

```python
def gen_with_exception():
    try:
        while True:
            value = yield
            print(f"收到: {value}")
    except GeneratorExit:
        print("生成器被关闭")
    except ValueError:
        print("捕获到 ValueError")

g = gen_with_exception()
next(g)
g.send("hello")  # 收到: hello
g.throw(ValueError)  # 捕获到 ValueError
g.close()  # 生成器被关闭
```

#### Q3: yield 和 return 的区别?

**答**:
- `return` 终止函数并返回值,函数状态丢失
- `yield` 暂停函数并返回值,保存函数状态,可恢复执行
- 生成器函数可以有 return,但 return 会触发 StopIteration,返回值作为异常属性

```python
def gen_with_return():
    yield 1
    yield 2
    return "finished"  # 返回值存储在 StopIteration.value

g = gen_with_return()
print(next(g))  # 1
print(next(g))  # 2
try:
    next(g)
except StopIteration as e:
    print(e.value)  # finished
```

### 六、性能对比

```python
import time

# 列表推导式
start = time.time()
result = sum([x**2 for x in range(10_000_000)])
print(f"列表: {time.time() - start:.2f}s")  # ~1.5s

# 生成器表达式
start = time.time()
result = sum(x**2 for x in range(10_000_000))
print(f"生成器: {time.time() - start:.2f}s")  # ~1.2s (更快且省内存)
```

### 七、总结

**迭代器**是 Python 中实现遍历的基础协议,通过 `__iter__` 和 `__next__` 实现。**生成器**是迭代器的语法糖,通过 `yield` 关键字实现,极大简化了迭代器的编写。

**核心优势**:
1. **内存效率**: 惰性求值,只在需要时计算,适合处理大数据集
2. **代码简洁**: 无需手动管理状态,减少样板代码
3. **支持无限序列**: 可以表示无限数据流
4. **管道化处理**: 可以优雅地构建数据处理管道

在实际开发中,当需要遍历大量数据或实现延迟计算时,应优先考虑使用生成器,这不仅能提高性能,还能让代码更加 Pythonic
