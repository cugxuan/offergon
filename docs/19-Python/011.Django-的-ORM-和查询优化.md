---
title: Django 的 ORM 和查询优化
tags:
  - Python
status: robot
class: Python
slug: django-orm-query-optimization
ref:
---

## 核心要点

**ORM 核心**：将数据库操作抽象为 Python 对象操作，屏蔽底层 SQL
**N+1 问题**：最常见性能陷阱，使用 `select_related`（一对一/多对一）和 `prefetch_related`（多对多/反向外键）解决
**查询优化**：索引、only/defer、聚合查询、queryset 惰性求值、explain 分析

---

## 详细回答

### 一、Django ORM 基础

#### 1. 什么是 ORM？
ORM（Object-Relational Mapping，对象关系映射）是一种编程技术，用于在面向对象编程语言中实现数据库操作，无需编写原生 SQL。

**Django ORM 的核心组件**：
- **Model（模型）**：Python 类对应数据库表
- **QuerySet（查询集）**：表示数据库查询结果的集合
- **Manager（管理器）**：提供数据库查询接口（默认是 `objects`）

```python
# 模型定义
class Author(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    published_date = models.DateField()
    price = models.DecimalField(max_digits=10, decimal_places=2)

# ORM 查询示例
books = Book.objects.filter(price__lt=50).order_by('-published_date')
```

#### 2. QuerySet 的惰性求值
Django 的 QuerySet 是**惰性的**（lazy），只有在真正需要数据时才执行 SQL 查询：

```python
# 不会执行查询
books = Book.objects.filter(price__lt=50)
expensive_books = books.filter(price__gt=30)

# 这些操作会触发查询
list(expensive_books)  # 转为列表
len(expensive_books)   # 计算长度
for book in expensive_books: pass  # 迭代
if expensive_books.exists(): pass  # exists() 方法
```

**优势**：
- 可以链式调用多个过滤条件
- 延迟到最后时刻执行，减少不必要的查询
- 查询结果会被缓存（第一次迭代后）

---

### 二、常见的性能问题与解决方案

#### 1. N+1 查询问题（最严重！）

**问题描述**：
在访问关联对象时，每次都触发一次额外的数据库查询。

```python
# ❌ 错误示例：产生 N+1 查询
books = Book.objects.all()  # 1 次查询
for book in books:
    print(book.author.name)  # 每个 book 都触发 1 次查询获取 author
# 总查询次数：1 + N（N 为书籍数量）
```

**解决方案 1：`select_related()`**（用于一对一和多对一关系）

```python
# ✅ 正确示例：使用 JOIN 一次性获取数据
books = Book.objects.select_related('author').all()  # 1 次查询（带 JOIN）
for book in books:
    print(book.author.name)  # 不再触发额外查询
# 总查询次数：1
```

**底层 SQL**：
```sql
SELECT book.*, author.*
FROM book
INNER JOIN author ON book.author_id = author.id;
```

**解决方案 2：`prefetch_related()`**（用于多对多和反向外键）

```python
# 模型定义
class Book(models.Model):
    title = models.CharField(max_length=200)
    tags = models.ManyToManyField('Tag')

# ❌ 错误示例：N+1 问题
books = Book.objects.all()
for book in books:
    print(book.tags.all())  # 每本书触发 1 次查询

# ✅ 正确示例：使用 prefetch_related
books = Book.objects.prefetch_related('tags').all()
for book in books:
    print(book.tags.all())  # 不再触发额外查询
```

**底层执行逻辑**：
1. 先查询所有 Book
2. 提取所有 Book 的 ID
3. 一次性查询所有关联的 Tag（`WHERE book_id IN (1,2,3,...)`）
4. 在 Python 层面合并数据

**select_related vs prefetch_related**：

| 特性 | select_related | prefetch_related |
|------|----------------|------------------|
| 适用关系 | ForeignKey, OneToOne | ManyToMany, 反向 FK |
| SQL 策略 | JOIN（单次查询） | 多次查询 + Python 合并 |
| 返回数据 | 同一个 SQL 结果集 | 多个独立的查询 |
| 性能 | 适合小数据量 | 适合大数据量 |

#### 2. 查询字段过多

**问题**：默认 `select *` 会获取所有字段，浪费内存和传输时间。

```python
# ❌ 获取所有字段（包括大字段如 TextField）
books = Book.objects.all()

# ✅ 只获取需要的字段
books = Book.objects.only('id', 'title', 'price')
# SQL: SELECT id, title, price FROM book

# ✅ 排除某些大字段
books = Book.objects.defer('description', 'content')
# SQL: SELECT id, title, author_id, ... (除了 description 和 content)
```

**注意**：访问被 defer 的字段会触发额外查询！

#### 3. 重复查询相同数据

```python
# ❌ 错误示例：多次查询同一作者
author_id = 1
for i in range(10):
    author = Author.objects.get(id=author_id)  # 每次都查数据库

# ✅ 正确示例：查询一次，缓存结果
author = Author.objects.get(id=author_id)
for i in range(10):
    print(author.name)  # 使用已缓存的对象
```

#### 4. 使用 count() 和 exists() 优化

```python
# ❌ 低效：加载所有数据后统计
books = Book.objects.filter(price__lt=50)
if len(books) > 0:  # 触发完整查询
    pass

# ✅ 高效：只统计数量
if Book.objects.filter(price__lt=50).count() > 0:  # SELECT COUNT(*)
    pass

# ✅ 更高效：只检查是否存在
if Book.objects.filter(price__lt=50).exists():  # SELECT 1 FROM ... LIMIT 1
    pass
```

---

### 三、高级查询优化技巧

#### 1. 批量操作

```python
# ❌ 低效：循环插入（N 次 INSERT）
for i in range(1000):
    Book.objects.create(title=f"Book {i}", price=10)

# ✅ 高效：批量插入（1 次 INSERT 多行）
books = [Book(title=f"Book {i}", price=10) for i in range(1000)]
Book.objects.bulk_create(books, batch_size=100)

# ✅ 批量更新
Book.objects.filter(price__lt=20).update(price=25)

# ✅ 批量删除
Book.objects.filter(published_date__year=2020).delete()
```

#### 2. 聚合查询

```python
from django.db.models import Count, Avg, Max, Min, Sum

# 聚合查询
Book.objects.aggregate(
    total_books=Count('id'),
    avg_price=Avg('price'),
    max_price=Max('price')
)
# {'total_books': 150, 'avg_price': 35.5, 'max_price': 99.9}

# 分组聚合
Author.objects.annotate(
    book_count=Count('book')
).filter(book_count__gt=5)
# 查询出版超过 5 本书的作者
```

#### 3. 原生 SQL 和 explain()

**原生 SQL**（复杂查询时使用）：
```python
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("SELECT * FROM book WHERE price > %s", [50])
    rows = cursor.fetchall()

# 或使用 raw()
books = Book.objects.raw('SELECT * FROM book WHERE price > %s', [50])
```

**查询分析**（Django 2.1+）：
```python
# 查看查询执行计划
queryset = Book.objects.filter(price__lt=50).select_related('author')
print(queryset.explain())
# 输出 MySQL EXPLAIN 或 PostgreSQL EXPLAIN ANALYZE 结果
```

#### 4. 数据库索引

```python
class Book(models.Model):
    title = models.CharField(max_length=200, db_index=True)  # 单列索引
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    price = models.DecimalField(max_digits=10, decimal_places=2)

    class Meta:
        indexes = [
            models.Index(fields=['price', 'published_date']),  # 复合索引
            models.Index(fields=['-published_date']),  # 降序索引
        ]
```

**何时使用索引**：
- 频繁用于 WHERE、ORDER BY、JOIN 的字段
- 外键自动创建索引
- 不要过度索引（影响写入性能）

---

### 四、调试工具与最佳实践

#### 1. Django Debug Toolbar
安装后可以查看每个请求的 SQL 查询：

```python
# settings.py
INSTALLED_APPS += ['debug_toolbar']
MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']

# 查看 SQL 查询数量、执行时间、重复查询
```

#### 2. 日志 SQL 查询

```python
# settings.py
LOGGING = {
    'version': 1,
    'handlers': {
        'console': {'class': 'logging.StreamHandler'},
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',
        },
    },
}
```

#### 3. 使用 connection.queries 查看查询

```python
from django.db import connection
from django.test.utils import override_settings

@override_settings(DEBUG=True)
def test_query():
    Book.objects.select_related('author').all()
    print(len(connection.queries))  # 查询次数
    print(connection.queries)  # 查询详情
```

---

## 最佳实践总结

### ✅ 优化清单
1. **预加载关联对象**：始终使用 `select_related`/`prefetch_related`
2. **限制字段**：使用 `only()`/`defer()` 减少数据传输
3. **批量操作**：用 `bulk_create`/`update`/`delete` 替代循环
4. **正确计数**：用 `count()`/`exists()` 替代 `len()`
5. **添加索引**：为高频查询字段建立索引
6. **使用 explain()**：分析慢查询的执行计划
7. **缓存结果**：对不变数据使用缓存（如 Redis）
8. **分页大数据**：用 `Paginator` 避免一次性加载大量数据

### ❌ 常见错误
- 在循环中执行查询（导致 N+1）
- 不加索引就用 `ORDER BY` 或 `WHERE`
- 使用 `all()` 后再用 Python 过滤（应在数据库层过滤）
- 忘记使用 `iterator()` 处理超大数据集
- 过度依赖 ORM（复杂查询应使用原生 SQL）

### 性能对比示例

```python
# 场景：获取 1000 本书及其作者信息

# ❌ 最差实现：1001 次查询
books = Book.objects.all()
for book in books:
    print(book.author.name)

# ⚠️ 改进：2 次查询
books = Book.objects.prefetch_related('author').all()

# ✅ 最优实现：1 次查询
books = Book.objects.select_related('author').only('title', 'author__name')

# 查询时间对比（1000 条数据）
# 最差：~10 秒（网络延迟 + 1000 次查询）
# 改进：~50 毫秒
# 最优：~20 毫秒
```
