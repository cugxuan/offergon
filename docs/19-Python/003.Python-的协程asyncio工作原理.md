---
title: Python 的协程(asyncio)工作原理
tags:
  - Python
  - 同步原语
status: robot
class: Python
slug: asyncio-coroutine-workflow
ref:
---

## 核心要点

**本质**:单线程内通过事件循环(Event Loop)实现协作式多任务
**关键字**:`async/await`标记协程,`await`处主动让出控制权
**适用场景**:I/O密集型高并发(网络请求、数据库查询、文件读写)
**核心组件**:事件循环、协程对象、Future、Task

---

## 详细解答

### 一、什么是协程(Coroutine)?

**协程**是一种可以暂停和恢复执行的函数,相比线程:
- **协作式调度**:程序员通过`await`显式控制切换点,而非操作系统抢占
- **单线程运行**:所有协程在同一线程内交替执行,避免GIL和锁竞争
- **轻量级**:创建100万个协程只需几百MB内存,而线程需要数百GB

```python
import asyncio

# 普通函数
def sync_func():
    return "Hello"

# 协程函数(用async定义)
async def async_func():
    return "World"

# 调用方式不同
print(sync_func())  # 直接执行,返回结果

coro = async_func()  # 返回协程对象,不会执行
print(coro)  # <coroutine object async_func at 0x...>

# 需要通过事件循环执行
result = asyncio.run(async_func())
print(result)  # World
```

### 二、asyncio的工作原理

#### 核心架构图

```
┌─────────────────────────────────────────────┐
│         应用代码 (async/await)               │
│  async def fetch(): await http_request()    │
└──────────────────┬──────────────────────────┘
                   │
         ┌─────────▼──────────┐
         │  协程对象/Task      │
         │  (Coroutine/Task)  │
         └─────────┬──────────┘
                   │
         ┌─────────▼──────────────────┐
         │    事件循环 (Event Loop)    │
         │  - 调度协程                 │
         │  - 监听I/O事件              │
         │  - 管理回调                 │
         └─────────┬──────────────────┘
                   │
    ┌──────────────┼──────────────┐
    │              │              │
┌───▼───┐    ┌────▼────┐    ┌───▼────┐
│ 网络  │    │  定时器  │    │  信号  │
│ I/O   │    │ Timers   │    │Signals │
└───────┘    └─────────┘    └────────┘
```

#### 事件循环的执行流程

```python
# 简化版事件循环伪代码
class EventLoop:
    def __init__(self):
        self.ready_queue = []   # 就绪的协程队列
        self.io_waiting = {}     # 等待I/O的协程字典

    def run_until_complete(self, coro):
        task = Task(coro)
        self.ready_queue.append(task)

        while self.ready_queue or self.io_waiting:
            # 1. 执行所有就绪的协程
            while self.ready_queue:
                task = self.ready_queue.pop(0)
                try:
                    # 执行协程直到遇到await
                    task.step()
                except StopIteration:
                    # 协程执行完毕
                    task.set_result()

            # 2. 检查I/O事件(使用select/epoll)
            ready_ios = select(self.io_waiting.keys(), timeout=0.1)
            for io_obj in ready_ios:
                task = self.io_waiting.pop(io_obj)
                self.ready_queue.append(task)
```

### 三、async/await的底层机制

#### 1. 协程的生命周期

```python
import asyncio

async def fetch_data():
    print("开始请求")
    await asyncio.sleep(1)  # 模拟网络请求
    print("请求完成")
    return "data"

# 创建协程对象(此时不执行)
coro = fetch_data()

# 通过事件循环运行
asyncio.run(coro)
```

**执行过程**:
1. `fetch_data()`返回协程对象,不执行函数体
2. `asyncio.run()`创建事件循环并运行协程
3. 执行到`await asyncio.sleep(1)`时暂停,控制权返回事件循环
4. 事件循环等待1秒后唤醒协程
5. 协程继续执行直到结束

#### 2. await的本质:yield from

```python
# async/await 是生成器的语法糖
# 以下代码等价(Python 3.4风格)

# 现代语法
async def modern_coro():
    result = await some_async_func()
    return result

# 等价的生成器版本
@asyncio.coroutine
def generator_coro():
    result = yield from some_async_func()
    return result
```

**await做了什么?**
1. 暂停当前协程的执行
2. 将控制权交还给事件循环
3. 等待被`await`的对象(Future/Task)完成
4. 完成后恢复协程执行并返回结果

#### 3. 协程的内部状态机

```python
import inspect

async def example():
    print("步骤1")
    await asyncio.sleep(0)
    print("步骤2")
    await asyncio.sleep(0)
    print("步骤3")

coro = example()
print(inspect.getcoroutinestate(coro))  # CORO_CREATED

# 手动推进协程(内部机制演示)
coro.send(None)  # 执行到第一个await
print(inspect.getcoroutinestate(coro))  # CORO_SUSPENDED

coro.send(None)  # 恢复执行到第二个await
coro.send(None)  # 执行到结束
```

### 四、Task和Future的区别

#### Future:占位符对象

```python
import asyncio

async def demo():
    # 创建一个Future对象
    future = asyncio.Future()

    # 在另一个协程中设置结果
    async def set_result():
        await asyncio.sleep(1)
        future.set_result("完成!")

    asyncio.create_task(set_result())

    # 等待Future完成
    result = await future
    print(result)  # 输出:完成!

asyncio.run(demo())
```

#### Task:包装协程的可调度对象

```python
import asyncio

async def worker(name, delay):
    print(f"{name} 开始")
    await asyncio.sleep(delay)
    print(f"{name} 完成")
    return f"{name}的结果"

async def main():
    # 创建Task对象(自动调度)
    task1 = asyncio.create_task(worker("任务1", 2))
    task2 = asyncio.create_task(worker("任务2", 1))

    # 等待所有任务完成
    results = await asyncio.gather(task1, task2)
    print(results)

asyncio.run(main())
```

**输出**:
```
任务1 开始
任务2 开始
任务2 完成  (1秒后)
任务1 完成  (2秒后)
['任务1的结果', '任务2的结果']
```

**关键区别**:
- **Future**:低级抽象,需要手动设置结果
- **Task**:高级抽象,自动包装协程并调度执行

### 五、并发模式实战

#### 模式1:并发执行多个任务

```python
import asyncio
import aiohttp
import time

async def fetch_url(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [
        'http://httpbin.org/delay/1',
        'http://httpbin.org/delay/2',
        'http://httpbin.org/delay/3'
    ]

    start = time.time()
    async with aiohttp.ClientSession() as session:
        # 并发执行所有请求
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)

    print(f"总耗时: {time.time() - start:.2f}秒")  # 约3秒(最长任务的时间)

asyncio.run(main())
```

#### 模式2:限流并发(信号量)

```python
import asyncio

async def limited_worker(sem, task_id):
    async with sem:  # 获取信号量
        print(f"任务{task_id}开始")
        await asyncio.sleep(1)
        print(f"任务{task_id}完成")

async def main():
    # 限制同时运行的任务数为3
    sem = asyncio.Semaphore(3)

    tasks = [limited_worker(sem, i) for i in range(10)]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

**输出**:每次只有3个任务并发执行

#### 模式3:超时控制

```python
import asyncio

async def slow_operation():
    await asyncio.sleep(5)
    return "完成"

async def main():
    try:
        result = await asyncio.wait_for(slow_operation(), timeout=2.0)
    except asyncio.TimeoutError:
        print("操作超时!")

asyncio.run(main())
```

#### 模式4:生产者-消费者

```python
import asyncio
import random

async def producer(queue, producer_id):
    for i in range(5):
        item = f"P{producer_id}-Item{i}"
        await queue.put(item)
        print(f"生产: {item}")
        await asyncio.sleep(random.uniform(0.1, 0.5))

async def consumer(queue, consumer_id):
    while True:
        item = await queue.get()
        if item is None:  # 结束信号
            break
        print(f"消费者{consumer_id}处理: {item}")
        await asyncio.sleep(random.uniform(0.2, 0.8))
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=10)

    # 启动2个生产者和3个消费者
    producers = [asyncio.create_task(producer(queue, i)) for i in range(2)]
    consumers = [asyncio.create_task(consumer(queue, i)) for i in range(3)]

    await asyncio.gather(*producers)
    await queue.join()  # 等待所有任务处理完毕

    # 发送结束信号
    for _ in consumers:
        await queue.put(None)
    await asyncio.gather(*consumers)

asyncio.run(main())
```

### 六、asyncio的底层实现:事件循环选择器

asyncio根据操作系统选择高效的I/O多路复用机制:

| 操作系统 | 默认选择器 | 最大连接数 |
|---------|-----------|----------|
| Linux   | epoll     | 无限制    |
| macOS   | kqueue    | 无限制    |
| Windows | IOCP(ProactorEventLoop) | 无限制 |

```python
import asyncio
import sys

# 查看当前事件循环
loop = asyncio.get_event_loop()
print(type(loop))

# 手动指定选择器(高级用法)
if sys.platform == 'linux':
    selector = asyncio.unix_events._UnixSelectorEventLoop
```

### 七、常见陷阱和最佳实践

#### 陷阱1:阻塞调用阻塞整个事件循环

```python
import asyncio
import time

async def bad_example():
    # ❌ 错误:同步sleep会阻塞整个事件循环
    time.sleep(1)

async def good_example():
    # ✅ 正确:使用异步版本
    await asyncio.sleep(1)

async def mixed_example():
    # 如果必须调用阻塞函数,使用线程池
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(None, time.sleep, 1)
```

#### 陷阱2:忘记await

```python
async def fetch_data():
    return "data"

async def main():
    # ❌ 错误:忘记await,data是协程对象
    data = fetch_data()
    print(data)  # <coroutine object fetch_data at 0x...>

    # ✅ 正确
    data = await fetch_data()
    print(data)  # data
```

#### 陷阱3:协程未被调度

```python
async def background_task():
    await asyncio.sleep(1)
    print("完成")

async def main():
    # ❌ 错误:协程被创建但从未调度
    coro = background_task()
    # main结束,协程被丢弃

    # ✅ 正确:创建Task或await
    task = asyncio.create_task(background_task())
    await task

asyncio.run(main())
```

#### 最佳实践

1. **I/O密集任务**:全部使用`async/await`
2. **CPU密集任务**:使用`loop.run_in_executor()`委托给进程池
3. **资源清理**:使用`async with`确保正确关闭
4. **错误处理**:每个Task应该有异常处理
5. **避免阻塞**:所有I/O操作使用异步库(aiohttp、aiopg等)

### 八、与多线程的对比

| 维度 | asyncio协程 | 多线程 |
|------|------------|--------|
| **调度方式** | 协作式(程序控制) | 抢占式(OS控制) |
| **并发数量** | 数十万(轻量级) | 数百(受内存限制) |
| **上下文切换** | 纳秒级(无系统调用) | 微秒级(内核调度) |
| **适用场景** | I/O密集高并发 | I/O密集中等并发 |
| **GIL影响** | 单线程,不受影响 | 受GIL限制 |
| **调试难度** | 中等(栈追踪困难) | 高(竞态条件) |

**性能对比**:
```python
# 10000个并发HTTP请求
asyncio: 2.3秒
threading: 超时/资源耗尽
multiprocessing: 不适用(进程开销)
```

### 九、高级话题

#### 1. 自定义awaitable对象

```python
class MyAwaitable:
    def __await__(self):
        # 返回一个迭代器
        yield from asyncio.sleep(1).__await__()
        return "自定义结果"

async def main():
    result = await MyAwaitable()
    print(result)

asyncio.run(main())
```

#### 2. 协程链式调用

```python
async def step1():
    await asyncio.sleep(1)
    return "步骤1完成"

async def step2(data):
    await asyncio.sleep(1)
    return f"{data} -> 步骤2完成"

async def pipeline():
    result = await step1()
    result = await step2(result)
    return result

asyncio.run(pipeline())
```

#### 3. 事件循环集成到GUI

```python
import asyncio
import tkinter as tk

async def background_task():
    while True:
        print("后台任务运行中...")
        await asyncio.sleep(1)

def run_gui():
    root = tk.Tk()

    # 在GUI主循环中运行asyncio
    loop = asyncio.get_event_loop()
    loop.create_task(background_task())

    def update():
        loop.run_until_complete(asyncio.sleep(0))
        root.after(100, update)

    root.after(100, update)
    root.mainloop()
```

### 十、面试官可能的追问

**Q1: asyncio是否能利用多核CPU?**
A: 不能。asyncio运行在单线程中,只能通过`run_in_executor()`委托给进程池来利用多核。

**Q2: 什么情况下asyncio比多线程慢?**
A: 当任务不涉及I/O等待(纯CPU计算),或I/O操作延迟很小时,协程切换的开销可能超过其收益。

**Q3: 如何调试asyncio程序?**
A: 使用`asyncio.run(debug=True)`启用调试模式,检测未`await`的协程和阻塞调用;使用`aiodebug`等工具可视化协程状态。

**Q4: uvloop是什么?**
A: uvloop是基于libuv的asyncio事件循环替代实现,性能比默认实现快2-4倍,安装后通过`uvloop.install()`替换默认循环。
