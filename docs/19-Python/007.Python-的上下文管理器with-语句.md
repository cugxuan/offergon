---
title: Python 的上下文管理器（with 语句）
tags:
  - Python
status: robot
class: Python
slug: python-context-manager-with-statement
ref:
---

## 核心要点

- **上下文管理器本质**：实现了 `__enter__` 和 `__exit__` 协议的对象,用于资源的自动管理和清理
- **with 语句作用**：确保资源的正确获取和释放,无论是否发生异常都会执行清理操作
- **实现方式**：类实现协议或使用 `@contextmanager` 装饰器
- **典型应用**：文件操作、数据库连接、锁管理、事务处理

---

## 详细回答

### 一、什么是上下文管理器

上下文管理器是 Python 中一个实现了**上下文管理协议**的对象,该协议包含两个特殊方法:

```python
class MyContextManager:
    def __enter__(self):
        """进入上下文时调用,返回值会赋给 as 后的变量"""
        print("进入上下文")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文时调用,无论是否发生异常都会执行"""
        print("退出上下文")
        # 返回 True 表示压制异常,False 或 None 则异常会继续传播
        return False
```

**关键点**:
- `__enter__`: 在进入 with 代码块前执行,返回值可通过 `as` 关键字绑定
- `__exit__`: 在退出 with 代码块时执行,接收三个异常相关参数
  - `exc_type`: 异常类型
  - `exc_val`: 异常值
  - `exc_tb`: 异常追踪信息
  - 如果没有异常,三个参数都为 None

### 二、with 语句的工作原理

```python
with expression as variable:
    # 代码块
    pass
```

**执行流程**:
1. 计算 `expression`,得到上下文管理器对象
2. 调用上下文管理器的 `__enter__` 方法
3. 将 `__enter__` 的返回值赋给 `variable`(如果有 as 子句)
4. 执行 with 代码块
5. 无论代码块是否抛出异常,都调用 `__exit__` 方法
6. 如果 `__exit__` 返回 True,异常被压制;否则异常继续传播

**等价代码**:
```python
manager = expression
value = manager.__enter__()
try:
    variable = value
    # 代码块
except Exception:
    # __exit__ 返回 True 则压制异常
    if not manager.__exit__(*sys.exc_info()):
        raise
else:
    manager.__exit__(None, None, None)
```

### 三、实现上下文管理器的两种方式

#### 方式1: 类实现协议

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        # 不处理异常,让异常继续传播
        return False

# 使用
with FileManager('test.txt', 'w') as f:
    f.write('Hello World')
# 文件自动关闭,无需手动调用 close()
```

#### 方式2: 使用 contextlib.contextmanager 装饰器

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    try:
        f = open(filename, mode)
        yield f  # yield 的值会传给 as 变量
    finally:
        f.close()

# 使用
with file_manager('test.txt', 'w') as f:
    f.write('Hello World')
```

**装饰器方式的原理**:
- `yield` 之前的代码相当于 `__enter__`
- `yield` 的值是 `__enter__` 的返回值
- `yield` 之后的代码(通常在 finally 中)相当于 `__exit__`

### 四、实际应用场景

#### 1. 数据库连接管理

```python
class DatabaseConnection:
    def __init__(self, db_config):
        self.db_config = db_config
        self.conn = None

    def __enter__(self):
        self.conn = connect_to_db(self.db_config)
        return self.conn

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.conn.rollback()  # 发生异常则回滚
        else:
            self.conn.commit()    # 正常则提交
        self.conn.close()
        return False

with DatabaseConnection(config) as conn:
    cursor = conn.cursor()
    cursor.execute("INSERT INTO users VALUES (...)")
    # 自动提交或回滚,并关闭连接
```

#### 2. 线程锁管理

```python
import threading

lock = threading.Lock()

# 使用上下文管理器自动获取和释放锁
with lock:
    # 临界区代码
    shared_resource += 1
# 锁自动释放,即使发生异常
```

#### 3. 临时修改状态

```python
@contextmanager
def temporary_attribute(obj, attr, value):
    """临时修改对象属性,退出时恢复"""
    old_value = getattr(obj, attr)
    setattr(obj, attr, value)
    try:
        yield obj
    finally:
        setattr(obj, attr, old_value)

class Config:
    debug = False

config = Config()
with temporary_attribute(config, 'debug', True):
    print(config.debug)  # True
print(config.debug)  # False,已恢复
```

#### 4. 性能计时

```python
import time

@contextmanager
def timer(name):
    start = time.time()
    yield
    end = time.time()
    print(f"{name} took {end - start:.2f} seconds")

with timer("数据库查询"):
    # 执行耗时操作
    result = db.query("SELECT * FROM large_table")
# 输出: 数据库查询 took 2.35 seconds
```

### 五、多个上下文管理器的使用

Python 支持在一个 with 语句中使用多个上下文管理器:

```python
# 方式1: 使用逗号分隔
with open('input.txt') as infile, open('output.txt', 'w') as outfile:
    outfile.write(infile.read())

# 方式2: 嵌套(Python 3.10+ 支持括号)
with (
    open('input.txt') as infile,
    open('output.txt', 'w') as outfile
):
    outfile.write(infile.read())
```

**执行顺序**: 从左到右依次调用 `__enter__`,从右到左依次调用 `__exit__`(类似栈结构)

### 六、常见面试考点

**Q: with 语句能否压制异常?**

A: 可以,但需要在 `__exit__` 方法中返回 True:

```python
class SuppressException:
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is ValueError:
            print(f"捕获并压制了 ValueError: {exc_val}")
            return True  # 压制 ValueError
        return False  # 其他异常继续传播

with SuppressException():
    raise ValueError("这个异常会被压制")
print("程序继续执行")  # 会打印
```

**Q: contextlib 还提供了哪些有用的工具?**

A:
- `contextlib.suppress(*exceptions)`: 压制指定异常
- `contextlib.closing(obj)`: 确保对象的 `close()` 方法被调用
- `contextlib.ExitStack`: 动态管理多个上下文

```python
from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove('nonexistent_file.txt')  # 不会抛出异常
```

### 七、总结

上下文管理器是 Python 中优雅处理资源管理的机制,通过 `__enter__` 和 `__exit__` 协议实现了资源的自动清理。with 语句保证了无论代码块是否发生异常,清理代码都会被执行,避免了资源泄漏。在实际开发中,文件操作、数据库连接、锁管理等场景都应该优先考虑使用上下文管理器,这不仅能让代码更简洁,还能提高程序的健壮性
