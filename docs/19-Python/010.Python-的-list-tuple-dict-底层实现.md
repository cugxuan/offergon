---
title: Python 的 list、tuple、dict 底层实现
tags:
  - Python
status: robot
class: Python
slug: python-list-tuple-dict-implementation
ref:
---

## 核心要点

**list**：动态数组，预分配内存+增长策略，支持 O(1) 尾部追加和索引访问
**tuple**：不可变数组，紧凑内存布局，无额外增长空间，性能优于 list
**dict**：哈希表实现，Python 3.6+ 保持插入顺序，动态扩容，平均 O(1) 查找

---

## 详细回答

### 一、list（列表）的底层实现

#### 1. 数据结构
Python 的 list 是一个**动态数组**（dynamic array），底层用 C 语言实现为 `PyListObject` 结构体：

```c
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;  // 指向元素指针数组
    Py_ssize_t allocated; // 已分配的槽位数量
} PyListObject;
```

**关键特性**：
- `ob_item` 是一个指针数组，存储的是指向 Python 对象的指针（不是对象本身）
- `ob_size` 表示当前元素个数（继承自 `PyObject_VAR_HEAD`）
- `allocated` 表示已分配的内存槽位数，通常 `allocated >= ob_size`

#### 2. 内存分配策略
当向 list 追加元素时，如果 `ob_size == allocated`，需要重新分配内存。Python 采用**过度分配**（over-allocation）策略来减少频繁的内存重分配：

```python
# 增长公式（简化版）
new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) + newsize
```

**实际增长规律**：
- 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
- 增长因子约为 1.125（与 C++ vector 的 1.5-2 相比更节省内存）

**时间复杂度**：
- `append()`: 均摊 O(1)（偶尔触发扩容为 O(n)）
- `insert(0, x)`: O(n)（需要移动所有元素）
- `pop()`: O(1)，`pop(0)`: O(n)
- 索引访问: O(1)

#### 3. 为什么 list 可以存储不同类型？
因为 `ob_item` 存储的是 `PyObject*` 指针，所有 Python 对象都继承自 `PyObject`，所以可以存储任意类型。

---

### 二、tuple（元组）的底层实现

#### 1. 数据结构
tuple 的底层结构 `PyTupleObject` 与 list 类似，但**不可变**：

```c
typedef struct {
    PyObject_VAR_HEAD
    PyObject *ob_item[1];  // 变长数组，直接存储在结构体内
} PyTupleObject;
```

**与 list 的关键区别**：
- tuple 的元素直接存储在结构体内存中（`ob_item` 是内联数组，不是指针）
- 没有 `allocated` 字段，因为大小固定不变
- 创建时一次性分配所有内存，无需动态扩容

#### 2. 性能优势
1. **内存更紧凑**：没有额外的预分配空间
2. **创建更快**：无需额外的内存分配逻辑
3. **缓存友好**：小 tuple（长度 ≤ 20）会被缓存重用（free list 机制）
4. **可哈希**：不可变特性使其可作为 dict 的键

```python
# 示例：tuple 比 list 占用内存更小
import sys
lst = [1, 2, 3]
tup = (1, 2, 3)
print(sys.getsizeof(lst))  # 64 字节
print(sys.getsizeof(tup))  # 48 字节
```

#### 3. 不可变的本质
tuple 的不可变是指：
- **不能修改引用**：不能改变 `ob_item` 中存储的指针
- **但对象本身可变**：如果元素是可变对象（如 list），其内容可以修改

```python
t = ([1, 2], 3)
t[0].append(4)  # 合法，t 变为 ([1, 2, 4], 3)
t[0] = [5, 6]   # 非法，TypeError
```

---

### 三、dict（字典）的底层实现

#### 1. 哈希表结构（Python 3.6+）
Python 的 dict 基于**哈希表 + 数组索引**实现，自 3.6 起默认保持**插入顺序**。

**核心数据结构**：
```c
typedef struct {
    PyObject_HEAD
    Py_ssize_t ma_used;          // 已使用的键值对数量
    PyDictKeysObject *ma_keys;   // 键数组（共享）
    PyObject **ma_values;        // 值数组（或 NULL）
} PyDictObject;
```

**分离式哈希表**（Combined vs Split Table）：
- **索引数组**（indices）：存储哈希桶，值为 entries 数组的索引
- **条目数组**（entries）：按插入顺序存储键值对

```
indices: [None, 1, None, 0, None, 2]  # 哈希槽 -> entries 索引
entries: [
    (hash0, key0, value0),  # 第 1 个插入
    (hash1, key1, value1),  # 第 2 个插入
    (hash2, key2, value2),  # 第 3 个插入
]
```

#### 2. 哈希冲突解决
采用**开放地址法**（Open Addressing）+ **扰动探测**（Perturbation Probing）：

```python
# 探测序列伪代码
perturb = hash_value
i = hash_value % size
while True:
    if slot[i] is empty or matches:
        return i
    i = (5*i + 1 + perturb) % size
    perturb >>= 5  # 逐步减小扰动
```

**优势**：
- 避免聚集（clustering）问题
- 缓存友好（相邻内存访问）

#### 3. 动态扩容
- **负载因子**：当 `ma_used / size > 2/3` 时触发扩容
- **扩容倍数**：通常扩大为原来的 2 倍（`size = 2^n`）
- **最小大小**：8 个槽位

```python
# 示例：观察 dict 扩容
import sys
d = {}
for i in range(100):
    d[i] = i
    if i in [0, 5, 10, 20, 40, 80]:
        print(f"Size {i+1}: {sys.getsizeof(d)} bytes")
# 输出：64 -> 240 -> 368 -> 648 -> 1192 -> 2280
```

#### 4. 键的要求
- 必须**可哈希**（实现 `__hash__()` 和 `__eq__()`）
- 不可变类型（int, str, tuple）天然可哈希
- 可变类型（list, dict）不可哈希

```python
# 合法
d = {(1, 2): "tuple_key"}

# 非法
d = {[1, 2]: "list_key"}  # TypeError: unhashable type: 'list'
```

#### 5. Python 3.7+ 的顺序保证
- 3.6 是实现细节，3.7+ 成为**语言规范**
- 遍历 dict 时按插入顺序返回
- 删除键后再插入会放在末尾

```python
d = {"a": 1, "b": 2, "c": 3}
del d["b"]
d["b"] = 20
print(list(d.keys()))  # ['a', 'c', 'b']
```

---

## 性能对比总结

| 操作 | list | tuple | dict |
|------|------|-------|------|
| 索引访问 | O(1) | O(1) | O(1) 平均 |
| 追加元素 | O(1) 均摊 | - | O(1) 均摊 |
| 插入/删除 | O(n) | - | O(1) 平均 |
| 查找元素 | O(n) | O(n) | O(1) 平均 |
| 内存占用 | 中等 | 最小 | 最大 |
| 创建速度 | 中等 | 最快 | 较慢 |

**最佳实践**：
1. 需要修改 → 用 list
2. 只读数据/作为 dict 键 → 用 tuple
3. 需要快速查找/去重 → 用 dict/set
4. 大量追加操作 → collections.deque 更优（双端队列）
