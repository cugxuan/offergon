---
title: Python 的内存管理和垃圾回收
tags:
  - Python
  - 内存管理
status: robot
class: Python
slug: python-memory-management-garbage-collection
ref:
---

## 核心要点

- **引用计数机制**：Python 主要采用引用计数来管理内存,对象引用计数为 0 时立即释放
- **循环引用问题**：引用计数无法处理循环引用,需要额外的垃圾回收机制
- **分代回收算法**：基于"大部分对象生命周期短"的假设,将对象分为 0、1、2 三代进行管理
- **内存池机制**：小对象使用 PyMalloc 内存池,减少 malloc/free 系统调用,提高性能
- **优化技巧**：使用 `__slots__`、对象池、弱引用等方式优化内存使用

---

## 详细回答

### 一、Python 内存管理的核心机制

Python 的内存管理分为三个层次:

```
第三层: Python 对象内存管理 (引用计数 + 垃圾回收)
第二层: PyMalloc 内存池 (小对象优化)
第一层: C 标准库的 malloc/free (大对象和底层内存)
```

### 二、引用计数(Reference Counting)

#### 2.1 基本原理

每个 Python 对象都有一个引用计数器,记录有多少个引用指向该对象:

```python
import sys

a = []  # 创建空列表,引用计数 = 1
print(sys.getrefcount(a))  # 输出 2 (实际引用 + getrefcount 的临时引用)

b = a  # 引用计数 +1
print(sys.getrefcount(a))  # 输出 3

del b  # 引用计数 -1
print(sys.getrefcount(a))  # 输出 2
```

**引用计数的增减场景**:

| 操作 | 引用计数变化 | 示例 |
|------|-------------|------|
| 对象创建 | +1 | `a = []` |
| 赋值给变量 | +1 | `b = a` |
| 作为参数传递 | +1 | `func(a)` |
| 加入容器 | +1 | `list.append(a)` |
| 变量删除 | -1 | `del a` |
| 引用离开作用域 | -1 | 函数返回 |
| 从容器移除 | -1 | `list.remove(a)` |

#### 2.2 引用计数的实现

在 CPython 源码中,每个对象都有 `ob_refcnt` 字段:

```c
typedef struct _object {
    Py_ssize_t ob_refcnt;  // 引用计数
    struct _typeobject *ob_type;  // 对象类型
} PyObject;
```

**引用计数的优缺点**:

✅ **优点**:
- 简单直观,容易理解
- 内存释放及时(引用计数为 0 时立即释放)
- 实时性好,没有明显的 GC 停顿

❌ **缺点**:
- 无法处理循环引用
- 维护引用计数有性能开销
- 多线程环境下需要加锁(GIL 的原因之一)

#### 2.3 循环引用问题

引用计数最大的问题是**无法处理循环引用**:

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

# 创建循环引用
node1 = Node(1)
node2 = Node(2)
node1.next = node2  # node1 引用 node2
node2.next = node1  # node2 引用 node1

# 删除外部引用
del node1
del node2

# 此时两个对象互相引用,引用计数都不为 0
# 但外部已无法访问,造成内存泄漏
```

**可视化理解**:
```
外部变量         对象空间
node1 -----> [Node(1)] <----+
                 |          |
                 v          |
node2 -----> [Node(2)] -----+

删除 node1, node2 后:
[Node(1)] <----+
    |          |
    v          |
[Node(2)] -----+
两个对象互相引用,引用计数都是 1,无法释放
```

### 三、垃圾回收(Garbage Collection)

为了解决循环引用,Python 引入了**分代垃圾回收**机制。

#### 3.1 标记-清除算法(Mark & Sweep)

**核心思想**: 从根对象(全局变量、栈上的局部变量等)出发,标记所有可达对象,未标记的对象即为垃圾。

```python
import gc

# 手动触发垃圾回收
collected = gc.collect()
print(f"回收了 {collected} 个对象")

# 查看垃圾回收统计
print(gc.get_count())  # (第 0 代计数, 第 1 代计数, 第 2 代计数)
print(gc.get_stats())  # 详细统计信息
```

**工作流程**:
1. **标记阶段**: 从根对象出发,遍历所有可达对象并标记
2. **清除阶段**: 遍历所有对象,清除未标记的对象
3. **整理阶段**(可选): 整理内存碎片

```python
# 演示循环引用的检测
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

# 禁用 GC 观察效果
gc.disable()

node1 = Node(1)
node2 = Node(2)
node1.next = node2
node2.next = node1

print(f"删除前: {gc.get_count()}")
del node1
del node2
print(f"删除后: {gc.get_count()}")

# 手动 GC
collected = gc.collect()
print(f"GC 回收了 {collected} 个对象")

gc.enable()
```

#### 3.2 分代回收算法(Generational GC)

**理论基础**: "弱分代假说" - 大多数对象存活时间很短,少数对象存活时间很长。

Python 将对象分为**三代**(Generation 0, 1, 2):

```
Generation 0 (年轻代): 新创建的对象,回收频率最高
    ↓ 存活
Generation 1 (中年代): 从 Gen0 存活下来的对象
    ↓ 存活
Generation 2 (老年代): 从 Gen1 存活下来的对象,回收频率最低
```

**分代回收策略**:
- Gen0 阈值默认 700 个对象,触发一次 Gen0 回收
- Gen0 回收 10 次,触发一次 Gen1 回收
- Gen1 回收 10 次,触发一次 Gen2 回收

```python
import gc

# 查看阈值设置
print(gc.get_threshold())  # (700, 10, 10)

# 修改阈值
gc.set_threshold(1000, 15, 15)

# 查看各代对象数量
print(gc.get_count())  # (当前 Gen0 对象数, Gen1 对象数, Gen2 对象数)

# 禁用/启用自动 GC
gc.disable()
gc.enable()

# 手动回收指定代
gc.collect(0)  # 只回收 Gen0
gc.collect(1)  # 回收 Gen0 和 Gen1
gc.collect(2)  # 全量回收(默认)
```

**分代回收的性能优化**:

```python
import gc
import time

# 测试:关闭 GC 可能提升性能(适合短期计算密集任务)
gc.disable()
start = time.time()
# ... 执行密集计算 ...
result = sum([i**2 for i in range(1000000)])
print(f"GC 关闭耗时: {time.time() - start:.3f}s")

# 手动回收
gc.collect()

gc.enable()
start = time.time()
result = sum([i**2 for i in range(1000000)])
print(f"GC 开启耗时: {time.time() - start:.3f}s")
```

#### 3.3 查找循环引用

```python
import gc

class Node:
    def __init__(self, value):
        self.value = value
        self.ref = None

    def __repr__(self):
        return f"Node({self.value})"

# 创建循环引用
a = Node(1)
b = Node(2)
a.ref = b
b.ref = a

# 查找所有垃圾对象
gc.collect()
garbage = gc.garbage
print(f"垃圾对象: {garbage}")

# 查找引用了某个对象的所有对象
referrers = gc.get_referrers(a)
print(f"引用 a 的对象: {referrers}")

# 查找某个对象引用的所有对象
referents = gc.get_referents(a)
print(f"a 引用的对象: {referents}")
```

### 四、内存池机制(PyMalloc)

为了提高小对象的内存分配效率,Python 实现了**内存池**机制。

#### 4.1 内存分配的层次结构

```
Block (8-512 字节): 最小分配单位,固定大小
    ↓ 组成
Pool (4KB): 包含多个相同大小的 Block
    ↓ 组成
Arena (256KB): 包含多个 Pool
```

**内存分配策略**:
- **小对象**(< 512 字节): 使用内存池 PyMalloc
- **大对象**(≥ 512 字节): 直接调用系统 malloc

```python
import sys

# 小对象使用内存池
small_list = []
print(sys.getsizeof(small_list))  # 56 字节(小对象)

# 大对象直接分配
large_list = list(range(100000))
print(sys.getsizeof(large_list))  # 800984 字节(大对象)
```

#### 4.2 对象的内存结构

```python
import sys

# 空对象的基本开销
print(sys.getsizeof(object()))        # 16 字节
print(sys.getsizeof(int()))           # 24 字节
print(sys.getsizeof([]))              # 56 字节
print(sys.getsizeof({}))              # 64 字节
print(sys.getsizeof(""))              # 49 字节

# 对象内存随内容增长
print(sys.getsizeof([1]))             # 64 字节
print(sys.getsizeof([1, 2, 3, 4]))    # 88 字节
print(sys.getsizeof("hello"))         # 54 字节
```

### 五、内存优化技巧

#### 5.1 使用 `__slots__` 减少内存

默认情况下,Python 对象使用字典存储属性,消耗较多内存:

```python
import sys

class WithoutSlots:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class WithSlots:
    __slots__ = ['x', 'y']  # 固定属性,不使用字典
    def __init__(self, x, y):
        self.x = x
        self.y = y

obj1 = WithoutSlots(1, 2)
obj2 = WithSlots(1, 2)

print(f"不使用 __slots__: {sys.getsizeof(obj1.__dict__)} 字节")  # ~112 字节
print(f"使用 __slots__: {sys.getsizeof(obj2)} 字节")           # ~48 字节

# 批量创建时差异明显
import sys
objects1 = [WithoutSlots(i, i) for i in range(10000)]
objects2 = [WithSlots(i, i) for i in range(10000)]

print(f"10000 个对象不使用 __slots__: {sum(sys.getsizeof(o.__dict__) for o in objects1) / 1024:.1f} KB")
print(f"10000 个对象使用 __slots__: {sum(sys.getsizeof(o) for o in objects2) / 1024:.1f} KB")
```

**注意**: `__slots__` 限制了动态添加属性,适合属性固定的数据类。

#### 5.2 使用生成器替代列表

```python
import sys

# 列表 - 一次性占用内存
big_list = [x**2 for x in range(1000000)]
print(f"列表内存: {sys.getsizeof(big_list) / 1024 / 1024:.2f} MB")  # ~8.5 MB

# 生成器 - 惰性计算
big_gen = (x**2 for x in range(1000000))
print(f"生成器内存: {sys.getsizeof(big_gen) / 1024:.2f} KB")  # ~0.1 KB
```

#### 5.3 使用 `array` 替代列表(存储基本类型)

```python
import sys
import array

# 列表存储 100 万个整数
int_list = list(range(1000000))
print(f"列表内存: {sys.getsizeof(int_list) / 1024 / 1024:.2f} MB")  # ~8.5 MB

# array 存储 100 万个整数
int_array = array.array('i', range(1000000))
print(f"array 内存: {sys.getsizeof(int_array) / 1024 / 1024:.2f} MB")  # ~4 MB
```

#### 5.4 使用弱引用避免循环引用

```python
import weakref

class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

    def add_child(self, child):
        self.children.append(child)
        child.parent = weakref.ref(self)  # 使用弱引用

parent = Node("parent")
child = Node("child")
parent.add_child(child)

print(child.parent())  # 通过弱引用访问父节点
del parent
print(child.parent())  # None,父节点已被回收
```

#### 5.5 使用 `del` 显式释放内存

```python
import gc

# 处理大对象后显式删除
def process_large_data():
    large_data = [x for x in range(10000000)]
    result = sum(large_data)
    del large_data  # 立即释放
    gc.collect()    # 手动触发 GC
    return result
```

### 六、内存调试与分析

#### 6.1 使用 `tracemalloc` 跟踪内存分配

```python
import tracemalloc

# 开始跟踪
tracemalloc.start()

# 执行代码
large_list = [x**2 for x in range(100000)]
dict_data = {i: str(i) for i in range(10000)}

# 获取内存快照
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics('lineno')

print("[ Top 10 内存消耗 ]")
for stat in top_stats[:10]:
    print(stat)

# 停止跟踪
tracemalloc.stop()
```

#### 6.2 使用 `objgraph` 可视化对象引用

```bash
pip install objgraph
```

```python
import objgraph

class MyClass:
    pass

a = MyClass()
b = MyClass()
a.ref = b
b.ref = a

# 显示最多的对象类型
objgraph.show_most_common_types()

# 显示对象的引用链
objgraph.show_refs([a], filename='refs.png')

# 显示反向引用
objgraph.show_backrefs([a], filename='backrefs.png')
```

### 七、常见面试考点

#### Q1: Python 如何处理循环引用?

**答**: Python 使用**引用计数**作为主要内存管理机制,但引用计数无法处理循环引用。为此,Python 引入了**分代垃圾回收**机制,使用**标记-清除算法**定期检测并回收循环引用的对象。

#### Q2: 什么是内存泄漏?Python 中如何避免?

**答**: 内存泄漏指程序无法释放不再使用的内存。Python 中常见原因:
1. **循环引用**: 使用 `gc` 模块可自动处理
2. **全局变量**: 避免使用可变全局变量存储大量数据
3. **闭包**: 注意闭包捕获的外部变量
4. **C 扩展**: C 扩展中的内存泄漏需手动检查

**避免方法**:
- 使用 `with` 语句管理资源
- 使用弱引用 `weakref`
- 及时 `del` 大对象
- 使用 `tracemalloc` 定位问题

#### Q3: GIL 和垃圾回收有什么关系?

**答**: **GIL(全局解释器锁)**确保同一时刻只有一个线程执行 Python 字节码,其主要原因之一就是保护引用计数的线程安全。如果没有 GIL,多个线程同时修改引用计数会导致数据竞争。

#### Q4: 如何查看对象的引用计数?

**答**: 使用 `sys.getrefcount(obj)`,注意返回值会比实际多 1(函数参数传递增加了临时引用)。

```python
import sys
a = []
print(sys.getrefcount(a) - 1)  # 实际引用计数
```

### 八、总结

Python 的内存管理是一个多层次的系统:

1. **引用计数**: 快速、实时,但无法处理循环引用
2. **垃圾回收**: 处理循环引用,采用分代回收优化性能
3. **内存池**: 优化小对象分配,减少系统调用

**最佳实践**:
- 理解引用计数机制,避免不必要的引用
- 使用 `__slots__` 减少对象内存占用
- 用生成器处理大数据集
- 使用弱引用避免循环引用
- 使用 `tracemalloc` 和 `gc` 模块进行内存调试

掌握这些知识,不仅能帮助你写出高性能的 Python 代码,也能在面试中展现你对 Python 底层机制的深入理解
