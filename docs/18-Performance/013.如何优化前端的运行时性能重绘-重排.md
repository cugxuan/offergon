---
title: 如何优化前端的运行时性能(重绘、重排)?
tags:
  - 性能优化
status: robot
class: 性能优化
slug: frontend-runtime-performance-optimization-repaint-reflow
ref:
---

## 核心要点

**重排(Reflow)与重绘(Repaint)的本质:**
- 重排:元素的几何属性变化,需要重新计算布局树,开销大
- 重绘:元素外观变化但不影响布局,只需重新绘制,开销较小
- 优化原则:减少触发次数、批量操作、使用 GPU 加速、避免强制同步布局

**优化策略分层:**
1. **DOM 操作层**:批量修改、文档碎片、离线操作
2. **CSS 层**:使用 transform/opacity、避免复杂选择器、减少层级
3. **JavaScript 层**:防抖节流、RAF 优化动画、缓存计算结果
4. **现代技术**:虚拟滚动、Web Workers、CSS Containment

---

## 详细回答

### 一、理解重排(Reflow)和重绘(Repaint)

#### 1.1 浏览器渲染流程

浏览器从 HTML 到页面显示的完整流程:

```
HTML 解析 → DOM 树
              ↓
CSS 解析 → CSSOM 树
              ↓
      合成渲染树(Render Tree)
              ↓
         布局计算(Layout/Reflow)  ← 计算元素几何位置
              ↓
         绘制(Paint/Repaint)      ← 填充像素(颜色、文字等)
              ↓
         合成(Composite)          ← 分层合成最终画面
```

#### 1.2 重排(Reflow)

**定义:** 当元素的几何属性发生变化时,浏览器需要重新计算元素的位置和大小,并重新构建渲染树的过程。

**触发条件:**
- 添加/删除可见 DOM 元素
- 元素位置、尺寸发生变化(`width`、`height`、`padding`、`margin`、`left`、`top` 等)
- 内容变化(文本改变、图片替换导致尺寸变化)
- 页面首次渲染
- 浏览器窗口尺寸变化(`resize` 事件)
- 读取某些属性会强制触发重排(见下文)

**影响范围:** 重排的代价很高,因为它可能影响:
- 当前元素
- 父元素和子元素
- 兄弟元素
- 严重时可能导致整个文档的重排

#### 1.3 重绘(Repaint)

**定义:** 当元素的外观(如颜色、背景等)发生变化但不影响布局时,浏览器重新绘制元素的过程。

**触发条件:**
- 修改颜色属性(`color`、`background-color`)
- 修改边框样式(`border-style`、`outline`)
- 修改可见性(`visibility`)
- 修改文字装饰(`text-decoration`)
- 修改阴影(`box-shadow`、`text-shadow`)

**特点:** 重绘的开销比重排小,因为不需要重新计算布局。

**关系:** 重排必定导致重绘,但重绘不一定导致重排。

---

### 二、优化策略详解

#### 2.1 减少重排次数

##### (1) 批量修改 DOM 样式

**❌ 不好的做法(多次重排):**
```javascript
const element = document.getElementById('box');
element.style.width = '100px';   // 触发重排
element.style.height = '100px';  // 触发重排
element.style.margin = '10px';   // 触发重排
```

**✅ 推荐做法 1:使用 cssText**
```javascript
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';
// 只触发一次重排
```

**✅ 推荐做法 2:修改 className**
```css
.box-style {
  width: 100px;
  height: 100px;
  margin: 10px;
}
```
```javascript
element.className = 'box-style';  // 只触发一次重排
```

##### (2) 批量修改 DOM 结构

**❌ 不好的做法:**
```javascript
const list = document.getElementById('list');
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.appendChild(li);  // 每次追加都触发重排,共 1000 次!
}
```

**✅ 推荐做法 1:使用 DocumentFragment**
```javascript
const list = document.getElementById('list');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);  // 在内存中操作,不触发重排
}

list.appendChild(fragment);  // 一次性插入,只触发一次重排
```

**✅ 推荐做法 2:使用 innerHTML(适用于简单场景)**
```javascript
const html = Array.from({ length: 1000 }, (_, i) =>
  `<li>Item ${i}</li>`
).join('');
list.innerHTML = html;  // 只触发一次重排
```

##### (3) 离线操作 DOM

**方法 1:display: none 离线**
```javascript
const element = document.getElementById('box');

element.style.display = 'none';  // 触发一次重排

// 进行多次复杂操作
element.style.width = '100px';
element.style.height = '100px';
element.appendChild(newChild);
// ... 这些操作不会触发重排,因为元素已脱离文档流

element.style.display = 'block';  // 触发一次重排
// 总共只触发 2 次重排
```

**方法 2:克隆节点离线操作**
```javascript
const oldNode = document.getElementById('list');
const clone = oldNode.cloneNode(true);

// 在克隆节点上进行复杂操作
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  clone.appendChild(li);
}

oldNode.parentNode.replaceChild(clone, oldNode);  // 一次性替换
```

#### 2.2 避免强制同步布局(Forced Synchronous Layout)

##### 问题根源

某些 JavaScript 属性的读取会强制浏览器立即执行重排,以返回最新的值:

**会触发强制重排的属性:**
- 尺寸:`offsetWidth`、`offsetHeight`、`clientWidth`、`clientHeight`、`scrollWidth`、`scrollHeight`
- 位置:`offsetTop`、`offsetLeft`、`scrollTop`、`scrollLeft`
- 计算样式:`getComputedStyle()`、`getBoundingClientRect()`

**❌ 糟糕的例子(读写交替导致布局抖动):**
```javascript
// 每次循环都会:写样式 → 读属性(强制重排) → 写样式 → 读属性(强制重排)...
for (let i = 0; i < elements.length; i++) {
  elements[i].style.width = elements[i].offsetWidth + 10 + 'px';
  // offsetWidth 读取强制触发重排,循环 100 次就重排 100 次!
}
```

**✅ 优化做法(读写分离):**
```javascript
// 第一步:批量读取(只触发一次重排)
const widths = elements.map(el => el.offsetWidth);

// 第二步:批量写入(只触发一次重排)
elements.forEach((el, i) => {
  el.style.width = widths[i] + 10 + 'px';
});
```

##### FastDOM 库的应用

使用 [FastDOM](https://github.com/wilsonpage/fastdom) 自动优化读写顺序:

```javascript
import fastdom from 'fastdom';

elements.forEach(el => {
  fastdom.measure(() => {
    const width = el.offsetWidth;  // 批量读取阶段

    fastdom.mutate(() => {
      el.style.width = width + 10 + 'px';  // 批量写入阶段
    });
  });
});
```

#### 2.3 使用 CSS3 硬件加速

##### 原理

某些 CSS 属性可以触发 GPU 加速,将元素提升到独立的合成层(Composite Layer),这样修改这些属性时:
- **不会触发重排和重绘**
- 由 GPU 直接处理变换,性能极高
- 适合高频率动画

##### 触发合成层的属性

**推荐使用的属性:**
- `transform`:位移、旋转、缩放、倾斜
- `opacity`:透明度
- `filter`:滤镜效果
- `will-change`:提前告知浏览器优化

**❌ 不好的动画(频繁触发重排):**
```css
@keyframes move {
  from { left: 0; }
  to { left: 100px; }  /* 修改 left 会触发重排 */
}

.box {
  position: absolute;
  animation: move 1s;
}
```

**✅ 推荐动画(GPU 加速,不触发重排):**
```css
@keyframes move {
  from { transform: translateX(0); }
  to { transform: translateX(100px); }  /* transform 只触发合成 */
}

.box {
  animation: move 1s;
  will-change: transform;  /* 提前优化 */
}
```

##### will-change 的正确使用

**作用:** 提前告知浏览器元素将要发生变化,让浏览器提前做优化。

**✅ 正确用法(动态添加):**
```javascript
const element = document.querySelector('.box');

// 动画开始前添加
element.style.willChange = 'transform, opacity';

element.addEventListener('transitionend', () => {
  // 动画结束后移除,避免过度优化
  element.style.willChange = 'auto';
});

element.classList.add('animate');
```

**❌ 错误用法(过度使用):**
```css
/* 不要给所有元素都加 will-change,会浪费内存 */
* {
  will-change: transform, opacity;  /* 过度优化,反而降低性能 */
}
```

#### 2.4 优化 JavaScript 执行

##### (1) 使用 requestAnimationFrame 优化动画

**原理:** `requestAnimationFrame` 会在浏览器下一次重绘之前执行回调,避免掉帧。

**❌ 不好的做法(可能掉帧):**
```javascript
setInterval(() => {
  element.style.left = element.offsetLeft + 1 + 'px';
}, 16);  // 假设 60fps,但可能与浏览器重绘不同步
```

**✅ 推荐做法:**
```javascript
function animate() {
  element.style.transform = `translateX(${position}px)`;
  position += 1;

  if (position < 500) {
    requestAnimationFrame(animate);  // 与浏览器重绘同步
  }
}
requestAnimationFrame(animate);
```

##### (2) 防抖(Debounce)和节流(Throttle)

**场景:** 高频事件(如 `scroll`、`resize`、`input`)触发的操作。

**防抖:只执行最后一次**
```javascript
function debounce(func, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func.apply(this, args), delay);
  };
}

// 使用:窗口调整结束后才执行
window.addEventListener('resize', debounce(() => {
  console.log('窗口调整完成');
  // 重新计算布局
}, 300));
```

**节流:固定时间间隔执行一次**
```javascript
function throttle(func, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      lastTime = now;
      func.apply(this, args);
    }
  };
}

// 使用:滚动时每 100ms 最多执行一次
window.addEventListener('scroll', throttle(() => {
  console.log('滚动中...');
  // 懒加载图片等操作
}, 100));
```

##### (3) 缓存 DOM 查询结果

**❌ 不好的做法:**
```javascript
for (let i = 0; i < 1000; i++) {
  document.getElementById('list').appendChild(createItem(i));
  // 每次循环都查询 DOM
}
```

**✅ 推荐做法:**
```javascript
const list = document.getElementById('list');  // 缓存查询结果
for (let i = 0; i < 1000; i++) {
  list.appendChild(createItem(i));
}
```

#### 2.5 CSS 优化

##### (1) 减少选择器复杂度

**❌ 复杂选择器(浏览器需要从右向左匹配):**
```css
div.container > ul.list li.item span.text { }
/* 浏览器需要先找所有 span.text,再逐层向上匹配 */
```

**✅ 简化选择器:**
```css
.list-item-text { }
/* 直接类名匹配,效率最高 */
```

##### (2) 避免深层 DOM 嵌套

```html
<!-- ❌ 深层嵌套影响重排范围 -->
<div>
  <div>
    <div>
      <div>
        <div>
          <p id="target">内容</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ✅ 扁平化结构 -->
<div>
  <p id="target">内容</p>
</div>
```

##### (3) 使用 CSS Containment

CSS `contain` 属性可以隔离元素,限制重排范围:

```css
.card {
  contain: layout;  /* 内部布局变化不影响外部 */
}

.sidebar {
  contain: layout style paint;  /* 完全隔离 */
}
```

**contain 值说明:**
- `layout`:布局隔离,内部重排不影响外部
- `paint`:绘制隔离,内部重绘不影响外部
- `size`:尺寸固定,子元素不影响父元素尺寸
- `style`:样式隔离(主要用于 CSS 计数器)

#### 2.6 现代技术应用

##### (1) 虚拟滚动(Virtual Scrolling)

**场景:** 渲染大列表(如 10000 条数据)。

**原理:** 只渲染可视区域的元素,滚动时动态替换内容。

**实现示例(简化版):**
```javascript
class VirtualList {
  constructor(container, data, itemHeight) {
    this.container = container;
    this.data = data;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.startIndex = 0;

    this.render();
    container.addEventListener('scroll', () => this.onScroll());
  }

  render() {
    const endIndex = this.startIndex + this.visibleCount;
    const visibleData = this.data.slice(this.startIndex, endIndex);

    this.container.innerHTML = visibleData.map((item, i) =>
      `<div class="item" style="top: ${(this.startIndex + i) * this.itemHeight}px">
        ${item}
      </div>`
    ).join('');

    // 设置容器总高度,保持滚动条正确
    this.container.style.height = this.data.length * this.itemHeight + 'px';
  }

  onScroll() {
    const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);
    if (newStartIndex !== this.startIndex) {
      this.startIndex = newStartIndex;
      this.render();
    }
  }
}

// 使用
const data = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
new VirtualList(document.getElementById('list'), data, 50);
```

**成熟方案:**
- React:[react-window](https://github.com/bvaughn/react-window)、[react-virtualized](https://github.com/bvaughn/react-virtualized)
- Vue:[vue-virtual-scroll-list](https://github.com/tangbc/vue-virtual-scroll-list)

##### (2) Web Workers

**场景:** 复杂计算(如数据处理、图像处理)阻塞主线程。

**方案:** 将计算移至 Worker 线程,避免影响渲染。

```javascript
// main.js
const worker = new Worker('worker.js');

worker.postMessage({ data: largeArray });

worker.onmessage = (e) => {
  const result = e.data;
  // 使用计算结果更新 UI
  document.getElementById('result').textContent = result;
};

// worker.js
onmessage = (e) => {
  const data = e.data.data;
  // 执行复杂计算
  const result = data.reduce((sum, num) => sum + num, 0);
  postMessage(result);
};
```

##### (3) Intersection Observer

**场景:** 懒加载图片、无限滚动、曝光统计。

**优势:** 比监听 `scroll` 事件性能更好,不触发重排。

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;  // 加载图片
      observer.unobserve(img);     // 停止观察
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

---

### 三、性能监测工具

#### 3.1 Chrome DevTools

##### (1) Performance 面板

**使用步骤:**
1. 打开 DevTools → Performance 标签
2. 点击录制按钮,执行操作
3. 停止录制,查看火焰图

**关键指标:**
- **紫色条**:Rendering(包含重排和重绘)
- **绿色条**:Painting(绘制)
- **黄色条**:Scripting(JavaScript 执行)

##### (2) Rendering 面板

**开启重绘区域高亮:**
```
DevTools → More tools → Rendering
勾选 "Paint flashing"
```
绿色闪烁区域表示发生重绘,频繁闪烁说明性能问题。

##### (3) Layers 面板

**查看合成层:**
```
DevTools → More tools → Layers
```
可以看到哪些元素被提升为独立图层,是否过度使用 `will-change`。

#### 3.2 Lighthouse

**运行审计:**
```
DevTools → Lighthouse → Analyze page load
```

**关注指标:**
- **FCP(First Contentful Paint)**:首次内容绘制
- **LCP(Largest Contentful Paint)**:最大内容绘制
- **CLS(Cumulative Layout Shift)**:累积布局偏移(应 < 0.1)

---

### 四、最佳实践总结

#### 优化清单

**DOM 操作层:**
- ✅ 批量修改样式(cssText 或 class)
- ✅ 使用 DocumentFragment 批量插入节点
- ✅ 复杂操作前先 `display: none` 离线处理
- ✅ 避免逐个读取布局属性

**CSS 层:**
- ✅ 使用 `transform` 和 `opacity` 做动画
- ✅ 适度使用 `will-change` 提示浏览器
- ✅ 使用 `contain` 属性隔离重排范围
- ✅ 简化选择器,减少嵌套层级

**JavaScript 层:**
- ✅ 使用 `requestAnimationFrame` 优化动画
- ✅ 高频事件使用防抖/节流
- ✅ 读写分离,避免强制同步布局
- ✅ 缓存 DOM 查询结果和计算值

**现代方案:**
- ✅ 大列表使用虚拟滚动
- ✅ 复杂计算使用 Web Workers
- ✅ 懒加载使用 Intersection Observer
- ✅ 使用 React/Vue 等框架的虚拟 DOM 优化

#### 性能优化思维导图

```
前端性能优化
├── 减少重排次数
│   ├── 批量操作(cssText/class/fragment)
│   ├── 离线操作(display:none/clone)
│   └── 读写分离(避免强制同步布局)
│
├── 降低重排成本
│   ├── 使用 GPU 加速(transform/opacity)
│   ├── 提升合成层(will-change)
│   └── 隔离影响范围(contain)
│
├── JavaScript 优化
│   ├── requestAnimationFrame
│   ├── 防抖节流
│   └── Web Workers
│
└── 架构优化
    ├── 虚拟滚动
    ├── 虚拟 DOM
    └── 组件懒加载
```

---

### 五、实战案例

#### 案例:优化一个实时搜索组件

**初始版本(性能差):**
```javascript
// ❌ 问题:
// 1. 每次输入都触发搜索
// 2. 直接操作 DOM,频繁重排
// 3. 未缓存查询结果
input.addEventListener('input', (e) => {
  const keyword = e.target.value;
  const results = searchData(keyword);  // 同步搜索,可能耗时

  const list = document.getElementById('results');
  list.innerHTML = '';  // 清空列表(触发重排)

  results.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    list.appendChild(li);  // 逐个插入(多次重排)
  });
});
```

**优化版本:**
```javascript
// ✅ 优化点:
// 1. 防抖减少搜索次数
// 2. 使用 DocumentFragment 批量操作
// 3. 异步搜索避免阻塞
// 4. 虚拟滚动处理大量结果
const debouncedSearch = debounce(async (keyword) => {
  const results = await searchDataAsync(keyword);  // 异步搜索
  renderResults(results);
}, 300);

input.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});

function renderResults(results) {
  const list = document.getElementById('results');
  const fragment = document.createDocumentFragment();

  // 只渲染前 50 条,超过使用虚拟滚动
  const displayResults = results.slice(0, 50);

  displayResults.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });

  // 一次性替换内容(只触发一次重排)
  list.innerHTML = '';
  list.appendChild(fragment);

  if (results.length > 50) {
    // 超过 50 条使用虚拟滚动
    initVirtualScroll(list, results);
  }
}
```

**性能对比:**
- 初始版本:输入 10 个字符触发 10 次搜索,100 个结果插入触发 100 次重排
- 优化版本:防抖后只触发 1-2 次搜索,批量插入只触发 1 次重排
- **性能提升:约 50-100 倍**

---

## 总结

优化前端运行时性能的核心是**减少重排和重绘的次数与成本**:

1. **理解原理**:清楚什么操作会触发重排/重绘
2. **批量操作**:减少触发次数
3. **硬件加速**:使用 GPU 降低成本
4. **现代技术**:虚拟 DOM、虚拟滚动、Web Workers
5. **持续监测**:使用 DevTools 发现瓶颈

性能优化不是一次性工作,而是需要在开发过程中持续关注,结合工具监测,针对性优化。
