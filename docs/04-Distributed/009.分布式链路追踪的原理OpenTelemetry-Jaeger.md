---
title: 分布式链路追踪的原理（OpenTelemetry、Jaeger）
tags:
  - 分布式系统
  - 分布式
status: robot
class: 分布式系统
slug: distributed-tracing-principles-opentelemetry-jaeger
ref:
---

## 核心要点

- **分布式链路追踪通过 TraceID + SpanID 关联微服务调用链**：每个请求分配唯一 TraceID，跨服务传递；每个操作单元生成 SpanID，父子关系构建调用树
- **OpenTelemetry 是 CNCF 的标准化可观测性框架**：统一 Trace、Metrics、Logs 三大支柱的数据采集、处理和导出，支持多种后端（Jaeger/Zipkin/Prometheus）
- **Jaeger 提供全链路可视化与性能分析**：存储 Trace 数据（Cassandra/Elasticsearch），提供 UI 查询慢请求、依赖关系图、性能瓶颈分析
- **链路追踪的核心价值**：故障快速定位（精确到具体服务和方法）、性能优化（识别慢调用）、依赖分析（服务拓扑图）、调用量统计

---

## 1. 分布式链路追踪原理

### 1.1 为什么需要链路追踪

在微服务架构中，一个用户请求可能经过数十个服务的协作才能完成。当出现性能问题或故障时，传统日志难以定位问题：

```
用户请求 → API 网关 → 订单服务 → 库存服务 → 支付服务 → 物流服务
                ↓           ↓           ↓           ↓
            用户服务    商品服务    优惠券服务    通知服务
```

**痛点**：
- 日志分散在多个服务，难以关联同一个请求
- 无法知道请求在哪个环节耗时过长
- 服务间依赖关系复杂，故障影响范围不明确

### 1.2 核心概念

#### Trace（追踪）
代表一次完整的请求链路，包含多个 Span。每个 Trace 有唯一的 **TraceID**。

```
Trace (TraceID: abc123)
  ├── Span A (订单服务)
  ├── Span B (库存服务)
  └── Span C (支付服务)
```

#### Span（跨度）
代表一次操作单元（如一次 RPC 调用、数据库查询、HTTP 请求）。包含：
- **SpanID**：当前 Span 的唯一标识
- **ParentSpanID**：父 Span 的 ID（构建调用树）
- **开始时间 + 结束时间**：计算耗时
- **标签（Tags）**：附加元数据（如 `http.method=GET`、`db.statement=SELECT`）
- **日志（Logs）**：记录事件（如异常堆栈）

#### Context Propagation（上下文传播）
通过 HTTP Header、gRPC Metadata 等将 TraceID 和 SpanID 传递到下游服务。

**示例 HTTP Header**：
```
traceparent: 00-abc123def456-1234567890abcdef-01
            │   │           │                └─ Flags
            │   │           └── ParentSpanID
            │   └── TraceID
            └── Version
```

### 1.3 数据流转过程

```
┌──────────┐      ┌──────────────┐      ┌─────────┐      ┌─────────┐
│ 应用服务 │─────>│ OpenTelemetry│─────>│ Jaeger  │─────>│ 存储层  │
│          │ SDK  │  Collector   │ gRPC │ Collector│      │Cassandra│
└──────────┘      └──────────────┘      └─────────┘      └─────────┘
                                                             │
                                                             ↓
                                                        ┌─────────┐
                                                        │ Jaeger  │
                                                        │   UI    │
                                                        └─────────┘
```

1. **应用埋点**：通过 SDK 自动或手动创建 Span
2. **数据采集**：SDK 将 Span 发送到 Collector
3. **数据处理**：Collector 聚合、采样、批处理
4. **存储**：写入时序数据库（Cassandra/Elasticsearch）
5. **查询分析**：通过 Jaeger UI 可视化

---

## 2. OpenTelemetry 详解

### 2.1 架构组件

OpenTelemetry（简称 OTel）是 CNCF 的标准化可观测性框架，整合了 OpenTracing 和 OpenCensus。

**核心组件**：
- **API**：定义数据模型和接口（语言无关）
- **SDK**：具体语言实现（Go/Java/Python 等）
- **Exporter**：导出器（支持 Jaeger、Zipkin、Prometheus 等）
- **Collector**：可选的中间代理（采样、过滤、聚合）

### 2.2 Go 语言集成示例

#### 安装依赖

```bash
go get go.opentelemetry.io/otel
go get go.opentelemetry.io/otel/sdk
go get go.opentelemetry.io/otel/exporters/jaeger
go get go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp
```

#### 初始化 Tracer Provider

```go
package main

import (
    "context"
    "log"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

func initTracer(serviceName string) func() {
    // 创建 Jaeger Exporter
    exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(
        jaeger.WithEndpoint("http://localhost:14268/api/traces"),
    ))
    if err != nil {
        log.Fatalf("failed to create Jaeger exporter: %v", err)
    }

    // 创建 Resource（服务元数据）
    res, err := resource.New(context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String(serviceName),
            semconv.ServiceVersionKey.String("v1.0.0"),
        ),
    )
    if err != nil {
        log.Fatalf("failed to create resource: %v", err)
    }

    // 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter), // 批量发送
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.AlwaysSample()), // 采样策略
    )

    otel.SetTracerProvider(tp)

    // 返回清理函数
    return func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            log.Printf("Error shutting down tracer provider: %v", err)
        }
    }
}

func main() {
    cleanup := initTracer("order-service")
    defer cleanup()

    // 业务代码...
}
```

#### 手动创建 Span

```go
import (
    "context"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

func CreateOrder(ctx context.Context, userID string) error {
    // 获取 Tracer
    tracer := otel.Tracer("order-service")

    // 创建 Span
    ctx, span := tracer.Start(ctx, "CreateOrder")
    defer span.End()

    // 添加属性
    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.String("operation", "create_order"),
    )

    // 模拟业务逻辑
    if err := checkInventory(ctx); err != nil {
        span.RecordError(err) // 记录错误
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    if err := processPayment(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetStatus(codes.Ok, "Order created successfully")
    return nil
}

func checkInventory(ctx context.Context) error {
    tracer := otel.Tracer("order-service")
    _, span := tracer.Start(ctx, "CheckInventory")
    defer span.End()

    // 调用库存服务（HTTP/gRPC）
    // TraceID 会自动通过 Header 传播到下游
    return nil
}
```

#### HTTP 自动埋点

```go
import (
    "net/http"
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

func main() {
    cleanup := initTracer("api-gateway")
    defer cleanup()

    // 使用 otelhttp 中间件自动创建 Span
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从 Context 中提取 Span
        span := trace.SpanFromContext(r.Context())
        span.SetAttributes(attribute.String("custom.key", "value"))

        w.Write([]byte("Hello, World!"))
    })

    // 自动追踪 HTTP 请求
    http.Handle("/api", otelhttp.NewHandler(handler, "api-endpoint"))

    http.ListenAndServe(":8080", nil)
}
```

#### 跨服务传播（HTTP Client）

```go
import (
    "net/http"
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

func callInventoryService(ctx context.Context) error {
    // 创建带追踪的 HTTP Client
    client := http.Client{
        Transport: otelhttp.NewTransport(http.DefaultTransport),
    }

    req, _ := http.NewRequestWithContext(ctx, "GET", "http://inventory-service/check", nil)

    // TraceID 会自动注入到 Header
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}
```

### 2.3 采样策略

生产环境中不可能追踪 100% 的请求，需要采样：

```go
import "go.opentelemetry.io/otel/sdk/trace"

// 始终采样（开发环境）
sdktrace.WithSampler(sdktrace.AlwaysSample())

// 按概率采样（10% 请求）
sdktrace.WithSampler(sdktrace.TraceIDRatioBased(0.1))

// 父级采样（跟随上游决策）
sdktrace.WithSampler(sdktrace.ParentBased(sdktrace.TraceIDRatioBased(0.1)))
```

---

## 3. Jaeger 架构与使用

### 3.1 组件架构

```
┌─────────┐     ┌──────────┐     ┌─────────┐     ┌──────────────┐
│  Agent  │────>│Collector │────>│ Storage │<────│ Query Service│
│ (可选)   │ UDP │          │gRPC │         │     │    + UI      │
└─────────┘     └──────────┘     └─────────┘     └──────────────┘
```

- **Agent**：部署在应用节点，接收 Span 并批量转发（UDP 协议，低延迟）
- **Collector**：聚合数据、验证、索引、存储
- **Storage**：支持 Cassandra、Elasticsearch、Kafka、内存
- **Query + UI**：查询 API 和 Web 界面

### 3.2 快速部署（Docker）

```bash
# 使用 All-in-One 镜像（开发环境）
docker run -d --name jaeger \
  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \
  -p 5775:5775/udp \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 14268:14268 \
  -p 14250:14250 \
  -p 9411:9411 \
  jaegertracing/all-in-one:1.50

# 访问 UI: http://localhost:16686
```

**端口说明**：
- `6831/udp`：Jaeger Agent（Thrift Compact）
- `14268`：Collector HTTP 端点
- `16686`：Jaeger UI

### 3.3 生产环境配置（Kubernetes）

```yaml
# jaeger-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger-collector
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: jaeger-collector
        image: jaegertracing/jaeger-collector:1.50
        env:
        - name: SPAN_STORAGE_TYPE
          value: elasticsearch
        - name: ES_SERVER_URLS
          value: http://elasticsearch:9200
        ports:
        - containerPort: 14268
---
apiVersion: v1
kind: Service
metadata:
  name: jaeger-collector
spec:
  ports:
  - port: 14268
    targetPort: 14268
  selector:
    app: jaeger-collector
```

### 3.4 UI 使用场景

#### 场景 1：排查慢请求

1. 在 Jaeger UI 选择服务 `order-service`
2. 设置查询条件：
   - `Min Duration > 2s`（超过 2 秒的请求）
   - `Tags: http.status_code=500`（失败请求）
3. 点击 Trace 查看瀑布流：
   ```
   order-service: /api/order [3.2s]
     ├─ CheckInventory [0.5s]
     ├─ ProcessPayment [2.5s]  ← 耗时最长
     └─ SendNotification [0.2s]
   ```

#### 场景 2：分析服务依赖

1. 点击 `Dependencies` 查看拓扑图
2. 识别调用关系：
   ```
   API Gateway ──> Order Service ──> Payment Service
                        │
                        └──> Inventory Service
   ```
3. 定位故障影响范围

#### 场景 3：对比性能

1. 选择两个时间段的 Trace
2. 使用 `Compare` 功能对比：
   - 优化前：`ProcessPayment` 耗时 2.5s
   - 优化后：`ProcessPayment` 耗时 0.3s

---

## 4. 最佳实践

### 4.1 Span 命名规范

```go
// ✅ 好的命名（明确操作类型）
tracer.Start(ctx, "HTTP GET /api/users")
tracer.Start(ctx, "SQL SELECT users WHERE id=?")
tracer.Start(ctx, "Redis GET user:123")

// ❌ 差的命名（模糊不清）
tracer.Start(ctx, "Operation")
tracer.Start(ctx, "DoSomething")
```

### 4.2 关键属性标记

```go
span.SetAttributes(
    semconv.HTTPMethodKey.String("GET"),
    semconv.HTTPURLKey.String("/api/users/123"),
    semconv.HTTPStatusCodeKey.Int(200),
    semconv.DBSystemKey.String("mysql"),
    semconv.DBStatementKey.String("SELECT * FROM users WHERE id=?"),
)
```

### 4.3 错误处理

```go
if err != nil {
    span.RecordError(err, trace.WithStackTrace(true))
    span.SetStatus(codes.Error, "Failed to process payment")
    return err
}
```

### 4.4 异步任务追踪

```go
func asyncTask(ctx context.Context) {
    // 提取 Trace Context
    traceCtx := trace.ContextWithSpanContext(
        context.Background(),
        trace.SpanContextFromContext(ctx),
    )

    go func() {
        _, span := tracer.Start(traceCtx, "AsyncTask")
        defer span.End()
        // 异步逻辑...
    }()
}
```

### 4.5 数据库查询追踪

```go
import "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"

// 自动追踪 SQL 查询
db, err := otelsql.Open("mysql", dsn,
    otelsql.WithAttributes(semconv.DBSystemMySQL),
)
```

---

## 5. 性能优化建议

1. **合理采样**：生产环境使用 1%-10% 采样率，高流量场景可降至 0.1%
2. **批量发送**：使用 `BatchSpanProcessor` 减少网络开销
3. **异步导出**：避免追踪影响主流程性能
4. **限制 Span 数量**：单个 Trace 不超过 1000 个 Span
5. **使用 Agent**：本地缓冲，减少 Collector 压力

---

## 总结

分布式链路追踪通过 **TraceID 全局关联 + Span 树构建调用链**，解决了微服务架构下的故障定位、性能分析难题。**OpenTelemetry** 提供了标准化的 SDK 和协议，**Jaeger** 作为成熟的后端提供了强大的可视化能力。在生产环境中，需要结合采样策略、异步导出、合理埋点来平衡可观测性与性能开销。
