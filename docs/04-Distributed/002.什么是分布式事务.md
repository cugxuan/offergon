---
title: 什么是分布式事务？2PC、3PC、TCC、Saga 的区别是什么？
tags:
  - 分布式
  - 分布式事务
  - 分布式系统
status: robot
class: 分布式系统
slug: distributed-transactions-2pc-3pc-tcc-saga-differences
ref:
---

**要点提炼:**
- 分布式事务保证多个服务/数据库操作的原子性,要么全部成功要么全部失败
- 2PC/3PC 是强一致性方案,性能差但保证一致性
- TCC/Saga 是最终一致性方案,性能好但实现复杂

## 什么是分布式事务

分布式事务是指事务操作跨越多个分布式系统节点,需要保证所有节点操作的原子性、一致性、隔离性和持久性(ACID)。

**典型场景:**
- 电商下单: 订单服务创建订单 + 库存服务扣减库存 + 积分服务增加积分
- 转账操作: A 账户扣款 + B 账户加款

## 2PC(Two-Phase Commit 两阶段提交)

**流程:**
1. **准备阶段**: 协调者询问所有参与者是否可以提交,参与者执行事务但不提交,返回 Yes/No
2. **提交阶段**: 如果所有参与者都返回 Yes,协调者发送提交命令;否则发送回滚命令

**优点:**
- 强一致性保证
- 实现相对简单

**缺点:**
- 同步阻塞,性能差
- 单点故障: 协调者宕机导致参与者一直阻塞
- 数据不一致: 提交阶段网络分区可能导致部分节点提交,部分未提交

## 3PC(Three-Phase Commit 三阶段提交)

**流程:**
1. **CanCommit**: 询问参与者是否可以执行事务
2. **PreCommit**: 参与者执行事务但不提交,进入预提交状态
3. **DoCommit**: 正式提交或回滚

**改进:**
- 引入超时机制,减少阻塞时间
- 增加 PreCommit 阶段,降低阻塞范围

**缺点:**
- 仍然存在数据不一致风险
- 性能开销更大

## TCC(Try-Confirm-Cancel 补偿事务)

**流程:**
1. **Try**: 预留资源,检查业务规则(如冻结库存)
2. **Confirm**: 确认操作,使用预留资源(如扣减冻结库存)
3. **Cancel**: 取消操作,释放预留资源(如解冻库存)

**优点:**
- 不依赖数据库事务,性能好
- 业务隔离性好,不阻塞其他事务

**缺点:**
- 实现复杂,需要为每个操作实现 Try/Confirm/Cancel 三个接口
- 需要保证幂等性和防悬挂

**适用场景:**
- 对一致性要求高但能接受短暂不一致
- 高并发场景(如秒杀、抢购)

## Saga 模式

**核心思想:**
将长事务拆分为多个本地事务,每个本地事务都有对应的补偿事务。如果某个步骤失败,执行之前所有步骤的补偿操作。

**两种实现方式:**

1. **事件编排(Choreography)**: 各服务监听事件,自行决定下一步
   - 优点: 去中心化,服务解耦
   - 缺点: 流程分散,难以理解和调试

2. **命令协调(Orchestration)**: 中央协调器控制流程
   - 优点: 流程清晰,易于管理
   - 缺点: 中心化,协调器可能成为瓶颈

**优点:**
- 长事务场景友好
- 性能好,无锁

**缺点:**
- 最终一致性,不保证隔离性
- 需要设计补偿逻辑
- 补偿可能失败,需要人工介入

## 方案对比

| 方案 | 一致性 | 性能 | 实现复杂度 | 适用场景 |
|------|--------|------|-----------|---------|
| 2PC/3PC | 强一致 | 差 | 中 | 低并发,强一致性要求 |
| TCC | 最终一致 | 好 | 高 | 高并发,短事务 |
| Saga | 最终一致 | 好 | 中 | 长事务,可接受短暂不一致 |

## 实践建议

1. **能不用分布式事务就不用**: 通过业务重构避免跨库操作
2. **优先使用本地消息表 + 定时任务**: 简单可靠
3. **高并发场景选择 TCC**: 如秒杀、支付
4. **长流程场景选择 Saga**: 如订单处理流程
5. **关键操作保留人工审核**: 作为最后的兜底方案
