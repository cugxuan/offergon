---
title: 什么是幂等性？如何设计幂等接口？
tags:
  - 分布式系统
status: robot
class: 分布式系统
slug: idempotency-interface-design
ref:
---

## 核心要点

- 幂等性是指同一个请求执行多次与执行一次的效果完全相同，不会因为重复执行而产生副作用
- 在分布式系统中，网络超时、重试机制、消息重复投递等场景都需要接口具备幂等性
- 常见实现方案包括：唯一ID去重、Token机制、状态机、乐观锁、分布式锁等
- 幂等性保证的是业务层面的一致性，而非技术层面简单的请求去重

## 详细解答

### 一、什么是幂等性

幂等性（Idempotence）是分布式系统设计中的重要概念，指无论一个操作执行多少次，其产生的结果都与执行一次的结果相同。

**数学定义**：`f(f(x)) = f(x)`

**业务场景示例**：
- 订单创建：用户点击"提交订单"按钮时，因网络延迟多次点击，应只创建一个订单
- 支付扣款：支付请求重试时，不应重复扣款
- 消息消费：MQ消息可能重复投递，消费端需保证处理幂等

### 二、为什么需要幂等性

1. **网络不可靠**：网络超时、丢包导致客户端重试
2. **分布式特性**：微服务间调用可能因故障重试
3. **消息队列**：MQ至少一次投递（At Least Once）保证
4. **用户行为**：用户重复点击、表单重复提交
5. **服务降级**：熔断恢复后的重试机制

### 三、幂等性实现方案

#### 1. 唯一ID去重（推荐）

客户端生成全局唯一的请求ID（如UUID），服务端通过Redis缓存已处理的请求ID。

**实现代码**：

```go
package idempotent

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
    "github.com/google/uuid"
)

type IdempotentService struct {
    rdb *redis.Client
}

func NewIdempotentService(rdb *redis.Client) *IdempotentService {
    return &IdempotentService{rdb: rdb}
}

// CheckAndMarkIdempotent 检查并标记请求幂等性
func (s *IdempotentService) CheckAndMarkIdempotent(ctx context.Context, requestID string) (bool, error) {
    if requestID == "" {
        return false, fmt.Errorf("requestID is required")
    }

    key := fmt.Sprintf("idempotent:request:%s", requestID)

    // 使用 SetNX 实现原子性检查和设置
    // 如果 key 不存在则设置成功返回 true，已存在返回 false
    success, err := s.rdb.SetNX(ctx, key, "1", 24*time.Hour).Result()
    if err != nil {
        return false, fmt.Errorf("redis setnx failed: %w", err)
    }

    return success, nil
}

// 订单创建示例
type OrderService struct {
    idempotent *IdempotentService
}

func (s *OrderService) CreateOrder(ctx context.Context, requestID string, orderData map[string]interface{}) error {
    // 检查幂等性
    isFirst, err := s.idempotent.CheckAndMarkIdempotent(ctx, requestID)
    if err != nil {
        return err
    }

    if !isFirst {
        // 重复请求，直接返回成功（或返回之前的结果）
        return nil
    }

    // 执行业务逻辑
    fmt.Println("Creating order:", orderData)
    // ... 数据库插入等操作

    return nil
}

// 客户端调用示例
func ExampleClient() {
    requestID := uuid.New().String()

    // 第一次调用
    // err := orderService.CreateOrder(ctx, requestID, orderData)

    // 重试调用（使用相同的 requestID）
    // err = orderService.CreateOrder(ctx, requestID, orderData) // 不会重复创建
}
```

#### 2. Token机制

服务端预先生成Token，客户端提交时携带，服务端验证并删除Token，保证一次性使用。

**实现代码**：

```go
package token

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
    "github.com/google/uuid"
)

type TokenService struct {
    rdb *redis.Client
}

func NewTokenService(rdb *redis.Client) *TokenService {
    return &TokenService{rdb: rdb}
}

// GenerateToken 生成操作令牌
func (s *TokenService) GenerateToken(ctx context.Context, userID string) (string, error) {
    token := uuid.New().String()
    key := fmt.Sprintf("token:%s:%s", userID, token)

    // 设置5分钟过期
    err := s.rdb.Set(ctx, key, "1", 5*time.Minute).Err()
    if err != nil {
        return "", err
    }

    return token, nil
}

// ConsumeToken 消费令牌（原子性删除）
func (s *TokenService) ConsumeToken(ctx context.Context, userID, token string) (bool, error) {
    key := fmt.Sprintf("token:%s:%s", userID, token)

    // 使用 Lua 脚本保证原子性
    script := `
        if redis.call('exists', KEYS[1]) == 1 then
            redis.call('del', KEYS[1])
            return 1
        else
            return 0
        end
    `

    result, err := s.rdb.Eval(ctx, script, []string{key}).Int()
    if err != nil {
        return false, err
    }

    return result == 1, nil
}

// 使用示例
type PaymentService struct {
    tokenSvc *TokenService
}

func (s *PaymentService) Pay(ctx context.Context, userID, token string, amount float64) error {
    // 尝试消费 Token
    valid, err := s.tokenSvc.ConsumeToken(ctx, userID, token)
    if err != nil {
        return err
    }

    if !valid {
        return fmt.Errorf("invalid or expired token")
    }

    // 执行支付逻辑
    fmt.Printf("Processing payment: user=%s, amount=%.2f\n", userID, amount)

    return nil
}
```

#### 3. 数据库唯一约束

利用数据库唯一索引防止重复插入。

```go
package database

import (
    "database/sql"
    "fmt"
)

type Order struct {
    ID        int64
    OrderNo   string // 唯一订单号
    UserID    int64
    Amount    float64
}

// CreateOrder 使用唯一约束防止重复创建
func CreateOrder(db *sql.DB, orderNo string, userID int64, amount float64) error {
    // 数据库表定义：
    // CREATE TABLE orders (
    //     id BIGINT PRIMARY KEY AUTO_INCREMENT,
    //     order_no VARCHAR(64) UNIQUE NOT NULL,  -- 唯一约束
    //     user_id BIGINT NOT NULL,
    //     amount DECIMAL(10,2) NOT NULL,
    //     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    // );

    query := `INSERT INTO orders (order_no, user_id, amount) VALUES (?, ?, ?)`

    _, err := db.Exec(query, orderNo, userID, amount)
    if err != nil {
        // 判断是否为唯一约束冲突
        if isDuplicateKeyError(err) {
            // 重复订单号，幂等处理
            return nil
        }
        return fmt.Errorf("insert order failed: %w", err)
    }

    return nil
}

func isDuplicateKeyError(err error) bool {
    // MySQL Error 1062: Duplicate entry
    // 根据具体数据库驱动判断
    return err != nil && (err.Error() == "Error 1062" ||
                          err.Error() == "UNIQUE constraint failed")
}
```

#### 4. 状态机 + 乐观锁

通过版本号控制并发更新，保证状态流转幂等。

```go
package statemachine

import (
    "database/sql"
    "fmt"
)

type OrderStatus int

const (
    OrderStatusPending   OrderStatus = 1  // 待支付
    OrderStatusPaid      OrderStatus = 2  // 已支付
    OrderStatusShipped   OrderStatus = 3  // 已发货
    OrderStatusCompleted OrderStatus = 4  // 已完成
)

type OrderEntity struct {
    ID      int64
    Status  OrderStatus
    Version int64  // 乐观锁版本号
}

// UpdateOrderStatus 使用乐观锁更新订单状态
func UpdateOrderStatus(db *sql.DB, orderID int64, fromStatus, toStatus OrderStatus) error {
    // 使用乐观锁 + 状态流转控制
    query := `
        UPDATE orders
        SET status = ?, version = version + 1, updated_at = NOW()
        WHERE id = ? AND status = ? AND version = (
            SELECT version FROM (SELECT version FROM orders WHERE id = ?) AS tmp
        )
    `

    result, err := db.Exec(query, toStatus, orderID, fromStatus, orderID)
    if err != nil {
        return fmt.Errorf("update failed: %w", err)
    }

    affected, err := result.RowsAffected()
    if err != nil {
        return err
    }

    if affected == 0 {
        // 状态已变更或版本冲突，重复请求
        return fmt.Errorf("order status already changed or concurrent update")
    }

    return nil
}

// PayOrder 支付订单（幂等）
func PayOrder(db *sql.DB, orderID int64) error {
    err := UpdateOrderStatus(db, orderID, OrderStatusPending, OrderStatusPaid)
    if err != nil {
        // 如果状态已经是 Paid，说明之前已支付成功
        var currentStatus OrderStatus
        db.QueryRow("SELECT status FROM orders WHERE id = ?", orderID).Scan(&currentStatus)

        if currentStatus == OrderStatusPaid {
            // 幂等返回成功
            return nil
        }

        return err
    }

    return nil
}
```

#### 5. 分布式锁

通过分布式锁保证同一业务在同一时刻只能被一个请求处理。

```go
package distlock

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

type DistributedLock struct {
    rdb *redis.Client
}

func NewDistributedLock(rdb *redis.Client) *DistributedLock {
    return &DistributedLock{rdb: rdb}
}

// Lock 获取分布式锁
func (d *DistributedLock) Lock(ctx context.Context, key string, expiration time.Duration) (bool, error) {
    return d.rdb.SetNX(ctx, key, "1", expiration).Result()
}

// Unlock 释放锁
func (d *DistributedLock) Unlock(ctx context.Context, key string) error {
    return d.rdb.Del(ctx, key).Err()
}

// WithLock 使用分布式锁执行业务逻辑
func (d *DistributedLock) WithLock(ctx context.Context, key string, fn func() error) error {
    lockKey := fmt.Sprintf("lock:%s", key)

    // 尝试获取锁，最多等待3秒
    for i := 0; i < 30; i++ {
        locked, err := d.Lock(ctx, lockKey, 10*time.Second)
        if err != nil {
            return err
        }

        if locked {
            defer d.Unlock(ctx, lockKey)
            return fn()
        }

        time.Sleep(100 * time.Millisecond)
    }

    return fmt.Errorf("acquire lock timeout")
}

// 使用示例：防止重复退款
type RefundService struct {
    lock *DistributedLock
}

func (s *RefundService) ProcessRefund(ctx context.Context, orderID int64) error {
    lockKey := fmt.Sprintf("refund:%d", orderID)

    return s.lock.WithLock(ctx, lockKey, func() error {
        // 检查订单状态
        // 执行退款逻辑
        fmt.Printf("Processing refund for order: %d\n", orderID)
        return nil
    })
}
```

### 四、方案选择对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 唯一ID去重 | 简单高效，无侵入性 | 需要客户端配合生成ID | 通用场景，推荐首选 |
| Token机制 | 安全性高，防止重放攻击 | 需要额外的Token获取接口 | 敏感操作（支付、退款） |
| 数据库唯一约束 | 可靠性高，无需额外存储 | 依赖数据库特性，错误处理复杂 | 创建类操作 |
| 状态机+乐观锁 | 并发控制好，业务语义清晰 | 实现复杂，需要设计状态流转 | 有明确状态流转的业务 |
| 分布式锁 | 强一致性保证 | 性能开销大，可能死锁 | 高并发竞争场景 |

### 五、最佳实践

1. **客户端生成全局唯一ID**：使用UUID、Snowflake等算法
2. **设置合理的幂等时间窗口**：根据业务特点设置缓存过期时间
3. **区分业务幂等和技术幂等**：
   - 技术幂等：请求去重
   - 业务幂等：结果一致性
4. **记录幂等日志**：便于排查问题
5. **幂等与返回结果一致性**：重复请求应返回相同的结果
6. **考虑异常情况**：
   - Redis故障降级策略
   - 数据库事务回滚后的幂等性
7. **RESTful接口幂等性**：
   - GET、PUT、DELETE 天然幂等
   - POST 需要额外设计

### 六、实际案例

**微信支付回调幂等处理**：

```go
package wechat

import (
    "context"
    "crypto/md5"
    "encoding/hex"
    "fmt"
)

type WechatPayCallback struct {
    OutTradeNo string  // 商户订单号
    TransactionID string  // 微信支付订单号
    TotalFee   int     // 总金额（分）
}

type PaymentHandler struct {
    idempotent *IdempotentService
}

// HandleWechatCallback 处理微信支付回调（幂等）
func (h *PaymentHandler) HandleWechatCallback(ctx context.Context, callback *WechatPayCallback) error {
    // 使用微信支付订单号作为幂等ID
    requestID := fmt.Sprintf("wechat_pay:%s", callback.TransactionID)

    isFirst, err := h.idempotent.CheckAndMarkIdempotent(ctx, requestID)
    if err != nil {
        return err
    }

    if !isFirst {
        // 重复回调，返回成功
        fmt.Println("Duplicate wechat callback, ignored")
        return nil
    }

    // 处理支付成功逻辑
    fmt.Printf("Processing payment: order=%s, amount=%d\n",
        callback.OutTradeNo, callback.TotalFee)

    // 更新订单状态
    // 发放会员权益
    // 发送通知等

    return nil
}
```

## 总结

幂等性是分布式系统必须考虑的设计原则，通过合理选择实现方案（唯一ID去重、Token机制、数据库约束、状态机、分布式锁），可以有效防止重复请求导致的数据不一致问题。在实际应用中，应根据业务特点、性能要求、可靠性需求综合选择最适合的方案。
