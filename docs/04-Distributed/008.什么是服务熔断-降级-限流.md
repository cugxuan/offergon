---
title: 什么是服务熔断、降级、限流？如何实现？
tags:
  - 分布式系统
status: robot
class: 分布式系统
slug: service-fuse-degrade-rate-limit-implementation
ref:
---

## 核心要点

- **限流**：控制请求速率，防止系统过载（令牌桶、漏桶算法）
- **熔断**：快速失败机制，阻止故障扩散（基于错误率/响应时间自动断路）
- **降级**：牺牲非核心功能，保障核心服务可用（返回兜底数据或简化逻辑）
- **三者配合**：限流是预防、熔断是止损、降级是兜底，形成完整的服务保护体系

## 详细解答

### 一、限流（Rate Limiting）

#### 1.1 定义与作用
限流是通过控制请求速率来保护系统资源，防止突发流量压垮服务。常见场景包括：
- API 接口保护（如每用户每秒最多 100 次请求）
- 数据库连接池限制
- 消息队列消费速率控制

#### 1.2 常见算法

**令牌桶算法（Token Bucket）**
- 固定速率向桶中添加令牌，桶满则丢弃
- 请求到达时消耗令牌，无令牌则拒绝
- 支持突发流量（桶容量范围内）

**漏桶算法（Leaky Bucket）**
- 请求进入队列，固定速率处理
- 队列满则拒绝新请求
- 流量整形，输出恒定

**固定窗口计数器**
- 在固定时间窗口内统计请求数
- 简单高效，但有临界突发问题

**滑动窗口计数器**
- 解决固定窗口的临界问题
- 时间窗口随请求时间滑动

#### 1.3 Go 实现示例

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"

    "golang.org/x/time/rate"
)

// 1. 使用标准库的令牌桶限流器
type TokenBucketLimiter struct {
    limiter *rate.Limiter
}

func NewTokenBucketLimiter(r rate.Limit, b int) *TokenBucketLimiter {
    // r: 每秒生成令牌数, b: 桶容量
    return &TokenBucketLimiter{
        limiter: rate.NewLimiter(r, b),
    }
}

func (t *TokenBucketLimiter) Allow() bool {
    return t.limiter.Allow()
}

func (t *TokenBucketLimiter) Wait(ctx context.Context) error {
    return t.limiter.Wait(ctx)
}

// 2. 滑动窗口限流器实现
type SlidingWindowLimiter struct {
    mu       sync.Mutex
    requests []time.Time
    limit    int           // 最大请求数
    window   time.Duration // 时间窗口
}

func NewSlidingWindowLimiter(limit int, window time.Duration) *SlidingWindowLimiter {
    return &SlidingWindowLimiter{
        requests: make([]time.Time, 0, limit),
        limit:    limit,
        window:   window,
    }
}

func (s *SlidingWindowLimiter) Allow() bool {
    s.mu.Lock()
    defer s.mu.Unlock()

    now := time.Now()
    cutoff := now.Add(-s.window)

    // 清理过期请求
    validIdx := 0
    for i, t := range s.requests {
        if t.After(cutoff) {
            validIdx = i
            break
        }
    }
    s.requests = s.requests[validIdx:]

    if len(s.requests) < s.limit {
        s.requests = append(s.requests, now)
        return true
    }
    return false
}

// 3. 分布式限流（基于 Redis）
type RedisRateLimiter struct {
    // redis.Client
    key    string
    limit  int
    window time.Duration
}

func (r *RedisRateLimiter) Allow() bool {
    // Lua 脚本保证原子性
    script := `
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])

        redis.call('ZREMRANGEBYSCORE', key, 0, now - window)
        local count = redis.call('ZCARD', key)

        if count < limit then
            redis.call('ZADD', key, now, now)
            redis.call('EXPIRE', key, window)
            return 1
        end
        return 0
    `
    // 执行 Lua 脚本...
    return true
}

// 使用示例
func main() {
    // 每秒 10 个令牌，桶容量 20
    limiter := NewTokenBucketLimiter(10, 20)

    for i := 0; i < 100; i++ {
        if limiter.Allow() {
            fmt.Printf("Request %d: Allowed\n", i)
        } else {
            fmt.Printf("Request %d: Rate limited\n", i)
        }
        time.Sleep(50 * time.Millisecond)
    }
}
```

### 二、熔断（Circuit Breaker）

#### 2.1 定义与作用
熔断器是一种自动保护机制，当检测到依赖服务故障率过高时，快速失败，避免雪崩效应。类似于电路保险丝。

#### 2.2 三种状态
- **Closed（关闭）**：正常请求通过，统计失败率
- **Open（打开）**：所有请求直接失败，不调用后端
- **Half-Open（半开）**：尝试部分请求，判断是否恢复

#### 2.3 状态转换条件
```
Closed → Open: 失败率超过阈值（如 50%）或连续失败次数过多
Open → Half-Open: 经过冷却时间（如 30 秒）
Half-Open → Closed: 试探请求成功
Half-Open → Open: 试探请求失败
```

#### 2.4 Go 实现示例

```go
package main

import (
    "context"
    "errors"
    "sync"
    "time"
)

type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

type CircuitBreaker struct {
    mu            sync.RWMutex
    state         State
    failureCount  int
    successCount  int
    lastFailTime  time.Time

    maxFailures   int           // 最大失败次数
    timeout       time.Duration // 冷却时间
    maxRequests   int           // Half-Open 状态最大试探次数
}

func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:       StateClosed,
        maxFailures: maxFailures,
        timeout:     timeout,
        maxRequests: 3,
    }
}

func (cb *CircuitBreaker) Call(ctx context.Context, fn func() error) error {
    if err := cb.beforeCall(); err != nil {
        return err
    }

    err := fn()
    cb.afterCall(err)
    return err
}

func (cb *CircuitBreaker) beforeCall() error {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    switch cb.state {
    case StateOpen:
        // 检查是否可以进入半开状态
        if time.Since(cb.lastFailTime) > cb.timeout {
            cb.state = StateHalfOpen
            cb.successCount = 0
            return nil
        }
        return errors.New("circuit breaker is open")

    case StateHalfOpen:
        // 限制试探请求数量
        if cb.successCount+cb.failureCount >= cb.maxRequests {
            return errors.New("too many requests in half-open state")
        }
    }

    return nil
}

func (cb *CircuitBreaker) afterCall(err error) {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err != nil {
        cb.onFailure()
    } else {
        cb.onSuccess()
    }
}

func (cb *CircuitBreaker) onSuccess() {
    switch cb.state {
    case StateClosed:
        cb.failureCount = 0

    case StateHalfOpen:
        cb.successCount++
        if cb.successCount >= cb.maxRequests {
            cb.state = StateClosed
            cb.failureCount = 0
            cb.successCount = 0
        }
    }
}

func (cb *CircuitBreaker) onFailure() {
    cb.lastFailTime = time.Now()

    switch cb.state {
    case StateClosed:
        cb.failureCount++
        if cb.failureCount >= cb.maxFailures {
            cb.state = StateOpen
        }

    case StateHalfOpen:
        cb.state = StateOpen
        cb.failureCount = 0
        cb.successCount = 0
    }
}

// 使用示例
func main() {
    cb := NewCircuitBreaker(3, 5*time.Second)

    unreliableService := func() error {
        // 模拟不稳定的服务
        if time.Now().Unix()%2 == 0 {
            return errors.New("service error")
        }
        return nil
    }

    for i := 0; i < 10; i++ {
        err := cb.Call(context.Background(), unreliableService)
        if err != nil {
            fmt.Printf("Request %d failed: %v\n", i, err)
        } else {
            fmt.Printf("Request %d succeeded\n", i)
        }
        time.Sleep(1 * time.Second)
    }
}
```

### 三、降级（Degradation）

#### 3.1 定义与作用
降级是在系统压力过大或依赖服务不可用时，主动关闭或简化非核心功能，保障核心业务可用。是一种有损服务策略。

#### 3.2 降级策略
- **返回默认值/缓存数据**：如推荐系统降级返回热门商品
- **关闭次要功能**：如关闭评论、点赞功能
- **同步改异步**：如订单确认改为消息队列异步处理
- **读写分离降级**：只读不写，或只写不读

#### 3.3 Go 实现示例

```go
package main

import (
    "context"
    "errors"
    "time"
)

type DegradationLevel int

const (
    LevelNormal DegradationLevel = iota
    LevelPartial                 // 部分降级
    LevelSevere                  // 严重降级
)

type ServiceDegrader struct {
    level         DegradationLevel
    cache         map[string]interface{}
    fallbackData  interface{}
}

func NewServiceDegrader() *ServiceDegrader {
    return &ServiceDegrader{
        level: LevelNormal,
        cache: make(map[string]interface{}),
    }
}

// 设置降级级别
func (sd *ServiceDegrader) SetLevel(level DegradationLevel) {
    sd.level = level
}

// 获取推荐列表（带降级）
func (sd *ServiceDegrader) GetRecommendations(ctx context.Context, userID string) ([]string, error) {
    switch sd.level {
    case LevelNormal:
        // 正常调用推荐服务
        return sd.callRecommendService(ctx, userID)

    case LevelPartial:
        // 部分降级：优先使用缓存
        if cached, ok := sd.cache[userID]; ok {
            return cached.([]string), nil
        }
        // 缓存未命中，返回热门商品
        return sd.getHotProducts(), nil

    case LevelSevere:
        // 严重降级：直接返回热门商品
        return sd.getHotProducts(), nil
    }

    return nil, errors.New("unknown degradation level")
}

func (sd *ServiceDegrader) callRecommendService(ctx context.Context, userID string) ([]string, error) {
    // 调用真实推荐服务，设置超时
    ctx, cancel := context.WithTimeout(ctx, 200*time.Millisecond)
    defer cancel()

    // 模拟服务调用
    result := []string{"personalized_1", "personalized_2", "personalized_3"}

    // 更新缓存
    sd.cache[userID] = result
    return result, nil
}

func (sd *ServiceDegrader) getHotProducts() []string {
    return []string{"hot_1", "hot_2", "hot_3"}
}

// 自动降级管理器
type AutoDegradeManager struct {
    degrader      *ServiceDegrader
    errorRate     float64
    checkInterval time.Duration
}

func (adm *AutoDegradeManager) Monitor() {
    ticker := time.NewTicker(adm.checkInterval)
    defer ticker.Stop()

    for range ticker.C {
        // 根据系统指标自动调整降级级别
        if adm.errorRate > 0.5 {
            adm.degrader.SetLevel(LevelSevere)
        } else if adm.errorRate > 0.2 {
            adm.degrader.SetLevel(LevelPartial)
        } else {
            adm.degrader.SetLevel(LevelNormal)
        }
    }
}
```

### 四、三者对比与配合使用

| 机制 | 触发条件 | 作用范围 | 恢复方式 | 典型场景 |
|------|----------|----------|----------|----------|
| 限流 | 请求速率超限 | 单个服务入口 | 立即（令牌恢复） | 防止突发流量、保护数据库 |
| 熔断 | 错误率/超时率过高 | 服务调用链路 | 自动试探恢复 | 依赖服务故障、网络抖动 |
| 降级 | 系统负载高/手动触发 | 业务功能级别 | 手动或自动恢复 | 大促流量、服务故障 |

#### 4.1 配合使用示例

```go
func HandleRequest(ctx context.Context, req *Request) (*Response, error) {
    // 1. 限流检查
    if !rateLimiter.Allow() {
        return nil, errors.New("rate limit exceeded")
    }

    // 2. 熔断保护
    var result *Response
    err := circuitBreaker.Call(ctx, func() error {
        var err error

        // 3. 根据降级级别调用不同逻辑
        switch degrader.GetLevel() {
        case LevelNormal:
            result, err = callFullService(ctx, req)
        case LevelPartial:
            result, err = callSimplifiedService(ctx, req)
        case LevelSevere:
            result = getFallbackResponse(req)
            err = nil
        }

        return err
    })

    return result, err
}
```

### 五、实践建议

#### 5.1 限流建议
- **分层限流**：全局限流 + 用户级限流 + IP 限流
- **动态调整**：根据系统负载自动调整限流阈值
- **优先级队列**：重要请求优先通过
- **监控告警**：限流触发时及时告警

#### 5.2 熔断建议
- **合理设置阈值**：失败率 50%+、超时时间 1-3 秒
- **快速失败**：避免长时间等待
- **监控可视化**：实时查看熔断器状态
- **降级配合**：熔断时自动触发降级

#### 5.3 降级建议
- **提前规划**：设计时明确核心/非核心功能
- **多级降级**：根据严重程度分级
- **自动+手动**：系统自动降级 + 人工干预能力
- **预案演练**：定期演练降级流程

#### 5.4 开源方案推荐
- **Go**: [hystrix-go](https://github.com/afex/hystrix-go)、[sentinel-go](https://github.com/alibaba/sentinel-golang)
- **Java**: Hystrix、Sentinel、Resilience4j
- **网关**: Kong、APISIX（内置限流熔断）
