---
title: 详细解释 Go 的 channel 底层实现原理，有缓冲和无缓冲 channel 的区别是什么？
tags:
  - Go
  - 并发
status: robot
class: Go
ref:
---

## 要点精炼

- **底层结构**：hchan 结构体（环形队列 + 发送/接收等待队列 + 互斥锁）
- **无缓冲 channel**：同步通信，发送和接收必须配对，否则阻塞
- **有缓冲 channel**：异步通信，缓冲区未满时发送不阻塞，缓冲区非空时接收不阻塞
- **核心机制**：数据直接拷贝 + goroutine 唤醒 + 调度切换

## 详细回答

### hchan 底层结构

```go
// runtime/chan.go
type hchan struct {
    qcount   uint           // 队列中元素个数
    dataqsiz uint           // 环形队列大小
    buf      unsafe.Pointer // 环形队列指针
    elemsize uint16         // 元素大小
    closed   uint32         // 关闭标志
    elemtype *_type         // 元素类型
    sendx    uint           // 发送索引
    recvx    uint           // 接收索引
    recvq    waitq          // 接收等待队列（sudog 链表）
    sendq    waitq          // 发送等待队列（sudog 链表）
    lock     mutex          // 保护所有字段的互斥锁
}

type waitq struct {
    first *sudog  // 等待队列头
    last  *sudog  // 等待队列尾
}
```

### 发送操作（ch <- v）

**流程：**
```
1. 加锁 hchan.lock
2. 情况 1：如果 recvq 非空（有等待接收的 goroutine）
   - 从 recvq 取出一个 sudog
   - 直接将数据拷贝给该 goroutine 的接收变量
   - 唤醒该 goroutine（goready）

3. 情况 2：如果缓冲区未满（qcount < dataqsiz）
   - 将数据拷贝到 buf[sendx]
   - sendx = (sendx + 1) % dataqsiz
   - qcount++

4. 情况 3：如果缓冲区已满（或无缓冲）
   - 将当前 goroutine 封装成 sudog
   - 加入 sendq 队列
   - 调用 gopark 挂起当前 goroutine
   - 等待被接收者唤醒

5. 解锁
```

### 接收操作（v := <-ch）

**流程：**
```
1. 加锁 hchan.lock
2. 情况 1：如果 sendq 非空（有等待发送的 goroutine）
   - 如果无缓冲：直接从发送者拷贝数据
   - 如果有缓冲：从 buf[recvx] 取数据，将发送者数据放入 buf[sendx]
   - 唤醒发送者 goroutine

3. 情况 2：如果缓冲区有数据（qcount > 0）
   - 从 buf[recvx] 拷贝数据
   - recvx = (recvx + 1) % dataqsiz
   - qcount--

4. 情况 3：如果缓冲区为空
   - 将当前 goroutine 封装成 sudog
   - 加入 recvq 队列
   - 调用 gopark 挂起
   - 等待被发送者唤醒

5. 解锁
```

### 有缓冲 vs 无缓冲

| 特性 | 无缓冲 `make(chan T)` | 有缓冲 `make(chan T, N)` |
|------|----------------------|-------------------------|
| dataqsiz | 0 | N |
| 通信方式 | 同步（必须配对） | 异步（缓冲区未满时不阻塞） |
| 发送阻塞条件 | 没有接收者时立即阻塞 | 缓冲区满时阻塞 |
| 接收阻塞条件 | 没有发送者时立即阻塞 | 缓冲区空时阻塞 |
| 典型用途 | 信号通知、同步点 | 限流、任务队列、生产者消费者 |
| 性能 | 每次操作都需要配对 | 减少 goroutine 切换 |

### 关闭 channel

```go
close(ch)
// 1. 设置 closed = 1
// 2. 唤醒所有 recvq 中的等待者（返回零值）
// 3. 唤醒所有 sendq 中的等待者（panic）
```

**关闭特性：**
- 已关闭的 channel 接收操作返回零值和 false
- 向已关闭的 channel 发送会 panic
- 关闭已关闭的 channel 会 panic
- 关闭 nil channel 会 panic

### 示例对比

**无缓冲 channel：**
```go
ch := make(chan int)

go func() {
    ch <- 42  // 阻塞，直到有接收者
    fmt.Println("sent")
}()

time.Sleep(1 * time.Second)
v := <-ch  // 接收，发送者被唤醒
fmt.Println("received:", v)
// 输出：received: 42
//      sent（1秒后）
```

**有缓冲 channel：**
```go
ch := make(chan int, 2)

ch <- 1  // 不阻塞
ch <- 2  // 不阻塞
ch <- 3  // 阻塞，缓冲区已满

fmt.Println(<-ch)  // 1
fmt.Println(<-ch)  // 2
fmt.Println(<-ch)  // 3（发送者此时被唤醒）
```

### 性能考虑

1. **锁开销**：每次操作都需要加锁，高并发下可能成为瓶颈
2. **内存拷贝**：数据在发送者、缓冲区、接收者之间拷贝
3. **调度开销**：阻塞和唤醒涉及 goroutine 调度切换
4. **优化建议**：
   - 批量操作减少锁竞争
   - 合理设置缓冲区大小
   - 考虑使用 sync.Pool 或无锁数据结构
