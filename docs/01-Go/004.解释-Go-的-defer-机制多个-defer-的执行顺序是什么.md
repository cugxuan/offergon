---
title: 解释 Go 的 defer 机制，多个 defer 的执行顺序是什么？defer 有哪些坑？
tags:
  - Go
  - 语言特性
status: robot
class: Go
slug: go-defer-mechanism-execution-order-pitfalls
ref:
---

## 要点精炼

- **执行时机**：defer 在函数返回前执行（return 之后，实际返回之前）
- **执行顺序**：LIFO（后进先出），类似栈结构
- **参数求值**：defer 注册时立即求值，而非执行时求值
- **常见陷阱**：循环中 defer、闭包捕获变量、命名返回值修改

## 详细回答

### 基本特性

**1. 执行顺序（LIFO）**
```go
func example() {
    defer fmt.Println("1")  // 第三个执行
    defer fmt.Println("2")  // 第二个执行
    defer fmt.Println("3")  // 第一个执行
    fmt.Println("body")
}
// 输出：body 3 2 1
```

**2. 参数预计算**
```go
func paramEval() {
    i := 0
    defer fmt.Println(i)  // 注册时 i=0，输出 0
    i++
    // defer 输出：0（而非 1）
}
```

**3. 可以读取/修改命名返回值**
```go
func modifyReturn() (result int) {
    defer func() {
        result++  // 可以修改返回值
    }()
    return 0  // 实际返回 1
}
```

### 底层实现

**Go 1.13 前：堆分配**
```go
type _defer struct {
    siz     int32   // 参数和结果的大小
    started bool    // defer 是否已执行
    sp      uintptr // 栈指针
    pc      uintptr // 程序计数器
    fn      *funcval // defer 函数
    _panic  *_panic
    link    *_defer  // 链表指针
}
// defer 链表头：当前 goroutine.defer
```

**Go 1.13+：开放编码优化**
- 简单场景（≤8 个 defer，无循环）：内联到函数尾部
- 延迟信息记录在栈上的延迟比特位
- 零开销或接近零开销

**Go 1.14+：栈上分配**
- 复杂场景使用栈分配而非堆分配
- 大幅降低内存分配和 GC 压力

### 常见陷阱

**1. 循环中的 defer（资源泄漏）**
```go
// ❌ 错误：所有文件在函数结束才关闭
func badLoop() error {
    for i := 0; i < 1000; i++ {
        f, err := os.Open(fmt.Sprintf("file%d.txt", i))
        if err != nil {
            return err
        }
        defer f.Close()  // 累积 1000 个 defer，占用 1000 个文件句柄
        // 处理文件...
    }
    return nil
}

// ✅ 正确：用匿名函数包裹
func goodLoop() error {
    for i := 0; i < 1000; i++ {
        err := func() error {
            f, err := os.Open(fmt.Sprintf("file%d.txt", i))
            if err != nil {
                return err
            }
            defer f.Close()  // 每次迭代结束关闭
            // 处理文件...
            return nil
        }()
        if err != nil {
            return err
        }
    }
    return nil
}
```

**2. 闭包捕获变量**
```go
// ❌ 错误：闭包捕获循环变量
func badClosure() {
    for i := 0; i < 3; i++ {
        defer func() {
            fmt.Println(i)  // 输出：3 3 3
        }()
    }
}

// ✅ 正确：传参或使用局部变量
func goodClosure1() {
    for i := 0; i < 3; i++ {
        defer func(n int) {
            fmt.Println(n)  // 输出：2 1 0
        }(i)
    }
}

func goodClosure2() {
    for i := 0; i < 3; i++ {
        i := i  // 创建新变量
        defer func() {
            fmt.Println(i)  // 输出：2 1 0
        }()
    }
}
```

**3. defer 与命名返回值**
```go
// 返回值顺序：赋值返回值 -> 执行 defer -> 返回
func returnOrder1() (result int) {
    defer func() {
        result++  // 修改返回值
    }()
    return 0  // result = 0 -> defer 将其改为 1 -> 返回 1
}

func returnOrder2() int {
    result := 0
    defer func() {
        result++  // 修改局部变量，不影响返回值
    }()
    return result  // 返回 0（return 会拷贝 result 的值）
}

func returnOrder3() (result int) {
    defer func() {
        result = 100  // 覆盖返回值
    }()
    return 10  // 实际返回 100
}
```

**4. defer 与 panic**
```go
func panicRecover() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("recovered:", r)
        }
    }()
    panic("oops")
    // defer 仍会执行，recover 捕获 panic
}

func multiDefer() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    panic("oops")
    defer fmt.Println("3")  // 不会执行
}
// 输出：2 1 panic: oops
```

**5. defer 与 os.Exit**
```go
func noDefer() {
    defer fmt.Println("will not run")
    os.Exit(1)  // 立即终止，defer 不执行
}
```

### 性能考虑

**开销对比（Go 1.14+）：**
```
无 defer：              基准
开放编码 defer（内联）：~0ns（几乎无开销）
栈上分配 defer：        ~35ns
堆上分配 defer：        ~50ns
```

**优化建议：**
- 简单场景（≤8 个，无循环）：编译器自动优化
- 避免在热路径大量使用 defer（如紧密循环内）
- 可以考虑显式清理代替 defer（性能敏感场景）

### 最佳实践

**1. 资源释放**
```go
func bestPractice() error {
    mu.Lock()
    defer mu.Unlock()  // 确保锁一定被释放

    f, err := os.Open("file.txt")
    if err != nil {
        return err
    }
    defer f.Close()  // 确保文件一定被关闭

    // 业务逻辑...
    return nil
}
```

**2. 错误处理**
```go
func transaction() (err error) {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer func() {
        if err != nil {
            tx.Rollback()  // 出错时回滚
        } else {
            err = tx.Commit()  // 成功时提交
        }
    }()

    // 数据库操作...
    return nil
}
```

**3. 性能追踪**
```go
func trace(name string) func() {
    start := time.Now()
    fmt.Printf("enter %s\n", name)
    return func() {
        fmt.Printf("exit %s (%s)\n", name, time.Since(start))
    }
}

func business() {
    defer trace("business")()
    // 业务逻辑...
}
```
