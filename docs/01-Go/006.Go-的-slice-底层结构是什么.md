---
title: Go 的 slice 底层结构是什么？append 扩容机制是怎样的？
tags:
  - Go
  - 数据结构
status: robot
class: Go
ref:
---

## 要点精炼

1. **三元组结构**：slice 由指针、长度、容量三个字段组成，本质是对底层数组的引用视图
2. **扩容策略**：容量小于 256 时翻倍，大于 256 时增长因子递减（1.25x 到 2x 之间），最终向上取整到内存类
3. **共享底层数组**：切片操作可能导致多个 slice 共享同一数组，修改会相互影响
4. **拷贝 vs 引用**：slice 作为函数参数是值传递但共享底层数组，append 可能改变指针导致分离

## 详细回答

### 一、Slice 的底层结构

Slice 的运行时表示定义在 `runtime/slice.go` 中：

```go
type slice struct {
    array unsafe.Pointer  // 指向底层数组的指针
    len   int             // 当前长度
    cap   int             // 容量（底层数组长度）
}
```

**示例说明**：

```go
s := make([]int, 3, 5)
// array: 指向长度为 5 的底层数组
// len: 3 (可访问的元素个数)
// cap: 5 (底层数组的总容量)

s = append(s, 4, 5)  // len = 5, cap = 5
s = append(s, 6)     // len = 6, cap = 10 (扩容)
```

### 二、Append 扩容机制

#### 1. 扩容策略（Go 1.18+）

```go
func growslice(et *_type, old slice, cap int) slice {
    newcap := old.cap
    doublecap := newcap + newcap

    if cap > doublecap {
        newcap = cap  // 如果需要的容量超过两倍，直接使用所需容量
    } else {
        const threshold = 256
        if old.cap < threshold {
            newcap = doublecap  // 小于 256，直接翻倍
        } else {
            // 大于 256，增长因子从 2.0 逐渐降到 1.25
            for 0 < newcap && newcap < cap {
                newcap += (newcap + 3*threshold) / 4
            }
            if newcap <= 0 {
                newcap = cap
            }
        }
    }

    // 根据元素大小对齐到内存类
    // ...
}
```

#### 2. 扩容示例

```go
// 容量变化演示
s := make([]int, 0)
for i := 0; i < 1024; i++ {
    s = append(s, i)
    if cap(s) != prevCap {
        fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))
        prevCap = cap(s)
    }
}

// 输出：
// len=1, cap=1
// len=2, cap=2
// len=3, cap=4
// len=5, cap=8
// len=9, cap=16
// ...
// len=257, cap=512
// len=513, cap=848    // 增长因子 < 2
// len=849, cap=1280
```

#### 3. 内存对齐

扩容后的容量会向上取整到内存分配的大小类（size class）：

```go
// 例如：需要 33 字节，但会分配 48 字节的内存块
// 这样 []int 的容量从理论的 8 变成实际的 12
```

### 三、Slice 的陷阱

#### 1. 共享底层数组

```go
func main() {
    s1 := []int{1, 2, 3, 4, 5}
    s2 := s1[1:3]  // s2 = [2, 3]

    s2[0] = 999
    fmt.Println(s1)  // [1, 999, 3, 4, 5] - s1 被修改！
}
```

**解决方案**：使用完整拷贝

```go
s2 := make([]int, len(s1[1:3]))
copy(s2, s1[1:3])
s2[0] = 999
fmt.Println(s1)  // [1, 2, 3, 4, 5] - s1 不受影响
```

#### 2. Append 导致的指针分离

```go
func appendValue(s []int) {
    s = append(s, 4)  // 可能扩容，改变 s 的指针
}

func main() {
    s := []int{1, 2, 3}
    appendValue(s)
    fmt.Println(s)  // [1, 2, 3] - 没有变化！
}
```

**解决方案**：返回新的 slice

```go
func appendValue(s []int) []int {
    return append(s, 4)
}

s = appendValue(s)  // 正确
```

#### 3. 切片泄漏

```go
func getHeader(data []byte) []byte {
    return data[:100]  // 保持对整个 data 的引用
}

// 如果 data 是 10MB，但只用前 100 字节，剩余 10MB 无法回收
```

**解决方案**：完整拷贝

```go
func getHeader(data []byte) []byte {
    header := make([]byte, 100)
    copy(header, data[:100])
    return header  // data 可以被 GC 回收
}
```

### 四、性能优化技巧

#### 1. 预分配容量

```go
// 差的做法
s := []int{}
for i := 0; i < 10000; i++ {
    s = append(s, i)  // 多次扩容
}

// 好的做法
s := make([]int, 0, 10000)
for i := 0; i < 10000; i++ {
    s = append(s, i)  // 无需扩容
}
```

#### 2. 使用索引替代 append

```go
// 如果知道最终长度
s := make([]int, 10000)
for i := 0; i < 10000; i++ {
    s[i] = i  // 比 append 更快
}
```

#### 3. 重用 slice

```go
// 避免重复分配
var buf []byte
for {
    buf = buf[:0]  // 重置长度，保留容量
    // 使用 buf...
}
```

### 五、Slice vs Array

| 特性 | Array | Slice |
|------|-------|-------|
| 类型 | 值类型 | 引用类型（指向数组） |
| 大小 | 固定，类型的一部分 | 动态，运行时确定 |
| 传参 | 拷贝整个数组 | 拷贝 24 字节（3个字段） |
| 使用场景 | 固定大小、栈分配 | 动态大小、常用场景 |

```go
// 数组
var a [5]int       // 栈分配，固定 5 个元素
b := a             // 完整拷贝

// 切片
s := make([]int, 5) // 堆分配
t := s              // 共享底层数组
```

### 六、最佳实践

1. **明确容量需求时预分配**：
   ```go
   s := make([]int, 0, expectedSize)
   ```

2. **避免意外共享**：
   ```go
   // 需要独立副本时
   dst := make([]T, len(src))
   copy(dst, src)
   ```

3. **使用三索引切片限制容量**：
   ```go
   s2 := s1[low:high:max]  // cap(s2) = max - low
   ```

4. **及时释放大对象**：
   ```go
   // 使用完大 slice 后
   bigSlice = nil
   ```

5. **范围循环注意指针**：
   ```go
   for i := range s {
       // 使用索引访问 s[i]，而非 for _, v := range s
   }
   ```
