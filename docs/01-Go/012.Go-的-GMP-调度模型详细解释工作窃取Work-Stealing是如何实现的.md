---
title: Go 的 GMP 调度模型详细解释，工作窃取（Work Stealing）是如何实现的？
tags:
  - Go
status: robot
class: Go
slug: gmp-scheduling-work-stealing-implementation
ref:
---

## 要点精炼

1. **GMP 模型组成**：G（Goroutine）是用户态线程、M（Machine）是系统线程、P（Processor）是调度器，P 数量默认等于 CPU 核心数
2. **调度流程**：G 必须绑定到 P 才能被 M 执行，P 维护本地队列（最多 256 个 G），全局队列作为补充
3. **工作窃取**：当 P 的本地队列为空时，会从其他 P 的本地队列尾部窃取一半的 G，提高 CPU 利用率
4. **系统调用处理**：M 进入系统调用时会与 P 解绑，P 可以绑定到其他 M 继续执行，避免阻塞

## 详细回答

### GMP 调度模型概述

Go 的 GMP 调度模型是一个 M:N 调度器，将 M 个 goroutine 调度到 N 个 OS 线程上执行。它解决了传统线程模型的两个问题：
1. 线程创建和切换成本高
2. 无法充分利用多核 CPU

#### 三个核心组件

**G (Goroutine)**
- 代表一个 goroutine，包含栈、指令指针、状态等信息
- 初始栈大小只有 2KB，可动态增长
- 结构体：`runtime.g`

**M (Machine)**
- 代表一个操作系统线程
- 负责执行 G 的代码
- 数量可动态增长，但有上限（默认 10000）
- 结构体：`runtime.m`

**P (Processor)**
- 代表调度的上下文，维护 G 的本地队列
- 数量由 GOMAXPROCS 决定，默认等于 CPU 核心数
- 包含本地可运行队列、mcache（内存缓存）等
- 结构体：`runtime.p`

### GMP 调度流程

```
┌─────────────────────────────────────────┐
│          Global Queue (全局队列)          │
│        存放等待运行的 Goroutine           │
└─────────────────────────────────────────┘
         ↑                    ↑
         │                    │
    ┌────┴────┐          ┌────┴────┐
    │    P0   │          │    P1   │
    │ Local Q │          │ Local Q │  ← P 的本地队列（最多 256 个 G）
    └────┬────┘          └────┬────┘
         │                    │
    ┌────┴────┐          ┌────┴────┐
    │    M0   │          │    M1   │  ← M 绑定 P 执行 G
    └────┬────┘          └────┬────┘
         │                    │
    ┌────┴────┐          ┌────┴────┐
    │    G1   │          │    G2   │  ← 正在执行的 Goroutine
    └─────────┘          └─────────┘
```

#### 调度时机

1. **主动调度**：调用 `runtime.Gosched()` 主动让出 CPU
2. **被动调度**：系统调用（syscall）、channel 阻塞、锁等待
3. **抢占调度**：G 运行时间过长（超过 10ms），被强制抢占

#### 调度策略

```go
// 伪代码展示调度逻辑
func schedule() {
    gp := findRunnable()  // 查找可运行的 G
    execute(gp)           // 执行 G
}

func findRunnable() *g {
    // 1. 每执行 61 次，从全局队列获取（防止饥饿）
    if schedtick % 61 == 0 {
        gp := globrunqget()  // 从全局队列获取
        if gp != nil {
            return gp
        }
    }

    // 2. 从 P 的本地队列获取
    gp := runqget(p)
    if gp != nil {
        return gp
    }

    // 3. 从全局队列获取
    gp = globrunqget()
    if gp != nil {
        return gp
    }

    // 4. 从网络轮询器获取就绪的 G
    gp = netpoll()
    if gp != nil {
        return gp
    }

    // 5. 工作窃取：从其他 P 偷取
    gp = stealWork()
    return gp
}
```

### 工作窃取（Work Stealing）机制

#### 为什么需要工作窃取

在多核系统中，不同的 P 负载可能不均衡：
- P0 的本地队列有 100 个 G
- P1 的本地队列空了

如果不做处理，P1 会闲置，造成 CPU 资源浪费。工作窃取就是让空闲的 P 从忙碌的 P 那里"偷"一些任务过来。

#### 工作窃取实现原理

```go
// 工作窃取的核心逻辑（简化版）
func stealWork(p *p) *g {
    // 随机选择一个起始 P
    offset := fastrand() % uint32(gomaxprocs)

    // 遍历所有 P（最多 4 轮）
    for i := 0; i < 4*gomaxprocs; i++ {
        // 计算要窃取的 P 索引
        victimP := allp[(offset + uint32(i)) % uint32(gomaxprocs)]

        if victimP == p {
            continue  // 跳过自己
        }

        // 从目标 P 的本地队列尾部窃取一半的 G
        gp := runqsteal(p, victimP)
        if gp != nil {
            return gp
        }
    }

    return nil
}

// 窃取逻辑：从 victim 的队列尾部拿一半
func runqsteal(p, victimP *p) *g {
    // 获取 victim 队列的一半
    n := len(victimP.runq) / 2

    if n == 0 {
        return nil
    }

    // 从尾部取出一半的 G
    var batch []*g
    for i := 0; i < n; i++ {
        gp := victimP.runq.pop()
        batch = append(batch, gp)
    }

    // 将窃取的 G 放入当前 P 的队列
    for _, gp := range batch[1:] {
        p.runq.push(gp)
    }

    // 返回第一个 G 立即执行
    return batch[0]
}
```

#### 工作窃取的关键特性

1. **从队尾窃取**：窃取者从队列尾部拿，所有者从队列头部拿，减少竞争
2. **窃取一半**：不是全部窃取，保持负载均衡
3. **随机选择**：随机选择起始 P，避免总是从同一个 P 窃取
4. **多轮尝试**：最多尝试 4 轮，增加成功率

### 系统调用处理

#### 阻塞式系统调用（如 read、write）

```go
// 当 G 执行系统调用时
func syscall() {
    // 1. M 与 P 解绑（handoffp）
    //    P 进入空闲状态或被其他 M 绑定
    handoffp(p)

    // 2. M 带着 G 进入系统调用
    //    此时 M 被阻塞，但不影响其他 G 的调度
    entersyscall()

    // 3. 系统调用返回后
    //    尝试重新绑定原来的 P，如果不行就绑定其他空闲 P
    exitsyscall()
}
```

#### 非阻塞式系统调用（网络 I/O）

Go 使用 netpoller（基于 epoll/kqueue）实现异步 I/O：

```go
// 网络 I/O 不会阻塞 M
func netRead() {
    // 1. 将 fd 注册到 netpoller
    pollDesc := netpollopen(fd)

    // 2. 如果数据未就绪，G 挂起，M 继续执行其他 G
    netpollblock(pollDesc)

    // 3. 数据就绪后，netpoller 唤醒 G，重新加入调度队列
}
```

### GMP 调度的优势

#### 1. 高效的用户态调度

```go
// 对比：内核线程切换需要保存/恢复大量寄存器
// Go 的 G 切换只需保存少量状态

type g struct {
    stack       stack     // 栈信息
    sched       gobuf     // 调度信息（PC、SP）
    goid        int64     // goroutine ID
    gopc        uintptr   // 创建位置
    // ... 其他字段很少
}

// 切换成本：几十纳秒 vs 几微秒（内核线程）
```

#### 2. 减少锁竞争

```go
// P 的本地队列无锁操作
func runqput(p *p, gp *g) {
    // 使用 lock-free 的 ring buffer
    // 只在队列满时才需要加锁放入全局队列
    h := atomic.LoadAcq(&p.runqhead)
    t := p.runqtail
    if t-h < uint32(len(p.runq)) {
        p.runq[t%uint32(len(p.runq))].set(gp)
        atomic.StoreRel(&p.runqtail, t+1)
        return
    }

    // 队列满，放入全局队列（需要加锁）
    runqputslow(p, gp)
}
```

#### 3. 充分利用多核

```go
// 示例：CPU 密集型任务
func main() {
    runtime.GOMAXPROCS(4)  // 设置 4 个 P

    for i := 0; i < 100; i++ {
        go func() {
            // CPU 密集型计算
            sum := 0
            for j := 0; j < 1000000; j++ {
                sum += j
            }
        }()
    }

    // 100 个 G 会被分配到 4 个 P 上
    // 通过工作窃取保持负载均衡
}
```

### 实际应用案例

#### 案例 1：理解 GOMAXPROCS 的影响

```go
func testGOMAXPROCS() {
    // CPU 密集型任务
    compute := func() {
        sum := 0
        for i := 0; i < 1e9; i++ {
            sum += i
        }
    }

    // GOMAXPROCS = 1：单核运行
    runtime.GOMAXPROCS(1)
    start := time.Now()
    for i := 0; i < 4; i++ {
        go compute()
    }
    time.Sleep(5 * time.Second)
    fmt.Printf("GOMAXPROCS=1: %v\n", time.Since(start))

    // GOMAXPROCS = 4：4 核并行
    runtime.GOMAXPROCS(4)
    start = time.Now()
    for i := 0; i < 4; i++ {
        go compute()
    }
    time.Sleep(5 * time.Second)
    fmt.Printf("GOMAXPROCS=4: %v\n", time.Since(start))
    // 输出：4 核版本明显更快
}
```

#### 案例 2：观察工作窃取

```go
func observeWorkStealing() {
    runtime.GOMAXPROCS(2)  // 2 个 P

    // P0 分配 100 个快速任务
    for i := 0; i < 100; i++ {
        go func(id int) {
            fmt.Printf("Task %d on P%d\n", id, getPID())
        }(i)
    }

    // P1 开始时可能空闲，会从 P0 窃取任务
    // 最终两个 P 都会执行约 50 个任务

    time.Sleep(1 * time.Second)
}
```

### 总结

GMP 调度模型是 Go 高并发性能的核心：
1. **G**：轻量级用户态线程，创建成本低
2. **M**：系统线程，数量可控
3. **P**：调度上下文，本地队列减少竞争
4. **工作窃取**：动态负载均衡，充分利用多核
5. **异步 I/O**：网络操作不阻塞 M

面试要点：
- 理解 G、M、P 的关系和作用
- 掌握调度时机和策略
- 能解释工作窃取的实现细节
- 了解系统调用的处理方式
