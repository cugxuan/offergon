---
title: Go 的 map 底层是如何实现的？为什么 map 不是线程安全的？
tags:
  - Go
  - 数据结构
status: robot
class: Go
ref:
---

## 要点精炼

1. **哈希表 + 桶结构**：map 使用哈希表实现，每个桶存储 8 个键值对，采用开放寻址法解决冲突
2. **渐进式扩容**：负载因子超过 6.5 或溢出桶过多时触发扩容，扩容过程是增量式的，分摊到多次操作中
3. **非线程安全**：map 读写没有加锁，并发读写会触发 panic（检测到并发写）
4. **无序迭代**：遍历 map 时会随机选择起始位置，保证迭代顺序的不确定性

## 详细回答

### 一、Map 的底层结构

Map 的核心结构定义在 `runtime/map.go` 中：

```go
// map 的头部结构
type hmap struct {
    count     int    // 元素个数
    flags     uint8  // 状态标志（是否在写入、迭代等）
    B         uint8  // 桶数组的大小为 2^B
    noverflow uint16 // 溢出桶的近似数量
    hash0     uint32 // 哈希种子

    buckets    unsafe.Pointer // 桶数组（2^B 个桶）
    oldbuckets unsafe.Pointer // 扩容时的老桶数组
    nevacuate  uintptr        // 扩容进度（小于此值的桶已迁移）

    extra *mapextra // 溢出桶等额外信息
}

// 每个桶的结构
type bmap struct {
    tophash [8]uint8  // 存储每个键哈希值的高 8 位
    // 后面紧跟：
    // keys     [8]keytype
    // values   [8]valuetype
    // overflow *bmap      // 溢出桶指针
}
```

**存储布局**：

```
┌─────────────┐
│    hmap     │
│  B = 2      │  // 2^2 = 4 个桶
│  count = 10 │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────┐
│  buckets array (2^B 个 bmap)        │
├─────────┬─────────┬─────────┬───────┤
│ bmap[0] │ bmap[1] │ bmap[2] │ bmap[3]│
└─────────┴─────────┴─────────┴───────┘
    │
    ▼ (溢出桶)
┌─────────┐
│overflow │
└─────────┘
```

### 二、哈希与寻址

#### 1. 哈希计算

```go
// 插入或查找时的哈希计算
func mapaccess(m *hmap, key) value {
    hash := m.hash0 ^ hashfunc(key)  // 计算哈希值

    // 确定桶位置
    bucket := hash & (1<<m.B - 1)    // hash % (2^B)
    b := (*bmap)(add(m.buckets, bucket*uintptr(t.bucketsize)))

    // 获取高 8 位用于快速比较
    top := tophash(hash)  // hash 的高 8 位

    // 在桶中查找
    for ; b != nil; b = b.overflow {
        for i := 0; i < 8; i++ {
            if b.tophash[i] != top {
                continue
            }
            k := (*keytype)(add(unsafe.Pointer(b), dataOffset+i*keysize))
            if key == *k {
                v := (*valuetype)(add(unsafe.Pointer(b), dataOffset+8*keysize+i*valuesize))
                return *v
            }
        }
    }
    return nil
}
```

#### 2. 寻址过程

1. 计算 key 的哈希值
2. 取哈希值的低 B 位确定桶号
3. 取哈希值的高 8 位作为 tophash
4. 在桶内顺序查找（比较 tophash，相同再比较完整 key）
5. 如果桶满了，查找溢出桶

### 三、扩容机制

#### 1. 扩容触发条件

```go
// 条件 1：负载因子 > 6.5 (元素过多)
if count > 6.5 * (1 << B) {
    // 翻倍扩容（B++）
}

// 条件 2：溢出桶过多（删除操作多，导致空洞）
if noverflow > (1 << (B & 15)) {
    // 等量扩容（B 不变，重新整理）
}
```

#### 2. 渐进式扩容

```go
// 扩容是增量的，不是一次性完成
func growWork(m *hmap, bucket uintptr) {
    evacuate(m, bucket)              // 迁移当前访问的桶
    if m.growing() {
        evacuate(m, m.nevacuate)      // 再迁移一个桶
    }
}
```

**扩容流程**：

1. 分配新的桶数组（大小为原来的 2 倍或相同）
2. 设置 `oldbuckets` 指向旧桶
3. 后续的每次写入或删除操作时，顺带迁移 1-2 个桶
4. 查找时需要同时查找新旧桶
5. 迁移完成后释放旧桶

**示例**：

```go
m := make(map[int]int)
for i := 0; i < 100; i++ {
    m[i] = i
    // 当 i = 14 时触发扩容 (13 * 6.5 ≈ 84)
    // 但扩容是增量的，不会阻塞
}
```

### 四、为什么 Map 不是线程安全的

#### 1. 并发写检测

```go
// 写操作时设置标志位
func mapassign(m *hmap, key, value) {
    if m.flags&hashWriting != 0 {
        throw("concurrent map writes")  // 检测到并发写
    }
    m.flags ^= hashWriting  // 设置写标志

    // ... 写入操作 ...

    m.flags &^= hashWriting  // 清除写标志
}
```

#### 2. 并发问题示例

```go
// 并发写会 panic
m := make(map[int]int)
go func() {
    for i := 0; i < 1000; i++ {
        m[i] = i
    }
}()
go func() {
    for i := 0; i < 1000; i++ {
        m[i] = i
    }
}()
// fatal error: concurrent map writes
```

#### 3. 为什么不加锁

1. **性能考虑**：大多数场景不需要并发访问，加锁会降低性能
2. **使用者选择**：需要并发时可使用 `sync.Map` 或自己加锁
3. **设计哲学**：Go 倾向于简单高效，将并发控制交给使用者

### 五、线程安全的替代方案

#### 1. sync.Map

```go
var m sync.Map

// 写入
m.Store("key", "value")

// 读取
value, ok := m.Load("key")

// 删除
m.Delete("key")

// 范围遍历
m.Range(func(key, value interface{}) bool {
    // 处理 key, value
    return true  // 返回 false 停止遍历
})
```

**适用场景**：
- 读多写少
- 键集合稳定（新增键不频繁）

#### 2. 互斥锁保护

```go
type SafeMap struct {
    mu sync.RWMutex
    m  map[string]int
}

func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    v, ok := sm.m[key]
    return v, ok
}

func (sm *SafeMap) Set(key string, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.m[key] = value
}
```

#### 3. 分片锁（性能更好）

```go
type ShardedMap struct {
    shards [32]struct {
        mu sync.RWMutex
        m  map[string]int
    }
}

func (sm *ShardedMap) getShard(key string) *struct {
    mu sync.RWMutex
    m  map[string]int
} {
    hash := fnv32(key)
    return &sm.shards[hash%32]
}
```

### 六、Map 的特性与陷阱

#### 1. 无序性

```go
m := map[int]string{1: "a", 2: "b", 3: "c"}
for k, v := range m {
    fmt.Println(k, v)  // 顺序不确定
}
// Go 1.0+: 随机选择起始位置，保证无序
```

#### 2. 零值可用

```go
var m map[string]int  // nil map，不能写入
m["key"] = 1          // panic: assignment to entry in nil map

m = make(map[string]int)  // 必须初始化
m["key"] = 1              // OK
```

#### 3. 删除不存在的键

```go
m := map[string]int{"a": 1}
delete(m, "b")  // 不会 panic，安全操作
```

#### 4. 不能取地址

```go
m := map[string]int{"a": 1}
p := &m["a"]  // 编译错误：cannot take address of map element
// 原因：扩容时元素可能移动位置
```

### 七、性能优化建议

1. **预估容量**：
   ```go
   m := make(map[string]int, 1000)  // 避免扩容
   ```

2. **使用高效的键类型**：
   ```go
   // 好：基本类型
   map[int]string
   map[string]int

   // 避免：复杂类型（哈希慢）
   map[[1000]byte]string
   ```

3. **避免频繁删除**：
   ```go
   // 如果需要频繁清空，直接重新创建
   m = make(map[string]int)
   ```

4. **读多写少用 sync.Map**：
   ```go
   var cache sync.Map  // 比 map + RWMutex 更快
   ```

### 八、最佳实践

1. **检查键是否存在**：
   ```go
   if v, ok := m[key]; ok {
       // 键存在，使用 v
   }
   ```

2. **并发安全**：
   ```go
   // 简单场景：互斥锁
   // 读多写少：sync.Map
   // 高性能：分片锁
   ```

3. **避免 nil map**：
   ```go
   // 好的做法
   m := make(map[string]int)

   // 或者
   var m map[string]int
   if m == nil {
       m = make(map[string]int)
   }
   ```

4. **顺序遍历需排序**：
   ```go
   keys := make([]string, 0, len(m))
   for k := range m {
       keys = append(keys, k)
   }
   sort.Strings(keys)
   for _, k := range keys {
       fmt.Println(k, m[k])
   }
   ```
