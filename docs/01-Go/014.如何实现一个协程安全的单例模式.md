---
title: 如何实现一个协程安全的单例模式？
tags:
  - Go
status: robot
class: Go
slug: thread-safe-singleton-pattern
ref:
---

## 要点精炼

1. **sync.Once 方案**：最推荐的方式，利用 sync.Once 保证初始化函数只执行一次，性能好且代码简洁
2. **双重检查锁**：先无锁检查，再加锁检查，减少锁竞争，但在 Go 中不如 sync.Once 简洁
3. **init 函数**：在包初始化时创建，最简单但不支持延迟初始化和错误处理
4. **channel 方案**：使用 channel 控制初始化，适合需要异步初始化的场景

## 详细回答

### 单例模式概述

单例模式确保一个类只有一个实例，并提供全局访问点。在 Go 中，由于 goroutine 的并发特性，实现线程安全的单例需要特别注意。

### 方案一：sync.Once（推荐）

这是 Go 中实现单例最标准、最优雅的方式。

```go
package singleton

import "sync"

type Singleton struct {
    data string
}

var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{
            data: "singleton instance",
        }
    })
    return instance
}

// 使用示例
func Example() {
    s1 := GetInstance()
    s2 := GetInstance()
    fmt.Println(s1 == s2)  // true，同一个实例
}
```

#### sync.Once 工作原理

```go
// sync.Once 的简化实现
type Once struct {
    done uint32
    m    Mutex
}

func (o *Once) Do(f func()) {
    // 快速路径：原子读取，无锁
    if atomic.LoadUint32(&o.done) == 0 {
        o.doSlow(f)
    }
}

func (o *Once) doSlow(f func()) {
    o.m.Lock()
    defer o.m.Unlock()

    // 双重检查
    if o.done == 0 {
        defer atomic.StoreUint32(&o.done, 1)
        f()
    }
}
```

#### 优势

- 线程安全且性能高（只在第一次调用时加锁）
- 代码简洁，符合 Go 习惯
- 标准库保证，经过充分测试

### 方案二：双重检查锁（Double-Checked Locking）

虽然可行，但在 Go 中不如 sync.Once 优雅。

```go
package singleton

import "sync"

type Singleton struct {
    data string
}

var (
    instance *Singleton
    mu       sync.Mutex
)

func GetInstance() *Singleton {
    // 第一次检查（无锁）
    if instance == nil {
        mu.Lock()
        defer mu.Unlock()

        // 第二次检查（加锁后）
        if instance == nil {
            instance = &Singleton{
                data: "singleton instance",
            }
        }
    }
    return instance
}
```

#### 问题

在 Go 中，上述代码实际上有问题，因为编译器可能会重排指令：

```go
// 不安全的写法
instance = &Singleton{data: "test"}

// 可能被重排为：
// 1. 分配内存
// 2. instance 指向内存（此时对象未初始化）
// 3. 初始化对象

// 其他 goroutine 可能看到 instance != nil 但对象未初始化
```

正确的双重检查需要使用 atomic：

```go
package singleton

import (
    "sync"
    "sync/atomic"
    "unsafe"
)

type Singleton struct {
    data string
}

var (
    instance unsafe.Pointer
    mu       sync.Mutex
)

func GetInstance() *Singleton {
    // 原子读取
    ptr := atomic.LoadPointer(&instance)
    if ptr == nil {
        mu.Lock()
        defer mu.Unlock()

        ptr = atomic.LoadPointer(&instance)
        if ptr == nil {
            s := &Singleton{data: "singleton"}
            atomic.StorePointer(&instance, unsafe.Pointer(s))
            ptr = unsafe.Pointer(s)
        }
    }
    return (*Singleton)(ptr)
}
```

### 方案三：init 函数

最简单的方式，包初始化时创建。

```go
package singleton

type Singleton struct {
    data string
}

var instance *Singleton

func init() {
    instance = &Singleton{
        data: "singleton instance",
    }
}

func GetInstance() *Singleton {
    return instance
}
```

#### 优缺点

优点：
- 最简单，无需考虑并发
- Go 保证 init 只执行一次

缺点：
- 不支持延迟初始化（lazy initialization）
- 无法处理初始化错误
- 增加启动时间

### 方案四：Channel 控制

适合异步初始化场景。

```go
package singleton

type Singleton struct {
    data string
}

var (
    instance *Singleton
    initChan = make(chan struct{})
)

func init() {
    go func() {
        // 模拟耗时初始化
        time.Sleep(100 * time.Millisecond)
        instance = &Singleton{data: "singleton"}
        close(initChan)
    }()
}

func GetInstance() *Singleton {
    <-initChan  // 等待初始化完成
    return instance
}
```

### 带错误处理的单例

实际应用中，初始化可能失败，需要返回错误。

```go
package singleton

import (
    "errors"
    "sync"
)

type Database struct {
    conn string
}

var (
    dbInstance *Database
    dbOnce     sync.Once
    dbErr      error
)

func GetDatabase() (*Database, error) {
    dbOnce.Do(func() {
        db, err := initDatabase()
        if err != nil {
            dbErr = err
            return
        }
        dbInstance = db
    })

    if dbErr != nil {
        return nil, dbErr
    }
    return dbInstance, nil
}

func initDatabase() (*Database, error) {
    // 模拟数据库连接
    conn := "localhost:3306"
    if conn == "" {
        return nil, errors.New("database connection failed")
    }
    return &Database{conn: conn}, nil
}
```

### 支持重置的单例

有时需要在测试中重置单例。

```go
package singleton

import "sync"

type Config struct {
    value string
}

var (
    config     *Config
    configOnce sync.Once
    configMu   sync.RWMutex
)

func GetConfig() *Config {
    configMu.RLock()
    defer configMu.RUnlock()

    configOnce.Do(func() {
        config = &Config{value: "default"}
    })
    return config
}

// 仅用于测试
func ResetConfig() {
    configMu.Lock()
    defer configMu.Unlock()

    config = nil
    configOnce = sync.Once{}  // 重置 Once
}
```

### 泛型单例（Go 1.18+）

使用泛型实现通用的单例模式。

```go
package singleton

import "sync"

type Singleton[T any] struct {
    instance *T
    once     sync.Once
}

func (s *Singleton[T]) GetInstance(initializer func() *T) *T {
    s.once.Do(func() {
        s.instance = initializer()
    })
    return s.instance
}

// 使用示例
type Logger struct {
    name string
}

var loggerSingleton Singleton[Logger]

func GetLogger() *Logger {
    return loggerSingleton.GetInstance(func() *Logger {
        return &Logger{name: "app-logger"}
    })
}
```

### 实际应用案例

#### 案例 1：配置管理器

```go
package config

import (
    "encoding/json"
    "os"
    "sync"
)

type Manager struct {
    settings map[string]interface{}
}

var (
    manager *Manager
    once    sync.Once
)

func GetManager() *Manager {
    once.Do(func() {
        manager = &Manager{
            settings: make(map[string]interface{}),
        }
        manager.load()
    })
    return manager
}

func (m *Manager) load() {
    data, _ := os.ReadFile("config.json")
    json.Unmarshal(data, &m.settings)
}

func (m *Manager) Get(key string) interface{} {
    return m.settings[key]
}
```

#### 案例 2：数据库连接池

```go
package database

import (
    "database/sql"
    "sync"
)

type Pool struct {
    db *sql.DB
}

var (
    pool *Pool
    once sync.Once
)

func GetPool() (*Pool, error) {
    var err error
    once.Do(func() {
        db, e := sql.Open("mysql", "user:pass@/dbname")
        if e != nil {
            err = e
            return
        }
        db.SetMaxOpenConns(100)
        pool = &Pool{db: db}
    })
    return pool, err
}

func (p *Pool) Query(query string) (*sql.Rows, error) {
    return p.db.Query(query)
}
```

#### 案例 3：日志记录器

```go
package logger

import (
    "log"
    "os"
    "sync"
)

type Logger struct {
    *log.Logger
}

var (
    instance *Logger
    once     sync.Once
)

func GetLogger() *Logger {
    once.Do(func() {
        file, err := os.OpenFile("app.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil {
            file = os.Stdout
        }
        instance = &Logger{
            Logger: log.New(file, "[APP] ", log.LstdFlags),
        }
    })
    return instance
}

// 全局函数
func Info(msg string) {
    GetLogger().Println("[INFO]", msg)
}

func Error(msg string) {
    GetLogger().Println("[ERROR]", msg)
}
```

### 性能对比

```go
package singleton

import (
    "sync"
    "testing"
)

// sync.Once 实现
func BenchmarkOnce(b *testing.B) {
    var once sync.Once
    var instance *Singleton

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            once.Do(func() {
                instance = &Singleton{}
            })
            _ = instance
        }
    })
}

// 双重检查锁
func BenchmarkDoubleCheck(b *testing.B) {
    var mu sync.Mutex
    var instance *Singleton

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            if instance == nil {
                mu.Lock()
                if instance == nil {
                    instance = &Singleton{}
                }
                mu.Unlock()
            }
            _ = instance
        }
    })
}

// 结果：sync.Once 性能明显更好
// BenchmarkOnce-8          1000000000    0.25 ns/op
// BenchmarkDoubleCheck-8   100000000     10.5 ns/op
```

### 最佳实践

1. **首选 sync.Once**：简洁、安全、高性能
2. **考虑延迟初始化**：只有在真正需要时才创建
3. **处理初始化错误**：返回 error，不要 panic
4. **避免全局状态**：如果可能，使用依赖注入而不是单例
5. **测试友好**：提供重置方法供测试使用

### 反模式警告

```go
// 不要这样做：使用 nil 检查而不加锁
func BadGetInstance() *Singleton {
    if instance == nil {  // 竞态条件！
        instance = &Singleton{}
    }
    return instance
}

// 不要这样做：每次都加锁
func SlowGetInstance() *Singleton {
    mu.Lock()
    defer mu.Unlock()
    if instance == nil {
        instance = &Singleton{}
    }
    return instance
}
```

### 总结

Go 中实现协程安全单例的最佳方式是使用 `sync.Once`：
- 线程安全，性能优异
- 代码简洁，易于维护
- 标准库支持，久经考验

其他方案各有适用场景：
- init 函数：最简单，但不支持延迟加载
- 双重检查：性能较好，但代码复杂
- channel：适合异步初始化

面试要点：
- 理解为什么需要并发安全
- 掌握 sync.Once 的用法和原理
- 能写出支持错误处理的单例
- 了解各种方案的优缺点
