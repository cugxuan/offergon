---
title: Go 的 testing 包和 benchmark 最佳实践
tags:
  - Go
status: robot
class: Go
slug: go-testing-benchmark-best-practices
ref:
---

## 要点精炼

1. **testing 包功能**：提供单元测试（Test）、基准测试（Benchmark）、示例测试（Example）、模糊测试（Fuzz），支持并行测试和子测试
2. **Benchmark 原理**：自动调整运行次数（b.N）达到统计显著性，测量 CPU 时间、内存分配、操作次数等指标
3. **最佳实践**：使用 Table-Driven Tests、testify 断言库、mock 隔离依赖、基准测试使用 b.ResetTimer 排除初始化开销
4. **性能分析**：结合 pprof 分析热点、使用 benchstat 对比优化效果、避免编译器优化干扰（使用全局变量接收结果）

## 详细回答

### 1. 单元测试基础

#### 1.1 测试函数规范

```go
// math.go
package math

func Add(a, b int) int {
    return a + b
}

func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// math_test.go
package math

import "testing"

// 测试函数必须以 Test 开头，参数为 *testing.T
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5

    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}

func TestDivide(t *testing.T) {
    // 正常情况
    result, err := Divide(10, 2)
    if err != nil {
        t.Fatalf("Divide(10, 2) unexpected error: %v", err)
    }
    if result != 5.0 {
        t.Errorf("Divide(10, 2) = %f; want 5.0", result)
    }

    // 错误情况
    _, err = Divide(10, 0)
    if err == nil {
        t.Error("Divide(10, 0) expected error, got nil")
    }
}

// 运行测试
// go test                    # 运行所有测试
// go test -v                 # 详细输出
// go test -run TestAdd       # 只运行特定测试
// go test -cover             # 代码覆盖率
```

#### 1.2 Table-Driven Tests（表驱动测试）

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative numbers", -2, -3, -5},
        {"mixed", 5, -3, 2},
        {"zero", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d",
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

#### 1.3 子测试和并行测试

```go
func TestFeatures(t *testing.T) {
    // 并行运行子测试
    t.Run("FeatureA", func(t *testing.T) {
        t.Parallel() // 标记为并行
        // 测试 Feature A
    })

    t.Run("FeatureB", func(t *testing.T) {
        t.Parallel()
        // 测试 Feature B
    })
}

// 运行特定子测试
// go test -run TestFeatures/FeatureA
```

### 2. Benchmark 基准测试

#### 2.1 基础用法

```go
// Benchmark 函数必须以 Benchmark 开头，参数为 *testing.B
func BenchmarkAdd(b *testing.B) {
    // b.N 会自动调整到合适的值
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}

// 运行基准测试
// go test -bench=.                   # 运行所有基准测试
// go test -bench=BenchmarkAdd        # 运行特定基准测试
// go test -bench=. -benchtime=5s     # 运行 5 秒
// go test -bench=. -benchmem         # 显示内存分配统计
```

输出示例：
```
BenchmarkAdd-8    1000000000    0.25 ns/op
```
解释：
- `BenchmarkAdd-8`: 函数名-GOMAXPROCS
- `1000000000`: b.N 的值（执行次数）
- `0.25 ns/op`: 每次操作耗时

#### 2.2 ResetTimer 和 StopTimer

```go
func BenchmarkComplexOperation(b *testing.B) {
    // 准备测试数据（不计入测试时间）
    data := prepareData()

    // 重置计时器，排除初始化时间
    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        // 暂停计时器（需要排除某些操作）
        b.StopTimer()
        setupForIteration()
        b.StartTimer()

        // 被测试的代码
        processData(data)
    }
}
```

#### 2.3 内存分配测试

```go
func BenchmarkStringConcat(b *testing.B) {
    b.ReportAllocs() // 报告内存分配

    for i := 0; i < b.N; i++ {
        var s string
        for j := 0; j < 100; j++ {
            s += "a"
        }
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        var sb strings.Builder
        for j := 0; j < 100; j++ {
            sb.WriteString("a")
        }
        _ = sb.String()
    }
}

// 输出
// BenchmarkStringConcat-8    50000    35000 ns/op    54000 B/op    99 allocs/op
// BenchmarkStringBuilder-8  500000     2500 ns/op      512 B/op     1 allocs/op
```

#### 2.4 并行基准测试

```go
func BenchmarkParallel(b *testing.B) {
    // 测试并发性能
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            // 每个 goroutine 执行的代码
            Add(2, 3)
        }
    })
}

// go test -bench=BenchmarkParallel -cpu=1,2,4,8
```

### 3. 完整的测试示例

```go
// user.go
package user

import (
    "errors"
    "regexp"
)

type User struct {
    ID    int
    Email string
    Name  string
}

var emailRegex = regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)

func ValidateEmail(email string) error {
    if !emailRegex.MatchString(email) {
        return errors.New("invalid email")
    }
    return nil
}

// user_test.go
package user

import (
    "testing"
)

func TestValidateEmail(t *testing.T) {
    tests := []struct {
        name    string
        email   string
        wantErr bool
    }{
        {"valid email", "test@example.com", false},
        {"valid with plus", "test+tag@example.com", false},
        {"invalid - no @", "testexample.com", true},
        {"invalid - no domain", "test@", true},
        {"invalid - no TLD", "test@example", true},
        {"empty", "", true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateEmail(tt.email)
            if (err != nil) != tt.wantErr {
                t.Errorf("ValidateEmail(%q) error = %v, wantErr %v",
                    tt.email, err, tt.wantErr)
            }
        })
    }
}

func BenchmarkValidateEmail(b *testing.B) {
    email := "test@example.com"
    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        ValidateEmail(email)
    }
}
```

### 4. 使用 testify 库

```bash
go get github.com/stretchr/testify
```

```go
package user

import (
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestUserWithTestify(t *testing.T) {
    user := &User{
        ID:    1,
        Email: "test@example.com",
        Name:  "Test User",
    }

    // assert：失败后继续执行
    assert.Equal(t, 1, user.ID)
    assert.Equal(t, "test@example.com", user.Email)

    // require：失败后立即停止
    require.NotNil(t, user)
    require.NoError(t, ValidateEmail(user.Email))

    // 更多断言
    assert.Contains(t, user.Email, "@")
    assert.Len(t, user.Name, 9)
    assert.True(t, user.ID > 0)
}
```

### 5. Mock 和依赖注入

```go
// repository.go
package user

type UserRepository interface {
    GetByID(id int) (*User, error)
    Save(user *User) error
}

type UserService struct {
    repo UserRepository
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) GetUser(id int) (*User, error) {
    return s.repo.GetByID(id)
}

// repository_test.go (使用 testify/mock)
package user

import (
    "errors"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock 实现
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) GetByID(id int) (*User, error) {
    args := m.Called(id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) Save(user *User) error {
    args := m.Called(user)
    return args.Error(0)
}

// 测试
func TestUserService_GetUser(t *testing.T) {
    // 创建 mock
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    // 设置期望
    expectedUser := &User{ID: 1, Name: "Test"}
    mockRepo.On("GetByID", 1).Return(expectedUser, nil)
    mockRepo.On("GetByID", 999).Return(nil, errors.New("not found"))

    // 测试成功场景
    user, err := service.GetUser(1)
    assert.NoError(t, err)
    assert.Equal(t, expectedUser, user)

    // 测试失败场景
    _, err = service.GetUser(999)
    assert.Error(t, err)

    // 验证 mock 被正确调用
    mockRepo.AssertExpectations(t)
}
```

### 6. 避免 Benchmark 陷阱

#### 6.1 编译器优化干扰

```go
// 错误：结果未使用，可能被优化掉
func BenchmarkBad(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3) // 结果未使用，编译器可能优化
    }
}

// 正确：使用全局变量接收结果
var result int

func BenchmarkGood(b *testing.B) {
    var r int
    for i := 0; i < b.N; i++ {
        r = Add(2, 3)
    }
    result = r // 防止优化
}
```

#### 6.2 循环内分配

```go
// 慢：每次循环都分配
func BenchmarkAllocInLoop(b *testing.B) {
    for i := 0; i < b.N; i++ {
        data := make([]int, 1000)
        processData(data)
    }
}

// 快：复用分配
func BenchmarkReuseAlloc(b *testing.B) {
    data := make([]int, 1000)
    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        processData(data)
    }
}
```

### 7. 代码覆盖率

```bash
# 生成覆盖率报告
go test -cover

# 详细覆盖率
go test -coverprofile=coverage.out
go tool cover -html=coverage.out

# 查看覆盖率（命令行）
go tool cover -func=coverage.out
```

### 8. 性能对比工具：benchstat

```bash
# 安装
go install golang.org/x/perf/cmd/benchstat@latest

# 运行基准测试并保存结果
go test -bench=. -count=10 > old.txt

# 优化代码后再次测试
go test -bench=. -count=10 > new.txt

# 对比结果
benchstat old.txt new.txt
```

输出示例：
```
name      old time/op  new time/op  delta
Add-8     0.25ns ± 2%  0.20ns ± 1%  -20.00%  (p=0.000 n=10+10)

name      old alloc/op  new alloc/op  delta
Add-8     0.00B         0.00B         ~
```

### 9. 模糊测试（Go 1.18+）

```go
func FuzzValidateEmail(f *testing.F) {
    // 添加种子语料库
    f.Add("test@example.com")
    f.Add("invalid")

    // 模糊测试函数
    f.Fuzz(func(t *testing.T, email string) {
        err := ValidateEmail(email)
        // 不应该 panic
        _ = err
    })
}

// 运行模糊测试
// go test -fuzz=FuzzValidateEmail -fuzztime=30s
```

### 10. 最佳实践总结

#### 10.1 测试组织

```
project/
├── pkg/
│   ├── user/
│   │   ├── user.go
│   │   ├── user_test.go          # 单元测试
│   │   └── user_integration_test.go  # 集成测试
│   └── ...
└── testdata/                      # 测试数据文件
    └── users.json
```

#### 10.2 命名规范

```go
// 测试函数
func TestAdd(t *testing.T)                // 基础测试
func TestAdd_NegativeNumbers(t *testing.T) // 特定场景

// 基准测试
func BenchmarkAdd(b *testing.B)
func BenchmarkAdd_Large(b *testing.B)

// 示例测试
func ExampleAdd() {
    fmt.Println(Add(2, 3))
    // Output: 5
}
```

#### 10.3 编写可测试的代码

```go
// 不好：难以测试
func ProcessUser() {
    db := openDatabase()       // 硬编码依赖
    user := db.GetUser(1)
    sendEmail(user.Email)      // 副作用
}

// 好：依赖注入，易于测试
func ProcessUser(db Database, emailSender EmailSender, userID int) error {
    user, err := db.GetUser(userID)
    if err != nil {
        return err
    }
    return emailSender.Send(user.Email)
}
```

#### 10.4 常用测试技巧

```go
// 1. 临时目录
func TestFileOperation(t *testing.T) {
    tmpDir := t.TempDir() // 自动清理
    // 使用 tmpDir
}

// 2. Cleanup 函数
func TestWithCleanup(t *testing.T) {
    resource := acquireResource()
    t.Cleanup(func() {
        releaseResource(resource)
    })
    // 测试逻辑
}

// 3. Helper 函数
func assertEqual(t *testing.T, got, want int) {
    t.Helper() // 标记为辅助函数，错误报告在调用处
    if got != want {
        t.Errorf("got %d, want %d", got, want)
    }
}

// 4. 跳过测试
func TestSomething(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping in short mode")
    }
    // 长时间运行的测试
}
```

### 11. 完整示例：HTTP Handler 测试

```go
// handler.go
package api

import (
    "encoding/json"
    "net/http"
)

type Handler struct {
    userService UserService
}

func (h *Handler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")

    user, err := h.userService.GetByID(id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }

    json.NewEncoder(w).Encode(user)
}

// handler_test.go
package api

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestHandler_GetUser(t *testing.T) {
    // 创建 mock service
    mockService := new(MockUserService)
    handler := &Handler{userService: mockService}

    // 设置期望
    expectedUser := &User{ID: "1", Name: "Test"}
    mockService.On("GetByID", "1").Return(expectedUser, nil)

    // 创建测试请求
    req := httptest.NewRequest("GET", "/user?id=1", nil)
    w := httptest.NewRecorder()

    // 执行处理函数
    handler.GetUser(w, req)

    // 验证响应
    assert.Equal(t, http.StatusOK, w.Code)

    var user User
    json.Unmarshal(w.Body.Bytes(), &user)
    assert.Equal(t, expectedUser.Name, user.Name)

    mockService.AssertExpectations(t)
}
```

### 12. 性能优化检查清单

```go
// ✓ 使用 b.ResetTimer()
// ✓ 避免循环内分配
// ✓ 使用全局变量防止优化
// ✓ 运行多次取平均值（-count=10）
// ✓ 使用 benchstat 对比
// ✓ 结合 pprof 分析
// ✓ 测试不同输入规模
// ✓ 并行基准测试（-cpu=1,2,4,8）

// 完整的 benchmark 模板
func BenchmarkOptimized(b *testing.B) {
    // 1. 准备数据
    data := prepareTestData()

    // 2. 重置计时器
    b.ResetTimer()
    b.ReportAllocs()

    // 3. 运行基准测试
    var result int
    for i := 0; i < b.N; i++ {
        result = processData(data)
    }

    // 4. 防止优化
    globalResult = result
}

var globalResult int
```

这份完整的答案涵盖了 Go testing 包和 benchmark 的所有核心概念、最佳实践和实战技巧，适合面试场景使用。
