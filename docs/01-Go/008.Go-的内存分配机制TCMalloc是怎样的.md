---
title: Go 的内存分配机制（TCMalloc）是怎样的？什么是内存逃逸？
tags:
  - Go
  - 内存管理
status: robot
class: Go
ref:
---

## 要点精炼

1. **三级缓存结构**：借鉴 TCMalloc，使用 mcache（线程缓存）、mcentral（中心缓存）、mheap（堆分配）三级结构，减少锁竞争
2. **大小分类**：将内存分为微对象（< 16B）、小对象（16B-32KB）、大对象（> 32KB），采用不同的分配策略
3. **内存逃逸**：编译器分析变量生命周期，栈上变量若被外部引用或过大会逃逸到堆，可通过 `go build -gcflags=-m` 分析
4. **span 管理**：以页（8KB）为单位管理内存，多个页组成 span，span 按对象大小分为 67 个等级

## 详细回答

### 一、Go 内存分配器架构

Go 的内存分配器受 TCMalloc 启发，采用多级缓存结构：

```
┌─────────────────────────────────────────┐
│         应用程序申请内存                  │
└────────────────┬────────────────────────┘
                 │
        ┌────────┴────────┐
        │ 微对象 < 16B    │
        │ 小对象 16B-32KB │
        │ 大对象 > 32KB   │
        └────────┬────────┘
                 │
    ┌────────────┼────────────┐
    │            │            │
    ▼            ▼            ▼
┌────────┐  ┌────────┐  ┌────────┐
│mcache  │  │mcache  │  │mcache  │ ← 每个 P 独享
│(P0)    │  │(P1)    │  │(Pn)    │   无锁访问
└───┬────┘  └───┬────┘  └───┬────┘
    │           │           │
    └───────────┼───────────┘
                │ (缓存不足)
                ▼
        ┌────────────┐
        │  mcentral  │ ← 全局缓存
        │  (有锁)    │   按 spanClass 分类
        └──────┬─────┘
               │ (内存不足)
               ▼
        ┌────────────┐
        │   mheap    │ ← 全局堆
        │  (页管理)  │   向 OS 申请内存
        └────────────┘
```

### 二、核心数据结构

#### 1. mcache - 线程级缓存

```go
// 每个 P（处理器）关联一个 mcache
type mcache struct {
    alloc [numSpanClasses]*mspan  // 67*2 = 134 个 span 链表
    // numSpanClasses = 67 种大小 * 2（scan/noscan）
}
```

- **无锁分配**：每个 P 独享 mcache，无需加锁
- **span 分类**：按对象大小分为 67 个等级（8B, 16B, 32B, ..., 32KB）
- **scan/noscan**：区分含指针（需 GC 扫描）和不含指针的对象

#### 2. mcentral - 中心缓存

```go
type mcentral struct {
    spanclass spanClass
    partial  [2]spanSet  // 有空闲对象的 span 列表
    full     [2]spanSet  // 无空闲对象的 span 列表
}
```

- **全局共享**：所有 P 共享，需要加锁
- **按类别管理**：每个 spanClass 一个 mcentral

#### 3. mheap - 全局堆

```go
type mheap struct {
    lock      mutex
    pages     pageAlloc       // 页分配器
    central   [numSpanClasses]mcentral
    arenas    [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena
}
```

- **页级管理**：以 8KB 页为单位
- **arena 结构**：64MB 的 arena 块，方便扩展
- **大对象分配**：直接从 mheap 分配

### 三、分配流程

#### 1. 微对象分配（< 16B）

```go
// 微对象分配器
func mallocgc(size uintptr, typ *_type) unsafe.Pointer {
    if size < 16 && typ.ptrdata == 0 {  // 无指针的微对象
        off := c.tinyoffset
        if off+size <= maxTinySize && c.tiny != 0 {
            // 从 tiny 块中分配
            x := add(c.tiny, off)
            c.tinyoffset = off + size
            return x
        }
        // tiny 块不足，申请新的 16B 块
        span := c.alloc[tinySpanClass]
        v := nextFreeFast(span)
        if v == 0 {
            v = nextFree(span)  // 从 mcentral 获取
        }
        c.tiny = v
        c.tinyoffset = size
        return v
    }
    // ...
}
```

**特点**：
- 多个微对象共享一个 16B 的内存块
- 减少内存碎片
- 仅限无指针对象（避免 GC 扫描复杂度）

#### 2. 小对象分配（16B - 32KB）

```go
// 1. 根据大小确定 spanClass
sizeclass := size_to_class8[size/8]
spanClass := makeSpanClass(sizeclass, noscan)

// 2. 从 mcache 获取对应的 span
span := c.alloc[spanClass]

// 3. 从 span 中分配对象
v := nextFreeFast(span)
if v == 0 {
    // mcache 中的 span 已满
    v, span = c.nextFree(spanClass)  // 从 mcentral 补充
}
return v
```

**步骤**：
1. 计算 spanClass（67 个等级）
2. 从 mcache 的对应 span 中快速分配
3. span 不足时从 mcentral 获取新 span
4. mcentral 不足时从 mheap 申请

#### 3. 大对象分配（> 32KB）

```go
func largeAlloc(size uintptr) *mspan {
    // 直接从 mheap 分配，跳过 mcache/mcentral
    npages := size >> pageShift
    s := mheap.alloc(npages, spanClass)
    return s
}
```

**特点**：
- 绕过 mcache 和 mcentral
- 直接从 mheap 分配多个连续页
- 大对象分配和释放较慢（需要加锁）

### 四、Span 和 Size Class

#### 1. Span 结构

```go
type mspan struct {
    startAddr uintptr  // 起始地址
    npages    uintptr  // 页数（每页 8KB）
    spanclass spanClass

    allocBits  *gcBits  // 分配位图
    allocCount uint16   // 已分配对象数
    nelems     uint16   // 总对象数

    freeindex  uintptr  // 下一个空闲对象的索引
}
```

#### 2. Size Class 表（部分）

| class | bytes/obj | bytes/span | objects | waste |
|-------|-----------|------------|---------|-------|
| 1     | 8         | 8192       | 1024    | 0%    |
| 2     | 16        | 8192       | 512     | 0%    |
| 3     | 24        | 8192       | 341     | 0.69% |
| 4     | 32        | 8192       | 256     | 0%    |
| ...   | ...       | ...        | ...     | ...   |
| 66    | 28672     | 57344      | 2       | 0%    |
| 67    | 32768     | 32768      | 1       | 0%    |

**规律**：
- 对象越小，每个 span 包含的对象越多
- 大对象的 span 占用更多页
- 设计目标：平衡内存利用率和分配效率

### 五、内存逃逸分析

#### 1. 什么是内存逃逸

```go
// 逃逸到堆
func escape() *int {
    x := 42
    return &x  // x 的地址被返回，逃逸到堆
}

// 不逃逸
func noEscape() int {
    x := 42
    return x  // 值拷贝，x 在栈上
}
```

#### 2. 逃逸场景

```go
// 场景 1：返回指针
func foo() *int {
    x := 42
    return &x  // 逃逸
}

// 场景 2：赋值给接口
func bar() interface{} {
    x := 42
    return x  // 逃逸（接口需要存储类型信息）
}

// 场景 3：赋值给外部指针
func baz(p **int) {
    x := 42
    *p = &x  // 逃逸
}

// 场景 4：对象过大
func large() {
    var x [100000]int  // 逃逸（超过栈大小限制）
}

// 场景 5：闭包引用
func closure() func() int {
    x := 42
    return func() int {
        return x  // x 逃逸
    }
}

// 场景 6：slice/map 的动态扩容
func dynamic() {
    s := make([]int, 10000)  // 逃逸
    m := make(map[int]int)   // 逃逸
}
```

#### 3. 逃逸分析工具

```bash
# 查看逃逸分析结果
go build -gcflags="-m -m" main.go

# 输出示例：
# ./main.go:5:6: x escapes to heap
# ./main.go:5:6:   from ~r0 (return) at ./main.go:6:2
```

#### 4. 避免逃逸的技巧

```go
// 1. 避免返回指针
func good() int {
    x := 42
    return x  // 值传递，不逃逸
}

// 2. 使用具体类型而非接口
func typed(x int) int {
    return x  // 不逃逸
}

// 3. 预分配容量
func prealloc() {
    s := make([]int, 0, 100)  // 小对象可能不逃逸
}

// 4. 使用 sync.Pool 复用对象
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}
```

### 六、GC 与内存回收

#### 1. 标记清除

Go 使用三色标记法：
- **白色**：未标记（待回收）
- **灰色**：已标记，子对象未扫描
- **黑色**：已标记，子对象已扫描

#### 2. 写屏障

```go
// 插入写屏障（Go 1.8+）
writePointer(slot, ptr) {
    shade(ptr)  // 将 ptr 标记为灰色
    *slot = ptr
}
```

#### 3. GC 触发时机

- 内存分配达到阈值（默认 GOGC=100，即堆增长 100%）
- 2 分钟未触发 GC（强制触发）
- 手动调用 `runtime.GC()`

### 七、性能优化建议

1. **减少内存分配**：
   ```go
   // 避免频繁分配
   var buf bytes.Buffer
   buf.Reset()  // 复用
   ```

2. **使用对象池**：
   ```go
   var pool = sync.Pool{
       New: func() interface{} {
           return new(MyStruct)
       },
   }
   ```

3. **预分配切片/map**：
   ```go
   s := make([]int, 0, 1000)
   m := make(map[int]int, 1000)
   ```

4. **避免不必要的逃逸**：
   ```go
   // 使用值接收者
   func (s MyStruct) Method() { }

   // 避免返回指针
   func GetValue() MyStruct { }
   ```

5. **分析内存使用**：
   ```go
   import _ "net/http/pprof"
   // 访问 /debug/pprof/heap
   ```

### 八、对比 TCMalloc

| 特性 | Go 分配器 | TCMalloc |
|------|----------|----------|
| 线程缓存 | mcache（每 P） | ThreadCache（每线程） |
| 中心缓存 | mcentral | CentralCache |
| 页堆 | mheap | PageHeap |
| 小对象 | 67 个 size class | 88 个 size class |
| GC 集成 | 内置 | 无 |

**主要区别**：
- Go 与 goroutine 调度器深度集成
- Go 的 GC 需要更多元数据（扫描位图等）
- Go 针对 GC 优化了对象布局
