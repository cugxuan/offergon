---
title: Go 的 interface 底层是如何实现的？空接口和非空接口有什么区别？
tags:
  - Go
  - 接口
status: robot
class: Go
slug: go-interface-implementation-empty-vs-non-empty
ref:
---

## 要点精炼

1. **两种实现**：空接口用 `eface`（只有类型信息），非空接口用 `iface`（包含类型信息和方法表）
2. **动态分派**：非空接口通过 `itab` 结构的方法表实现运行时多态，避免每次查找方法
3. **类型断言原理**：通过比较接口中存储的动态类型信息实现类型判断和转换
4. **性能考量**：接口调用比直接调用慢（需查表），空接口装箱可能导致堆分配

## 详细回答

### 一、接口的底层结构

Go 的接口在运行时有两种不同的表示形式：

#### 1. 空接口 (eface)

空接口 `interface{}` 的底层结构定义在 `runtime/runtime2.go` 中：

```go
type eface struct {
    _type *_type          // 动态类型信息
    data  unsafe.Pointer  // 动态值的指针
}
```

- `_type`：指向类型元数据，包含类型的大小、hash、对齐等信息
- `data`：指向实际数据的指针

#### 2. 非空接口 (iface)

非空接口（定义了方法的接口）的底层结构：

```go
type iface struct {
    tab  *itab           // 接口表
    data unsafe.Pointer  // 动态值的指针
}

type itab struct {
    inter *interfacetype  // 接口类型信息
    _type *_type          // 动态类型信息
    hash  uint32          // 类型 hash，用于快速类型断言
    _     [4]byte
    fun   [1]uintptr      // 方法表（可变长度）
}
```

**itab 的作用**：
- 缓存了接口类型和动态类型的映射关系
- `fun` 数组存储了具体类型实现的方法地址，实现动态分派
- itab 会被缓存，相同的类型-接口组合会复用同一个 itab

### 二、方法调用的实现

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type File struct{}

func (f *File) Read(p []byte) (n int, err error) {
    // 实现
    return 0, nil
}

func main() {
    var r Reader = &File{}
    r.Read(nil)  // 动态分派
}
```

当调用 `r.Read()` 时：
1. 从 `iface` 的 `tab` 字段获取 `itab`
2. 从 `itab.fun` 中找到对应方法的地址（编译时确定索引）
3. 调用该方法，传入 `iface.data` 作为 receiver

### 三、类型断言的实现

```go
// 类型断言
if f, ok := r.(*File); ok {
    // 使用 f
}

// 类型判断
switch v := r.(type) {
case *File:
    // 处理 File
case *Buffer:
    // 处理 Buffer
}
```

**实现原理**：
- 编译器生成对 `runtime` 包函数的调用（如 `assertI2I`、`assertE2I`）
- 运行时比较接口中的 `_type` 和目标类型
- 对于非空接口，还需要检查 `itab.hash` 和方法集

### 四、空接口 vs 非空接口

| 特性 | 空接口 (eface) | 非空接口 (iface) |
|------|----------------|------------------|
| 结构大小 | 16 字节（2个指针） | 16 字节（2个指针） |
| 方法调用 | 不支持 | 支持动态分派 |
| 类型断言成本 | 较低（只比较类型） | 稍高（需检查方法集） |
| 使用场景 | 泛型容器、反射 | 多态、依赖注入 |

### 五、性能考量

```go
// 直接调用
func BenchmarkDirect(b *testing.B) {
    f := &File{}
    for i := 0; i < b.N; i++ {
        f.Read(nil)  // 直接调用，可内联
    }
}

// 接口调用
func BenchmarkInterface(b *testing.B) {
    var r Reader = &File{}
    for i := 0; i < b.N; i++ {
        r.Read(nil)  // 间接调用，不可内联
    }
}
```

**性能影响**：
1. 接口调用比直接调用慢 5%-20%（需要查表）
2. 空接口赋值可能导致内存逃逸到堆
3. 接口方法调用无法内联（Go 1.20+ 支持部分内联优化）

### 六、最佳实践

1. **接受接口，返回具体类型**：
   ```go
   // 好的设计
   func ProcessData(r io.Reader) *Result

   // 避免
   func ProcessData(r io.Reader) io.Reader
   ```

2. **小接口原则**：接口应该尽可能小
   ```go
   // 好的设计
   type Reader interface {
       Read(p []byte) (n int, err error)
   }

   // 避免过大的接口
   type BigInterface interface {
       Method1()
       Method2()
       // ... 10+ 方法
   }
   ```

3. **避免不必要的空接口**：
   ```go
   // 类型安全
   func Process(data string) error

   // 避免滥用
   func Process(data interface{}) error
   ```

4. **注意内存逃逸**：
   ```go
   // 可能逃逸到堆
   var i interface{} = 123

   // 使用具体类型避免装箱
   var i int = 123
   ```
