---
title: context 的传播机制，多个 WithCancel 如何级联取消？
tags:
  - Go
  - 上下文
status: robot
class: Go
ref:
---

## 要点精炼

1. **传播机制**：Context 通过树形结构传播，父 context 取消时，所有子 context 自动级联取消
2. **四种类型**：Background/TODO（根节点）、WithCancel（可取消）、WithTimeout/WithDeadline（超时取消）、WithValue（携带值）
3. **级联取消**：调用父 context 的 cancel 函数会触发树形结构的递归取消，通过关闭 Done channel 通知所有子节点
4. **使用场景**：HTTP 请求、数据库查询、RPC 调用、goroutine 生命周期控制，是 Go 并发控制的标准模式

## 详细回答

### Context 概述

Context 是 Go 1.7 引入的标准库包，用于在 goroutine 之间传递取消信号、截止时间和请求范围的值。

#### Context 接口

```go
type Context interface {
    // Done 返回一个 channel，当 context 被取消时关闭
    Done() <-chan struct{}

    // Err 返回 context 被取消的原因
    Err() error

    // Deadline 返回 context 的截止时间
    Deadline() (deadline time.Time, ok bool)

    // Value 返回与 key 关联的值
    Value(key interface{}) interface{}
}
```

#### 四种创建方式

```go
// 1. 根 context（永不取消）
ctx := context.Background()  // 用于 main、测试
ctx := context.TODO()        // 当不确定用什么 context 时

// 2. 可取消的 context
ctx, cancel := context.WithCancel(parent)
defer cancel()  // 确保资源释放

// 3. 带超时的 context
ctx, cancel := context.WithTimeout(parent, 5*time.Second)
defer cancel()

// 4. 带截止时间的 context
deadline := time.Now().Add(5*time.Second)
ctx, cancel := context.WithDeadline(parent, deadline)
defer cancel()

// 5. 携带值的 context
ctx := context.WithValue(parent, key, value)
```

### Context 的树形结构

```go
// Context 形成树形结构
//
//          Background
//               |
//       WithCancel (ctx1)
//          /         \
//  WithTimeout    WithValue
//     (ctx2)         (ctx3)
//       |
//  WithCancel
//     (ctx4)

// 取消 ctx1 会级联取消 ctx2、ctx3、ctx4
```

### 传播机制原理

#### 内部实现

```go
// 简化的 cancelCtx 结构
type cancelCtx struct {
    Context                // 父 context
    mu       sync.Mutex
    done     chan struct{} // 关闭后表示取消
    children map[canceler]struct{}  // 子 context 集合
    err      error         // 取消原因
}

// cancel 函数
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    c.mu.Lock()
    if c.err != nil {
        c.mu.Unlock()
        return  // 已取消
    }

    c.err = err
    close(c.done)  // 关闭 done channel，通知所有等待者

    // 递归取消所有子 context
    for child := range c.children {
        child.cancel(false, err)
    }
    c.children = nil
    c.mu.Unlock()

    if removeFromParent {
        removeChild(c.Context, c)  // 从父节点移除
    }
}
```

### 基础使用示例

#### 示例 1：简单的取消传播

```go
func example1() {
    // 创建可取消的 context
    ctx, cancel := context.WithCancel(context.Background())

    go func() {
        select {
        case <-ctx.Done():
            fmt.Println("goroutine 收到取消信号")
            fmt.Println("原因:", ctx.Err())  // context canceled
        }
    }()

    time.Sleep(1 * time.Second)
    cancel()  // 取消 context
    time.Sleep(1 * time.Second)
}
```

#### 示例 2：多级取消

```go
func example2() {
    // 父 context
    parent, cancelParent := context.WithCancel(context.Background())

    // 子 context 1
    child1, _ := context.WithCancel(parent)

    // 子 context 2
    child2, _ := context.WithCancel(parent)

    // 孙 context
    grandchild, _ := context.WithCancel(child1)

    // 监听取消信号
    go listen(child1, "child1")
    go listen(child2, "child2")
    go listen(grandchild, "grandchild")

    time.Sleep(1 * time.Second)
    cancelParent()  // 取消父节点，所有子节点级联取消
    time.Sleep(1 * time.Second)
}

func listen(ctx context.Context, name string) {
    <-ctx.Done()
    fmt.Printf("%s 收到取消信号\n", name)
}

// 输出：
// child1 收到取消信号
// child2 收到取消信号
// grandchild 收到取消信号
```

### 高级用法

#### 场景 1：HTTP 请求超时控制

```go
func fetchWithTimeout(url string) ([]byte, error) {
    // 创建带超时的 context
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err  // 可能是超时错误
    }
    defer resp.Body.Close()

    return io.ReadAll(resp.Body)
}

// 使用示例
func main() {
    data, err := fetchWithTimeout("https://example.com/slow-api")
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            fmt.Println("请求超时")
        } else {
            fmt.Println("请求失败:", err)
        }
        return
    }
    fmt.Println("数据长度:", len(data))
}
```

#### 场景 2：数据库查询超时

```go
func queryWithTimeout(db *sql.DB) ([]User, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    rows, err := db.QueryContext(ctx, "SELECT * FROM users WHERE active = ?", true)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []User
    for rows.Next() {
        var u User
        if err := rows.Scan(&u.ID, &u.Name); err != nil {
            return nil, err
        }
        users = append(users, u)
    }

    return users, rows.Err()
}
```

#### 场景 3：多个并发任务的协调取消

```go
func processWithMultipleWorkers(ctx context.Context, tasks []Task) error {
    // 创建派生 context，以便单独控制
    workerCtx, cancel := context.WithCancel(ctx)
    defer cancel()

    errChan := make(chan error, len(tasks))
    var wg sync.WaitGroup

    for _, task := range tasks {
        wg.Add(1)
        go func(t Task) {
            defer wg.Done()

            // 模拟任务执行
            select {
            case <-workerCtx.Done():
                errChan <- workerCtx.Err()
            case <-time.After(time.Duration(t.Duration) * time.Second):
                if t.ShouldFail {
                    errChan <- fmt.Errorf("task %d failed", t.ID)
                    cancel()  // 任务失败，取消所有其他任务
                }
            }
        }(task)
    }

    wg.Wait()
    close(errChan)

    for err := range errChan {
        if err != nil {
            return err
        }
    }

    return nil
}
```

#### 场景 4：管道处理的取消

```go
func pipeline(ctx context.Context, nums []int) <-chan int {
    out := make(chan int)

    go func() {
        defer close(out)
        for _, n := range nums {
            select {
            case <-ctx.Done():
                return  // context 取消，退出
            case out <- n * 2:
            }
        }
    }()

    return out
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    for n := range pipeline(ctx, nums) {
        fmt.Println(n)
        time.Sleep(500 * time.Millisecond)
    }
}
```

### WithValue 使用

#### 正确使用 WithValue

```go
// 定义 key 类型（避免冲突）
type contextKey string

const (
    requestIDKey contextKey = "request-id"
    userIDKey    contextKey = "user-id"
)

// 设置值
func withRequestID(ctx context.Context, id string) context.Context {
    return context.WithValue(ctx, requestIDKey, id)
}

// 获取值
func getRequestID(ctx context.Context) string {
    if id, ok := ctx.Value(requestIDKey).(string); ok {
        return id
    }
    return ""
}

// HTTP 中间件示例
func requestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := generateRequestID()
        ctx := withRequestID(r.Context(), requestID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func handler(w http.ResponseWriter, r *http.Request) {
    requestID := getRequestID(r.Context())
    log.Printf("Request ID: %s", requestID)
    // 处理请求...
}
```

#### WithValue 最佳实践

```go
// 好的做法：使用类型安全的包装
type contextKey string

func (c contextKey) String() string {
    return "myapp context key " + string(c)
}

// 不好的做法：使用字符串作为 key
ctx := context.WithValue(ctx, "user-id", 123)  // 容易冲突

// 不要在 WithValue 中存储：
// 1. 可选参数（应该用函数参数）
// 2. 大量数据（应该用专门的存储）
// 3. 会改变的数据（WithValue 是不可变的）
```

### 常见错误模式

#### 错误 1：不调用 cancel

```go
// 错误：导致内存泄漏
func bad() {
    ctx, cancel := context.WithCancel(context.Background())
    // 忘记调用 cancel()
    go worker(ctx)
}

// 正确：使用 defer
func good() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()  // 确保资源释放
    go worker(ctx)
}
```

#### 错误 2：忽略 context.Done()

```go
// 错误：goroutine 可能永远不退出
func badWorker(ctx context.Context) {
    for {
        doWork()  // 没有检查 ctx.Done()
    }
}

// 正确：检查取消信号
func goodWorker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        default:
            doWork()
        }
    }
}
```

#### 错误 3：传递 nil context

```go
// 错误：可能导致 panic
func bad(ctx context.Context) {
    // 如果 ctx 是 nil，会 panic
    select {
    case <-ctx.Done():
    }
}

// 正确：总是传递有效的 context
func good() {
    ctx := context.Background()  // 至少使用 Background
    processRequest(ctx)
}
```

### 实际应用案例

#### 案例 1：优雅关闭服务器

```go
type Server struct {
    ctx    context.Context
    cancel context.CancelFunc
}

func NewServer() *Server {
    ctx, cancel := context.WithCancel(context.Background())
    return &Server{ctx: ctx, cancel: cancel}
}

func (s *Server) Start() {
    // 启动多个 worker
    for i := 0; i < 5; i++ {
        go s.worker(i)
    }

    // 监听信号
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
    <-sigChan

    fmt.Println("Shutting down...")
    s.cancel()  // 取消所有 worker
    time.Sleep(2 * time.Second)  // 等待清理
}

func (s *Server) worker(id int) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-s.ctx.Done():
            fmt.Printf("Worker %d stopped\n", id)
            return
        case <-ticker.C:
            fmt.Printf("Worker %d working\n", id)
        }
    }
}
```

#### 案例 2：限制请求处理时间

```go
func handleRequestWithTimeout(w http.ResponseWriter, r *http.Request) {
    // 从请求获取 context，添加超时
    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    defer cancel()

    resultCh := make(chan Result, 1)
    errCh := make(chan error, 1)

    go func() {
        result, err := processRequest(ctx, r)
        if err != nil {
            errCh <- err
        } else {
            resultCh <- result
        }
    }()

    select {
    case result := <-resultCh:
        json.NewEncoder(w).Encode(result)
    case err := <-errCh:
        http.Error(w, err.Error(), http.StatusInternalServerError)
    case <-ctx.Done():
        http.Error(w, "Request timeout", http.StatusGatewayTimeout)
    }
}
```

#### 案例 3：分布式追踪

```go
type traceKey struct{}

type TraceContext struct {
    TraceID string
    SpanID  string
}

func withTrace(ctx context.Context, trace *TraceContext) context.Context {
    return context.WithValue(ctx, traceKey{}, trace)
}

func getTrace(ctx context.Context) *TraceContext {
    if trace, ok := ctx.Value(traceKey{}).(*TraceContext); ok {
        return trace
    }
    return nil
}

func handleRequest(ctx context.Context) {
    trace := getTrace(ctx)
    log.Printf("[%s:%s] Processing request", trace.TraceID, trace.SpanID)

    // 调用下游服务，传递 trace
    callDownstream(ctx)
}
```

### 性能考量

```go
// WithValue 性能测试
func BenchmarkContextValue(b *testing.B) {
    ctx := context.Background()
    for i := 0; i < 10; i++ {
        ctx = context.WithValue(ctx, contextKey(fmt.Sprintf("key%d", i)), i)
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = ctx.Value(contextKey("key5"))
    }
}

// 注意：
// - WithValue 查找是 O(n)，n 是嵌套层数
// - 不要在热路径中频繁调用
// - 考虑使用专门的上下文存储
```

### 总结

Context 的核心要点：

1. **传播机制**：
   - 树形结构
   - 级联取消
   - 单向传播（子不能取消父）

2. **四种类型**：
   - Background/TODO：根节点
   - WithCancel：手动取消
   - WithTimeout/Deadline：自动超时
   - WithValue：传递数据

3. **最佳实践**：
   - 总是调用 cancel
   - 检查 Done() 信号
   - 合理使用 WithValue
   - 传递 context 作为第一个参数

4. **使用场景**：
   - HTTP 请求控制
   - 数据库查询超时
   - goroutine 生命周期
   - 分布式追踪

面试要点：
- 理解 context 的树形结构
- 掌握四种 context 的用法
- 能解释级联取消的机制
- 知道 WithValue 的正确用法
- 了解常见错误和最佳实践
