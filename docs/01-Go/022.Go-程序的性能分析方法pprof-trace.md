---
title: Go 程序的性能分析方法（pprof、trace）
tags:
  - Go
status: robot
class: Go
slug: go-performance-analysis-pprof-trace
ref:
---

## 要点精炼

1. **pprof 工具**：用于 CPU、内存、goroutine、锁等性能分析，支持 HTTP 接口和文件导出两种方式
2. **trace 工具**：提供微观的执行追踪，可视化 goroutine 调度、系统调用、GC 等事件，适合分析并发和延迟问题
3. **使用场景**：pprof 适合定位热点代码和资源泄漏，trace 适合分析程序执行流程和调度问题
4. **实践技巧**：生产环境开启 pprof HTTP 端口需控制访问权限；使用采样分析降低性能影响；结合 benchmark 和 pprof 定位优化点

## 详细回答

### 1. pprof 基本使用

#### 1.1 HTTP 接口方式（推荐用于长期运行的服务）

```go
package main

import (
    "net/http"
    _ "net/http/pprof" // 自动注册 pprof handlers
    "time"
)

func main() {
    // 启动 pprof HTTP 服务
    go func() {
        // 建议使用独立端口，避免暴露在公网
        http.ListenAndServe("localhost:6060", nil)
    }()

    // 业务代码
    for {
        doWork()
        time.Sleep(100 * time.Millisecond)
    }
}

func doWork() {
    // 模拟业务逻辑
    data := make([]byte, 1024*1024) // 分配内存
    _ = data
}
```

访问 pprof 端点：
```bash
# 查看所有可用的 profile
http://localhost:6060/debug/pprof/

# 主要的 profile 类型
http://localhost:6060/debug/pprof/heap        # 堆内存分析
http://localhost:6060/debug/pprof/goroutine   # goroutine 分析
http://localhost:6060/debug/pprof/profile     # CPU profile（默认 30s）
http://localhost:6060/debug/pprof/block       # 阻塞分析
http://localhost:6060/debug/pprof/mutex       # 锁竞争分析
```

#### 1.2 代码嵌入方式（用于测试和临时分析）

```go
package main

import (
    "os"
    "runtime/pprof"
    "time"
)

func main() {
    // CPU profiling
    cpuFile, _ := os.Create("cpu.prof")
    pprof.StartCPUProfile(cpuFile)
    defer pprof.StopCPUProfile()

    // 运行业务代码
    doWork()

    // 内存 profiling
    memFile, _ := os.Create("mem.prof")
    pprof.WriteHeapProfile(memFile)
    memFile.Close()

    // Goroutine profiling
    goroutineFile, _ := os.Create("goroutine.prof")
    pprof.Lookup("goroutine").WriteTo(goroutineFile, 0)
    goroutineFile.Close()
}

func doWork() {
    for i := 0; i < 1000000; i++ {
        _ = make([]byte, 1024)
    }
}
```

### 2. pprof 分析命令

```bash
# CPU profiling - 采集 30 秒 CPU 数据
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 内存分析 - 当前堆内存分配
go tool pprof http://localhost:6060/debug/pprof/heap

# 分析本地文件
go tool pprof cpu.prof
go tool pprof mem.prof

# 交互式命令
(pprof) top           # 显示前 10 个热点函数
(pprof) top20         # 显示前 20 个
(pprof) list funcName # 查看函数源码和耗时
(pprof) web           # 生成调用图（需要 graphviz）
(pprof) svg           # 生成 SVG 格式调用图
(pprof) pdf           # 生成 PDF 报告
(pprof) traces        # 查看采样轨迹

# Web UI 方式（推荐）
go tool pprof -http=:8080 cpu.prof
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile
```

### 3. pprof 实战示例

```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "runtime"
    "time"
)

// 模拟内存泄漏
var leakyCache = make(map[int][]byte)

func main() {
    // 启动 pprof
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    fmt.Println("pprof 服务已启动: http://localhost:6060/debug/pprof/")

    // 定期打印内存统计
    go func() {
        ticker := time.NewTicker(5 * time.Second)
        for range ticker.C {
            var m runtime.MemStats
            runtime.ReadMemStats(&m)
            fmt.Printf("Alloc = %v MB, TotalAlloc = %v MB, Sys = %v MB, NumGC = %v\n",
                m.Alloc/1024/1024, m.TotalAlloc/1024/1024, m.Sys/1024/1024, m.NumGC)
        }
    }()

    // 模拟业务逻辑（会产生内存泄漏）
    for i := 0; ; i++ {
        cpuIntensiveWork()
        memoryLeakWork(i)
        time.Sleep(100 * time.Millisecond)
    }
}

// CPU 密集型操作
func cpuIntensiveWork() {
    sum := 0
    for i := 0; i < 1000000; i++ {
        sum += i
    }
}

// 内存泄漏操作
func memoryLeakWork(id int) {
    // 不断分配内存且不释放
    leakyCache[id] = make([]byte, 1024*1024) // 1MB
}
```

分析步骤：
```bash
# 1. 查看内存分配热点
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/heap

# 2. 查看 CPU 热点
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30

# 3. 查看 goroutine 数量和堆栈
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# 4. 对比两个时间点的内存差异（查找泄漏）
go tool pprof -http=:8080 -base heap1.prof heap2.prof
```

### 4. trace 工具使用

#### 4.1 采集 trace 数据

```go
package main

import (
    "os"
    "runtime/trace"
    "time"
)

func main() {
    // 创建 trace 文件
    f, _ := os.Create("trace.out")
    defer f.Close()

    // 开始 trace
    trace.Start(f)
    defer trace.Stop()

    // 业务代码
    runConcurrentWork()
}

func runConcurrentWork() {
    done := make(chan bool)

    // 启动多个 goroutine
    for i := 0; i < 10; i++ {
        go func(id int) {
            defer func() { done <- true }()

            // 模拟 CPU 密集型任务
            for j := 0; j < 1000000; j++ {
                _ = j * j
            }

            // 模拟 I/O 等待
            time.Sleep(10 * time.Millisecond)
        }(i)
    }

    // 等待所有任务完成
    for i := 0; i < 10; i++ {
        <-done
    }
}
```

#### 4.2 HTTP 方式采集 trace

```go
package main

import (
    "net/http"
    _ "net/http/pprof"
)

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
    // 处理请求
    w.Write([]byte("Hello"))
}
```

采集命令：
```bash
# 采集 5 秒的 trace 数据
curl http://localhost:6060/debug/pprof/trace?seconds=5 > trace.out

# 或者使用 wget
wget -O trace.out http://localhost:6060/debug/pprof/trace?seconds=5
```

#### 4.3 分析 trace 数据

```bash
# 启动 trace web UI
go tool trace trace.out

# 浏览器会自动打开，主要功能：
# 1. View trace：查看详细的执行时间线
# 2. Goroutine analysis：分析 goroutine 执行情况
# 3. Network blocking profile：网络阻塞分析
# 4. Synchronization blocking profile：同步阻塞分析
# 5. Syscall blocking profile：系统调用阻塞分析
# 6. Scheduler latency profile：调度延迟分析
```

### 5. pprof vs trace 对比

| 特性 | pprof | trace |
|------|-------|-------|
| **用途** | 性能热点分析、资源使用统计 | 程序执行流程、并发行为分析 |
| **粒度** | 函数级别（采样） | 事件级别（精确） |
| **开销** | 较小（1-5%） | 较大（10-30%） |
| **适用场景** | CPU 热点、内存泄漏、goroutine 泄漏 | 调度问题、延迟分析、并发瓶颈 |
| **数据量** | 小（几 MB） | 大（几十到几百 MB） |
| **时长** | 可长期开启 | 短期采集（几秒到几分钟） |

### 6. 最佳实践

#### 6.1 生产环境使用建议

```go
package main

import (
    "net/http"
    "net/http/pprof"
    "os"
)

func setupPprof() {
    // 仅在开发/测试环境开启
    if os.Getenv("ENV") != "production" {
        go func() {
            http.ListenAndServe("localhost:6060", nil)
        }()
        return
    }

    // 生产环境：使用独立的 mux，添加认证
    mux := http.NewServeMux()
    mux.HandleFunc("/debug/pprof/", authMiddleware(pprof.Index))
    mux.HandleFunc("/debug/pprof/cmdline", authMiddleware(pprof.Cmdline))
    mux.HandleFunc("/debug/pprof/profile", authMiddleware(pprof.Profile))
    mux.HandleFunc("/debug/pprof/symbol", authMiddleware(pprof.Symbol))
    mux.HandleFunc("/debug/pprof/trace", authMiddleware(pprof.Trace))

    go http.ListenAndServe("127.0.0.1:6060", mux)
}

func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 添加认证逻辑
        token := r.Header.Get("X-Auth-Token")
        if token != os.Getenv("PPROF_TOKEN") {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next(w, r)
    }
}
```

#### 6.2 常见问题排查

```bash
# 1. CPU 占用过高
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30

# 2. 内存占用持续增长
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/heap
# 查看 inuse_space（当前使用）和 alloc_space（累计分配）

# 3. goroutine 数量持续增长
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/goroutine

# 4. 程序响应慢
curl http://localhost:6060/debug/pprof/trace?seconds=5 > trace.out
go tool trace trace.out
# 查看 Goroutine analysis 和 Scheduler latency

# 5. 锁竞争严重
# 需要在代码中开启
runtime.SetBlockProfileRate(1)
runtime.SetMutexProfileFraction(1)
# 然后分析
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/mutex
```

#### 6.3 benchmark 结合 pprof

```go
// benchmark_test.go
package main

import "testing"

func BenchmarkWork(b *testing.B) {
    for i := 0; i < b.N; i++ {
        doWork()
    }
}

func doWork() {
    sum := 0
    for i := 0; i < 100000; i++ {
        sum += i
    }
}
```

运行命令：
```bash
# 生成 CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 生成内存 profile
go test -bench=. -memprofile=mem.prof

# 分析结果
go tool pprof -http=:8080 cpu.prof
go tool pprof -http=:8080 mem.prof
```

### 7. 高级技巧

```go
// 自定义 profile
import "runtime/pprof"

var customProfile = pprof.NewProfile("custom")

func trackOperation() {
    customProfile.Add(currentOperation, 0)
    defer customProfile.Remove(currentOperation)

    // 执行操作
    doSomething()
}

// 导出自定义 profile
f, _ := os.Create("custom.prof")
customProfile.WriteTo(f, 0)
f.Close()
```
