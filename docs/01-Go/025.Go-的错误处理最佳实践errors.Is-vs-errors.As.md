---
title: Go 的错误处理最佳实践，errors.Is vs errors.As
tags:
  - Go
status: robot
class: Go
ref:
---

## 要点精炼

1. **errors.Is vs errors.As**：errors.Is 用于判断错误值相等性（包括包装链），errors.As 用于提取特定类型的错误（类型断言）
2. **错误包装**：使用 fmt.Errorf 的 %w 动词包装错误，保留原始错误信息和堆栈，便于错误追踪和判断
3. **自定义错误类型**：实现 error 接口创建自定义错误类型，携带额外上下文信息（错误码、字段等）
4. **最佳实践**：底层返回详细错误，上层添加上下文；避免忽略错误；使用哨兵错误（sentinel errors）表示特定场景

## 详细回答

### 1. Go 错误处理基础

#### 1.1 error 接口

```go
type error interface {
    Error() string
}

// 简单错误创建
err := errors.New("something went wrong")
err := fmt.Errorf("failed to process: %s", reason)
```

#### 1.2 错误处理的演进

```go
// Go 1.13 之前：字符串比较（脆弱）
if err.Error() == "file not found" {
    // 处理错误
}

// Go 1.13+：使用 errors.Is 和 errors.As
if errors.Is(err, os.ErrNotExist) {
    // 处理错误
}
```

### 2. errors.Is 详解

#### 2.1 基本用法

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

// 定义哨兵错误（sentinel errors）
var (
    ErrNotFound     = errors.New("resource not found")
    ErrUnauthorized = errors.New("unauthorized access")
    ErrInvalidInput = errors.New("invalid input")
)

func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, ErrInvalidInput
    }

    // 查询数据库...
    if notFound {
        return nil, ErrNotFound
    }

    return user, nil
}

func main() {
    user, err := GetUser(-1)
    if err != nil {
        // 使用 errors.Is 判断错误
        if errors.Is(err, ErrInvalidInput) {
            fmt.Println("输入无效，请检查参数")
            return
        }

        if errors.Is(err, ErrNotFound) {
            fmt.Println("用户不存在")
            return
        }

        fmt.Println("未知错误:", err)
    }
}
```

#### 2.2 错误包装与 errors.Is

```go
func ProcessUser(id int) error {
    user, err := GetUser(id)
    if err != nil {
        // 使用 %w 包装错误，保留原始错误
        return fmt.Errorf("process user failed: %w", err)
    }

    // 处理用户...
    return nil
}

func HandleRequest() {
    err := ProcessUser(123)
    if err != nil {
        // errors.Is 会遍历错误链
        if errors.Is(err, ErrNotFound) {
            // 即使 err 被包装多层，仍然可以识别
            fmt.Println("用户不存在")
        }
    }
}
```

#### 2.3 errors.Is 工作原理

```go
// errors.Is 的简化实现
func Is(err, target error) bool {
    if target == nil {
        return err == target
    }

    // 遍历错误链
    for {
        if err == target {
            return true
        }

        // 检查是否实现了 Is 方法
        if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
            return true
        }

        // 获取被包装的错误
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}
```

#### 2.4 自定义 Is 方法

```go
type TemporaryError struct {
    Err error
}

func (e *TemporaryError) Error() string {
    return fmt.Sprintf("temporary error: %v", e.Err)
}

func (e *TemporaryError) Unwrap() error {
    return e.Err
}

// 自定义 Is 方法
func (e *TemporaryError) Is(target error) bool {
    // 自定义匹配逻辑
    _, ok := target.(*TemporaryError)
    return ok
}

// 使用
var ErrTemp = &TemporaryError{}

err := &TemporaryError{Err: errors.New("network timeout")}
if errors.Is(err, ErrTemp) {
    fmt.Println("这是一个临时错误，可以重试")
}
```

### 3. errors.As 详解

#### 3.1 基本用法

```go
package main

import (
    "errors"
    "fmt"
)

// 自定义错误类型
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "email is required",
        }
    }
    return nil
}

func main() {
    err := ValidateUser(&User{})
    if err != nil {
        // 使用 errors.As 提取具体错误类型
        var validationErr *ValidationError
        if errors.As(err, &validationErr) {
            fmt.Printf("字段 %s 验证失败: %s\n",
                validationErr.Field,
                validationErr.Message)
            return
        }

        fmt.Println("其他错误:", err)
    }
}
```

#### 3.2 错误包装与 errors.As

```go
type HTTPError struct {
    StatusCode int
    Message    string
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}

func FetchData(url string) error {
    // 模拟 HTTP 请求失败
    httpErr := &HTTPError{
        StatusCode: 404,
        Message:    "Not Found",
    }

    // 包装错误
    return fmt.Errorf("fetch data from %s: %w", url, httpErr)
}

func ProcessData() {
    err := FetchData("https://api.example.com/users")
    if err != nil {
        // errors.As 会遍历错误链，找到 HTTPError 类型
        var httpErr *HTTPError
        if errors.As(err, &httpErr) {
            fmt.Printf("HTTP 请求失败，状态码: %d\n", httpErr.StatusCode)

            // 根据状态码采取不同策略
            if httpErr.StatusCode == 404 {
                fmt.Println("资源不存在")
            } else if httpErr.StatusCode >= 500 {
                fmt.Println("服务器错误，可以重试")
            }
        }
    }
}
```

#### 3.3 errors.As 工作原理

```go
// errors.As 的简化实现
func As(err error, target interface{}) bool {
    if target == nil {
        panic("errors: target cannot be nil")
    }

    val := reflect.ValueOf(target)
    typ := val.Type()
    if typ.Kind() != reflect.Ptr || val.IsNil() {
        panic("errors: target must be a non-nil pointer")
    }

    targetType := typ.Elem()

    for {
        if reflect.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflect.ValueOf(err))
            return true
        }

        // 检查是否实现了 As 方法
        if x, ok := err.(interface{ As(interface{}) bool }); ok && x.As(target) {
            return true
        }

        // 获取被包装的错误
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}
```

### 4. errors.Is vs errors.As 对比

| 特性 | errors.Is | errors.As |
|------|-----------|-----------|
| **用途** | 判断错误值是否相等 | 提取特定类型的错误 |
| **比较对象** | 错误值（sentinel error） | 错误类型 |
| **返回值** | bool | bool + 填充 target |
| **使用场景** | 判断是否为特定错误 | 获取错误详细信息 |
| **示例** | `errors.Is(err, ErrNotFound)` | `errors.As(err, &httpErr)` |

### 5. 错误包装最佳实践

#### 5.1 使用 %w 包装错误

```go
// 正确：使用 %w 包装错误
func ReadConfig(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("read config file: %w", err)
    }

    var cfg Config
    if err := json.Unmarshal(data, &cfg); err != nil {
        return nil, fmt.Errorf("parse config: %w", err)
    }

    return &cfg, nil
}

// 错误：使用 %v 会丢失错误链
func ReadConfigBad(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("read config file: %v", err)  // 错误！
    }
    // ...
}
```

#### 5.2 添加上下文信息

```go
func ProcessOrder(orderID string) error {
    order, err := fetchOrder(orderID)
    if err != nil {
        // 添加上下文：哪个订单处理失败
        return fmt.Errorf("process order %s: %w", orderID, err)
    }

    if err := validateOrder(order); err != nil {
        // 添加上下文：验证哪个环节失败
        return fmt.Errorf("validate order %s: %w", orderID, err)
    }

    if err := saveOrder(order); err != nil {
        // 添加上下文：保存失败
        return fmt.Errorf("save order %s: %w", orderID, err)
    }

    return nil
}
```

#### 5.3 选择性包装错误

```go
func GetUser(id int) (*User, error) {
    if id <= 0 {
        // 不包装：这是这一层产生的错误
        return nil, ErrInvalidInput
    }

    user, err := db.QueryUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            // 转换为业务错误
            return nil, ErrNotFound
        }

        // 包装：这是下层传来的错误
        return nil, fmt.Errorf("query user %d: %w", id, err)
    }

    return user, nil
}
```

### 6. 自定义错误类型

#### 6.1 携带结构化信息

```go
type AppError struct {
    Code    string                 // 错误码
    Message string                 // 错误信息
    Details map[string]interface{} // 额外细节
    Err     error                  // 原始错误
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// 工厂函数
func NewAppError(code, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Details: make(map[string]interface{}),
    }
}

func (e *AppError) WithDetail(key string, value interface{}) *AppError {
    e.Details[key] = value
    return e
}

// 使用
func CreateUser(email string) error {
    if !isValidEmail(email) {
        return NewAppError("INVALID_EMAIL", "Invalid email format").
            WithDetail("email", email).
            WithDetail("pattern", emailPattern)
    }

    if err := db.InsertUser(email); err != nil {
        return &AppError{
            Code:    "DB_ERROR",
            Message: "Failed to create user",
            Err:     err,
        }
    }

    return nil
}
```

#### 6.2 实现常见接口

```go
type RetryableError struct {
    Err        error
    RetryAfter time.Duration
}

func (e *RetryableError) Error() string {
    return fmt.Sprintf("retryable error (retry after %v): %v", e.RetryAfter, e.Err)
}

func (e *RetryableError) Unwrap() error {
    return e.Err
}

// 实现临时错误接口（net 包使用）
func (e *RetryableError) Temporary() bool {
    return true
}

// 使用
func CallAPI() error {
    resp, err := http.Get("https://api.example.com")
    if err != nil {
        return &RetryableError{
            Err:        err,
            RetryAfter: 5 * time.Second,
        }
    }

    if resp.StatusCode == 429 { // Too Many Requests
        return &RetryableError{
            Err:        fmt.Errorf("rate limited"),
            RetryAfter: 10 * time.Second,
        }
    }

    return nil
}

func ProcessWithRetry() {
    err := CallAPI()
    if err != nil {
        var retryErr *RetryableError
        if errors.As(err, &retryErr) {
            fmt.Printf("可重试错误，%v 后重试\n", retryErr.RetryAfter)
            time.Sleep(retryErr.RetryAfter)
            // 重试逻辑...
        }
    }
}
```

### 7. 错误处理模式

#### 7.1 哨兵错误（Sentinel Errors）

```go
// 定义包级别的错误变量
var (
    ErrNotFound        = errors.New("not found")
    ErrAlreadyExists   = errors.New("already exists")
    ErrInvalidArgument = errors.New("invalid argument")
)

// 使用
func GetItem(id string) (*Item, error) {
    if id == "" {
        return nil, ErrInvalidArgument
    }

    item, ok := store[id]
    if !ok {
        return nil, ErrNotFound
    }

    return item, nil
}

// 调用方判断
if errors.Is(err, ErrNotFound) {
    // 处理未找到的情况
}
```

#### 7.2 错误类型（Error Types）

```go
// 适合需要携带额外信息的场景
type NotFoundError struct {
    Resource string
    ID       string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
}

func GetUser(id string) (*User, error) {
    user, ok := users[id]
    if !ok {
        return nil, &NotFoundError{
            Resource: "user",
            ID:       id,
        }
    }
    return user, nil
}

// 调用方提取信息
var notFoundErr *NotFoundError
if errors.As(err, &notFoundErr) {
    fmt.Printf("资源 %s (ID: %s) 不存在\n",
        notFoundErr.Resource, notFoundErr.ID)
}
```

#### 7.3 不透明错误（Opaque Errors）

```go
// 只返回 error 接口，不暴露内部结构
func ProcessData(data []byte) error {
    if len(data) == 0 {
        return fmt.Errorf("empty data")
    }

    // 调用方只能通过错误消息判断
    return nil
}
```

### 8. 完整示例：Web 应用错误处理

```go
package main

import (
    "database/sql"
    "encoding/json"
    "errors"
    "fmt"
    "net/http"
)

// 错误定义
var (
    ErrNotFound     = errors.New("resource not found")
    ErrUnauthorized = errors.New("unauthorized")
)

type AppError struct {
    Code    int
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// Repository 层
func GetUserFromDB(id int) (*User, error) {
    row := db.QueryRow("SELECT * FROM users WHERE id = ?", id)

    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrNotFound
        }
        return nil, fmt.Errorf("scan user: %w", err)
    }

    return &user, nil
}

// Service 层
func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, &AppError{
            Code:    http.StatusBadRequest,
            Message: "invalid user id",
        }
    }

    user, err := GetUserFromDB(id)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            return nil, &AppError{
                Code:    http.StatusNotFound,
                Message: "user not found",
                Err:     err,
            }
        }

        return nil, &AppError{
            Code:    http.StatusInternalServerError,
            Message: "internal server error",
            Err:     err,
        }
    }

    return user, nil
}

// Handler 层
func UserHandler(w http.ResponseWriter, r *http.Request) {
    id := parseID(r)

    user, err := GetUser(id)
    if err != nil {
        handleError(w, err)
        return
    }

    json.NewEncoder(w).Encode(user)
}

func handleError(w http.ResponseWriter, err error) {
    var appErr *AppError
    if errors.As(err, &appErr) {
        w.WriteHeader(appErr.Code)
        json.NewEncoder(w).Encode(map[string]string{
            "error": appErr.Message,
        })
        return
    }

    // 未知错误
    w.WriteHeader(http.StatusInternalServerError)
    json.NewEncoder(w).Encode(map[string]string{
        "error": "internal server error",
    })
}
```

### 9. 错误处理反模式

```go
// 反模式 1：忽略错误
data, _ := os.ReadFile("config.json")  // 危险！

// 反模式 2：过度包装
return fmt.Errorf("error: %w", fmt.Errorf("failed: %w", err))

// 反模式 3：使用 panic 处理普通错误
if err != nil {
    panic(err)  // 应该返回 error
}

// 反模式 4：返回 nil error 但有错误
func GetUser() (*User, error) {
    if somethingWrong {
        return nil, nil  // 应该返回 error
    }
    return user, nil
}
```

### 10. 总结建议

1. **使用 errors.Is 判断特定错误**：`if errors.Is(err, ErrNotFound)`
2. **使用 errors.As 提取错误信息**：`if errors.As(err, &httpErr)`
3. **使用 %w 包装错误**：`fmt.Errorf("context: %w", err)`
4. **底层返回详细错误，上层添加上下文**
5. **自定义错误类型携带结构化信息**
6. **哨兵错误用于简单场景，错误类型用于复杂场景**
7. **不要忽略错误，即使暂时不处理也要记录日志**
8. **错误信息要清晰，包含足够的上下文便于排查**
