---
title: Go 中有哪些常用的并发原语？sync.Mutex 和 sync.RWMutex 的区别是什么？
tags:
  - Go
  - 锁
  - 同步原语
status: robot
class: Go
slug: go-concurrency-primitives-mutex-rwmutex-difference
ref:
---

## 要点精炼

1. **锁类型**：Mutex（互斥锁）用于独占访问，RWMutex（读写锁）允许多读单写，后者适合读多写少场景
2. **同步原语**：WaitGroup 用于等待一组 goroutine 完成，Once 保证函数只执行一次，Cond 用于条件等待
3. **原子操作**：atomic 包提供无锁的原子操作，比锁更高效但使用场景受限（仅支持基本类型）
4. **高级工具**：sync.Map（并发安全的 map）、errgroup（goroutine 组错误管理）、Context（取消传播）

## 详细回答

### 一、互斥锁（Mutex）

#### 1. 基本用法

```go
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}
```

#### 2. 实现原理

```go
// Mutex 的内部状态（简化）
type Mutex struct {
    state int32   // 锁状态（0=未锁定，1=锁定）
    sema  uint32  // 信号量，用于阻塞等待的 goroutine
}

// 状态位定义
const (
    mutexLocked      = 1 << 0  // 锁定标志
    mutexWoken       = 1 << 1  // 唤醒标志
    mutexStarving    = 1 << 2  // 饥饿模式标志
)
```

**两种模式**：
- **正常模式**：等待的 goroutine 按 FIFO 入队，但被唤醒后需与新到达的 goroutine 竞争（新 goroutine 更可能获得锁）
- **饥饿模式**：等待超过 1ms 后进入，锁直接交给队首 goroutine，防止等待过久

#### 3. 常见错误

```go
// 错误 1：忘记解锁
func bad1() {
    mu.Lock()
    if err != nil {
        return  // 锁未释放，死锁！
    }
    mu.Unlock()
}

// 错误 2：重复加锁
func bad2() {
    mu.Lock()
    mu.Lock()  // 死锁！
    mu.Unlock()
    mu.Unlock()
}

// 错误 3：拷贝锁
func bad3() {
    var mu sync.Mutex
    mu2 := mu  // 错误：不能拷贝锁
}

// 正确做法
func good() {
    mu.Lock()
    defer mu.Unlock()  // 确保解锁

    if err != nil {
        return  // defer 会执行 Unlock
    }
}
```

### 二、读写锁（RWMutex）

#### 1. 基本用法

```go
type Cache struct {
    mu    sync.RWMutex
    data  map[string]string
}

// 读操作：允许多个 goroutine 并发读
func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    val, ok := c.data[key]
    return val, ok
}

// 写操作：独占访问
func (c *Cache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = value
}
```

#### 2. Mutex vs RWMutex

| 特性 | Mutex | RWMutex |
|------|-------|---------|
| 读操作 | 独占 | 共享（多个 goroutine 可同时读） |
| 写操作 | 独占 | 独占 |
| 适用场景 | 读写比例接近 | 读多写少（读 >> 写） |
| 性能 | 写操作更快 | 读操作更快，写操作较慢 |
| 内存占用 | 小（8 字节） | 大（32 字节） |

#### 3. 性能对比

```go
// 基准测试
func BenchmarkMutex(b *testing.B) {
    var mu sync.Mutex
    var val int

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            mu.Lock()
            val++
            mu.Unlock()
        }
    })
}

func BenchmarkRWMutex_Read(b *testing.B) {
    var mu sync.RWMutex
    var val int

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            mu.RLock()
            _ = val
            mu.RUnlock()
        }
    })
}

// 结果（读多写少场景）：
// BenchmarkMutex-8           10000000    150 ns/op
// BenchmarkRWMutex_Read-8    50000000     30 ns/op
```

#### 4. RWMutex 的注意事项

```go
// 错误：读锁升级为写锁会死锁
func deadlock() {
    mu.RLock()
    // ...
    mu.Lock()   // 死锁！
    mu.Unlock()
    mu.RUnlock()
}

// 正确：先释放读锁再获取写锁
func correct() {
    mu.RLock()
    // ...
    mu.RUnlock()

    mu.Lock()
    // ...
    mu.Unlock()
}
```

### 三、WaitGroup

#### 1. 基本用法

```go
func processItems(items []Item) {
    var wg sync.WaitGroup

    for _, item := range items {
        wg.Add(1)  // 增加计数
        go func(item Item) {
            defer wg.Done()  // 完成时减少计数
            process(item)
        }(item)
    }

    wg.Wait()  // 等待所有 goroutine 完成
}
```

#### 2. 常见错误

```go
// 错误 1：在 goroutine 内 Add
func bad1() {
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        go func() {
            wg.Add(1)  // 错误：可能在 Wait 后才 Add
            defer wg.Done()
            // ...
        }()
    }
    wg.Wait()
}

// 错误 2：拷贝 WaitGroup
func bad2(wg sync.WaitGroup) {  // 错误：值传递会拷贝
    wg.Done()  // 影响的是副本，不是原始 WaitGroup
}

// 正确做法
func good() {
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)  // 在启动 goroutine 前 Add
        go func() {
            defer wg.Done()
            // ...
        }()
    }
    wg.Wait()
}

func good2(wg *sync.WaitGroup) {  // 正确：指针传递
    wg.Done()
}
```

#### 3. 限制并发数

```go
func processWithLimit(items []Item, maxConcurrency int) {
    var wg sync.WaitGroup
    sem := make(chan struct{}, maxConcurrency)

    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()

            sem <- struct{}{}        // 获取信号量
            defer func() { <-sem }() // 释放信号量

            process(item)
        }(item)
    }

    wg.Wait()
}
```

### 四、Once

#### 1. 基本用法

```go
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}  // 只执行一次
    })
    return instance
}
```

#### 2. 实现原理

```go
type Once struct {
    done uint32  // 原子操作的标志位
    m    Mutex   // 锁
}

func (o *Once) Do(f func()) {
    // 快速路径：已执行过
    if atomic.LoadUint32(&o.done) == 0 {
        o.doSlow(f)
    }
}

func (o *Once) doSlow(f func()) {
    o.m.Lock()
    defer o.m.Unlock()
    if o.done == 0 {
        defer atomic.StoreUint32(&o.done, 1)
        f()
    }
}
```

#### 3. 应用场景

```go
// 场景 1：单例模式
var db *sql.DB
var dbOnce sync.Once

func GetDB() *sql.DB {
    dbOnce.Do(func() {
        db, _ = sql.Open("mysql", "dsn")
    })
    return db
}

// 场景 2：延迟初始化
var config *Config
var configOnce sync.Once

func GetConfig() *Config {
    configOnce.Do(func() {
        config = loadConfig()  // 耗时操作只做一次
    })
    return config
}

// 场景 3：资源关闭
var closeOnce sync.Once

func Close() error {
    var err error
    closeOnce.Do(func() {
        err = realClose()  // 确保只关闭一次
    })
    return err
}
```

### 五、Cond（条件变量）

#### 1. 基本用法

```go
type Queue struct {
    mu    sync.Mutex
    cond  *sync.Cond
    items []interface{}
}

func NewQueue() *Queue {
    q := &Queue{}
    q.cond = sync.NewCond(&q.mu)
    return q
}

// 生产者
func (q *Queue) Put(item interface{}) {
    q.mu.Lock()
    defer q.mu.Unlock()

    q.items = append(q.items, item)
    q.cond.Signal()  // 唤醒一个等待者
}

// 消费者
func (q *Queue) Get() interface{} {
    q.mu.Lock()
    defer q.mu.Unlock()

    for len(q.items) == 0 {
        q.cond.Wait()  // 等待条件满足
    }

    item := q.items[0]
    q.items = q.items[1:]
    return item
}
```

#### 2. Cond 的三个方法

```go
// Signal: 唤醒一个等待的 goroutine
cond.Signal()

// Broadcast: 唤醒所有等待的 goroutine
cond.Broadcast()

// Wait: 释放锁并等待，被唤醒后重新获取锁
cond.Wait()
```

#### 3. 使用注意事项

```go
// 错误：不在循环中 Wait
func bad() {
    cond.L.Lock()
    defer cond.L.Unlock()

    if len(items) == 0 {
        cond.Wait()  // 可能虚假唤醒
    }
    // 使用 items
}

// 正确：在循环中 Wait
func good() {
    cond.L.Lock()
    defer cond.L.Unlock()

    for len(items) == 0 {  // 循环检查条件
        cond.Wait()
    }
    // 使用 items
}
```

### 六、原子操作（atomic）

#### 1. 基本操作

```go
var counter int64

// 原子加法
atomic.AddInt64(&counter, 1)

// 原子加载
value := atomic.LoadInt64(&counter)

// 原子存储
atomic.StoreInt64(&counter, 100)

// 比较并交换（CAS）
swapped := atomic.CompareAndSwapInt64(&counter, 100, 101)

// 交换
old := atomic.SwapInt64(&counter, 200)
```

#### 2. atomic.Value

```go
var config atomic.Value

// 存储
config.Store(&Config{Timeout: 5})

// 加载
c := config.Load().(*Config)

// 典型应用：配置热更新
func updateConfig() {
    newConfig := loadConfigFromFile()
    config.Store(newConfig)  // 原子更新
}

func getConfig() *Config {
    return config.Load().(*Config)
}
```

#### 3. 原子操作 vs 锁

```go
// 使用锁
var mu sync.Mutex
var counter int64

func incWithLock() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// 使用原子操作
var atomicCounter int64

func incAtomic() {
    atomic.AddInt64(&atomicCounter, 1)
}

// 性能对比：
// BenchmarkLock-8      50000000    30 ns/op
// BenchmarkAtomic-8   200000000     5 ns/op
```

**选择建议**：
- 原子操作：简单的计数、标志位
- 锁：复杂的临界区、多个变量的一致性

### 七、sync.Map

#### 1. 基本用法

```go
var m sync.Map

// 存储
m.Store("key", "value")

// 加载
value, ok := m.Load("key")

// 加载或存储
actual, loaded := m.LoadOrStore("key", "default")

// 删除
m.Delete("key")

// 范围遍历
m.Range(func(key, value interface{}) bool {
    fmt.Printf("%v: %v\n", key, value)
    return true  // 返回 false 停止遍历
})
```

#### 2. 适用场景

```go
// 场景 1：缓存（读多写少）
var cache sync.Map

func getUser(id int) *User {
    if v, ok := cache.Load(id); ok {
        return v.(*User)
    }

    user := loadFromDB(id)
    cache.Store(id, user)
    return user
}

// 场景 2：多个 goroutine 写入不同的键
var results sync.Map

func process(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            result := compute(item)
            results.Store(item.ID, result)  // 不同键，无冲突
        }(item)
    }
    wg.Wait()
}
```

#### 3. sync.Map vs map + Mutex

| 特性 | sync.Map | map + RWMutex |
|------|----------|---------------|
| 读多写少 | 优秀 | 良好 |
| 写多读少 | 一般 | 良好 |
| 键集合稳定 | 优秀 | 良好 |
| 键集合频繁变化 | 较差 | 良好 |
| 类型安全 | 否（interface{}） | 是 |

### 八、errgroup

#### 1. 基本用法

```go
import "golang.org/x/sync/errgroup"

func fetchAll(urls []string) error {
    g, ctx := errgroup.WithContext(context.Background())

    results := make([][]byte, len(urls))
    for i, url := range urls {
        i, url := i, url  // 捕获变量
        g.Go(func() error {
            data, err := fetch(ctx, url)
            if err != nil {
                return err  // 任一失败会取消其他任务
            }
            results[i] = data
            return nil
        })
    }

    // 等待所有 goroutine 完成，返回第一个错误
    if err := g.Wait(); err != nil {
        return err
    }

    return nil
}
```

#### 2. 限制并发数

```go
func fetchWithLimit(urls []string, maxConcurrency int) error {
    g, ctx := errgroup.WithContext(context.Background())
    g.SetLimit(maxConcurrency)  // Go 1.20+

    for _, url := range urls {
        url := url
        g.Go(func() error {
            return fetch(ctx, url)
        })
    }

    return g.Wait()
}
```

### 九、Channel 作为同步原语

#### 1. 信号量

```go
// 限制并发数
sem := make(chan struct{}, maxConcurrency)

for _, item := range items {
    sem <- struct{}{}  // 获取
    go func(item Item) {
        defer func() { <-sem }()  // 释放
        process(item)
    }(item)
}
```

#### 2. 通知退出

```go
done := make(chan struct{})

go func() {
    // 工作...
    close(done)  // 通知完成
}()

<-done  // 等待完成
```

#### 3. 定时器

```go
select {
case <-time.After(5 * time.Second):
    fmt.Println("timeout")
case result := <-workChan:
    fmt.Println("got result:", result)
}
```

### 十、最佳实践

1. **优先使用高层抽象**：
   - 使用 channel 而非共享内存
   - 使用 errgroup 管理 goroutine 组
   - 使用 context 传播取消信号

2. **锁的使用规范**：
   - 尽量减小临界区
   - defer 解锁确保安全
   - 不要拷贝锁
   - 避免在持有锁时调用外部函数

3. **避免常见陷阱**：
   - WaitGroup 在 goroutine 外 Add
   - Mutex 不可重入
   - 读锁不能升级为写锁
   - atomic.Value 的值类型应一致

4. **性能考量**：
   - 读多写少用 RWMutex 或 sync.Map
   - 简单计数用 atomic
   - 复杂临界区用 Mutex
   - 高并发场景考虑分片锁
