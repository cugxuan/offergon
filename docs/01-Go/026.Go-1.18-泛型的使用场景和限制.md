---
title: Go 1.18 泛型的使用场景和限制
tags:
  - Go
status: robot
class: Go
ref:
---

## 要点精炼

1. **泛型核心价值**：消除类型断言和反射，提高代码复用性和类型安全性，适合容器、算法、工具函数等通用场景
2. **类型参数约束**：使用 `any`、`comparable`、自定义接口约束类型参数，控制泛型函数/类型的行为
3. **主要限制**：不支持类型参数的特化（specialization）、不支持变长类型参数、方法不能声明类型参数（只能在接收者类型上）
4. **性能考虑**：泛型通过字典传递实现，有轻微性能开销（相比手写代码），但比反射快得多

## 详细回答

### 1. 泛型基础语法

#### 1.1 泛型函数

```go
// 基本泛型函数
func Print[T any](value T) {
    fmt.Println(value)
}

// 使用
Print[int](42)
Print[string]("hello")
Print(3.14)  // 类型推导

// 多个类型参数
func Map[T, U any](slice []T, fn func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// 使用
numbers := []int{1, 2, 3}
strings := Map(numbers, func(n int) string {
    return fmt.Sprintf("num-%d", n)
})
// strings: ["num-1", "num-2", "num-3"]
```

#### 1.2 泛型类型

```go
// 泛型切片
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

// 使用
intStack := &Stack[int]{}
intStack.Push(1)
intStack.Push(2)
value, ok := intStack.Pop()  // value: 2

stringStack := &Stack[string]{}
stringStack.Push("hello")
```

### 2. 类型约束（Type Constraints）

#### 2.1 内置约束

```go
// any：任意类型（interface{} 的别名）
func Print[T any](value T) {
    fmt.Println(value)
}

// comparable：可比较类型（支持 == 和 !=）
func Contains[T comparable](slice []T, target T) bool {
    for _, item := range slice {
        if item == target {
            return true
        }
    }
    return false
}

// 使用
Contains([]int{1, 2, 3}, 2)        // true
Contains([]string{"a", "b"}, "c")  // false
// Contains([][]int{{1}}, []int{1}) // 编译错误：[]int 不是 comparable
```

#### 2.2 自定义约束

```go
// 方式1：接口约束
type Number interface {
    int | int64 | float64
}

func Sum[T Number](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

// 使用
Sum([]int{1, 2, 3})           // 6
Sum([]float64{1.5, 2.5, 3.0}) // 7.0

// 方式2：结构约束
type Stringer interface {
    String() string
}

func PrintAll[T Stringer](items []T) {
    for _, item := range items {
        fmt.Println(item.String())
    }
}

// 方式3：组合约束
type Ordered interface {
    ~int | ~int64 | ~float64 | ~string
}

func Max[T Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

#### 2.3 类型近似（Type Approximation）

```go
// ~ 表示底层类型（underlying type）
type MyInt int

type Integer interface {
    ~int  // 包括 int 和底层类型为 int 的自定义类型
}

func Double[T Integer](n T) T {
    return n * 2
}

// 使用
var x int = 5
var y MyInt = 10

Double(x)  // 10
Double(y)  // 20 (如果没有 ~，MyInt 不满足约束)
```

### 3. 泛型使用场景

#### 3.1 数据结构

```go
// 泛型链表
type Node[T any] struct {
    Value T
    Next  *Node[T]
}

type LinkedList[T any] struct {
    Head *Node[T]
}

func (l *LinkedList[T]) Add(value T) {
    node := &Node[T]{Value: value, Next: l.Head}
    l.Head = node
}

func (l *LinkedList[T]) ToSlice() []T {
    var result []T
    for node := l.Head; node != nil; node = node.Next {
        result = append(result, node.Value)
    }
    return result
}

// 泛型 Map
type SafeMap[K comparable, V any] struct {
    mu   sync.RWMutex
    data map[K]V
}

func NewSafeMap[K comparable, V any]() *SafeMap[K, V] {
    return &SafeMap[K, V]{
        data: make(map[K]V),
    }
}

func (m *SafeMap[K, V]) Set(key K, value V) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.data[key] = value
}

func (m *SafeMap[K, V]) Get(key K) (V, bool) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    value, ok := m.data[key]
    return value, ok
}
```

#### 3.2 算法和工具函数

```go
// 泛型排序
func Sort[T Ordered](slice []T) {
    sort.Slice(slice, func(i, j int) bool {
        return slice[i] < slice[j]
    })
}

// 泛型过滤
func Filter[T any](slice []T, predicate func(T) bool) []T {
    var result []T
    for _, item := range slice {
        if predicate(item) {
            result = append(result, item)
        }
    }
    return result
}

// 使用
numbers := []int{1, 2, 3, 4, 5}
evens := Filter(numbers, func(n int) bool {
    return n%2 == 0
})
// evens: [2, 4]

// 泛型 Reduce
func Reduce[T, U any](slice []T, initial U, fn func(U, T) U) U {
    result := initial
    for _, item := range slice {
        result = fn(result, item)
    }
    return result
}

// 使用
sum := Reduce([]int{1, 2, 3, 4}, 0, func(acc, n int) int {
    return acc + n
})
// sum: 10
```

#### 3.3 Option/Result 类型

```go
// Option 类型（模拟 Rust 的 Option）
type Option[T any] struct {
    value *T
}

func Some[T any](value T) Option[T] {
    return Option[T]{value: &value}
}

func None[T any]() Option[T] {
    return Option[T]{value: nil}
}

func (o Option[T]) IsSome() bool {
    return o.value != nil
}

func (o Option[T]) Unwrap() T {
    if o.value == nil {
        panic("unwrap on None")
    }
    return *o.value
}

func (o Option[T]) UnwrapOr(defaultValue T) T {
    if o.value == nil {
        return defaultValue
    }
    return *o.value
}

// 使用
func FindUser(id int) Option[User] {
    user, ok := users[id]
    if !ok {
        return None[User]()
    }
    return Some(user)
}

result := FindUser(123)
if result.IsSome() {
    user := result.Unwrap()
    fmt.Println(user.Name)
} else {
    fmt.Println("User not found")
}

// Result 类型（模拟 Rust 的 Result）
type Result[T any] struct {
    value T
    err   error
}

func Ok[T any](value T) Result[T] {
    return Result[T]{value: value}
}

func Err[T any](err error) Result[T] {
    return Result[T]{err: err}
}

func (r Result[T]) IsOk() bool {
    return r.err == nil
}

func (r Result[T]) Unwrap() T {
    if r.err != nil {
        panic(r.err)
    }
    return r.value
}

func (r Result[T]) UnwrapOr(defaultValue T) T {
    if r.err != nil {
        return defaultValue
    }
    return r.value
}
```

#### 3.4 通道操作

```go
// 泛型 channel 工具
func Merge[T any](channels ...<-chan T) <-chan T {
    out := make(chan T)
    var wg sync.WaitGroup

    wg.Add(len(channels))
    for _, ch := range channels {
        go func(c <-chan T) {
            defer wg.Done()
            for v := range c {
                out <- v
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}

// Fan-out
func FanOut[T any](in <-chan T, n int) []<-chan T {
    outs := make([]<-chan T, n)
    for i := 0; i < n; i++ {
        ch := make(chan T)
        outs[i] = ch
        go func(out chan<- T) {
            defer close(out)
            for v := range in {
                out <- v
            }
        }(ch)
    }
    return outs
}
```

### 4. 泛型的限制

#### 4.1 方法不能声明类型参数

```go
// 错误：方法不能有类型参数
type Container struct {}

func (c *Container) Add[T any](value T) {  // 编译错误！
    // ...
}

// 正确：在类型上声明泛型
type Container[T any] struct {
    items []T
}

func (c *Container[T]) Add(value T) {
    c.items = append(c.items, value)
}
```

#### 4.2 不支持类型特化（Specialization）

```go
// 无法为特定类型提供优化实现
func Process[T any](value T) {
    // 不能写：
    // if T is int {
    //     // 针对 int 的优化
    // }

    // 只能使用类型断言（失去泛型优势）
    if v, ok := any(value).(int); ok {
        // 处理 int
        _ = v
    }
}
```

#### 4.3 不支持变长类型参数

```go
// 错误：不支持变长类型参数
func MultiType[T1, T2... any](values ...T2) {  // 编译错误！
    // ...
}

// 需要明确指定类型数量
func Pair[T1, T2 any](a T1, b T2) (T1, T2) {
    return a, b
}
```

#### 4.4 不支持类型参数的操作符重载

```go
// 不能直接使用操作符
func Add[T any](a, b T) T {
    return a + b  // 编译错误：T 不一定支持 +
}

// 需要使用约束
type Number interface {
    ~int | ~int64 | ~float64
}

func Add[T Number](a, b T) T {
    return a + b  // OK
}
```

#### 4.5 不能使用类型断言或类型切换

```go
func Process[T any](value T) {
    // 错误：不能直接判断 T 的具体类型
    // switch T {  // 编译错误！
    // case int:
    //     // ...
    // }

    // 需要转换为 any
    switch v := any(value).(type) {
    case int:
        fmt.Println("int:", v)
    case string:
        fmt.Println("string:", v)
    }
}
```

### 5. 性能考虑

#### 5.1 泛型 vs 接口 vs 反射

```go
// 泛型
func SumGeneric[T Number](numbers []T) T {
    var sum T
    for _, n := range numbers {
        sum += n
    }
    return sum
}

// 接口
func SumInterface(numbers []interface{}) int {
    sum := 0
    for _, n := range numbers {
        sum += n.(int)  // 类型断言开销
    }
    return sum
}

// 反射
func SumReflect(numbers interface{}) int {
    sum := 0
    slice := reflect.ValueOf(numbers)
    for i := 0; i < slice.Len(); i++ {
        sum += int(slice.Index(i).Int())
    }
    return sum
}

// Benchmark 结果（大致）：
// SumGeneric:   1.0x  （基准）
// SumInterface: 1.2x  （稍慢，有类型断言）
// SumReflect:   10x   （慢得多）
```

#### 5.2 泛型实现机制

Go 泛型通过"字典传递"（Dictionaries）实现，而不是 C++ 的模板实例化：

```go
// Go 编译器为每个不同的类型生成一份字典
// 字典包含类型信息和操作方法指针

func Process[T any](value T) {
    // 编译器生成类似：
    // func Process(value interface{}, dict *TypeDict) {
    //     // 使用 dict 获取 T 的类型信息
    // }
}
```

优点：
- 编译产物更小（不会为每种类型生成代码）
- 编译速度快

缺点：
- 运行时有间接调用开销
- 无法进行类型特化优化

### 6. 最佳实践

#### 6.1 何时使用泛型

**适合使用泛型：**
```go
// 1. 容器类型
type Queue[T any] struct { /* ... */ }

// 2. 通用算法
func Map[T, U any](slice []T, fn func(T) U) []U

// 3. 工具函数
func Must[T any](value T, err error) T {
    if err != nil {
        panic(err)
    }
    return value
}

// 4. 类型安全的包装
type Atomic[T any] struct {
    mu    sync.Mutex
    value T
}
```

**不适合使用泛型：**
```go
// 1. 简单的接口场景（接口更灵活）
type Reader interface {
    Read([]byte) (int, error)
}

// 2. 需要类型特化的场景
// 不如手写针对特定类型的优化版本

// 3. 业务逻辑代码
// 泛型增加复杂度，业务代码应该简单明了
```

#### 6.2 命名约定

```go
// 单个类型参数：T、E、K、V
func Process[T any](value T) T

// 多个类型参数：描述性名称
func Convert[Input, Output any](value Input) Output

// 约束性类型参数：描述约束
func Sum[N Number](numbers []N) N
```

#### 6.3 避免过度泛型化

```go
// 过度泛型化
func DoSomething[T any, U any, V any](a T, b U) V {
    // 过于抽象，难以理解
}

// 更好的做法：具体化
func ConvertUser(data UserData) User {
    // 清晰明了
}
```

### 7. 实战示例：泛型缓存

```go
package cache

import (
    "sync"
    "time"
)

type item[T any] struct {
    value      T
    expiration time.Time
}

type Cache[K comparable, V any] struct {
    mu    sync.RWMutex
    items map[K]item[V]
}

func New[K comparable, V any]() *Cache[K, V] {
    return &Cache[K, V]{
        items: make(map[K]item[V]),
    }
}

func (c *Cache[K, V]) Set(key K, value V, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()

    c.items[key] = item[V]{
        value:      value,
        expiration: time.Now().Add(ttl),
    }
}

func (c *Cache[K, V]) Get(key K) (V, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    item, ok := c.items[key]
    if !ok {
        var zero V
        return zero, false
    }

    if time.Now().After(item.expiration) {
        var zero V
        return zero, false
    }

    return item.value, true
}

func (c *Cache[K, V]) Delete(key K) {
    c.mu.Lock()
    defer c.mu.Unlock()
    delete(c.items, key)
}

// 使用
func main() {
    // 字符串键，整数值
    intCache := cache.New[string, int]()
    intCache.Set("count", 42, 1*time.Minute)

    // 整数键，结构体值
    userCache := cache.New[int, User]()
    userCache.Set(123, User{Name: "Alice"}, 5*time.Minute)

    if value, ok := userCache.Get(123); ok {
        fmt.Println(value.Name)
    }
}
```

### 8. 总结

1. **泛型适合通用代码**：容器、算法、工具函数
2. **使用约束控制行为**：`any`、`comparable`、自定义接口
3. **注意限制**：方法不能有类型参数、不支持特化
4. **性能权衡**：比反射快，比手写慢一点点
5. **保持简单**：不要过度泛型化，业务代码优先使用具体类型
6. **类型推导**：大多数情况下编译器可以自动推导类型参数
