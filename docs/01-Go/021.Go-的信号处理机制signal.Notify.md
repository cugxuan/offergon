---
title: Go 的信号处理机制（signal.Notify）
tags:
  - Go
status: robot
class: Go
ref:
---

## 要点精炼

1. **信号处理机制**：Go 通过 `signal.Notify` 函数将操作系统信号转发到 channel，实现异步非阻塞的信号处理
2. **常用信号**：SIGINT（Ctrl+C）、SIGTERM（优雅终止）、SIGHUP（重载配置）、SIGUSR1/SIGUSR2（自定义信号）
3. **处理模式**：使用 goroutine 监听信号 channel，支持多个信号同时注册和选择性处理
4. **注意事项**：信号 channel 需要有足够缓冲区，避免信号丢失；使用 `signal.Stop` 取消注册；某些信号（如 SIGKILL）无法捕获

## 详细回答

### 1. 信号处理基本用法

Go 的 `signal` 包提供了跨平台的信号处理机制：

```go
package main

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // 创建信号接收 channel，建议使用缓冲 channel
    sigChan := make(chan os.Signal, 1)

    // 注册要接收的信号
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

    // 启动业务逻辑
    ctx, cancel := context.WithCancel(context.Background())
    go doWork(ctx)

    // 等待信号
    sig := <-sigChan
    fmt.Printf("收到信号: %v\n", sig)

    // 触发优雅关闭
    cancel()
    time.Sleep(2 * time.Second) // 等待清理完成
    fmt.Println("程序退出")
}

func doWork(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            fmt.Println("停止工作...")
            return
        case <-ticker.C:
            fmt.Println("工作中...")
        }
    }
}
```

### 2. 多信号处理和信号重置

```go
func advancedSignalHandling() {
    sigChan := make(chan os.Signal, 2)

    // 监听多个信号
    signal.Notify(sigChan,
        syscall.SIGINT,  // Ctrl+C
        syscall.SIGTERM, // kill
        syscall.SIGHUP,  // 终端关闭
        syscall.SIGUSR1, // 自定义信号1
    )

    // 信号处理循环
    for sig := range sigChan {
        switch sig {
        case syscall.SIGINT, syscall.SIGTERM:
            fmt.Println("收到终止信号，开始优雅关闭...")
            // 执行清理逻辑
            cleanup()
            os.Exit(0)

        case syscall.SIGHUP:
            fmt.Println("收到 SIGHUP，重载配置...")
            reloadConfig()

        case syscall.SIGUSR1:
            fmt.Println("收到 SIGUSR1，打印堆栈信息...")
            dumpStackTrace()
        }
    }
}

// 取消信号监听
func stopSignalHandling(sigChan chan os.Signal) {
    signal.Stop(sigChan) // 停止向 channel 发送信号
    close(sigChan)       // 关闭 channel
}
```

### 3. 结合优雅关闭的完整示例

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

type Server struct {
    httpServer *http.Server
}

func (s *Server) Start() {
    s.httpServer = &http.Server{
        Addr:    ":8080",
        Handler: http.HandlerFunc(handler),
    }

    go func() {
        if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            fmt.Printf("服务启动失败: %v\n", err)
        }
    }()
}

func (s *Server) Shutdown(ctx context.Context) error {
    fmt.Println("开始关闭 HTTP 服务...")
    return s.httpServer.Shutdown(ctx)
}

func handler(w http.ResponseWriter, r *http.Request) {
    time.Sleep(100 * time.Millisecond) // 模拟处理时间
    w.Write([]byte("Hello World"))
}

func main() {
    server := &Server{}
    server.Start()
    fmt.Println("服务已启动在 :8080")

    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

    <-quit
    fmt.Println("\n收到关闭信号...")

    // 设置关闭超时时间
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // 优雅关闭
    if err := server.Shutdown(ctx); err != nil {
        fmt.Printf("服务关闭失败: %v\n", err)
    }

    fmt.Println("服务已关闭")
}
```

### 4. 信号处理最佳实践

```go
// 1. 使用缓冲 channel，避免信号丢失
sigChan := make(chan os.Signal, 1) // 至少缓冲 1 个信号

// 2. 忽略某些信号
signal.Ignore(syscall.SIGHUP)

// 3. 重置为默认处理
signal.Reset(syscall.SIGINT)

// 4. 捕获所有信号（除了 SIGKILL 和 SIGSTOP）
signal.Notify(sigChan) // 不传入信号参数表示捕获所有

// 5. 使用 select 实现超时控制
select {
case sig := <-sigChan:
    fmt.Printf("收到信号: %v\n", sig)
case <-time.After(5 * time.Second):
    fmt.Println("超时，继续运行")
}
```

### 5. 常见信号说明

| 信号 | 编号 | 说明 | 是否可捕获 |
|------|------|------|-----------|
| SIGINT | 2 | Ctrl+C 中断 | 是 |
| SIGTERM | 15 | 终止信号（默认 kill） | 是 |
| SIGKILL | 9 | 强制终止 | 否 |
| SIGHUP | 1 | 终端挂起（常用于重载配置） | 是 |
| SIGUSR1 | 10 | 用户自定义信号1 | 是 |
| SIGUSR2 | 12 | 用户自定义信号2 | 是 |
| SIGQUIT | 3 | Ctrl+\ 退出并生成 core dump | 是 |

### 6. 注意事项

1. **信号不会排队**：如果处理速度慢于信号到达速度，信号可能丢失
2. **channel 容量**：建议使用缓冲 channel，容量至少为 1
3. **多次 Notify**：重复调用会累加信号集合，不会覆盖
4. **goroutine 安全**：信号处理在单独的 goroutine 中，需要注意并发安全
5. **平台差异**：某些信号在不同操作系统上行为不同（如 Windows 不支持 SIGUSR1）
6. **无法捕获的信号**：SIGKILL 和 SIGSTOP 无法被捕获或忽略

### 7. 生产环境应用场景

- **优雅关闭**：监听 SIGINT/SIGTERM，完成请求处理后退出
- **配置热更新**：监听 SIGHUP，重新加载配置文件
- **调试信息输出**：监听 SIGUSR1，打印 goroutine 堆栈或性能数据
- **日志轮转**：监听 SIGUSR2，触发日志文件切割
- **容器编排**：Kubernetes 使用 SIGTERM 进行优雅终止，需正确处理
