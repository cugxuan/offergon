---
title: Go 的网络模型（netpoller）是如何实现的？
tags:
  - Go
status: robot
class: Go
slug: go-netpoller-implementation
ref:
---

## 要点精炼

1. **核心机制**：netpoller 基于操作系统 I/O 多路复用（Linux epoll、BSD kqueue、Windows IOCP）实现，将网络 I/O 与 goroutine 调度器深度集成
2. **工作原理**：网络连接设为非阻塞模式，goroutine 在 I/O 就绪前挂起，netpoller 监听 I/O 事件并唤醒对应 goroutine，实现高并发低开销
3. **优势特点**：用户态调度（无系统调用开销）、自动负载均衡、支持百万级并发连接、goroutine 与网络 I/O 无缝集成
4. **使用场景**：所有标准库网络操作（net.Conn、http.Server）自动使用 netpoller，开发者无需手动管理，简化并发网络编程

## 详细回答

### 1. 传统网络模型 vs Go netpoller

#### 1.1 传统阻塞 I/O

```go
// 传统方式：每个连接一个线程
func handleClient(conn net.Conn) {
    buf := make([]byte, 1024)
    for {
        n, err := conn.Read(buf)  // 阻塞等待
        if err != nil {
            return
        }
        conn.Write(buf[:n])  // 阻塞写入
    }
}

// 主循环：每个连接创建一个线程
for {
    conn, err := listener.Accept()
    if err != nil {
        continue
    }
    go handleClient(conn)  // Go 中是 goroutine，开销小得多
}
```

问题：
- C10K 问题：10000 个连接需要 10000 个线程
- 线程上下文切换开销大
- 内存占用高（每个线程需要 MB 级栈）

#### 1.2 Go netpoller 方式

```go
// Go 的方式（自动使用 netpoller）
func handleClient(conn net.Conn) {
    buf := make([]byte, 1024)
    for {
        n, err := conn.Read(buf)  // 看似阻塞，实际是 netpoller 调度
        if err != nil {
            return
        }
        conn.Write(buf[:n])
    }
}

// 100 万并发连接也只需少量系统线程（GOMAXPROCS）
```

### 2. netpoller 实现原理

#### 2.1 架构图

```
┌─────────────────────────────────────────────┐
│            Application Code                 │
│  (net.Conn.Read/Write - Goroutine)        │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│         Runtime netpoller                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ fd ready │  │ fd ready │  │ fd ready │ │
│  │ queue    │  │ queue    │  │ queue    │ │
│  └──────────┘  └──────────┘  └──────────┘ │
│       P0           P1            P2         │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│      OS I/O Multiplexing                    │
│  ┌────────────────────────────────────┐    │
│  │  epoll (Linux)                     │    │
│  │  kqueue (BSD/macOS)                │    │
│  │  IOCP (Windows)                    │    │
│  └────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
```

#### 2.2 核心数据结构

```go
// runtime/netpoll.go (简化版)

// pollDesc 表示一个网络文件描述符
type pollDesc struct {
    fd      int            // 文件描述符
    rg      uintptr        // 等待读的 goroutine
    wg      uintptr        // 等待写的 goroutine
    rd      int64          // 读超时
    wd      int64          // 写超时
    // ...
}

// 网络轮询器
type netpollDesc struct {
    epfd int                // epoll 文件描述符 (Linux)
    fds  map[int]*pollDesc  // fd -> pollDesc 映射
    // ...
}
```

#### 2.3 工作流程

```go
// 1. 初始化：创建 epoll/kqueue
func netpollinit() {
    epfd = epollcreate1(EPOLL_CLOEXEC)
    // ...
}

// 2. 连接建立：注册 fd 到 netpoller
func netpollopen(fd uintptr, pd *pollDesc) int32 {
    var ev epollevent
    ev.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLET
    ev.data = *(**pollDesc)(unsafe.Pointer(&ev.data))
    ev.data = pd
    return epollctl(epfd, EPOLL_CTL_ADD, int32(fd), &ev)
}

// 3. I/O 操作：goroutine 挂起等待
func netpollblock(pd *pollDesc, mode int32) bool {
    gpp := &pd.rg  // 读操作
    if mode == 'w' {
        gpp := &pd.wg  // 写操作
    }

    // 将当前 goroutine 挂起
    gopark(netpollblockcommit, unsafe.Pointer(gpp), "IO wait")
    return true
}

// 4. I/O 就绪：netpoller 唤醒 goroutine
func netpoll(delay int64) gList {
    var events [128]epollevent
    n := epollwait(epfd, &events[0], int32(len(events)), delay)

    var toRun gList
    for i := int32(0); i < n; i++ {
        ev := &events[i]
        pd := *(**pollDesc)(unsafe.Pointer(&ev.data))

        // 唤醒等待读的 goroutine
        if ev.events & (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLERR) != 0 {
            netpollready(&toRun, pd, 'r')
        }

        // 唤醒等待写的 goroutine
        if ev.events & (EPOLLOUT | EPOLLHUP | EPOLLERR) != 0 {
            netpollready(&toRun, pd, 'w')
        }
    }
    return toRun
}
```

### 3. netpoller 与调度器集成

```go
// runtime/proc.go

// M (machine) 寻找可运行的 goroutine
func findrunnable() (gp *g, inheritTime bool) {
    // ... 其他逻辑

    // 如果没有可运行的 goroutine，检查 netpoller
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 {
        if gp := netpoll(false); gp != nil {
            injectglist(gp)  // 将就绪的 goroutine 放入运行队列
            status := readgstatus(gp)
            return gp, false
        }
    }

    // ...
}

// sysmon 系统监控线程定期检查 netpoller
func sysmon() {
    for {
        // ...

        // 检查网络 I/O
        if netpollinited() && lastpoll != 0 && lastpoll+10*1000*1000 < now {
            atomic.Cas64(&sched.lastpoll, uint64(lastpoll), uint64(now))
            gp := netpoll(false)
            if gp != nil {
                injectglist(gp)
            }
        }

        // ...
    }
}
```

### 4. 实际使用示例

#### 4.1 TCP Server

```go
package main

import (
    "fmt"
    "net"
    "time"
)

func main() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        panic(err)
    }
    defer listener.Close()

    fmt.Println("Server listening on :8080")

    for {
        conn, err := listener.Accept()  // 使用 netpoller
        if err != nil {
            continue
        }

        // 每个连接一个 goroutine（轻量级）
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()

    buf := make([]byte, 1024)
    for {
        // 看似阻塞，实际是 netpoller 调度
        conn.SetReadDeadline(time.Now().Add(30 * time.Second))
        n, err := conn.Read(buf)  // netpoller 挂起当前 goroutine
        if err != nil {
            return
        }

        // Echo 回复
        conn.Write(buf[:n])  // netpoller 管理写操作
    }
}
```

#### 4.2 HTTP Server

```go
// net/http 内部自动使用 netpoller
func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        // 读取请求体（netpoller）
        body, _ := io.ReadAll(r.Body)

        // 写入响应（netpoller）
        w.Write([]byte("Hello"))
    })

    // 支持百万级并发连接
    http.ListenAndServe(":8080", nil)
}
```

### 5. netpoller 性能优化

#### 5.1 边缘触发 (Edge-Triggered)

```go
// Linux epoll 使用 EPOLLET（边缘触发）
ev.events = EPOLLIN | EPOLLOUT | EPOLLET

// 优势：
// - 减少系统调用次数
// - 避免重复通知
// - 提高吞吐量
```

#### 5.2 零拷贝优化

```go
// sendfile 系统调用（零拷贝）
func (c *conn) sendFile(r io.Reader) (n int64, err error) {
    // 使用 splice/sendfile 避免用户态数据复制
    // 内核直接传输数据
}

// 使用示例
http.ServeFile(w, r, "largefile.dat")  // 自动使用零拷贝
```

### 6. netpoller 限制和注意事项

```go
// 1. 文件 I/O 不使用 netpoller
file, _ := os.Open("data.txt")
// 文件读写仍然是同步阻塞的

// 2. deadline 设置
conn.SetDeadline(time.Now().Add(5 * time.Second))
// netpoller 会在超时后唤醒 goroutine

// 3. 连接数限制
// ulimit -n  查看文件描述符限制
// 需要调整系统参数支持百万连接

// 4. 内存使用
// 每个 conn 占用约 4KB 内存
// 100 万连接约需 4GB 内存
```

### 7. 与其他语言对比

| 特性 | Go netpoller | Node.js | Java NIO | Rust Tokio |
|------|--------------|---------|----------|------------|
| **模型** | goroutine + netpoller | 事件循环 + 回调 | Selector + Channel | Future + Poll |
| **编程模式** | 同步（看起来） | 异步 + 回调/Promise | 显式异步 | async/await |
| **性能** | 高 | 高 | 高 | 最高 |
| **易用性** | 最佳 | 中等（回调地狱） | 复杂 | 中等 |
| **并发模型** | M:N（多对多） | 单线程 | N:N | M:N |

### 8. 实战：百万并发测试

```go
package main

import (
    "fmt"
    "net"
    "sync"
    "time"
)

func server() {
    listener, _ := net.Listen("tcp", ":8080")

    var count int64
    var mu sync.Mutex

    go func() {
        ticker := time.NewTicker(1 * time.Second)
        for range ticker.C {
            mu.Lock()
            fmt.Printf("Active connections: %d\n", count)
            mu.Unlock()
        }
    }()

    for {
        conn, _ := listener.Accept()

        mu.Lock()
        count++
        mu.Unlock()

        go func(c net.Conn) {
            defer func() {
                mu.Lock()
                count--
                mu.Unlock()
                c.Close()
            }()

            buf := make([]byte, 4)
            for {
                c.SetReadDeadline(time.Now().Add(1 * time.Minute))
                _, err := c.Read(buf)
                if err != nil {
                    return
                }
            }
        }(conn)
    }
}

func client(id int, wg *sync.WaitGroup) {
    defer wg.Done()

    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        return
    }
    defer conn.Close()

    // 保持连接
    time.Sleep(10 * time.Minute)
}

func main() {
    go server()

    time.Sleep(1 * time.Second)

    // 创建 100 万个并发连接
    var wg sync.WaitGroup
    for i := 0; i < 1000000; i++ {
        wg.Add(1)
        go client(i, &wg)

        if i%10000 == 0 {
            fmt.Printf("Created %d connections\n", i)
        }
    }

    wg.Wait()
}
```

### 9. 系统调优

```bash
# Linux 系统参数调优

# 1. 增加文件描述符限制
ulimit -n 1000000
# 或编辑 /etc/security/limits.conf
* soft nofile 1000000
* hard nofile 1000000

# 2. 调整 TCP 参数
sysctl -w net.ipv4.tcp_tw_reuse=1
sysctl -w net.ipv4.tcp_tw_recycle=1
sysctl -w net.ipv4.tcp_fin_timeout=30
sysctl -w net.ipv4.tcp_keepalive_time=1200
sysctl -w net.ipv4.ip_local_port_range="1024 65535"

# 3. 增加 socket 缓冲区
sysctl -w net.core.rmem_max=16777216
sysctl -w net.core.wmem_max=16777216
```

### 10. 总结

1. **netpoller 优势**：
   - 高并发（百万级连接）
   - 低延迟（事件驱动）
   - 易用性（同步编程模型）
   - 自动调度（与 runtime 集成）

2. **关键特性**：
   - 基于 epoll/kqueue/IOCP
   - 非阻塞 I/O + goroutine 调度
   - 边缘触发模式
   - 零系统调用开销（大多数情况）

3. **最佳实践**：
   - 使用 deadline 控制超时
   - 合理设置缓冲区大小
   - 注意系统资源限制
   - 监控 goroutine 数量
   - 性能测试验证并发能力

4. **适用场景**：
   - 高并发 Web 服务器
   - WebSocket 服务
   - RPC 框架
   - 代理服务器
   - 实时通信系统
