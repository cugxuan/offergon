---
title: Go 如何实现优雅关闭（graceful shutdown）？
tags:
  - Go
status: robot
class: Go
ref:
---

## 要点精炼

1. **核心原理**：监听系统信号（SIGINT/SIGTERM）触发关闭流程，停止接受新请求，等待现有请求完成，清理资源后退出
2. **实现步骤**：使用 signal.Notify 捕获信号 → 调用 http.Server.Shutdown 停止监听 → 设置超时等待请求完成 → 关闭数据库/缓存连接 → 程序退出
3. **关键组件**：context.WithTimeout 控制关闭超时、sync.WaitGroup 等待 goroutine 完成、defer 确保资源释放
4. **最佳实践**：合理设置超时时间（30-60s）、优先级关闭（先停新请求再清理资源）、记录关闭日志、健康检查配合

## 详细回答

### 1. 优雅关闭的必要性

#### 1.1 问题场景

```go
// 不优雅的关闭（直接杀进程）
$ kill -9 <pid>

// 可能导致的问题：
// 1. 正在处理的请求被中断，返回 500 错误
// 2. 数据库事务未提交，数据不一致
// 3. 缓存未刷新，数据丢失
// 4. 文件未关闭，数据损坏
// 5. 消息队列消息未 ACK，重复消费
```

#### 1.2 优雅关闭流程

```
1. 收到关闭信号（SIGTERM）
   ↓
2. 停止接受新请求（关闭 listener）
   ↓
3. 等待现有请求完成（最长 30s）
   ↓
4. 关闭数据库连接池
   ↓
5. 关闭缓存连接
   ↓
6. 刷新日志缓冲区
   ↓
7. 程序退出（exit 0）
```

### 2. HTTP 服务器优雅关闭

#### 2.1 基础实现

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // 创建 HTTP 服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: http.HandlerFunc(handler),
    }

    // 在 goroutine 中启动服务器
    go func() {
        fmt.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            fmt.Printf("Server error: %v\n", err)
        }
    }()

    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    fmt.Println("Shutting down server...")

    // 设置关闭超时
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // 优雅关闭
    if err := server.Shutdown(ctx); err != nil {
        fmt.Printf("Server forced to shutdown: %v\n", err)
    }

    fmt.Println("Server exited")
}

func handler(w http.ResponseWriter, r *http.Request) {
    // 模拟长时间处理
    time.Sleep(5 * time.Second)
    w.Write([]byte("Hello World"))
}
```

#### 2.2 完整的服务器生命周期

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"
)

type Server struct {
    httpServer *http.Server
    wg         sync.WaitGroup
    shutdownCh chan struct{}
}

func NewServer() *Server {
    return &Server{
        shutdownCh: make(chan struct{}),
    }
}

func (s *Server) Start() error {
    // 配置 HTTP 服务器
    s.httpServer = &http.Server{
        Addr:         ":8080",
        Handler:      s.routes(),
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  120 * time.Second,
    }

    // 启动后台任务
    s.startBackgroundTasks()

    // 启动服务器
    fmt.Println("Starting server on :8080")
    if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return err
    }

    return nil
}

func (s *Server) routes() http.Handler {
    mux := http.NewServeMux()
    mux.HandleFunc("/", s.handleRequest)
    mux.HandleFunc("/health", s.handleHealth)
    return mux
}

func (s *Server) handleRequest(w http.ResponseWriter, r *http.Request) {
    // 检查是否正在关闭
    select {
    case <-s.shutdownCh:
        http.Error(w, "Server is shutting down", http.StatusServiceUnavailable)
        return
    default:
    }

    // 处理请求
    time.Sleep(2 * time.Second) // 模拟处理
    w.Write([]byte("OK"))
}

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
    select {
    case <-s.shutdownCh:
        w.WriteHeader(http.StatusServiceUnavailable)
        w.Write([]byte("shutting down"))
    default:
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("healthy"))
    }
}

func (s *Server) startBackgroundTasks() {
    // 后台任务 1：定期清理
    s.wg.Add(1)
    go func() {
        defer s.wg.Done()
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        for {
            select {
            case <-s.shutdownCh:
                fmt.Println("Stopping cleanup task...")
                return
            case <-ticker.C:
                fmt.Println("Running cleanup...")
            }
        }
    }()

    // 后台任务 2：指标收集
    s.wg.Add(1)
    go func() {
        defer s.wg.Done()
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for {
            select {
            case <-s.shutdownCh:
                fmt.Println("Stopping metrics collection...")
                return
            case <-ticker.C:
                fmt.Println("Collecting metrics...")
            }
        }
    }()
}

func (s *Server) Shutdown(ctx context.Context) error {
    fmt.Println("Initiating graceful shutdown...")

    // 1. 通知所有后台任务停止
    close(s.shutdownCh)

    // 2. 停止接受新的 HTTP 请求
    if err := s.httpServer.Shutdown(ctx); err != nil {
        return fmt.Errorf("http server shutdown failed: %w", err)
    }
    fmt.Println("HTTP server stopped")

    // 3. 等待后台任务完成
    done := make(chan struct{})
    go func() {
        s.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("All background tasks stopped")
    case <-ctx.Done():
        return fmt.Errorf("shutdown timeout: %w", ctx.Err())
    }

    fmt.Println("Graceful shutdown completed")
    return nil
}

func main() {
    server := NewServer()

    // 在 goroutine 中启动服务器
    go func() {
        if err := server.Start(); err != nil {
            fmt.Printf("Server error: %v\n", err)
        }
    }()

    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    // 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := server.Shutdown(ctx); err != nil {
        fmt.Printf("Shutdown error: %v\n", err)
        os.Exit(1)
    }

    os.Exit(0)
}
```

### 3. 数据库连接优雅关闭

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "time"
)

type Application struct {
    db *sql.DB
}

func (app *Application) Shutdown(ctx context.Context) error {
    fmt.Println("Closing database connections...")

    // 停止接受新连接
    app.db.SetMaxOpenConns(0)

    // 等待活跃连接完成
    done := make(chan error, 1)
    go func() {
        done <- app.db.Close()
    }()

    select {
    case err := <-done:
        if err != nil {
            return fmt.Errorf("database close error: %w", err)
        }
        fmt.Println("Database connections closed")
        return nil
    case <-ctx.Done():
        return fmt.Errorf("database close timeout: %w", ctx.Err())
    }
}
```

### 4. Worker Pool 优雅关闭

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type WorkerPool struct {
    workers   int
    jobs      chan Job
    wg        sync.WaitGroup
    ctx       context.Context
    cancel    context.CancelFunc
}

type Job func()

func NewWorkerPool(workers int) *WorkerPool {
    ctx, cancel := context.WithCancel(context.Background())
    return &WorkerPool{
        workers: workers,
        jobs:    make(chan Job, 100),
        ctx:     ctx,
        cancel:  cancel,
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    fmt.Printf("Worker %d started\n", id)

    for {
        select {
        case <-wp.ctx.Done():
            fmt.Printf("Worker %d stopping...\n", id)
            return
        case job, ok := <-wp.jobs:
            if !ok {
                fmt.Printf("Worker %d: job channel closed\n", id)
                return
            }
            fmt.Printf("Worker %d processing job\n", id)
            job()
        }
    }
}

func (wp *WorkerPool) Submit(job Job) bool {
    select {
    case <-wp.ctx.Done():
        return false
    case wp.jobs <- job:
        return true
    }
}

func (wp *WorkerPool) Shutdown(ctx context.Context) error {
    fmt.Println("Shutting down worker pool...")

    // 1. 停止接受新任务
    wp.cancel()

    // 2. 关闭任务队列
    close(wp.jobs)

    // 3. 等待所有 worker 完成
    done := make(chan struct{})
    go func() {
        wp.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("All workers stopped")
        return nil
    case <-ctx.Done():
        return fmt.Errorf("worker pool shutdown timeout")
    }
}

func main() {
    pool := NewWorkerPool(5)
    pool.Start()

    // 提交任务
    for i := 0; i < 10; i++ {
        i := i
        pool.Submit(func() {
            fmt.Printf("Job %d executing\n", i)
            time.Sleep(2 * time.Second)
        })
    }

    // 模拟运行一段时间后关闭
    time.Sleep(3 * time.Second)

    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    if err := pool.Shutdown(ctx); err != nil {
        fmt.Printf("Shutdown error: %v\n", err)
    }
}
```

### 5. 完整的应用示例

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"

    "github.com/go-redis/redis/v8"
)

type App struct {
    httpServer *http.Server
    db         *sql.DB
    redis      *redis.Client
    wg         sync.WaitGroup
    shutdown   chan struct{}
}

func NewApp() *App {
    return &App{
        shutdown: make(chan struct{}),
    }
}

func (app *App) Initialize() error {
    // 初始化数据库
    db, err := sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        return err
    }
    app.db = db

    // 初始化 Redis
    app.redis = redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })

    // 初始化 HTTP 服务器
    app.httpServer = &http.Server{
        Addr:    ":8080",
        Handler: app.routes(),
    }

    return nil
}

func (app *App) routes() http.Handler {
    mux := http.NewServeMux()
    mux.HandleFunc("/", app.handleRequest)
    return mux
}

func (app *App) handleRequest(w http.ResponseWriter, r *http.Request) {
    select {
    case <-app.shutdown:
        http.Error(w, "shutting down", http.StatusServiceUnavailable)
        return
    default:
    }

    // 业务逻辑
    w.Write([]byte("OK"))
}

func (app *App) Start() error {
    fmt.Println("Starting application...")

    // 启动后台任务
    app.startBackgroundTasks()

    // 启动 HTTP 服务器
    fmt.Println("Starting HTTP server on :8080")
    if err := app.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return err
    }

    return nil
}

func (app *App) startBackgroundTasks() {
    app.wg.Add(1)
    go func() {
        defer app.wg.Done()
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        for {
            select {
            case <-app.shutdown:
                return
            case <-ticker.C:
                // 执行后台任务
            }
        }
    }()
}

func (app *App) Shutdown(ctx context.Context) error {
    fmt.Println("=== Starting graceful shutdown ===")

    // 1. 通知所有组件停止接受新请求
    close(app.shutdown)

    // 2. 关闭 HTTP 服务器
    fmt.Println("Shutting down HTTP server...")
    if err := app.httpServer.Shutdown(ctx); err != nil {
        fmt.Printf("HTTP server shutdown error: %v\n", err)
    } else {
        fmt.Println("HTTP server stopped")
    }

    // 3. 等待后台任务完成
    fmt.Println("Waiting for background tasks...")
    done := make(chan struct{})
    go func() {
        app.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("Background tasks stopped")
    case <-ctx.Done():
        fmt.Println("Background tasks shutdown timeout")
    }

    // 4. 关闭数据库连接
    fmt.Println("Closing database connections...")
    if err := app.db.Close(); err != nil {
        fmt.Printf("Database close error: %v\n", err)
    } else {
        fmt.Println("Database connections closed")
    }

    // 5. 关闭 Redis 连接
    fmt.Println("Closing Redis connection...")
    if err := app.redis.Close(); err != nil {
        fmt.Printf("Redis close error: %v\n", err)
    } else {
        fmt.Println("Redis connection closed")
    }

    fmt.Println("=== Graceful shutdown completed ===")
    return nil
}

func main() {
    app := NewApp()

    if err := app.Initialize(); err != nil {
        fmt.Printf("Initialization error: %v\n", err)
        os.Exit(1)
    }

    // 在 goroutine 中启动应用
    go func() {
        if err := app.Start(); err != nil {
            fmt.Printf("Application error: %v\n", err)
        }
    }()

    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

    <-quit
    fmt.Println("\nReceived shutdown signal")

    // 优雅关闭，最长等待 30 秒
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := app.Shutdown(ctx); err != nil {
        fmt.Printf("Shutdown error: %v\n", err)
        os.Exit(1)
    }

    os.Exit(0)
}
```

### 6. Kubernetes 中的优雅关闭

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 15"]
        # 优雅关闭超时时间
        terminationGracePeriodSeconds: 30
```

配合代码：
```go
func main() {
    // Kubernetes 会发送 SIGTERM 信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGTERM)

    // 等待信号
    <-quit

    // 执行优雅关闭（有 30 秒时间）
    ctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)
    defer cancel()

    app.Shutdown(ctx)
}
```

### 7. 最佳实践

1. **合理的超时时间**：
   - HTTP 请求通常 30 秒足够
   - 长连接（WebSocket）可能需要 60 秒
   - 批处理任务可能需要更长时间

2. **优先级关闭**：
   ```go
   // 优先级顺序
   1. 停止接受新请求
   2. 等待现有请求完成
   3. 关闭数据库连接
   4. 关闭缓存连接
   5. 刷新日志
   6. 退出进程
   ```

3. **健康检查配合**：
   ```go
   func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
       select {
       case <-s.shutdownCh:
           // 关闭中，返回不健康状态
           w.WriteHeader(http.StatusServiceUnavailable)
       default:
           w.WriteHeader(http.StatusOK)
       }
   }
   ```

4. **记录关闭日志**：
   ```go
   log.Info("Starting graceful shutdown...")
   log.Info("HTTP server stopped")
   log.Info("Database connections closed")
   log.Info("Graceful shutdown completed")
   ```

5. **超时后强制退出**：
   ```go
   ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
   defer cancel()

   if err := app.Shutdown(ctx); err != nil {
       log.Error("Shutdown timeout, forcing exit")
       os.Exit(1)  // 强制退出
   }
   ```

### 8. 总结

优雅关闭的核心要点：

1. **信号监听**：使用 `signal.Notify` 捕获 SIGTERM/SIGINT
2. **停止新请求**：调用 `http.Server.Shutdown`
3. **等待完成**：使用 context.WithTimeout 设置超时
4. **资源清理**：关闭数据库、缓存、文件等
5. **日志记录**：记录关闭过程，便于排查问题
6. **超时保护**：避免无限等待，超时后强制退出
