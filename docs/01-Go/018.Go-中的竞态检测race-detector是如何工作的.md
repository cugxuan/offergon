---
title: Go 中的竞态检测（race detector）是如何工作的？
tags:
  - Go
status: robot
class: Go
slug: go-race-detector-how-it-works
ref:
---

## 要点精炼

1. **核心原理**：基于 ThreadSanitizer（TSan）算法，在编译时插入额外代码，运行时追踪内存访问和同步事件
2. **工作机制**：记录每个内存位置的读写历史，检测无同步保护的并发访问，发现 happens-before 规则违反
3. **使用方法**：通过 `-race` 编译标志启用，支持 build、run、test，建议在测试和开发环境使用
4. **性能代价**：内存开销 5-10x，CPU 开销 2-20x，不适合生产环境，但能有效发现隐藏的并发问题

## 详细回答

### Race Detector 概述

Go 的竞态检测器（Race Detector）是一个强大的工具，用于检测并发程序中的数据竞态（data race）。

#### 什么是数据竞态

数据竞态指：多个 goroutine 同时访问同一内存位置，且至少有一个是写操作，并且没有适当的同步机制。

```go
// 典型的数据竞态
var counter int

func increment() {
    counter++  // 读-改-写操作，不是原子的
}

func main() {
    for i := 0; i < 1000; i++ {
        go increment()
    }
    time.Sleep(time.Second)
    fmt.Println(counter)  // 结果不确定，通常 < 1000
}
```

### 启用 Race Detector

#### 命令行使用

```bash
# 构建时启用
go build -race

# 运行时启用
go run -race main.go

# 测试时启用（推荐）
go test -race

# 安装时启用
go install -race
```

#### 示例：检测竞态

```go
package main

import (
    "fmt"
    "time"
)

var data int

func writer() {
    data = 42  // 写操作
}

func reader() {
    fmt.Println(data)  // 读操作
}

func main() {
    go writer()
    go reader()
    time.Sleep(time.Second)
}
```

运行 `go run -race main.go` 输出：

```
==================
WARNING: DATA RACE
Write at 0x00c000018088 by goroutine 6:
  main.writer()
      /path/to/main.go:9 +0x38

Previous read at 0x00c000018088 by goroutine 7:
  main.reader()
      /path/to/main.go:13 +0x3a

Goroutine 6 (running) created at:
  main.main()
      /path/to/main.go:17 +0x3c

Goroutine 7 (running) created at:
  main.main()
      /path/to/main.go:18 +0x4e
==================
```

### 工作原理

#### ThreadSanitizer 算法

Go 的 race detector 基于 Google 的 ThreadSanitizer（TSan）：

1. **编译时插桩**：编译器在每个内存访问前后插入检测代码
2. **运行时追踪**：记录每个内存位置的访问历史
3. **同步事件**：追踪锁、channel、原子操作等同步事件
4. **Happens-Before 分析**：检查是否违反 happens-before 规则

#### 内部机制

```go
// 伪代码：编译器插桩后的效果

// 原始代码
x = 42

// 插桩后
func raceWrite(addr uintptr, size int)
raceWrite(&x, 8)
x = 42

// 读操作
y := x

// 插桩后
func raceRead(addr uintptr, size int)
raceRead(&x, 8)
y := x
```

#### 追踪数据结构

```go
// 简化的内部结构
type Shadow struct {
    tid       int       // 线程 ID
    clock     VectorClock  // 向量时钟
    isWrite   bool      // 是否是写操作
}

type VectorClock []int  // 向量时钟，用于 happens-before 分析

// 每个内存位置维护一个 Shadow
var shadowMemory map[uintptr]*Shadow
```

### 实际应用示例

#### 案例 1：Map 并发读写

```go
// 错误代码：并发读写 map
var m = make(map[string]int)

func write() {
    m["key"] = 42  // 写
}

func read() {
    _ = m["key"]  // 读
}

func main() {
    go write()
    go read()
    time.Sleep(time.Second)
}

// go run -race 会报告：
// WARNING: DATA RACE
// concurrent map read and map write
```

**修复方法**：

```go
var (
    m  = make(map[string]int)
    mu sync.RWMutex
)

func write() {
    mu.Lock()
    m["key"] = 42
    mu.Unlock()
}

func read() {
    mu.RLock()
    _ = m["key"]
    mu.RUnlock()
}

// 或使用 sync.Map
var m sync.Map

func write() {
    m.Store("key", 42)
}

func read() {
    m.Load("key")
}
```

#### 案例 2：Slice 竞态

```go
// 错误代码
var slice []int

func append1() {
    slice = append(slice, 1)
}

func append2() {
    slice = append(slice, 2)
}

func main() {
    go append1()
    go append2()
    time.Sleep(time.Second)
    fmt.Println(slice)
}

// Race detector 输出：
// WARNING: DATA RACE
// Write at 0x... by goroutine 6
// Previous write at 0x... by goroutine 7
```

**修复方法**：

```go
var (
    slice []int
    mu    sync.Mutex
)

func append1() {
    mu.Lock()
    slice = append(slice, 1)
    mu.Unlock()
}

func append2() {
    mu.Lock()
    slice = append(slice, 2)
    mu.Unlock()
}

// 或使用 channel
func main() {
    ch := make(chan int, 10)
    go func() {
        ch <- 1
        ch <- 2
        close(ch)
    }()

    var slice []int
    for v := range ch {
        slice = append(slice, v)
    }
}
```

#### 案例 3：闭包变量竞态

```go
// 经典错误：循环中的闭包
func wrongLoop() {
    for i := 0; i < 10; i++ {
        go func() {
            fmt.Println(i)  // 竞态！所有 goroutine 访问同一个 i
        }()
    }
    time.Sleep(time.Second)
}

// 修复方法 1：传递参数
func correctLoop1() {
    for i := 0; i < 10; i++ {
        go func(id int) {
            fmt.Println(id)
        }(i)  // 传递副本
    }
}

// 修复方法 2：局部变量
func correctLoop2() {
    for i := 0; i < 10; i++ {
        i := i  // 创建新变量
        go func() {
            fmt.Println(i)
        }()
    }
}
```

#### 案例 4：延迟初始化竞态

```go
// 错误的懒加载
var config *Config

func getConfig() *Config {
    if config == nil {  // 竞态：读
        config = loadConfig()  // 竞态：写
    }
    return config
}

// 修复方法：sync.Once
var (
    config *Config
    once   sync.Once
)

func getConfig() *Config {
    once.Do(func() {
        config = loadConfig()
    })
    return config
}
```

### Race Detector 的限制

#### 1. 只能检测运行时发生的竞态

```go
// 只有当代码实际执行时才能检测到
func conditionalRace(condition bool) {
    var x int
    if condition {
        go func() { x = 1 }()  // 只有 condition=true 时才触发
    }
    fmt.Println(x)
}

// 解决：编写充分的测试用例
func TestConditionalRace(t *testing.T) {
    conditionalRace(true)   // 测试 true 分支
    conditionalRace(false)  // 测试 false 分支
}
```

#### 2. 性能开销

```go
// 性能影响
// - 内存使用：5-10 倍
// - CPU 使用：2-20 倍
// - 不适合生产环境

// 建议：
// - 在 CI/CD 中启用 -race 测试
// - 定期运行压力测试 + race detector
// - 开发环境默认启用
```

#### 3. 不检测某些类型的竞态

```go
// Race detector 不检测的情况

// 1. 不同字段的伪共享（false sharing）
type Data struct {
    a int64  // Cache line 1
    _padding [56]byte
    b int64  // Cache line 2
}

// 2. 外部 C 代码的竞态
// import "C"
// C 代码中的竞态无法检测

// 3. 未初始化的读取（不一定是竞态）
var x int
fmt.Println(x)  // 读取零值，不算竞态
```

### 最佳实践

#### 1. 在测试中启用

```go
// Makefile
test:
    go test -race ./...

# 或在 go.mod 同级目录创建 .golangci.yml
linters-settings:
  govet:
    enable:
      - shadow  # 检测变量遮蔽
```

#### 2. CI/CD 集成

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-go@v2
        with:
          go-version: 1.21
      - run: go test -race -coverprofile=coverage.txt ./...
```

#### 3. 编写竞态测试

```go
func TestConcurrentMap(t *testing.T) {
    m := make(map[int]int)
    var wg sync.WaitGroup

    // 并发写
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            m[id] = id  // 期望触发竞态检测
        }(i)
    }

    wg.Wait()
}
```

#### 4. 环境变量配置

```bash
# 控制 race detector 行为
export GORACE="halt_on_error=1"  # 发现第一个竞态后立即退出
export GORACE="log_path=/tmp/race"  # 竞态报告输出路径
export GORACE="history_size=2"  # 历史记录大小（默认1）
```

### 常见竞态模式及修复

#### 模式 1：无保护的全局变量

```go
// 错误
var counter int
func Inc() { counter++ }

// 修复
var counter int64
func Inc() { atomic.AddInt64(&counter, 1) }
```

#### 模式 2：共享 struct 字段

```go
// 错误
type Server struct {
    count int
}
func (s *Server) Inc() { s.count++ }

// 修复
type Server struct {
    count int64
}
func (s *Server) Inc() { atomic.AddInt64(&s.count, 1) }
```

#### 模式 3：Check-Then-Act

```go
// 错误
if len(cache) == 0 {
    cache = loadCache()
}

// 修复
mu.Lock()
if len(cache) == 0 {
    cache = loadCache()
}
mu.Unlock()
```

### 调试技巧

```go
// 1. 缩小范围
// 使用二分法注释代码，找到触发竞态的最小代码

// 2. 增加并发度
func TestRace(t *testing.T) {
    for i := 0; i < 1000; i++ {  // 重复多次增加触发概率
        // 测试代码
    }
}

// 3. 使用 runtime.GOMAXPROCS
func TestRaceMultiCore(t *testing.T) {
    old := runtime.GOMAXPROCS(8)  // 增加并发
    defer runtime.GOMAXPROCS(old)
    // 测试代码
}
```

### 总结

Go Race Detector 是检测并发问题的利器：

1. **工作原理**：
   - 基于 ThreadSanitizer
   - 编译时插桩 + 运行时追踪
   - Happens-before 分析

2. **使用方法**：
   - `-race` 标志
   - 测试和开发环境启用
   - CI/CD 集成

3. **限制**：
   - 只检测执行到的代码
   - 性能开销大
   - 不适合生产环境

4. **最佳实践**：
   - 编写充分的并发测试
   - 定期运行 race detector
   - 及时修复发现的问题

面试要点：
- 理解数据竞态的定义
- 掌握 race detector 的使用方法
- 了解工作原理和限制
- 能识别常见的竞态模式
- 知道如何修复竞态问题
