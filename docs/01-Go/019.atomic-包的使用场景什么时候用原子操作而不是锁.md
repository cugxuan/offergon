---
title: atomic 包的使用场景，什么时候用原子操作而不是锁？
tags:
  - Go
status: robot
class: Go
ref:
---

## 要点精炼

1. **核心优势**：无锁操作，性能高，适合简单的读写场景，CPU 直接提供硬件支持
2. **适用场景**：计数器、标志位、单值读写、简单状态管理，不涉及复杂业务逻辑
3. **vs 锁的对比**：atomic 适合单变量操作，锁适合保护多个变量或复杂逻辑的原子性
4. **内存顺序保证**：atomic 操作提供 happens-before 保证，但需要理解内存模型避免误用

## 详细回答

### atomic 包概述

`sync/atomic` 包提供了底层的原子内存原语，用于实现无锁的并发数据结构。

#### 为什么需要 atomic

```go
// 问题：普通操作不是原子的
var counter int64

func increment() {
    counter++  // 实际是三步：读 -> 加 -> 写
}

// 在并发环境下，结果不确定
func main() {
    for i := 0; i < 1000; i++ {
        go increment()
    }
    time.Sleep(time.Second)
    fmt.Println(counter)  // 可能 < 1000
}
```

#### atomic 提供的操作

```go
// 1. 增减操作
atomic.AddInt32(&i, 1)
atomic.AddInt64(&i, -1)
atomic.AddUint32(&i, 1)

// 2. 加载（读取）
v := atomic.LoadInt32(&i)
v := atomic.LoadInt64(&i)
v := atomic.LoadPointer(&p)

// 3. 存储（写入）
atomic.StoreInt32(&i, 42)
atomic.StoreInt64(&i, 42)
atomic.StorePointer(&p, unsafe.Pointer(&x))

// 4. 交换
old := atomic.SwapInt32(&i, new)

// 5. 比较并交换（CAS）
swapped := atomic.CompareAndSwapInt32(&i, old, new)

// 6. 指针操作
atomic.LoadPointer(&p)
atomic.StorePointer(&p, unsafe.Pointer(&x))
atomic.CompareAndSwapPointer(&p, old, new)

// 7. Value 类型（任意类型）
var v atomic.Value
v.Store("hello")
val := v.Load().(string)
```

### 使用场景

#### 场景 1：计数器

```go
// 使用 atomic 实现线程安全的计数器
type Counter struct {
    value int64
}

func (c *Counter) Inc() {
    atomic.AddInt64(&c.value, 1)
}

func (c *Counter) Dec() {
    atomic.AddInt64(&c.value, -1)
}

func (c *Counter) Get() int64 {
    return atomic.LoadInt64(&c.value)
}

// 使用示例
func ExampleCounter() {
    counter := &Counter{}
    var wg sync.WaitGroup

    // 1000 个 goroutine 各自增加 1000 次
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Inc()
            }
        }()
    }

    wg.Wait()
    fmt.Println(counter.Get())  // 精确输出 1000000
}
```

#### 场景 2：标志位

```go
// 使用 atomic 实现状态标志
type Service struct {
    running int32  // 0: stopped, 1: running
}

func (s *Service) Start() bool {
    // CAS 操作：只有当前是 stopped 才能启动
    return atomic.CompareAndSwapInt32(&s.running, 0, 1)
}

func (s *Service) Stop() bool {
    return atomic.CompareAndSwapInt32(&s.running, 1, 0)
}

func (s *Service) IsRunning() bool {
    return atomic.LoadInt32(&s.running) == 1
}

// 使用示例
func ExampleService() {
    svc := &Service{}

    if svc.Start() {
        fmt.Println("Service started")
        // 做一些工作
        svc.Stop()
    } else {
        fmt.Println("Service already running")
    }
}
```

#### 场景 3：配置热更新

```go
// 使用 atomic.Value 实现配置热更新
type Config struct {
    Host string
    Port int
}

type ConfigManager struct {
    config atomic.Value  // 存储 *Config
}

func (cm *ConfigManager) Load() *Config {
    return cm.config.Load().(*Config)
}

func (cm *ConfigManager) Store(cfg *Config) {
    cm.config.Store(cfg)
}

// 使用示例
var configMgr = &ConfigManager{}

func init() {
    // 初始配置
    configMgr.Store(&Config{Host: "localhost", Port: 8080})

    // 后台定期重载配置
    go func() {
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for range ticker.C {
            newCfg := loadConfigFromFile()
            configMgr.Store(newCfg)
        }
    }()
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
    cfg := configMgr.Load()  // 无锁读取最新配置
    fmt.Fprintf(w, "Host: %s, Port: %d", cfg.Host, cfg.Port)
}
```

#### 场景 4：单例模式

```go
// 使用 atomic + double-check 实现单例
var (
    instance unsafe.Pointer
    mu       sync.Mutex
)

func GetInstance() *Singleton {
    // 第一次检查（无锁）
    ptr := atomic.LoadPointer(&instance)
    if ptr == nil {
        mu.Lock()
        defer mu.Unlock()

        // 第二次检查（加锁后）
        ptr = atomic.LoadPointer(&instance)
        if ptr == nil {
            s := &Singleton{}
            atomic.StorePointer(&instance, unsafe.Pointer(s))
            ptr = unsafe.Pointer(s)
        }
    }
    return (*Singleton)(ptr)
}

// 注意：通常更推荐使用 sync.Once
```

#### 场景 5：无锁栈

```go
// 使用 CAS 实现无锁栈
type Node struct {
    value int
    next  unsafe.Pointer  // *Node
}

type LockFreeStack struct {
    top unsafe.Pointer  // *Node
}

func (s *LockFreeStack) Push(v int) {
    node := &Node{value: v}

    for {
        oldTop := atomic.LoadPointer(&s.top)
        node.next = oldTop

        // CAS 操作：如果 top 没变，则更新
        if atomic.CompareAndSwapPointer(&s.top, oldTop, unsafe.Pointer(node)) {
            return
        }
        // CAS 失败，说明有其他 goroutine 修改了 top，重试
    }
}

func (s *LockFreeStack) Pop() (int, bool) {
    for {
        oldTop := atomic.LoadPointer(&s.top)
        if oldTop == nil {
            return 0, false  // 栈空
        }

        node := (*Node)(oldTop)
        newTop := atomic.LoadPointer(&node.next)

        // CAS 操作：如果 top 没变，则更新
        if atomic.CompareAndSwapPointer(&s.top, oldTop, newTop) {
            return node.value, true
        }
        // CAS 失败，重试
    }
}
```

### atomic vs 锁

#### 何时使用 atomic

1. **单个变量的简单操作**
   - 计数器（+1, -1）
   - 标志位（true/false）
   - 单值读写

2. **性能敏感的场景**
   - 高频访问的共享变量
   - 读多写少的场景

3. **无锁数据结构**
   - 无锁队列、栈
   - 无锁链表

```go
// 适合 atomic 的场景
var counter int64
atomic.AddInt64(&counter, 1)

// 不适合 atomic 的场景（需要多步操作的原子性）
var balance int64
// 错误：两个 atomic 操作不是整体原子的
if atomic.LoadInt64(&balance) >= amount {
    atomic.AddInt64(&balance, -amount)  // 可能被其他 goroutine 打断
}
```

#### 何时使用锁

1. **保护多个变量**
   ```go
   type BankAccount struct {
       mu      sync.Mutex
       balance int64
       history []Transaction
   }

   func (a *BankAccount) Transfer(amount int64) {
       a.mu.Lock()
       defer a.mu.Unlock()

       a.balance -= amount
       a.history = append(a.history, Transaction{Amount: amount})
   }
   ```

2. **复杂的业务逻辑**
   ```go
   func (cache *Cache) GetOrCreate(key string) *Value {
       cache.mu.Lock()
       defer cache.mu.Unlock()

       if v, ok := cache.data[key]; ok {
           return v
       }

       v := createValue(key)
       cache.data[key] = v
       return v
   }
   ```

3. **条件等待**
   ```go
   var (
       mu    sync.Mutex
       cond  = sync.NewCond(&mu)
       ready bool
   )

   func wait() {
       mu.Lock()
       for !ready {
           cond.Wait()  // 等待条件满足
       }
       mu.Unlock()
   }
   ```

#### 性能对比

```go
// Benchmark: atomic vs mutex
var (
    atomicCounter int64
    mutexCounter  int64
    mu            sync.Mutex
)

func BenchmarkAtomic(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            atomic.AddInt64(&atomicCounter, 1)
        }
    })
}

func BenchmarkMutex(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            mu.Lock()
            mutexCounter++
            mu.Unlock()
        }
    })
}

// 结果（示例）：
// BenchmarkAtomic-8    100000000    10.5 ns/op
// BenchmarkMutex-8      50000000    35.2 ns/op
// atomic 快约 3 倍
```

### 高级用法

#### 1. atomic.Value 的泛型包装（Go 1.19+）

```go
type Atomic[T any] struct {
    v atomic.Value
}

func (a *Atomic[T]) Store(val T) {
    a.v.Store(val)
}

func (a *Atomic[T]) Load() T {
    val := a.v.Load()
    if val == nil {
        var zero T
        return zero
    }
    return val.(T)
}

// 使用示例
var config Atomic[*Config]
config.Store(&Config{Host: "localhost"})
cfg := config.Load()
```

#### 2. 基于 CAS 的自旋锁

```go
type SpinLock struct {
    state int32
}

func (s *SpinLock) Lock() {
    for !atomic.CompareAndSwapInt32(&s.state, 0, 1) {
        runtime.Gosched()  // 让出 CPU
    }
}

func (s *SpinLock) Unlock() {
    atomic.StoreInt32(&s.state, 0)
}

// 适用场景：锁持有时间极短
```

#### 3. 引用计数

```go
type RefCounted struct {
    refs  int32
    value interface{}
}

func (r *RefCounted) Acquire() {
    atomic.AddInt32(&r.refs, 1)
}

func (r *RefCounted) Release() {
    if atomic.AddInt32(&r.refs, -1) == 0 {
        // 引用计数降为 0，释放资源
        r.cleanup()
    }
}
```

### 常见陷阱

#### 陷阱 1：误以为多个 atomic 操作是原子的

```go
// 错误：两个 atomic 操作之间可能被打断
if atomic.LoadInt64(&balance) >= amount {
    atomic.AddInt64(&balance, -amount)  // 危险！
}

// 正确：使用锁或 CAS 循环
func withdraw(amount int64) bool {
    for {
        old := atomic.LoadInt64(&balance)
        if old < amount {
            return false
        }
        if atomic.CompareAndSwapInt64(&balance, old, old-amount) {
            return true
        }
        // CAS 失败，重试
    }
}
```

#### 陷阱 2：atomic.Value 的 nil 问题

```go
var v atomic.Value
v.Store(nil)  // panic: sync/atomic: store of nil value into Value

// 正确：使用指针包装
type Wrapper struct {
    value interface{}
}
v.Store(&Wrapper{value: nil})
```

#### 陷阱 3：对齐问题

```go
// 错误：32 位系统上 int64 可能不对齐
type MyStruct struct {
    a byte
    counter int64  // 可能导致 panic
}

// 正确：将 int64 放在最前面
type MyStruct struct {
    counter int64
    a byte
}

// 或使用 aligned 标签（Go 1.19+）
```

### 实际应用案例

#### 案例 1：HTTP 请求计数

```go
type Server struct {
    requests int64
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    atomic.AddInt64(&s.requests, 1)
    // 处理请求...
}

func (s *Server) Stats() int64 {
    return atomic.LoadInt64(&s.requests)
}
```

#### 案例 2：优雅关闭

```go
type Worker struct {
    stopped int32
}

func (w *Worker) Stop() {
    atomic.StoreInt32(&w.stopped, 1)
}

func (w *Worker) Run() {
    for atomic.LoadInt32(&w.stopped) == 0 {
        // 执行工作
        doWork()
    }
}
```

#### 案例 3：缓存统计

```go
type Cache struct {
    data sync.Map
    hits   int64
    misses int64
}

func (c *Cache) Get(key string) (interface{}, bool) {
    val, ok := c.data.Load(key)
    if ok {
        atomic.AddInt64(&c.hits, 1)
    } else {
        atomic.AddInt64(&c.misses, 1)
    }
    return val, ok
}

func (c *Cache) HitRate() float64 {
    hits := atomic.LoadInt64(&c.hits)
    misses := atomic.LoadInt64(&c.misses)
    total := hits + misses
    if total == 0 {
        return 0
    }
    return float64(hits) / float64(total)
}
```

### 总结

atomic 包的使用原则：

1. **适用场景**：
   - 单个变量的简单操作
   - 高性能要求
   - 无锁数据结构

2. **选择标准**：
   - 操作简单 → atomic
   - 多变量协调 → 锁
   - 条件等待 → channel 或 sync.Cond

3. **最佳实践**：
   - 理解内存模型
   - 注意对齐要求
   - 使用 race detector 测试
   - 复杂逻辑优先考虑锁

4. **性能考量**：
   - atomic 比锁快 2-10 倍
   - 但可维护性更重要
   - 过早优化是万恶之源

面试要点：
- 理解 atomic 的原子性保证
- 掌握常用操作的使用方法
- 能判断何时用 atomic vs 锁
- 了解 CAS 的工作原理
- 知道常见陷阱和解决方法
