---
title: 什么是 goroutine 泄漏？如何排查和避免？
tags:
  - Go
  - 并发
status: robot
class: Go
slug: goroutine-leak-detection-prevention
ref:
---

## 要点精炼

1. **Goroutine 泄漏定义**：启动的 goroutine 无法正常退出，持续占用内存和系统资源，最终导致资源耗尽
2. **常见泄漏场景**：阻塞的 channel 操作、未正确取消的 context、永久阻塞的 select、死锁等待
3. **排查方法**：使用 pprof 分析 goroutine 数量和堆栈、runtime.NumGoroutine() 监控、日志追踪
4. **避免策略**：使用 context 超时控制、确保 channel 双向配对、使用 defer 清理、设置合理的超时机制

## 详细回答

### 什么是 Goroutine 泄漏

Goroutine 泄漏指的是程序中启动的 goroutine 无法正常退出，持续占用内存和 CPU 资源。由于 Go 的 GC 无法回收正在运行的 goroutine，这些泄漏的 goroutine 会累积导致：
- 内存持续增长（OOM）
- 系统资源耗尽
- 程序性能下降
- 最终导致服务崩溃

### 常见泄漏场景

#### 1. Channel 阻塞导致泄漏

```go
// 错误示例：发送者无人接收
func leak1() {
    ch := make(chan int)
    go func() {
        ch <- 1  // 永久阻塞，goroutine 泄漏
    }()
    // 主函数直接返回，没有从 ch 接收
}

// 正确做法：使用 buffered channel 或确保配对
func fix1() {
    ch := make(chan int, 1)  // 使用带缓冲的 channel
    go func() {
        ch <- 1
    }()
}
```

#### 2. Context 未正确传递

```go
// 错误示例：goroutine 无法感知取消信号
func leak2() {
    go func() {
        for {
            // 永久循环，没有退出条件
            doWork()
        }
    }()
}

// 正确做法：使用 context 控制生命周期
func fix2(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                return  // 接收到取消信号，退出
            default:
                doWork()
            }
        }
    }()
}
```

#### 3. 死锁等待

```go
// 错误示例：互相等待导致死锁
func leak3() {
    var mu sync.Mutex
    go func() {
        mu.Lock()
        defer mu.Unlock()
        // 持有锁，然后尝试获取同一个锁
        anotherFunc(&mu)  // 如果 anotherFunc 也尝试获取 mu，则死锁
    }()
}
```

#### 4. 永久阻塞的 Select

```go
// 错误示例：等待永远不会到来的信号
func leak4() {
    ch := make(chan int)
    go func() {
        select {
        case <-ch:  // 永远不会收到数据
            fmt.Println("received")
        }
    }()
}

// 正确做法：添加超时
func fix4() {
    ch := make(chan int)
    go func() {
        select {
        case <-ch:
            fmt.Println("received")
        case <-time.After(5 * time.Second):
            fmt.Println("timeout")
            return
        }
    }()
}
```

### 排查 Goroutine 泄漏

#### 1. 使用 pprof 分析

```go
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    // 你的业务代码
}

// 命令行查看 goroutine 信息
// go tool pprof http://localhost:6060/debug/pprof/goroutine
// 在 pprof 交互模式下使用 top, list 命令分析
```

#### 2. 监控 Goroutine 数量

```go
import "runtime"

func monitorGoroutines() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        n := runtime.NumGoroutine()
        if n > 1000 {  // 设置阈值告警
            log.Printf("警告: goroutine 数量过多 %d", n)
        }
    }
}
```

#### 3. 查看 Goroutine 堆栈

```go
func dumpGoroutineStack() {
    buf := make([]byte, 1<<20)
    stackLen := runtime.Stack(buf, true)
    fmt.Printf("=== Goroutine Stack ===\n%s\n", buf[:stackLen])
}
```

### 避免 Goroutine 泄漏的最佳实践

#### 1. 使用 Context 控制生命周期

```go
func worker(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            log.Println("worker 退出")
            return
        case <-ticker.C:
            doWork()
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    go worker(ctx)

    // 10 秒后 worker 会自动退出
    time.Sleep(15 * time.Second)
}
```

#### 2. Channel 操作确保配对

```go
func processData() {
    ch := make(chan int, 10)

    // 确保发送和接收配对
    go func() {
        defer close(ch)  // 发送完毕后关闭
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()

    // 接收所有数据
    for v := range ch {
        fmt.Println(v)
    }
}
```

#### 3. 使用 WaitGroup 等待完成

```go
func processWithWaitGroup() {
    var wg sync.WaitGroup

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            doWork(id)
        }(i)
    }

    wg.Wait()  // 等待所有 goroutine 完成
}
```

#### 4. 设置合理的超时

```go
func requestWithTimeout(url string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}
```

### 实际案例：HTTP Server 中的泄漏

```go
// 错误示例：每个请求启动 goroutine 但不控制退出
func badHandler(w http.ResponseWriter, r *http.Request) {
    go func() {
        // 长时间运行的任务，没有超时控制
        result := longRunningTask()  // 如果卡住，goroutine 永远不退出
        fmt.Fprintf(w, "result: %v", result)
    }()
}

// 正确做法：使用 request context 控制
func goodHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    resultCh := make(chan string, 1)

    go func() {
        select {
        case <-ctx.Done():
            return  // 客户端断开连接，goroutine 退出
        case resultCh <- longRunningTask():
        }
    }()

    select {
    case <-ctx.Done():
        http.Error(w, "request cancelled", http.StatusRequestTimeout)
    case result := <-resultCh:
        fmt.Fprintf(w, "result: %v", result)
    }
}
```

### 总结

Goroutine 泄漏是 Go 并发编程中常见且严重的问题。关键是：
1. 每个 goroutine 都应该有明确的退出条件
2. 使用 context 传递取消信号
3. Channel 操作要确保发送和接收配对
4. 定期监控 goroutine 数量
5. 使用 pprof 工具排查异常
