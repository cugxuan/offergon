---
title: Go 的 goroutine 和线程有什么区别？为什么 Go 能支持百万级并发？
tags:
  - Go
  - 并发
status: robot
class: Go
slug: goroutine-vs-thread-million-concurrency
ref:
---

## 要点精炼

- **资源开销**：goroutine 初始栈 2KB 可动态扩缩，线程固定 1-2MB
- **调度机制**：goroutine 用户态调度（GMP 模型，~200ns），线程内核态调度（~1-2μs）
- **并发模型**：M:N 模型，数万 goroutine 复用少量 OS 线程
- **百万级并发**：轻量级（100 万 goroutine ≈ 2GB 内存）+ 高效调度 + 异步 I/O

## 详细回答

### 核心区别

**1. 资源开销**
- **goroutine**：初始栈仅 2KB，可动态扩缩容（最大 1GB），创建销毁成本极低
- **线程**：栈固定 1-2MB，创建销毁涉及系统调用，成本高

**2. 调度机制**
- **goroutine**：由 Go 运行时在用户态调度（GMP 模型），切换成本约 200ns
- **线程**：由操作系统内核调度，切换需要 1-2μs，涉及内核态切换

**3. 并发模型**
- **goroutine**：M:N 模型，成千上万 goroutine 复用少量 OS 线程（GOMAXPROCS 个）
- **线程**：1:1 模型，每个用户线程对应一个内核线程

**4. 通信方式**
- **goroutine**：推崇 CSP 模型（通过 channel 通信）
- **线程**：通常使用共享内存 + 锁

### 百万级并发原理

**轻量级设计**
```
100 万 goroutine：~2GB 内存
100 万线程：~1-2TB 内存（物理机无法承受）
```

**高效调度器（GMP 模型）**
- **本地队列**：每个 P（Processor）有本地 goroutine 队列，减少锁竞争
- **工作窃取**：空闲的 P 可以从其他 P 偷取任务
- **hand-off 机制**：当 M（Machine/线程）阻塞时，将 P 转移给其他 M

**异步非阻塞 I/O**
- **netpoller**：将阻塞 I/O 转为事件驱动
- 网络操作不会占用线程，goroutine 挂起后 M 可以执行其他任务

### 对比示例

```go
// goroutine：轻量级并发
for i := 0; i < 1000000; i++ {
    go func(n int) {
        time.Sleep(time.Hour)
    }(i)
}
// 内存占用：约 2GB，程序正常运行

// 线程：重量级并发
for i := 0; i < 1000000; i++ {
    go func(n int) {
        runtime.LockOSThread()  // 绑定到 OS 线程
        time.Sleep(time.Hour)
    }(i)
}
// 结果：系统崩溃，无法创建如此多的线程
```

### 性能数据

| 操作 | goroutine | 线程 |
|------|-----------|------|
| 创建成本 | ~3μs | ~30μs |
| 内存占用 | 2KB | 1-2MB |
| 切换成本 | ~200ns | ~1-2μs |
| 最大数量 | 百万级 | 几千个 |
