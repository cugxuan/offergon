---
title: Go 的 context 包是用来做什么的？如何正确使用 context？
tags:
  - Go
  - 上下文
status: robot
class: Go
ref:
---

## 要点精炼

1. **四大功能**：取消信号传播、超时控制、截止时间管理、跨 API 传递请求域数据（如 trace ID、用户信息）
2. **不可变性**：context 是不可变的，每次派生都创建新的 context 节点，形成树形结构
3. **传播机制**：父 context 取消会自动取消所有子 context，通过 Done() channel 和递归通知实现
4. **规范使用**：应作为函数第一个参数传递，不要存储在结构体中，不要传递 nil（使用 context.TODO()）

## 详细回答

### 一、Context 的核心作用

`context` 包在 Go 1.7 引入，主要解决以下问题：

1. **goroutine 生命周期管理**：优雅地取消不再需要的 goroutine
2. **超时和截止时间控制**：防止 goroutine 无限期阻塞
3. **请求域数据传递**：在调用链中传递元数据（trace ID、认证信息等）
4. **跨 API 边界的取消传播**：确保整个调用树的资源及时释放

### 二、Context 接口定义

```go
type Context interface {
    // 返回取消时间（如果有设置）
    Deadline() (deadline time.Time, ok bool)

    // 返回一个 channel，context 取消时关闭
    Done() <-chan struct{}

    // 返回取消原因（取消、超时、截止时间到达）
    Err() error

    // 获取 context 中存储的值
    Value(key interface{}) interface{}
}
```

### 三、Context 的四种类型

#### 1. Background 和 TODO

```go
// Background: 根 context，永不取消
ctx := context.Background()

// TODO: 占位符，当不确定用什么 context 时使用
ctx := context.TODO()
```

**使用场景**：
- `Background`：main 函数、初始化、测试的根 context
- `TODO`：重构时临时使用

#### 2. WithCancel - 手动取消

```go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// 示例
ctx, cancel := context.WithCancel(context.Background())
defer cancel()  // 确保释放资源

go func() {
    // 执行任务
    select {
    case <-time.After(5 * time.Second):
        fmt.Println("work done")
    case <-ctx.Done():
        fmt.Println("canceled:", ctx.Err())
        return
    }
}()

time.Sleep(1 * time.Second)
cancel()  // 手动取消
```

#### 3. WithTimeout - 超时自动取消

```go
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)

// 示例：HTTP 请求超时
ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
defer cancel()

req, _ := http.NewRequestWithContext(ctx, "GET", "https://api.example.com", nil)
resp, err := http.DefaultClient.Do(req)
if err != nil {
    // 可能是 context.DeadlineExceeded
    fmt.Println("request failed:", err)
}
```

#### 4. WithDeadline - 指定截止时间

```go
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)

// 示例：任务必须在 17:00 前完成
deadline := time.Date(2025, 10, 7, 17, 0, 0, 0, time.Local)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

select {
case <-doWork(ctx):
    fmt.Println("work completed")
case <-ctx.Done():
    fmt.Println("deadline exceeded")
}
```

#### 5. WithValue - 传递请求域数据

```go
func WithValue(parent Context, key, val interface{}) Context

// 示例：传递 trace ID
type ctxKey string
const traceIDKey ctxKey = "trace-id"

ctx := context.WithValue(context.Background(), traceIDKey, "abc123")

// 在下游函数中获取
func processRequest(ctx context.Context) {
    traceID := ctx.Value(traceIDKey).(string)
    log.Printf("[%s] processing request", traceID)
}
```

### 四、Context 的实现原理

#### 1. Context 树结构

```go
// cancelCtx 的简化结构
type cancelCtx struct {
    Context

    mu       sync.Mutex
    done     chan struct{}     // 延迟创建
    children map[canceler]struct{}  // 子 context 集合
    err      error             // 取消原因
}
```

**树形结构**：

```
Background
    │
    ├─ WithCancel (A)
    │   ├─ WithTimeout (B)
    │   └─ WithValue (C)
    │
    └─ WithValue (D)
        └─ WithCancel (E)
```

取消 A 会自动取消 B 和 C。

#### 2. 取消传播机制

```go
// 取消 context 的实现
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    c.mu.Lock()
    if c.err != nil {
        c.mu.Unlock()
        return  // 已取消
    }
    c.err = err

    // 关闭 done channel，通知所有等待者
    if c.done == nil {
        c.done = closedchan
    } else {
        close(c.done)
    }

    // 递归取消所有子 context
    for child := range c.children {
        child.cancel(false, err)
    }
    c.children = nil
    c.mu.Unlock()

    // 从父节点中移除
    if removeFromParent {
        removeChild(c.Context, c)
    }
}
```

#### 3. Value 查找机制

```go
func (c *valueCtx) Value(key interface{}) interface{} {
    if c.key == key {
        return c.val
    }
    return c.Context.Value(key)  // 递归向上查找
}
```

**查找路径**：沿着 context 树向上查找，直到找到或到达根节点。

### 五、实战应用场景

#### 1. HTTP 服务器请求处理

```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
    // 每个请求都有独立的 context
    ctx := r.Context()

    // 设置超时
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    // 传递给下游服务
    result, err := fetchData(ctx)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            http.Error(w, "request timeout", http.StatusRequestTimeout)
            return
        }
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    json.NewEncoder(w).Encode(result)
}

func fetchData(ctx context.Context) (*Data, error) {
    // 检查 context 是否已取消
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }

    // 执行数据库查询
    return db.QueryWithContext(ctx, "SELECT ...")
}
```

#### 2. 并发任务管理

```go
func processBatch(ctx context.Context, items []Item) error {
    g, ctx := errgroup.WithContext(ctx)

    for _, item := range items {
        item := item  // 捕获循环变量
        g.Go(func() error {
            return processItem(ctx, item)
        })
    }

    // 等待所有任务完成或任一任务失败
    return g.Wait()
}

func processItem(ctx context.Context, item Item) error {
    select {
    case <-ctx.Done():
        return ctx.Err()  // 其他任务失败，提前退出
    default:
    }

    // 处理 item
    return nil
}
```

#### 3. 数据库查询超时

```go
func getUserByID(ctx context.Context, id int) (*User, error) {
    // 设置查询超时
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()

    var user User
    query := "SELECT * FROM users WHERE id = ?"

    // 使用 context 控制查询
    err := db.QueryRowContext(ctx, query, id).Scan(&user)
    if err != nil {
        return nil, err
    }

    return &user, nil
}
```

#### 4. 传递请求元数据

```go
// 定义类型安全的 key
type contextKey int

const (
    userIDKey contextKey = iota
    traceIDKey
    requestIDKey
)

// 中间件：注入用户信息
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        userID := extractUserID(r)
        ctx := context.WithValue(r.Context(), userIDKey, userID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 业务逻辑：获取用户信息
func handleAPI(w http.ResponseWriter, r *http.Request) {
    userID, ok := r.Context().Value(userIDKey).(int)
    if !ok {
        http.Error(w, "unauthorized", http.StatusUnauthorized)
        return
    }

    fmt.Fprintf(w, "User ID: %d", userID)
}
```

### 六、使用规范和最佳实践

#### 1. 参数传递规范

```go
// 正确：context 作为第一个参数
func DoWork(ctx context.Context, arg string) error

// 错误：不要放在结构体中
type Worker struct {
    ctx context.Context  // 避免这样做
}
```

**原因**：
- 使调用关系清晰
- 避免 context 生命周期混乱
- 方便测试和模拟

#### 2. 不要传递 nil

```go
// 错误
DoWork(nil, "data")

// 正确
DoWork(context.Background(), "data")
// 或
DoWork(context.TODO(), "data")
```

#### 3. 总是调用 cancel

```go
// 正确：defer 确保资源释放
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
defer cancel()  // 即使提前返回也会执行

// 错误：忘记调用 cancel 会导致 goroutine 泄漏
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
// 没有 defer cancel()
```

#### 4. WithValue 的正确使用

```go
// 好的做法：使用类型安全的 key
type ctxKey string
const requestIDKey ctxKey = "request-id"

ctx := context.WithValue(ctx, requestIDKey, "123")

// 避免：使用字符串 key（可能冲突）
ctx := context.WithValue(ctx, "request-id", "123")  // 不推荐

// 避免：传递大量数据
ctx := context.WithValue(ctx, "user", largeUserObject)  // 不推荐
// 应该只传递 ID，需要时再查询
ctx := context.WithValue(ctx, "user-id", 123)  // 推荐
```

#### 5. 检查 context 取消

```go
func longRunningTask(ctx context.Context) error {
    for i := 0; i < 1000; i++ {
        // 定期检查 context
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        // 执行工作
        doWork(i)
    }
    return nil
}
```

### 七、常见错误和陷阱

#### 1. Context 泄漏

```go
// 错误：创建 context 但不使用
func bad() {
    ctx, cancel := context.WithCancel(context.Background())
    // 忘记 defer cancel()

    go func() {
        // 这个 goroutine 永远不会退出
        <-ctx.Done()
    }()
}

// 正确
func good() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()  // 确保释放

    go func() {
        <-ctx.Done()
    }()
}
```

#### 2. 重复调用 cancel

```go
// 重复调用 cancel 是安全的（幂等）
ctx, cancel := context.WithCancel(context.Background())
cancel()
cancel()  // 不会 panic，但没有效果
```

#### 3. 误用 WithValue

```go
// 错误：存储可选参数
func Process(ctx context.Context) {
    // 不要这样传递配置
    timeout := ctx.Value("timeout").(time.Duration)
}

// 正确：使用显式参数
func Process(ctx context.Context, timeout time.Duration) {
    // 配置应该通过参数传递
}
```

### 八、性能考量

1. **Value 查找开销**：
   - 沿 context 链向上查找，O(n) 复杂度
   - 避免深层嵌套（通常不超过 10 层）

2. **创建 context 的成本**：
   - 轻量级，每个 context 约 96 字节
   - 但频繁创建仍有 GC 压力

3. **Done channel 延迟创建**：
   - 只在首次访问 `Done()` 时创建 channel
   - 节省不需要取消的 context 的内存

### 九、测试中的 Context

```go
func TestWithTimeout(t *testing.T) {
    ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
    defer cancel()

    err := doWork(ctx)
    if !errors.Is(err, context.DeadlineExceeded) {
        t.Errorf("expected timeout, got %v", err)
    }
}

// 模拟已取消的 context
func TestCanceled(t *testing.T) {
    ctx, cancel := context.WithCancel(context.Background())
    cancel()  // 立即取消

    err := doWork(ctx)
    if !errors.Is(err, context.Canceled) {
        t.Errorf("expected canceled, got %v", err)
    }
}
```
