---
title: Go 的依赖注入模式（wire、dig）
tags:
  - Go
status: robot
class: Go
ref:
---

## 要点精炼

1. **依赖注入作用**：解耦组件依赖关系，提高代码可测试性和可维护性，避免全局变量和硬编码依赖
2. **Wire vs Dig**：Wire 是编译期代码生成工具（零运行时开销），Dig 是运行时反射框架（更灵活但有性能损耗）
3. **Wire 优势**：编译期错误检查、零运行时开销、IDE 友好、调试简单；适合追求性能和类型安全的场景
4. **Dig 优势**：支持动态依赖、生命周期管理、装饰器模式；适合需要运行时灵活性的复杂应用

## 详细回答

### 1. 依赖注入基础概念

#### 1.1 传统方式 vs 依赖注入

```go
// 传统方式：硬编码依赖
type UserService struct {
    db     *sql.DB
    logger *log.Logger
}

func NewUserService() *UserService {
    // 在构造函数中创建依赖（紧耦合）
    db, _ := sql.Open("mysql", "root:password@/dbname")
    logger := log.New(os.Stdout, "USER: ", log.LstdFlags)

    return &UserService{
        db:     db,
        logger: logger,
    }
}

// 依赖注入方式：通过参数传入依赖
func NewUserService(db *sql.DB, logger *log.Logger) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
    }
}

// 使用时显式提供依赖
func main() {
    db, _ := sql.Open("mysql", "root:password@/dbname")
    logger := log.New(os.Stdout, "USER: ", log.LstdFlags)

    userService := NewUserService(db, logger)
    // 使用 userService...
}
```

#### 1.2 依赖注入的优势

1. **解耦**：组件不依赖具体实现，依赖抽象接口
2. **可测试**：方便注入 mock 对象进行单元测试
3. **可维护**：依赖关系清晰，易于修改和扩展
4. **可配置**：可根据环境动态配置不同的依赖实现

### 2. Wire 使用详解

#### 2.1 Wire 基本概念

Wire 是 Google 开发的编译期依赖注入工具，通过代码生成实现零运行时开销。

安装 Wire：
```bash
go install github.com/google/wire/cmd/wire@latest
```

#### 2.2 Wire 基础示例

项目结构：
```
project/
├── main.go
├── wire.go        # Wire 配置文件
├── wire_gen.go    # Wire 生成的代码（自动生成）
├── database/
│   └── database.go
├── logger/
│   └── logger.go
└── service/
    └── user.go
```

定义组件：

```go
// database/database.go
package database

import "database/sql"

type Database struct {
    *sql.DB
}

func NewDatabase(dsn string) (*Database, error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    return &Database{DB: db}, nil
}

// logger/logger.go
package logger

import "log"

type Logger struct {
    *log.Logger
}

func NewLogger(prefix string) *Logger {
    return &Logger{
        Logger: log.New(os.Stdout, prefix, log.LstdFlags),
    }
}

// service/user.go
package service

import (
    "project/database"
    "project/logger"
)

type UserService struct {
    db     *database.Database
    logger *logger.Logger
}

func NewUserService(db *database.Database, logger *logger.Logger) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
    }
}

func (s *UserService) CreateUser(name string) {
    s.logger.Printf("Creating user: %s", name)
    // 使用 s.db 操作数据库...
}
```

Wire 配置文件：

```go
// wire.go
//go:build wireinject
// +build wireinject

package main

import (
    "github.com/google/wire"
    "project/database"
    "project/logger"
    "project/service"
)

// InitializeUserService 是注入器函数，Wire 会生成实现
func InitializeUserService(dsn string, logPrefix string) (*service.UserService, error) {
    wire.Build(
        database.NewDatabase,
        logger.NewLogger,
        service.NewUserService,
    )
    return nil, nil // 返回值会被 Wire 生成的代码替换
}
```

生成代码：
```bash
wire gen
```

生成的 `wire_gen.go`：
```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
    "project/database"
    "project/logger"
    "project/service"
)

func InitializeUserService(dsn string, logPrefix string) (*service.UserService, error) {
    databaseDatabase, err := database.NewDatabase(dsn)
    if err != nil {
        return nil, err
    }
    loggerLogger := logger.NewLogger(logPrefix)
    userService := service.NewUserService(databaseDatabase, loggerLogger)
    return userService, nil
}
```

使用：
```go
// main.go
package main

func main() {
    userService, err := InitializeUserService(
        "root:password@/dbname",
        "USER: ",
    )
    if err != nil {
        panic(err)
    }

    userService.CreateUser("Alice")
}
```

#### 2.3 Wire 高级特性

##### Provider Sets（提供者集合）

```go
// database/provider.go
package database

import "github.com/google/wire"

// DatabaseSet 包含数据库相关的所有 provider
var DatabaseSet = wire.NewSet(
    NewDatabase,
    NewUserRepository,
    NewOrderRepository,
)

// logger/provider.go
package logger

import "github.com/google/wire"

var LoggerSet = wire.NewSet(
    NewLogger,
    NewMetrics,
)

// wire.go
func InitializeApp() (*App, error) {
    wire.Build(
        database.DatabaseSet,  // 引用 provider set
        logger.LoggerSet,
        service.ServiceSet,
        NewApp,
    )
    return nil, nil
}
```

##### Binding Interfaces（接口绑定）

```go
// repository/interface.go
package repository

type UserRepository interface {
    GetUser(id int) (*User, error)
}

// repository/mysql.go
package repository

type MySQLUserRepository struct {
    db *sql.DB
}

func NewMySQLUserRepository(db *sql.DB) *MySQLUserRepository {
    return &MySQLUserRepository{db: db}
}

func (r *MySQLUserRepository) GetUser(id int) (*User, error) {
    // 实现...
}

// wire.go
func InitializeApp() (*App, error) {
    wire.Build(
        database.NewDatabase,
        repository.NewMySQLUserRepository,
        wire.Bind(new(repository.UserRepository), new(*repository.MySQLUserRepository)),
        service.NewUserService,
        NewApp,
    )
    return nil, nil
}
```

##### Struct Providers（结构体提供者）

```go
// config/config.go
type Config struct {
    DBHost     string
    DBPort     int
    LogLevel   string
    ServerPort int
}

// wire.go
func InitializeApp() (*App, error) {
    wire.Build(
        // 使用结构体字面量作为 provider
        wire.Struct(new(Config), "*"),  // "*" 表示所有字段需要注入

        // 或者指定特定字段
        wire.Struct(new(Config), "DBHost", "DBPort"),

        database.NewDatabase,
        NewApp,
    )
    return nil, nil
}
```

##### Value Providers（值提供者）

```go
// wire.go
func InitializeApp() (*App, error) {
    wire.Build(
        wire.Value("localhost:3306"),  // 提供字符串值
        wire.Value(8080),               // 提供整数值
        database.NewDatabase,
        NewApp,
    )
    return nil, nil
}
```

##### Cleanup Functions（清理函数）

```go
// database/database.go
func NewDatabase(dsn string) (*Database, func(), error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, nil, err
    }

    cleanup := func() {
        db.Close()
    }

    return &Database{DB: db}, cleanup, nil
}

// wire_gen.go 会生成
func InitializeApp() (*App, func(), error) {
    database, cleanup1, err := database.NewDatabase("...")
    if err != nil {
        return nil, nil, err
    }
    logger := logger.NewLogger("...")
    app := NewApp(database, logger)
    return app, func() {
        cleanup1()
    }, nil
}

// main.go
func main() {
    app, cleanup, err := InitializeApp()
    if err != nil {
        panic(err)
    }
    defer cleanup()  // 确保资源被清理

    app.Run()
}
```

### 3. Dig 使用详解

#### 3.1 Dig 基本概念

Dig 是 Uber 开发的运行时依赖注入框架，使用反射实现。

安装 Dig：
```bash
go get go.uber.org/dig
```

#### 3.2 Dig 基础示例

```go
package main

import (
    "database/sql"
    "log"
    "os"

    "go.uber.org/dig"
)

type Database struct {
    *sql.DB
}

func NewDatabase() (*Database, error) {
    db, err := sql.Open("mysql", "root:password@/dbname")
    if err != nil {
        return nil, err
    }
    return &Database{DB: db}, nil
}

type Logger struct {
    *log.Logger
}

func NewLogger() *Logger {
    return &Logger{
        Logger: log.New(os.Stdout, "APP: ", log.LstdFlags),
    }
}

type UserService struct {
    db     *Database
    logger *Logger
}

func NewUserService(db *Database, logger *Logger) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
    }
}

func main() {
    // 创建容器
    container := dig.New()

    // 注册 providers
    container.Provide(NewDatabase)
    container.Provide(NewLogger)
    container.Provide(NewUserService)

    // 使用依赖
    err := container.Invoke(func(userService *UserService) {
        userService.logger.Println("User service initialized")
        // 使用 userService...
    })

    if err != nil {
        panic(err)
    }
}
```

#### 3.3 Dig 高级特性

##### Named Values（命名值）

```go
type Params struct {
    dig.In

    DBHost string `name:"db_host"`
    DBPort int    `name:"db_port"`
}

func NewDatabase(params Params) (*Database, error) {
    dsn := fmt.Sprintf("%s:%d", params.DBHost, params.DBPort)
    // 创建数据库连接...
}

func main() {
    container := dig.New()

    // 提供命名值
    container.Provide(func() string { return "localhost" }, dig.Name("db_host"))
    container.Provide(func() int { return 3306 }, dig.Name("db_port"))

    container.Provide(NewDatabase)
}
```

##### Value Groups（值组）

```go
type Plugin interface {
    Name() string
}

type PluginA struct{}
func (p PluginA) Name() string { return "plugin-a" }

type PluginB struct{}
func (p PluginB) Name() string { return "plugin-b" }

type App struct {
    Plugins []Plugin `group:"plugins"`
}

func main() {
    container := dig.New()

    // 添加到 group
    container.Provide(func() Plugin { return PluginA{} }, dig.Group("plugins"))
    container.Provide(func() Plugin { return PluginB{} }, dig.Group("plugins"))

    // 注入 group
    container.Provide(func(plugins []Plugin) *App {
        return &App{Plugins: plugins}
    })

    container.Invoke(func(app *App) {
        for _, plugin := range app.Plugins {
            fmt.Println(plugin.Name())
        }
    })
}
```

##### Optional Dependencies（可选依赖）

```go
type Params struct {
    dig.In

    Required *Database
    Optional *Cache `optional:"true"`
}

func NewUserService(params Params) *UserService {
    service := &UserService{db: params.Required}

    if params.Optional != nil {
        service.cache = params.Optional
    }

    return service
}
```

##### Decorators（装饰器）

```go
// 基础 logger
func NewLogger() *Logger {
    return &Logger{log.New(os.Stdout, "", 0)}
}

// 装饰器：添加时间戳
func DecorateLoggerWithTimestamp(logger *Logger) *Logger {
    logger.Logger.SetFlags(log.LstdFlags)
    return logger
}

// 装饰器：添加前缀
func DecorateLoggerWithPrefix(logger *Logger) *Logger {
    logger.Logger.SetPrefix("APP: ")
    return logger
}

func main() {
    container := dig.New()

    container.Provide(NewLogger)
    container.Decorate(DecorateLoggerWithTimestamp)
    container.Decorate(DecorateLoggerWithPrefix)

    container.Invoke(func(logger *Logger) {
        logger.Println("Hello")  // 输出带时间戳和前缀
    })
}
```

### 4. Wire vs Dig 对比

| 特性 | Wire | Dig |
|------|------|-----|
| **类型** | 编译期代码生成 | 运行时反射 |
| **性能** | 零运行时开销 | 有反射开销（微秒级） |
| **错误检查** | 编译期检查 | 运行时检查 |
| **IDE 支持** | 完整支持（代码跳转、重构） | 有限支持 |
| **调试** | 容易（生成普通代码） | 困难（反射调用栈） |
| **灵活性** | 较低（编译期确定） | 高（运行时动态） |
| **学习曲线** | 较陡（需理解代码生成） | 较平缓 |
| **生命周期管理** | 手动（通过 cleanup） | 内置支持 |
| **装饰器模式** | 不支持 | 支持 |
| **条件注入** | 不支持 | 支持（通过 optional） |

### 5. 实战场景选择

#### 5.1 选择 Wire 的场景

```go
// 微服务架构，追求性能
// wire.go
func InitializeServer() (*http.Server, func(), error) {
    wire.Build(
        config.LoadConfig,
        database.NewMySQL,
        cache.NewRedis,
        repository.RepositorySet,
        service.ServiceSet,
        handler.HandlerSet,
        NewHTTPServer,
    )
    return nil, nil, nil
}
```

优势：
- 编译期错误检查
- 零运行时开销
- 代码清晰可追溯

#### 5.2 选择 Dig 的场景

```go
// 插件系统，需要运行时灵活性
func main() {
    container := dig.New()

    // 加载核心组件
    container.Provide(NewCore)

    // 动态加载插件
    plugins := loadPlugins()  // 从配置或目录读取
    for _, plugin := range plugins {
        container.Provide(plugin.Provider, dig.Group("plugins"))
    }

    // 运行应用
    container.Invoke(func(app *App) {
        app.Run()
    })
}
```

优势：
- 动态插件加载
- 装饰器模式
- 条件依赖注入

### 6. 最佳实践

#### 6.1 通用原则

1. **依赖接口而非实现**

```go
type UserRepository interface {
    GetUser(id int) (*User, error)
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}  // 依赖接口
}
```

2. **保持构造函数简单**

```go
// 好的实践
func NewUserService(db *Database, logger *Logger) *UserService {
    return &UserService{db: db, logger: logger}
}

// 避免在构造函数中执行复杂逻辑
func NewUserService(db *Database) *UserService {
    service := &UserService{db: db}
    service.initialize()  // 避免！
    return service
}
```

3. **使用 Provider Sets 组织代码**

```go
// repository/provider.go
var RepositorySet = wire.NewSet(
    NewUserRepository,
    NewOrderRepository,
    NewProductRepository,
)

// service/provider.go
var ServiceSet = wire.NewSet(
    NewUserService,
    NewOrderService,
    NewProductService,
)
```

#### 6.2 Wire 最佳实践

1. **使用 build tags 分离配置**

```go
//go:build wireinject
// +build wireinject

package main
```

2. **添加 go:generate 注释**

```go
//go:generate wire
package main
```

3. **错误处理**

```go
func InitializeApp() (*App, func(), error) {
    // Wire 会自动传播错误
    wire.Build(...)
    return nil, nil, nil
}
```

#### 6.3 Dig 最佳实践

1. **使用 dig.In 和 dig.Out**

```go
type ServiceParams struct {
    dig.In

    DB     *Database
    Cache  *Cache
    Logger *Logger
}

type ServiceResult struct {
    dig.Out

    UserService  *UserService
    OrderService *OrderService
}

func NewServices(params ServiceParams) ServiceResult {
    return ServiceResult{
        UserService:  NewUserService(params.DB, params.Logger),
        OrderService: NewOrderService(params.DB, params.Cache),
    }
}
```

2. **避免循环依赖**

```go
// 错误：循环依赖
// A depends on B, B depends on A

// 正确：引入中介
// A depends on Interface, B implements Interface
```

3. **使用 Visualize 调试**

```go
container := dig.New()
// ... 注册 providers

// 可视化依赖图
fmt.Println(dig.Visualize(container))
```

### 7. 测试中的依赖注入

```go
// 生产代码
func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

// 测试代码
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) GetUser(id int) (*User, error) {
    args := m.Called(id)
    return args.Get(0).(*User), args.Error(1)
}

func TestUserService_GetUser(t *testing.T) {
    mockRepo := new(MockUserRepository)
    mockRepo.On("GetUser", 1).Return(&User{ID: 1, Name: "Alice"}, nil)

    service := NewUserService(mockRepo)  // 注入 mock
    user, err := service.GetUser(1)

    assert.NoError(t, err)
    assert.Equal(t, "Alice", user.Name)
    mockRepo.AssertExpectations(t)
}
```
