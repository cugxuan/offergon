---
title: 设计一个地理位置附近的人功能（LBS）
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-location-based-service-nearby-people
ref:
---

## 核心要点

**GeoHash编码+Redis Geo**实现空间索引,**分级网格(S2/H3)**处理边界问题。**位置更新采用异步批量**,**距离计算用Haversine公式**。**隐私保护**通过位置模糊化(精度降级到500米),**缓存热点区域**提升查询性能。

---

## 详细回答

### 一、核心功能

1. **上报位置**:用户实时上报经纬度
2. **查询附近的人**:查询5km内的用户
3. **距离计算**:显示精确距离(如1.2km)
4. **实时更新**:位置变化实时生效
5. **隐私保护**:模糊化位置,不暴露精确坐标

### 二、技术方案选择

#### GeoHash vs QuadTree vs S2

| 方案 | 原理 | 优点 | 缺点 | 推荐 |
|------|------|------|------|------|
| GeoHash | Z曲线编码 | 简单,Redis原生支持 | 边界问题严重 | ✅ 中小规模 |
| QuadTree | 四叉树递归分割 | 动态平衡 | 实现复杂,不支持分布式 | ❌ |
| S2 Geometry | Google的球面几何库 | 精度高,无边界问题 | 学习曲线陡 | ✅ 大规模场景 |

**最终选择**:Redis GeoHash + 边界扩展查询

### 三、数据库设计

```sql
CREATE TABLE user_location (
    user_id BIGINT PRIMARY KEY,
    longitude DOUBLE NOT NULL,        -- 经度
    latitude DOUBLE NOT NULL,         -- 纬度
    geohash VARCHAR(12),              -- GeoHash编码(12位精度=5cm)
    update_time BIGINT NOT NULL,
    INDEX idx_geohash (geohash),
    SPATIAL INDEX idx_location (location)  -- MySQL 8.0空间索引
);
```

### 四、核心实现

#### 1. 位置上报(批量更新)

```go
func UpdateLocation(userID int64, lng, lat float64) error {
    // 1. 计算GeoHash(精度6位=610米误差)
    geohash := geohash.Encode(lat, lng, 6)

    // 2. 写入Redis Geo(实时查询)
    redis.GeoAdd(ctx, "user_locations",
        &redis.GeoLocation{
            Name:      strconv.FormatInt(userID, 10),
            Longitude: lng,
            Latitude:  lat,
        })

    // 3. 异步写入MySQL(持久化)
    mq.Send("location_update", map[string]interface{}{
        "user_id": userID,
        "lng": lng,
        "lat": lat,
        "geohash": geohash,
        "time": time.Now().Unix(),
    })

    // 4. 设置过期时间(24小时未更新自动清除)
    redis.Expire(ctx, "user_locations", 24*time.Hour)

    return nil
}
```

#### 2. 查询附近的人

```go
func GetNearbyUsers(userID int64, radius float64) ([]NearbyUser, error) {
    // 1. 查询当前用户位置
    myLocation := getUserLocation(userID)

    // 2. Redis GeoRadius查询
    results := redis.GeoRadius(ctx, "user_locations",
        myLocation.Longitude, myLocation.Latitude,
        &redis.GeoRadiusQuery{
            Radius:      radius,          // 5km
            Unit:        "km",
            WithCoord:   true,            // 返回坐标
            WithDist:    true,            // 返回距离
            Count:       100,             // 最多100个
            Sort:        "ASC",           // 按距离升序
        }).Val()

    // 3. 批量查询用户信息
    userIDs := make([]int64, len(results))
    for i, r := range results {
        userIDs[i], _ = strconv.ParseInt(r.Name, 10, 64)
    }
    users := getUsersByIDs(userIDs)

    // 4. 组装结果
    nearby := make([]NearbyUser, len(results))
    for i, r := range results {
        nearby[i] = NearbyUser{
            User:     users[i],
            Distance: r.Dist,   // 单位:km
            Bearing:  calculateBearing(myLocation, r.GeoLocation), // 方位角
        }
    }

    return nearby, nil
}
```

#### 3. 边界问题处理

**问题**:GeoHash边界两侧的点,编码差异巨大,无法查询到

**解决方案**:九宫格查询
```go
func GetNearbyUsersWithBoundary(lat, lng, radius float64) []User {
    // 1. 计算中心点的GeoHash
    centerHash := geohash.Encode(lat, lng, 6)

    // 2. 获取周边8个网格的GeoHash
    neighbors := geohash.Neighbors(centerHash)
    allHashes := append([]string{centerHash}, neighbors...)

    // 3. 分别查询9个网格
    allUsers := []User{}
    for _, hash := range allHashes {
        users := queryByGeoHash(hash)
        allUsers = append(allUsers, users...)
    }

    // 4. 精确过滤(计算真实距离)
    result := []User{}
    for _, u := range allUsers {
        dist := haversine(lat, lng, u.Lat, u.Lng)
        if dist <= radius {
            result = append(result, u)
        }
    }

    return result
}

// Haversine公式计算球面距离
func haversine(lat1, lng1, lat2, lng2 float64) float64 {
    const R = 6371.0 // 地球半径(km)

    dLat := (lat2 - lat1) * math.Pi / 180
    dLng := (lng2 - lng1) * math.Pi / 180

    a := math.Sin(dLat/2)*math.Sin(dLat/2) +
         math.Cos(lat1*math.Pi/180)*math.Cos(lat2*math.Pi/180)*
         math.Sin(dLng/2)*math.Sin(dLng/2)

    c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
    return R * c
}
```

### 五、性能优化

#### 1. 热点区域缓存

```go
// 预热热门商圈的用户列表
func PreloadHotAreas() {
    hotAreas := []Area{
        {Name: "三里屯", Lat: 39.93, Lng: 116.45, Radius: 2},
        {Name: "西单", Lat: 39.91, Lng: 116.38, Radius: 1.5},
    }

    for _, area := range hotAreas {
        users := GetNearbyUsers(0, area.Lat, area.Lng, area.Radius)
        cacheKey := fmt.Sprintf("hot_area:%s", area.Name)
        redis.Set(ctx, cacheKey, json.Marshal(users), 5*time.Minute)
    }
}
```

#### 2. 分级精度

```go
// 根据距离动态调整精度
func GetAdaptivePrecision(radius float64) int {
    switch {
    case radius <= 1:    // 1km内,精度7位(76米)
        return 7
    case radius <= 5:    // 5km内,精度6位(610米)
        return 6
    case radius <= 20:   // 20km内,精度5位(2.4km)
        return 5
    default:
        return 4         // 20km+,精度4位(20km)
    }
}
```

### 六、隐私保护

```go
// 位置模糊化:降低精度到500米
func FuzzLocation(lat, lng float64) (float64, float64) {
    // 方案1:GeoHash截断
    hash := geohash.Encode(lat, lng, 6)  // 610米精度
    fuzzyLat, fuzzyLng := geohash.Decode(hash)
    return fuzzyLat, fuzzyLng

    // 方案2:随机偏移
    offset := 0.005  // 约500米
    return lat + rand.Float64()*offset, lng + rand.Float64()*offset
}

// 用户设置:是否允许被搜索
func SetLocationPrivacy(userID int64, visible bool) {
    if !visible {
        redis.ZRem(ctx, "user_locations", userID)
    }
}
```

### 七、容量评估

- 日活用户:1000万
- 位置更新QPS:1000万 × 10次/天 / 86400 ≈ 1157 QPS
- 附近的人查询:1000万 × 5次/天 / 86400 ≈ 579 QPS
- Redis存储:1000万用户 × 64B ≈ 640MB

### 八、总结

**技术选型**:Redis Geo + GeoHash + Haversine公式
**核心优化**:九宫格查询解决边界问题,热点区域缓存,位置模糊化保护隐私
