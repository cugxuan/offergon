---
title: 设计一个积分系统
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-points-system
ref:
---

## 核心要点

**关键挑战**: 积分发放准确性、防刷防作弊、高并发处理、账户一致性
**核心方案**: 复式记账 + 幂等性保证 + 流水记录 + 定时对账
**技术选型**: MySQL + Redis + MQ + 定时任务
**性能指标**: 支持万级QPS、零差错、实时到账

---

## 详细回答

### 一、业务场景分析

积分系统是用户激励体系的核心,需要支持:
- **积分获取**: 签到、购物、邀请好友、完成任务等
- **积分消费**: 兑换商品、抵扣现金、参与抽奖等
- **积分管理**: 查询余额、查看流水、积分过期等
- **等级体系**: 根据累计积分划分用户等级

**典型场景**:
1. **签到送积分**: 每日签到+5积分,连续签到额外奖励
2. **购物返积分**: 每消费1元返1积分
3. **邀请奖励**: 邀请新用户注册,双方各得50积分
4. **积分兑换**: 100积分兑换10元优惠券
5. **积分过期**: 12个月未使用的积分自动清零
6. **积分等级**: VIP1(1000分), VIP2(5000分), VIP3(10000分)

### 二、系统架构设计

#### 2.1 整体架构

```
┌──────────────────────────────────────────┐
│              积分系统                      │
│                                          │
│  ┌────────────┐  ┌────────────┐         │
│  │ 积分账户   │  │  积分规则   │         │
│  │ 管理       │  │  引擎       │         │
│  └────────────┘  └────────────┘         │
│                                          │
│  ┌────────────┐  ┌────────────┐         │
│  │ 积分发放   │  │  积分消费   │         │
│  │ 服务       │  │  服务       │         │
│  └────────────┘  └────────────┘         │
│                                          │
│  ┌────────────┐  ┌────────────┐         │
│  │ 等级计算   │  │  对账服务   │         │
│  └────────────┘  └────────────┘         │
└──────────────────────────────────────────┘
       │              │              │
       ↓              ↓              ↓
   MySQL          Redis           MQ
```

#### 2.2 核心模块

**1. 积分账户管理**
- 用户积分账户创建
- 积分余额查询
- 积分冻结/解冻

**2. 积分规则引擎**
- 配置各种积分获取规则
- 动态调整积分比例
- 活动期间加倍

**3. 积分发放服务**
- 签到积分
- 购物返积分
- 任务奖励
- 人工补发

**4. 积分消费服务**
- 积分兑换
- 积分抵扣
- 积分转赠

**5. 等级体系**
- 根据累计积分计算等级
- 等级权益管理

**6. 对账服务**
- 定时对账积分总量
- 异常积分告警

### 三、数据库设计

```sql
-- 用户积分账户表
CREATE TABLE user_points_account (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL UNIQUE COMMENT '用户ID',

    -- 积分余额
    available_points INT NOT NULL DEFAULT 0 COMMENT '可用积分',
    frozen_points INT NOT NULL DEFAULT 0 COMMENT '冻结积分',
    total_points INT NOT NULL DEFAULT 0 COMMENT '总积分(可用+冻结)',

    -- 累计统计
    total_earned INT NOT NULL DEFAULT 0 COMMENT '累计获得积分',
    total_consumed INT NOT NULL DEFAULT 0 COMMENT '累计消费积分',

    -- 版本号(乐观锁)
    version INT NOT NULL DEFAULT 0 COMMENT '版本号',

    -- 等级
    level VARCHAR(32) DEFAULT 'NORMAL' COMMENT '用户等级',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uk_user_id (user_id),
    INDEX idx_level (level)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户积分账户表';

-- 积分流水表(记录每一笔积分变动)
CREATE TABLE points_transaction (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',

    -- 交易信息
    transaction_no VARCHAR(64) NOT NULL UNIQUE COMMENT '流水号',
    biz_no VARCHAR(64) DEFAULT NULL COMMENT '业务单号(订单号/任务ID等)',
    biz_type VARCHAR(32) NOT NULL COMMENT '业务类型: SIGN_IN, ORDER, TASK, EXCHANGE, EXPIRE',

    -- 积分变动
    amount INT NOT NULL COMMENT '积分变动(正数为收入,负数为支出)',
    before_balance INT NOT NULL COMMENT '变动前余额',
    after_balance INT NOT NULL COMMENT '变动后余额',

    -- 状态
    status VARCHAR(32) NOT NULL DEFAULT 'SUCCESS' COMMENT '状态: SUCCESS, FAILED, PENDING',

    -- 描述
    remark VARCHAR(255) DEFAULT NULL COMMENT '备注',

    -- 过期时间(积分有效期)
    expire_time TIMESTAMP NULL COMMENT '过期时间',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_id (user_id),
    INDEX idx_biz_no (biz_no),
    INDEX idx_created_at (created_at),
    INDEX idx_expire_time (expire_time),
    UNIQUE KEY uk_transaction_no (transaction_no)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='积分流水表';

-- 积分规则配置表
CREATE TABLE points_rule (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(255) NOT NULL COMMENT '规则名称',
    rule_code VARCHAR(64) NOT NULL UNIQUE COMMENT '规则编码',
    biz_type VARCHAR(32) NOT NULL COMMENT '业务类型',

    -- 积分计算
    points_ratio DECIMAL(10,2) NOT NULL DEFAULT 1.00 COMMENT '积分比例(如1元=1积分)',
    fixed_points INT DEFAULT 0 COMMENT '固定积分(如签到+5分)',
    max_points INT DEFAULT 0 COMMENT '单次最高积分(0表示无限制)',

    -- 限制
    daily_limit INT DEFAULT 0 COMMENT '每日限制次数(0表示无限制)',
    valid_days INT DEFAULT 365 COMMENT '积分有效期(天)',

    -- 状态
    status VARCHAR(32) NOT NULL DEFAULT 'ACTIVE' COMMENT '状态: ACTIVE, INACTIVE',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uk_rule_code (rule_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='积分规则表';

-- 用户等级配置表
CREATE TABLE user_level_config (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    level_code VARCHAR(32) NOT NULL UNIQUE COMMENT '等级代码',
    level_name VARCHAR(64) NOT NULL COMMENT '等级名称',
    min_points INT NOT NULL COMMENT '最低积分要求',
    max_points INT DEFAULT NULL COMMENT '最高积分(NULL表示无上限)',
    privileges TEXT COMMENT '等级权益(JSON)',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uk_level_code (level_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户等级配置表';

-- 积分兑换商品表
CREATE TABLE points_goods (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    goods_name VARCHAR(255) NOT NULL COMMENT '商品名称',
    points_price INT NOT NULL COMMENT '积分价格',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存',
    status VARCHAR(32) NOT NULL DEFAULT 'ON_SALE' COMMENT '状态',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='积分商品表';

-- 积分兑换记录表
CREATE TABLE points_exchange_record (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    goods_id BIGINT NOT NULL COMMENT '商品ID',
    points_cost INT NOT NULL COMMENT '消耗积分',
    status VARCHAR(32) NOT NULL DEFAULT 'SUCCESS' COMMENT '状态',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='积分兑换记录表';
```

### 四、核心功能实现

#### 4.1 初始化积分账户

```go
// 用户注册时自动创建积分账户
func InitPointsAccount(userID int64) error {
    account := &UserPointsAccount{
        UserID:          userID,
        AvailablePoints: 0,
        FrozenPoints:    0,
        TotalPoints:     0,
        TotalEarned:     0,
        TotalConsumed:   0,
        Level:           "NORMAL",
        Version:         0,
    }

    err := db.Create(account).Error
    if err != nil {
        return err
    }

    // 新用户注册赠送积分
    AddPoints(userID, 100, "REGISTER", "", "新用户注册奖励")

    return nil
}
```

#### 4.2 积分发放(核心)

**关键点**: 使用乐观锁 + 流水记录,保证幂等性和准确性

```go
// 增加积分
func AddPoints(userID int64, amount int, bizType string, bizNo string, remark string) error {
    // 1. 幂等性校验 - 同一业务单号只能发放一次
    if bizNo != "" {
        exists := checkTransactionExists(bizNo)
        if exists {
            log.Warnf("业务单号 %s 已处理,跳过", bizNo)
            return nil
        }
    }

    // 2. 查询积分规则
    rule := getPointsRule(bizType)
    if rule == nil {
        return errors.New("积分规则不存在")
    }

    // 3. 检查规则限制(每日限制)
    if rule.DailyLimit > 0 {
        todayCount := getTodayTransactionCount(userID, bizType)
        if todayCount >= rule.DailyLimit {
            return errors.New("今日积分已达上限")
        }
    }

    // 4. 计算实际积分(考虑上限)
    actualAmount := amount
    if rule.MaxPoints > 0 && actualAmount > rule.MaxPoints {
        actualAmount = rule.MaxPoints
    }

    // 5. 使用乐观锁更新账户余额
    maxRetry := 3
    for i := 0; i < maxRetry; i++ {
        // 查询账户
        var account UserPointsAccount
        err := db.Where("user_id = ?", userID).First(&account).Error
        if err != nil {
            return err
        }

        // 计算过期时间
        expireTime := time.Now().AddDate(0, 0, rule.ValidDays)

        // 生成流水号
        transactionNo := generateTransactionNo()

        // 开启事务
        tx := db.Begin()

        // 更新账户(携带版本号条件)
        result := tx.Model(&UserPointsAccount{}).
            Where("user_id = ? AND version = ?", userID, account.Version).
            Updates(map[string]interface{}{
                "available_points": gorm.Expr("available_points + ?", actualAmount),
                "total_points":     gorm.Expr("total_points + ?", actualAmount),
                "total_earned":     gorm.Expr("total_earned + ?", actualAmount),
                "version":          gorm.Expr("version + 1"),
            })

        if result.Error != nil {
            tx.Rollback()
            return result.Error
        }

        // 检查是否更新成功
        if result.RowsAffected == 0 {
            tx.Rollback()
            // 版本号冲突,重试
            time.Sleep(time.Millisecond * 10)
            continue
        }

        // 插入流水记录
        transaction := &PointsTransaction{
            UserID:        userID,
            TransactionNo: transactionNo,
            BizNo:         bizNo,
            BizType:       bizType,
            Amount:        actualAmount,
            BeforeBalance: account.AvailablePoints,
            AfterBalance:  account.AvailablePoints + actualAmount,
            Status:        "SUCCESS",
            Remark:        remark,
            ExpireTime:    expireTime,
        }

        err = tx.Create(transaction).Error
        if err != nil {
            tx.Rollback()
            return err
        }

        // 提交事务
        err = tx.Commit().Error
        if err != nil {
            return err
        }

        // 成功,检查是否升级
        checkAndUpgradeLevel(userID)

        return nil
    }

    return errors.New("增加积分失败,请重试")
}

// 生成流水号
func generateTransactionNo() string {
    // 24位流水号: PT + 时间戳(10位) + 随机数(12位)
    timestamp := time.Now().Unix()
    random := rand.Intn(1000000000000)
    return fmt.Sprintf("PT%010d%012d", timestamp, random)
}

// 检查业务单号是否已处理
func checkTransactionExists(bizNo string) bool {
    var count int64
    db.Model(&PointsTransaction{}).
        Where("biz_no = ? AND status = ?", bizNo, "SUCCESS").
        Count(&count)
    return count > 0
}
```

#### 4.3 积分消费

```go
// 扣减积分
func DeductPoints(userID int64, amount int, bizType string, bizNo string, remark string) error {
    // 1. 幂等性校验
    if bizNo != "" {
        exists := checkTransactionExists(bizNo)
        if exists {
            log.Warnf("业务单号 %s 已处理,跳过", bizNo)
            return nil
        }
    }

    // 2. 使用乐观锁扣减
    maxRetry := 3
    for i := 0; i < maxRetry; i++ {
        // 查询账户
        var account UserPointsAccount
        err := db.Where("user_id = ?", userID).First(&account).Error
        if err != nil {
            return err
        }

        // 检查余额
        if account.AvailablePoints < amount {
            return errors.New("积分余额不足")
        }

        // 生成流水号
        transactionNo := generateTransactionNo()

        // 开启事务
        tx := db.Begin()

        // 更新账户
        result := tx.Model(&UserPointsAccount{}).
            Where("user_id = ? AND version = ? AND available_points >= ?",
                  userID, account.Version, amount).
            Updates(map[string]interface{}{
                "available_points": gorm.Expr("available_points - ?", amount),
                "total_points":     gorm.Expr("total_points - ?", amount),
                "total_consumed":   gorm.Expr("total_consumed + ?", amount),
                "version":          gorm.Expr("version + 1"),
            })

        if result.Error != nil {
            tx.Rollback()
            return result.Error
        }

        // 检查是否更新成功
        if result.RowsAffected == 0 {
            tx.Rollback()
            // 版本号冲突或余额不足,重试
            time.Sleep(time.Millisecond * 10)
            continue
        }

        // 插入流水记录(金额为负数)
        transaction := &PointsTransaction{
            UserID:        userID,
            TransactionNo: transactionNo,
            BizNo:         bizNo,
            BizType:       bizType,
            Amount:        -amount, // 负数表示支出
            BeforeBalance: account.AvailablePoints,
            AfterBalance:  account.AvailablePoints - amount,
            Status:        "SUCCESS",
            Remark:        remark,
        }

        err = tx.Create(transaction).Error
        if err != nil {
            tx.Rollback()
            return err
        }

        // 提交事务
        err = tx.Commit().Error
        if err != nil {
            return err
        }

        return nil
    }

    return errors.New("扣减积分失败,请重试")
}
```

#### 4.4 典型场景实现

**1. 签到送积分**

```go
// 每日签到
func DailySignIn(userID int64) error {
    // 1. 检查今天是否已签到
    today := time.Now().Format("2006-01-02")
    cacheKey := fmt.Sprintf("sign_in:%d:%s", userID, today)

    if redis.Exists(ctx, cacheKey).Val() == 1 {
        return errors.New("今日已签到")
    }

    // 2. 查询连续签到天数
    consecutiveDays := getConsecutiveSignInDays(userID)

    // 3. 计算积分(基础5分,连续7天额外10分)
    points := 5
    if consecutiveDays >= 6 { // 今天签到后满7天
        points += 10
    }

    // 4. 发放积分
    bizNo := fmt.Sprintf("SIGNIN_%d_%s", userID, today)
    err := AddPoints(userID, points, "SIGN_IN", bizNo, "每日签到奖励")
    if err != nil {
        return err
    }

    // 5. 记录签到
    redis.Set(ctx, cacheKey, "1", 24*time.Hour)

    return nil
}
```

**2. 购物返积分**

```go
// 订单完成返积分
func OrderCompleteReward(orderNo string, userID int64, orderAmount float64) error {
    // 1. 查询规则(假设1元=1积分)
    rule := getPointsRule("ORDER")

    // 2. 计算积分
    points := int(orderAmount * rule.PointsRatio)

    // 3. 检查上限
    if rule.MaxPoints > 0 && points > rule.MaxPoints {
        points = rule.MaxPoints
    }

    // 4. 发放积分
    bizNo := orderNo
    remark := fmt.Sprintf("订单 %s 完成,返还积分", orderNo)

    return AddPoints(userID, points, "ORDER", bizNo, remark)
}
```

**3. 积分兑换商品**

```go
// 积分兑换
func ExchangeGoods(userID int64, goodsID int64) error {
    // 1. 查询商品
    var goods PointsGoods
    err := db.First(&goods, goodsID).Error
    if err != nil {
        return err
    }

    // 2. 检查库存
    if goods.Stock <= 0 {
        return errors.New("商品库存不足")
    }

    // 3. 扣减积分
    bizNo := fmt.Sprintf("EXCHANGE_%d_%d_%d", userID, goodsID, time.Now().Unix())
    err = DeductPoints(userID, goods.PointsPrice, "EXCHANGE", bizNo,
                       fmt.Sprintf("兑换商品: %s", goods.GoodsName))
    if err != nil {
        return err
    }

    // 4. 扣减库存
    err = db.Model(&PointsGoods{}).
        Where("id = ? AND stock > 0", goodsID).
        Update("stock", gorm.Expr("stock - 1")).Error

    if err != nil {
        // 补偿:恢复积分
        AddPoints(userID, goods.PointsPrice, "EXCHANGE_REFUND", bizNo, "兑换失败退款")
        return err
    }

    // 5. 创建兑换记录
    record := &PointsExchangeRecord{
        UserID:     userID,
        GoodsID:    goodsID,
        PointsCost: goods.PointsPrice,
        Status:     "SUCCESS",
    }
    db.Create(record)

    return nil
}
```

#### 4.5 等级体系

```go
// 检查并升级用户等级
func checkAndUpgradeLevel(userID int64) {
    // 1. 查询用户累计积分
    var account UserPointsAccount
    db.Where("user_id = ?", userID).First(&account)

    // 2. 查询等级配置
    var levels []UserLevelConfig
    db.Order("min_points ASC").Find(&levels)

    // 3. 匹配等级
    newLevel := "NORMAL"
    for _, level := range levels {
        if account.TotalEarned >= level.MinPoints {
            if level.MaxPoints == nil || account.TotalEarned <= *level.MaxPoints {
                newLevel = level.LevelCode
            }
        }
    }

    // 4. 更新等级
    if newLevel != account.Level {
        db.Model(&UserPointsAccount{}).
            Where("user_id = ?", userID).
            Update("level", newLevel)

        // 通知用户升级
        notifyUser(userID, "恭喜升级", newLevel)
    }
}

// 等级配置示例
/*
INSERT INTO user_level_config (level_code, level_name, min_points, max_points) VALUES
('NORMAL', '普通用户', 0, 999),
('VIP1', 'VIP1', 1000, 4999),
('VIP2', 'VIP2', 5000, 9999),
('VIP3', 'VIP3', 10000, NULL);
*/
```

#### 4.6 积分过期

```go
// 定时任务 - 处理过期积分
func ExpirePoints() {
    // 1. 查询已过期的积分流水
    now := time.Now()

    var transactions []PointsTransaction
    db.Where("expire_time < ? AND amount > 0 AND status = ?", now, "SUCCESS").
       Find(&transactions)

    for _, tx := range transactions {
        // 2. 扣减过期积分
        bizNo := fmt.Sprintf("EXPIRE_%s", tx.TransactionNo)
        DeductPoints(tx.UserID, tx.Amount, "EXPIRE", bizNo, "积分过期")

        // 3. 更新流水状态
        db.Model(&PointsTransaction{}).
           Where("id = ?", tx.ID).
           Update("status", "EXPIRED")
    }
}
```

### 五、关键问题与优化

#### 5.1 如何保证积分准确性?

**方案: 复式记账 + 对账**

```go
// 1. 复式记账 - 账户表和流水表双写
// 账户表记录总额,流水表记录明细

// 2. 定时对账
func ReconcilePoints() {
    // 查询所有用户
    var accounts []UserPointsAccount
    db.Find(&accounts)

    for _, account := range accounts {
        // 从流水表计算余额
        var sum struct {
            Total int
        }

        db.Model(&PointsTransaction{}).
           Select("SUM(amount) as total").
           Where("user_id = ? AND status = ?", account.UserID, "SUCCESS").
           Scan(&sum)

        // 比对差异
        if sum.Total != account.TotalPoints {
            log.Errorf("用户 %d 积分不一致: 账户=%d, 流水=%d",
                       account.UserID, account.TotalPoints, sum.Total)

            // 告警
            alert("积分不一致", account.UserID, account.TotalPoints, sum.Total)
        }
    }
}
```

#### 5.2 如何防止刷积分?

**方案: 多维度防刷**

```go
// 1. 规则限制(每日上限)
type PointsRule struct {
    // ...
    DailyLimit int // 每日最多获得次数
}

// 2. IP限流
func checkIPLimit(ip string, bizType string) error {
    key := fmt.Sprintf("points:ip:%s:%s:%s", ip, bizType, time.Now().Format("2006-01-02"))
    count, _ := redis.Incr(ctx, key).Result()

    if count == 1 {
        redis.Expire(ctx, key, 24*time.Hour)
    }

    if count > 100 {
        return errors.New("操作过于频繁")
    }

    return nil
}

// 3. 风控检测
func checkRisk(userID int64) error {
    // 检测异常行为
    // - 短时间内大量积分变动
    // - 积分来源单一
    // - 异常设备登录

    recentCount := getRecentTransactionCount(userID, 1*time.Hour)
    if recentCount > 50 {
        return errors.New("积分变动异常,请联系客服")
    }

    return nil
}

// 4. 人工审核(大额积分)
func AddPointsWithAudit(userID int64, amount int, bizType string) error {
    if amount > 1000 {
        // 创建审核记录
        createAuditRecord(userID, amount, bizType)
        return errors.New("大额积分需人工审核")
    }

    return AddPoints(userID, amount, bizType, "", "")
}
```

#### 5.3 如何优化查询性能?

**方案: 缓存 + 分表**

```go
// 1. 缓存积分余额
func GetUserPoints(userID int64) (int, error) {
    // 优先从Redis获取
    cacheKey := fmt.Sprintf("points:balance:%d", userID)
    points, err := redis.Get(ctx, cacheKey).Int()

    if err == nil {
        return points, nil
    }

    // 从数据库查询
    var account UserPointsAccount
    err = db.Where("user_id = ?", userID).First(&account).Error
    if err != nil {
        return 0, err
    }

    // 写入缓存(TTL 5分钟)
    redis.Set(ctx, cacheKey, account.AvailablePoints, 5*time.Minute)

    return account.AvailablePoints, nil
}

// 2. 流水表分表(按月)
/*
points_transaction_202501
points_transaction_202502
points_transaction_202503
...
*/

// 3. 历史数据归档
// 将1年前的流水归档到历史表
```

#### 5.4 如何处理高并发?

**方案: 异步处理 + MQ削峰**

```go
// 1. 异步发放积分
func AddPointsAsync(userID int64, amount int, bizType string, bizNo string) error {
    // 发送MQ消息
    event := &PointsEvent{
        UserID:  userID,
        Amount:  amount,
        BizType: bizType,
        BizNo:   bizNo,
    }

    return mq.Publish("points.add", event)
}

// 2. MQ消费者
func ConsumePointsEvent(event *PointsEvent) {
    err := AddPoints(event.UserID, event.Amount, event.BizType, event.BizNo, "")
    if err != nil {
        log.Errorf("发放积分失败: %v", err)
        // 重试
    }
}

// 3. 批量发放
func BatchAddPoints(users []int64, amount int, bizType string) {
    // 使用协程池并发处理
    pool := worker.NewPool(10) // 10个并发

    for _, userID := range users {
        userID := userID // 注意闭包
        pool.Submit(func() {
            AddPointsAsync(userID, amount, bizType, "")
        })
    }

    pool.Wait()
}
```

### 六、监控与告警

```go
// 1. 监控指标
type PointsMetrics struct {
    // 积分发放量(每小时)
    HourlyIssued int

    // 积分消费量(每小时)
    HourlyConsumed int

    // 积分余额总量
    TotalBalance int

    // 异常账户数量
    AbnormalAccounts int
}

// 2. 告警规则
func CheckPointsAnomalies() {
    // 发放量突增
    if metrics.HourlyIssued > 100000 {
        alert("积分发放异常", metrics)
    }

    // 总余额异常
    expectedBalance := calculateExpectedBalance()
    actualBalance := getActualBalance()

    if abs(expectedBalance - actualBalance) > 10000 {
        alert("积分总量不一致", expectedBalance, actualBalance)
    }
}
```

### 七、总结

**核心设计要点**:
1. **账户表 + 流水表**: 账户记录余额,流水记录明细
2. **乐观锁**: 使用version字段防止并发问题
3. **幂等性**: 业务单号唯一,防止重复发放
4. **复式记账**: 账户和流水双写,定时对账
5. **等级体系**: 根据累计积分自动升级

**防刷关键**:
- 规则限制(每日上限)
- IP/设备限流
- 风控检测
- 大额审核

**性能优化**:
- 缓存余额
- 流水表分表
- 异步发放
- 批量处理

**面试加分项**:
- 能设计完整的积分账户模型
- 能保证积分准确性(对账机制)
- 能处理高并发场景
- 能提出防刷方案
- 能设计等级体系

**实际案例**:
京东、淘宝的积分系统都采用类似设计,支持签到、购物、任务等多种获取方式,日均处理千万级积分变动,且保证零差错。核心是"账户表 + 流水表 + 定时对账"的架构。
