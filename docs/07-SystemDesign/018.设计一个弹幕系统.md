---
title: 设计一个弹幕系统
tags:
  - 系统设计
status: robot
class: 系统设计
slug: bullet-chat-system-design
ref:
---

## 核心要点

**关键挑战：**海量消息高并发写入、实时推送、弹幕轨道碰撞检测、敏感词过滤、存储优化

**技术选型：**WebSocket长连接推送、Redis缓存热数据、Kafka消息队列削峰、布隆过滤器去重

**架构核心：**客户端发送 → API网关 → 消息队列 → 异步处理（过滤/存储）→ WebSocket推送服务 → 客户端渲染

---

## 详细回答

### 一、需求分析与场景理解

面试官您好，弹幕系统是视频网站的核心功能之一，让我先明确一下需求：

**功能需求：**
1. **发送弹幕**：用户在视频播放时发送文字评论
2. **实时展示**：弹幕从右向左滚动，与视频时间轴同步
3. **历史弹幕**：播放到某个时间点时，展示历史弹幕
4. **弹幕密度控制**：避免弹幕过多导致画面遮挡
5. **互动功能**：点赞弹幕、举报弹幕、屏蔽用户
6. **弹幕类型**：
   - 滚动弹幕（普通）
   - 顶部弹幕（固定在顶部）
   - 底部弹幕（固定在底部）
   - 彩色弹幕（会员特权）
   - 高级弹幕（代码弹幕、定位弹幕）

**非功能需求：**
1. **高并发写入**：热门视频每秒上万条弹幕发送
2. **实时性**：弹幕发送到展示延迟 < 500ms
3. **高可用**：弹幕服务不能因单点故障挂掉
4. **数据一致性**：弹幕不能丢失或重复
5. **内容安全**：自动过滤敏感词、违规内容

**典型场景分析：**
- **普通视频**：100并发观看，每秒10条弹幕
- **热门视频**：10万并发观看，每秒1万条弹幕
- **直播弹幕**：实时性要求更高，可能短时间爆发式增长

**核心挑战：**
1. **写多读多**：既要支持大量用户同时发送弹幕，又要实时推送给所有观看者
2. **时间轴同步**：弹幕与视频播放进度绑定，需要精确的时间戳
3. **存储成本**：长视频+高热度可能产生数百万条弹幕，存储和查询压力大
4. **渲染性能**：客户端同时展示上百条弹幕时，需优化渲染性能和碰撞检测

### 二、整体架构设计

我采用**读写分离 + 消息队列解耦 + 多级缓存**的架构：

```
[客户端]
   ↓ 发送弹幕
[API网关 - 鉴权/限流]
   ↓
[Kafka消息队列] ← 削峰
   ↓ (异步消费)
[弹幕处理服务] → [敏感词过滤] → [数据库 + ES]
   ↓
[Redis缓存层] ← 热点弹幕
   ↓
[WebSocket推送服务] → [在线用户连接池]
   ↓
[客户端] 接收并渲染弹幕
```

#### 核心模块职责：

**1. API网关（弹幕写入）**
- 接收用户发送弹幕的HTTP/WebSocket请求
- 用户鉴权：验证登录状态和发言权限
- 频率限制：单用户每秒最多发送5条弹幕，防刷屏
- 参数校验：字数限制（20字内）、合法性检查

**2. Kafka消息队列**
- 作为缓冲层，接收所有弹幕写入请求
- 削峰填谷：应对突发流量（如精彩片段爆发式弹幕）
- 保证消息不丢失：持久化到磁盘，消费失败可重试

**3. 弹幕处理服务（异步消费者）**
- 从Kafka消费弹幕消息
- 敏感词过滤：基于DFA算法的高性能匹配
- 数据持久化：写入MySQL（元数据）+ HBase/ES（全量弹幕）
- 更新缓存：将弹幕写入Redis

**4. WebSocket推送服务**
- 维护在线用户的长连接
- 实时推送弹幕到观看同一视频的所有用户
- 分房间管理：每个视频ID对应一个房间
- 心跳保活：检测连接状态，自动清理断线用户

**5. 弹幕查询服务**
- 用户进入视频时，加载指定时间段的历史弹幕
- 优先从Redis读取热点弹幕
- 冷数据从ES或HBase查询

**6. 客户端渲染引擎**
- Canvas渲染弹幕（性能优于DOM）
- 轨道分配算法：避免弹幕重叠
- 弹幕池管理：对象复用，减少GC

### 三、关键技术方案

#### 3.1 数据模型设计

**弹幕表结构（MySQL - 元数据）**：
```sql
CREATE TABLE danmaku_meta (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    video_id BIGINT NOT NULL,          -- 视频ID
    user_id BIGINT NOT NULL,            -- 发送用户ID
    video_time INT NOT NULL,            -- 弹幕出现时间（秒）
    send_time BIGINT NOT NULL,          -- 发送时间戳（毫秒）
    content VARCHAR(200) NOT NULL,      -- 弹幕内容
    type TINYINT DEFAULT 1,             -- 类型：1滚动 2顶部 3底部
    color VARCHAR(10) DEFAULT '#FFFFFF',-- 颜色
    status TINYINT DEFAULT 1,           -- 状态：1正常 2已删除 3被举报
    INDEX idx_video_time (video_id, video_time),
    INDEX idx_user_send (user_id, send_time)
) ENGINE=InnoDB;
```

**为什么需要分离存储？**
- **MySQL**：存储弹幕元数据（用于审核、统计、删除操作）
- **HBase/ES**：存储全量弹幕（按video_id + video_time查询）
  - HBase：适合海量数据存储，按rowkey范围扫描
  - Elasticsearch：支持全文检索（搜索弹幕内容）

**HBase RowKey设计**：
```
RowKey: {video_id}_{video_time}_{danmaku_id}
示例：  10086_125_9527  （视频10086，第125秒，弹幕ID 9527）
```
这样设计的好处：
- 查询某个时间段的弹幕，直接范围扫描
- 同一视频的弹幕聚集在一起，提升查询效率

#### 3.2 高并发写入方案

**问题**：热门视频每秒1万条弹幕，直接写数据库会被打垮

**解决方案**：**消息队列 + 批量写入**

1. **Kafka作为写入缓冲**：
   - 用户发送弹幕 → 直接写入Kafka（TPS可达百万级）
   - 返回成功响应（异步处理，用户无需等待数据库写入）

2. **消费者批量写入**：
   - 消费者每100ms或累计500条消息，批量写入数据库
   - 使用PreparedStatement批量插入，减少数据库交互次数

3. **数据库分片**：
   - 按video_id哈希分库分表
   - 热门视频的弹幕分散到不同分片，避免单表热点

**限流策略**：
- **用户级限流**：单用户每秒最多5条（Redis计数器 + 过期时间）
- **视频级限流**：单视频每秒最多2万条（令牌桶算法）
- **全局限流**：API网关层面限制总QPS

#### 3.3 实时推送方案

**技术选型：WebSocket**
- 比HTTP轮询节省95%带宽
- 服务端主动推送，延迟低（< 100ms）

**推送架构**：

```
[WebSocket网关集群]
   ↓（订阅Redis Pub/Sub）
[Redis频道: danmaku:video:{video_id}]
   ↑（发布消息）
[弹幕处理服务]
```

**流程**：
1. 用户打开视频，WebSocket连接到网关
2. 网关订阅Redis频道 `danmaku:video:10086`
3. 其他用户发送弹幕 → 写入Kafka → 消费者处理后发布到Redis频道
4. WebSocket网关收到Redis消息，推送给该视频的所有在线用户

**连接管理**：
- 单台服务器维护10万长连接（需调整内核参数）
- 通过Nginx或LVS负载均衡，分散连接到多台服务器
- 心跳包：客户端每30秒发送ping，服务端60秒无心跳则断开连接

**房间隔离**：
- 每个视频是一个独立房间
- 用户只接收当前观看视频的弹幕
- 使用Redis的Pub/Sub实现房间广播

**优化：采样推送**
- 当单视频在线人数超过10万时，采样推送：
  - 不是所有弹幕都推给所有人
  - 随机选择30%的弹幕推送，保证画面流畅
  - VIP弹幕、高价值弹幕优先级高

#### 3.4 弹幕查询与缓存

**场景**：用户打开视频，需要加载当前时间点附近的弹幕

**缓存策略（多级缓存）**：

1. **Redis缓存（一级缓存）**：
   - Key: `danmaku:video:{video_id}:time:{video_time}`
   - Value: 该时间点的弹幕列表（JSON数组）
   - 过期时间：热门视频7天，冷门视频1天

2. **缓存预热**：
   - 热门视频的弹幕提前加载到Redis
   - 使用定时任务分析播放量TOP100视频，预热缓存

3. **懒加载**：
   - 用户播放到某个时间点时，提前5秒加载未来的弹幕
   - 例如：当前播放到60秒，加载60-65秒的弹幕

4. **缓存穿透保护**：
   - 使用布隆过滤器判断视频是否存在弹幕
   - 不存在则直接返回空，避免查询数据库

**查询优化**：
- 用户进入视频时，只加载当前时间点前后10秒的弹幕
- 播放过程中，每5秒预加载接下来的弹幕（分页加载）
- 避免一次性加载全部弹幕（长视频可能有数百万条）

#### 3.5 敏感词过滤

**实时过滤**：发送时过滤（同步）+ 审核后过滤（异步）

**DFA算法（确定有限状态自动机）**：
- 将敏感词库构建成Trie树（字典树）
- 扫描弹幕内容，O(n)时间复杂度完成匹配
- 支持模糊匹配（如"法~轮~功"）

**过滤策略**：
1. **强制过滤**：命中敏感词直接拒绝发送，返回错误提示
2. **替换显示**：将敏感词替换为***，允许发送但脱敏
3. **人工审核**：疑似违规弹幕进入审核队列，人工复查

**敏感词库更新**：
- 使用Redis存储敏感词Trie树序列化数据
- 运营人员添加新敏感词后，推送到所有服务器热更新
- 无需重启服务

#### 3.6 客户端渲染优化

**挑战**：同时展示100+条弹幕时，浏览器性能瓶颈

**Canvas渲染方案**：
- 不使用DOM操作（每条弹幕一个<div>会导致页面卡顿）
- 使用Canvas绘制弹幕，每帧重绘一次
- 性能提升10倍以上

**轨道分配算法**：
- 将屏幕划分为多条轨道（如10条）
- 新弹幕寻找空闲轨道（从上到下扫描）
- 判断碰撞：计算前一条弹幕的位置和速度，避免追尾

**碰撞检测逻辑**：
```
弹幕A已在轨道1上移动：
- 位置：x = 800px
- 速度：v = 100px/s
- 宽度：w = 150px

新弹幕B想进入轨道1：
- 速度：v' = 120px/s（更快）

判断是否会追尾：
如果 (屏幕宽度 - x) / (v' - v) < 弹幕A完全消失时间
  → 会追尾，换下一个轨道
```

**对象池技术**：
- 预创建1000个弹幕对象，循环复用
- 避免频繁new对象导致垃圾回收（GC）卡顿

**弹幕密度控制**：
- 允许用户自定义弹幕显示密度（无限制/适中/稀疏）
- 稀疏模式：只显示50%的弹幕

### 四、高级功能设计

#### 4.1 弹幕点赞与互动

**点赞弹幕**：
- 用户点击弹幕可点赞
- 使用Redis Sorted Set存储点赞数：
  ```
  ZADD danmaku:like:{video_id} {like_count} {danmaku_id}
  ```
- 高赞弹幕高亮显示（如变成金色）

**弹幕屏蔽**：
- 用户可屏蔽某个用户的所有弹幕
- 屏蔽列表存储在用户本地或后端
- 客户端过滤：收到弹幕后，检查发送者是否在屏蔽列表

#### 4.2 弹幕举报与审核

**举报流程**：
1. 用户举报违规弹幕 → 写入举报表
2. 同一弹幕被举报超过10次 → 自动隐藏
3. 进入人工审核队列
4. 审核通过则恢复，否则永久删除并封禁用户

**AI辅助审核**：
- 使用NLP模型识别辱骂、暴力、政治敏感内容
- 高危弹幕直接拒绝，中危进入人工审核

#### 4.3 弹幕礼物与特效

**高级弹幕（会员特权）**：
- 彩色弹幕：支持自定义颜色
- 大字弹幕：字体放大，更醒目
- 特效弹幕：带动画效果（如飘雪、烟花）

**技术实现**：
- 弹幕表增加字段：`font_size`, `effect_type`
- 客户端根据字段渲染不同效果
- 需做好防滥用（如限制特效弹幕频率）

### 五、性能优化与容量规划

#### 性能指标
- **写入TPS**：单机API网关支持1万TPS，通过Kafka削峰到5万TPS
- **推送延迟**：P99 < 500ms（从发送到其他用户收到）
- **查询延迟**：Redis缓存命中率95%，P95 < 50ms

#### 容量规划（以B站为例）
假设某热门视频：
- 时长：30分钟
- 播放量：1000万
- 弹幕总数：500万条
- 存储空间：500万 × 200字节 ≈ 1GB

全站弹幕：
- 日新增弹幕：1亿条
- 存储空间：1亿 × 200字节 ≈ 20GB/天 ≈ 7TB/年

**成本优化**：
- 冷数据（发布超过1年的弹幕）归档到对象存储（OSS）
- 删除被封禁用户的弹幕
- 压缩存储：使用gzip压缩弹幕JSON

### 六、容灾与监控

**高可用设计**：
1. **服务无状态化**：WebSocket网关可任意扩容
2. **Redis主从 + 哨兵**：缓存高可用
3. **Kafka集群**：多副本保证消息不丢失
4. **数据库读写分离**：主库写入，从库查询

**降级策略**：
- 流量过载时，关闭弹幕推送（用户仍可发送，但不实时推送）
- 只展示历史弹幕，暂停实时弹幕
- 限制非会员用户发送弹幕

**监控指标**：
- 弹幕发送成功率、失败率
- WebSocket连接数、断线率
- Kafka消息积压量
- 缓存命中率
- 敏感词拦截率

### 七、总结

设计一个高性能弹幕系统，核心在于：

1. **读写分离**：消息队列异步写入，WebSocket实时推送
2. **多级缓存**：Redis缓存热点弹幕，减少数据库压力
3. **削峰填谷**：Kafka缓冲突发流量，批量写入数据库
4. **客户端优化**：Canvas渲染 + 轨道分配算法，保证流畅体验
5. **内容安全**：DFA敏感词过滤 + AI审核 + 人工复查

技术选型总结：
- **推送**：WebSocket（实时性）+ Redis Pub/Sub（房间广播）
- **存储**：MySQL（元数据）+ HBase/ES（海量弹幕）
- **缓存**：Redis（热点数据）+ 布隆过滤器（缓存穿透保护）
- **消息队列**：Kafka（削峰）+ 批量消费（提升写入性能）

弹幕系统看似简单，实则涉及高并发、实时通信、海量存储、内容审核等多个技术难点，是对分布式系统设计能力的全面考验。
