---
title: 设计一个支付系统（保证一致性）
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-payment-system-consistency
ref:
---

## 核心要点

**关键挑战**: 分布式事务一致性、幂等性、资金安全、对账机制
**核心方案**: 状态机 + 异步补偿 + 定时对账 + 分布式锁
**技术选型**: 数据库事务 + MQ + Redis + 定时任务
**性能指标**: 99.99% 可用性、秒级处理、零资金差错

---

## 详细回答

### 一、业务场景分析

支付系统是交易系统的核心,需要处理:
- **用户支付**: 用户向商户付款(微信支付、支付宝、银行卡等)
- **商户结算**: 定期将资金结算给商户
- **退款处理**: 处理退款请求
- **资金对账**: 与第三方支付平台对账

**核心挑战**:
1. **分布式一致性**: 订单系统、支付系统、账户系统、第三方支付平台多方数据一致
2. **幂等性**: 网络重试、用户重复点击不能导致重复扣款
3. **资金安全**: 绝对不能出现资金丢失或多扣的情况
4. **高可用性**: 支付是核心流程,不能因为系统故障影响交易

### 二、架构设计

#### 2.1 整体架构

```
┌──────────────┐
│   用户客户端   │
└──────┬───────┘
       │
       ↓
┌──────────────────────────────────────────┐
│            API Gateway / BFF              │
└──────┬───────────────────────────────────┘
       │
       ↓
┌──────────────────────────────────────────┐
│           支付服务(Payment Service)        │
│  ┌────────────┐  ┌──────────────┐        │
│  │ 订单模块    │  │  支付路由    │        │
│  └────────────┘  └──────────────┘        │
│  ┌────────────┐  ┌──────────────┐        │
│  │ 状态机管理  │  │  回调处理    │        │
│  └────────────┘  └──────────────┘        │
└──────┬──────────────────┬────────────────┘
       │                  │
       ↓                  ↓
┌─────────────┐    ┌─────────────┐
│ 账户服务     │    │  订单服务    │
└─────────────┘    └─────────────┘
       │                  │
       ↓                  ↓
┌─────────────────────────────────┐
│   第三方支付渠道(支付宝/微信)      │
└─────────────────────────────────┘
       │
       ↓
┌─────────────────────────────────┐
│   对账与补偿服务                  │
└─────────────────────────────────┘
```

#### 2.2 核心模块

**1. 支付订单模块**
- 创建支付订单
- 订单状态管理
- 订单查询与取消

**2. 支付路由模块**
- 根据支付方式路由到不同渠道(支付宝、微信、银行卡)
- 渠道降级与切换
- 支付参数构建

**3. 回调处理模块**
- 接收第三方支付回调
- 验签与幂等校验
- 状态更新与通知

**4. 对账模块**
- 定时拉取第三方对账文件
- 比对本地订单与第三方订单
- 差异处理与告警

**5. 补偿模块**
- 处理长时间未支付成功的订单
- 主动查询第三方订单状态
- 异常订单人工介入

### 三、核心技术方案

#### 3.1 分布式一致性保证

**问题**: 支付涉及多个系统(订单系统、账户系统、第三方支付),如何保证一致性?

**方案: 状态机 + 异步补偿(最终一致性)**

```
支付订单状态流转:

待支付(PENDING)
    ↓
支付中(PAYING) ← [调用第三方支付]
    ↓
支付成功(SUCCESS) / 支付失败(FAILED) / 超时(TIMEOUT)
    ↓
已完成(COMPLETED) / 已退款(REFUNDED)
```

**具体流程**:

```
1. 创建支付订单(状态: PENDING)
   - 在本地数据库创建订单记录
   - 记录订单号、金额、用户ID、商户ID等
   - 状态: PENDING

2. 调用第三方支付(状态: PAYING)
   - 更新订单状态为 PAYING
   - 调用支付宝/微信支付接口
   - 获取支付跳转URL或二维码

3. 用户完成支付
   - 用户在第三方平台完成支付
   - 第三方平台回调我们的系统

4. 处理支付回调(状态: SUCCESS/FAILED)
   - 验证签名防篡改
   - 幂等性校验(避免重复处理)
   - 更新订单状态
   - 发送MQ通知订单系统
   - 返回成功给第三方

5. 异步补偿机制
   - 定时任务扫描 PAYING 状态超过10分钟的订单
   - 主动调用第三方查询接口
   - 根据查询结果更新订单状态
```

**代码示例(Go语言)**:

```go
// 支付订单结构
type PaymentOrder struct {
    OrderNo       string    // 订单号(唯一标识)
    TradeNo       string    // 第三方交易号
    Amount        int64     // 金额(分)
    UserID        int64     // 用户ID
    MerchantID    int64     // 商户ID
    Channel       string    // 支付渠道(alipay/wechat)
    Status        string    // 订单状态
    CreatedAt     time.Time
    UpdatedAt     time.Time
    CallbackCount int       // 回调次数(防重复)
}

// 创建支付订单
func CreatePaymentOrder(ctx context.Context, req *CreateOrderReq) (*PaymentOrder, error) {
    // 1. 生成全局唯一订单号
    orderNo := generateOrderNo()

    // 2. 创建订单记录(状态: PENDING)
    order := &PaymentOrder{
        OrderNo:    orderNo,
        Amount:     req.Amount,
        UserID:     req.UserID,
        MerchantID: req.MerchantID,
        Channel:    req.Channel,
        Status:     "PENDING",
        CreatedAt:  time.Now(),
    }

    // 3. 数据库事务插入
    err := db.Transaction(func(tx *gorm.DB) error {
        return tx.Create(order).Error
    })

    if err != nil {
        return nil, err
    }

    // 4. 异步调用支付渠道(状态变更为 PAYING)
    go callPaymentChannel(ctx, order)

    return order, nil
}

// 处理支付回调
func HandlePaymentCallback(ctx context.Context, req *CallbackReq) error {
    // 1. 验证签名
    if !verifySign(req) {
        return errors.New("invalid signature")
    }

    // 2. 幂等性校验 - 使用分布式锁
    lockKey := fmt.Sprintf("payment:callback:%s", req.OrderNo)
    lock := redis.NewLock(lockKey, 30*time.Second)

    if !lock.TryLock() {
        return errors.New("duplicate callback")
    }
    defer lock.Unlock()

    // 3. 查询订单
    order, err := dao.GetPaymentOrder(req.OrderNo)
    if err != nil {
        return err
    }

    // 4. 状态校验(只有 PAYING 状态才能变更为 SUCCESS)
    if order.Status != "PAYING" {
        log.Warnf("order %s status is %s, ignore callback", req.OrderNo, order.Status)
        return nil // 返回成功,避免第三方重复回调
    }

    // 5. 更新订单状态
    err = db.Transaction(func(tx *gorm.DB) error {
        // 更新订单状态
        updates := map[string]interface{}{
            "status":         req.Status, // SUCCESS/FAILED
            "trade_no":       req.TradeNo,
            "callback_count": gorm.Expr("callback_count + 1"),
            "updated_at":     time.Now(),
        }

        if err := tx.Model(&PaymentOrder{}).
            Where("order_no = ? AND status = ?", req.OrderNo, "PAYING").
            Updates(updates).Error; err != nil {
            return err
        }

        return nil
    })

    if err != nil {
        return err
    }

    // 6. 发送MQ通知业务系统
    event := &PaymentSuccessEvent{
        OrderNo:    req.OrderNo,
        Amount:     order.Amount,
        UserID:     order.UserID,
        MerchantID: order.MerchantID,
    }
    mq.Publish("payment.success", event)

    return nil
}

// 补偿任务 - 处理超时订单
func CompensateTimeoutOrders(ctx context.Context) {
    // 1. 查询 PAYING 状态超过10分钟的订单
    orders, err := dao.GetTimeoutOrders("PAYING", 10*time.Minute)
    if err != nil {
        log.Errorf("get timeout orders failed: %v", err)
        return
    }

    for _, order := range orders {
        // 2. 主动查询第三方订单状态
        status, err := queryThirdPartyOrderStatus(order.Channel, order.OrderNo)
        if err != nil {
            log.Errorf("query third party order %s failed: %v", order.OrderNo, err)
            continue
        }

        // 3. 根据查询结果更新状态
        if status == "SUCCESS" {
            // 模拟回调处理
            HandlePaymentCallback(ctx, &CallbackReq{
                OrderNo: order.OrderNo,
                Status:  "SUCCESS",
                TradeNo: order.TradeNo,
            })
        } else if status == "FAILED" {
            updateOrderStatus(order.OrderNo, "FAILED")
        }
    }
}
```

#### 3.2 幂等性保证

**问题**: 网络重试、用户重复点击、第三方重复回调,如何避免重复扣款?

**方案: 多层防护**

**1. 前端防重复提交**
```javascript
// 按钮禁用 + loading
const handlePay = async () => {
    if (paying) return; // 防止重复点击
    setPaying(true);

    try {
        await payAPI();
    } finally {
        setPaying(false);
    }
}
```

**2. 接口层幂等性 - 使用全局唯一请求ID**
```go
func CreatePaymentOrder(ctx context.Context, req *CreateOrderReq) (*PaymentOrder, error) {
    // 1. 检查请求ID是否已处理
    requestID := req.RequestID // 客户端生成的唯一ID

    if redis.Exists(fmt.Sprintf("payment:request:%s", requestID)) {
        // 返回已有结果
        return getOrderByRequestID(requestID)
    }

    // 2. 设置请求ID(TTL 24小时)
    redis.SetNX(fmt.Sprintf("payment:request:%s", requestID), "1", 24*time.Hour)

    // 3. 创建订单...
}
```

**3. 回调处理幂等性 - 使用分布式锁 + 状态机**
```go
// 见上面的 HandlePaymentCallback 代码
// 使用 Redis 分布式锁 + 状态校验
```

**4. 数据库层幂等性 - 唯一索引**
```sql
CREATE TABLE payment_order (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(64) NOT NULL UNIQUE, -- 唯一索引
    trade_no VARCHAR(64) DEFAULT NULL,
    -- ...
    UNIQUE KEY uk_order_no (order_no)
);
```

#### 3.3 资金安全保证

**1. 金额校验**
```go
// 回调时校验金额是否一致
if req.Amount != order.Amount {
    log.Errorf("amount mismatch: expect %d, got %d", order.Amount, req.Amount)
    return errors.New("amount mismatch")
}
```

**2. 签名验证**
```go
// 使用第三方提供的公钥验证签名
func verifySign(req *CallbackReq) bool {
    publicKey := getPublicKey(req.Channel)
    return crypto.VerifySign(publicKey, req.Data, req.Sign)
}
```

**3. HTTPS加密传输**
- 所有支付接口必须使用HTTPS
- 敏感信息加密存储

**4. 定时对账**
```go
// 每天凌晨拉取第三方对账文件
func ReconcileDaily(date string) {
    // 1. 下载对账文件
    file := downloadReconcileFile(date)

    // 2. 解析对账文件
    thirdPartyOrders := parseReconcileFile(file)

    // 3. 比对本地订单
    localOrders := dao.GetOrdersByDate(date)

    // 4. 找出差异
    diff := compareOrders(localOrders, thirdPartyOrders)

    // 5. 处理差异
    for _, d := range diff {
        if d.Type == "本地有,第三方无" {
            // 可能是支付失败但本地记录为成功
            alert("订单差异", d)
        } else if d.Type == "第三方有,本地无" {
            // 可能是回调丢失
            补偿处理(d)
        } else if d.Type == "金额不一致" {
            // 严重问题,立即告警
            criticalAlert("金额不一致", d)
        }
    }
}
```

#### 3.4 高可用保证

**1. 服务多实例部署**
```yaml
# Kubernetes 部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-service
spec:
  replicas: 3  # 至少3个实例
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
```

**2. 数据库主从 + 读写分离**
```
主库(Master) → 从库1(Slave1)
             → 从库2(Slave2)

写操作 → 主库
读操作 → 从库(负载均衡)
```

**3. 缓存降级**
```go
// 订单查询优先走缓存
func GetOrder(orderNo string) (*PaymentOrder, error) {
    // 1. 尝试从Redis获取
    order, err := cache.Get(orderNo)
    if err == nil {
        return order, nil
    }

    // 2. 从数据库查询
    order, err = dao.GetOrder(orderNo)
    if err != nil {
        return nil, err
    }

    // 3. 写入缓存
    cache.Set(orderNo, order, 5*time.Minute)

    return order, nil
}
```

**4. 限流保护**
```go
// 使用令牌桶算法限流
limiter := rate.NewLimiter(1000, 2000) // 每秒1000个请求,桶容量2000

func CreateOrder(ctx context.Context, req *CreateOrderReq) {
    if !limiter.Allow() {
        return errors.New("too many requests")
    }
    // ...
}
```

### 四、数据库设计

```sql
-- 支付订单表
CREATE TABLE payment_order (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(64) NOT NULL UNIQUE COMMENT '订单号',
    trade_no VARCHAR(64) DEFAULT NULL COMMENT '第三方交易号',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    merchant_id BIGINT NOT NULL COMMENT '商户ID',
    amount BIGINT NOT NULL COMMENT '金额(分)',
    channel VARCHAR(32) NOT NULL COMMENT '支付渠道',
    status VARCHAR(32) NOT NULL COMMENT '订单状态',
    callback_count INT DEFAULT 0 COMMENT '回调次数',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_status_created (status, created_at),
    UNIQUE KEY uk_order_no (order_no)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='支付订单表';

-- 支付流水表(记录所有状态变更)
CREATE TABLE payment_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(64) NOT NULL,
    from_status VARCHAR(32) NOT NULL COMMENT '原状态',
    to_status VARCHAR(32) NOT NULL COMMENT '新状态',
    remark TEXT COMMENT '备注',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_order_no (order_no)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='支付流水表';

-- 对账差异表
CREATE TABLE reconcile_diff (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(64) NOT NULL,
    diff_type VARCHAR(32) NOT NULL COMMENT '差异类型',
    local_amount BIGINT COMMENT '本地金额',
    third_party_amount BIGINT COMMENT '第三方金额',
    status VARCHAR(32) NOT NULL COMMENT '处理状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='对账差异表';
```

### 五、关键问题与优化

#### 5.1 如何处理回调丢失?

**问题**: 用户支付成功,但第三方回调因网络问题未到达,导致订单一直是 PAYING 状态

**方案**:
1. **定时补偿任务**: 每5分钟扫描 PAYING 状态超过10分钟的订单,主动查询第三方状态
2. **用户主动查询**: 提供查询接口,用户可以主动触发状态同步
3. **MQ重试机制**: 第三方回调通过MQ异步处理,失败自动重试

#### 5.2 如何处理重复回调?

**方案**: 多层防护
- 分布式锁(Redis): 同一时刻只有一个线程处理回调
- 状态机校验: 只有 PAYING 状态才能变更为 SUCCESS
- 回调计数器: 记录回调次数,超过3次告警

#### 5.3 如何提升性能?

**优化点**:
1. **异步处理**: 回调通过MQ异步处理,立即返回成功
2. **缓存优化**: 订单查询走Redis缓存
3. **数据库索引**: 为 order_no、status、created_at 建立索引
4. **连接池**: 数据库连接池、Redis连接池
5. **批量处理**: 对账任务批量查询、批量更新

#### 5.4 如何监控告警?

**监控指标**:
- 订单创建量、成功率、失败率
- 回调处理耗时、回调失败次数
- PAYING 状态超时订单数量
- 对账差异数量

**告警规则**:
- 支付成功率低于99% → 告警
- PAYING 状态订单超过1000笔 → 告警
- 对账差异超过10笔 → 告警
- 金额不一致 → 紧急告警

### 六、总结

**核心设计要点**:
1. **状态机 + 异步补偿**: 保证最终一致性
2. **幂等性多层防护**: 前端 + 接口 + 回调 + 数据库
3. **定时对账**: 与第三方每日对账,发现并修复差异
4. **分布式锁**: 防止并发问题
5. **高可用架构**: 多实例、主从、缓存、限流

**面试加分项**:
- 能画出清晰的状态流转图
- 能说出幂等性的多种实现方式
- 能设计完整的对账流程
- 能识别并发场景下的边界问题
- 能提出监控告警方案

**实际案例**:
支付宝、微信支付都采用类似架构,核心是"异步回调 + 主动查询 + 定时对账"三重保障,确保资金安全和数据一致性。
