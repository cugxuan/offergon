---
title: 设计一个库存系统（防止超卖）
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-inventory-system-prevent-overselling
ref:
---

## 核心要点

**关键挑战**: 高并发扣减、超卖防止、数据一致性、性能优化
**核心方案**: 数据库行锁 + Redis预扣减 + 消息队列削峰 + 分布式锁
**技术选型**: MySQL + Redis + MQ + Lua脚本
**性能指标**: 支持万级QPS、零超卖、秒级响应

---

## 详细回答

### 一、业务场景分析

库存系统是电商的核心,特别是在秒杀、限量商品等高并发场景下,必须保证:
- **不能超卖**: 库存100件,只能卖出100件,不能卖101件
- **不能少卖**: 有库存时不能因为系统问题导致用户购买失败
- **高并发**: 秒杀场景下,可能有10万人同时抢购100件商品
- **高可用**: 系统不能因为库存服务挂掉而影响整个业务

**典型场景**:
1. **秒杀活动**: iPhone新品首发,10万人抢1000台
2. **限量商品**: 演唱会门票,10万人抢1万张
3. **日常下单**: 普通商品的库存扣减
4. **预售活动**: 预扣库存,支付后真正扣减

### 二、超卖问题分析

#### 2.1 什么是超卖?

**超卖**: 实际售出数量超过库存数量

```
库存: 100件
线程A: 查询库存 = 100, 扣减1 → 剩余99
线程B: 查询库存 = 100, 扣减1 → 剩余99  (此时已超卖!)
```

#### 2.2 超卖产生的原因

**1. 查询和更新不是原子操作**
```go
// 错误示例
stock := getStock(productID)  // 查询库存
if stock > 0 {
    updateStock(productID, stock-1)  // 更新库存
}
// 两个线程都查到stock=1,都执行了扣减
```

**2. 没有并发控制**
```sql
-- 错误示例
SELECT stock FROM product WHERE id = 1;  -- stock = 100
-- [并发场景下,多个线程都执行到这里]
UPDATE product SET stock = stock - 1 WHERE id = 1;
```

**3. 缓存与数据库不一致**
```
Redis: stock = 100
DB: stock = 99
用户基于Redis判断有库存,但DB已经没有
```

### 三、解决方案

#### 3.1 方案一: 数据库悲观锁 (低并发)

**原理**: 使用数据库的 `SELECT ... FOR UPDATE` 行锁

**优点**: 简单可靠,强一致性
**缺点**: 性能差,只适合低并发场景(QPS < 100)

**实现代码**:

```go
// 扣减库存 - 悲观锁
func DeductStockWithPessimisticLock(productID int64, quantity int) error {
    // 开启数据库事务
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. 查询并加行锁 (SELECT ... FOR UPDATE)
    var stock int
    err = tx.QueryRow(
        "SELECT stock FROM product WHERE id = ? FOR UPDATE",
        productID,
    ).Scan(&stock)

    if err != nil {
        return err
    }

    // 2. 判断库存是否充足
    if stock < quantity {
        return errors.New("库存不足")
    }

    // 3. 扣减库存
    _, err = tx.Exec(
        "UPDATE product SET stock = stock - ? WHERE id = ?",
        quantity, productID,
    )

    if err != nil {
        return err
    }

    // 4. 提交事务
    return tx.Commit()
}
```

**优化点**:
- 事务要尽可能短,避免长时间占用锁
- 只锁需要的行,不要锁整张表

#### 3.2 方案二: 数据库乐观锁 (中并发)

**原理**: 使用版本号或CAS(Compare And Swap)

**优点**: 性能优于悲观锁,适合中等并发(QPS < 1000)
**缺点**: 可能需要重试,用户体验不好

**实现代码**:

```go
// 扣减库存 - 乐观锁(基于版本号)
func DeductStockWithOptimisticLock(productID int64, quantity int) error {
    maxRetry := 3  // 最多重试3次

    for i := 0; i < maxRetry; i++ {
        // 1. 查询当前库存和版本号
        var stock, version int
        err := db.QueryRow(
            "SELECT stock, version FROM product WHERE id = ?",
            productID,
        ).Scan(&stock, &version)

        if err != nil {
            return err
        }

        // 2. 判断库存是否充足
        if stock < quantity {
            return errors.New("库存不足")
        }

        // 3. 更新库存(携带版本号条件)
        result, err := db.Exec(
            "UPDATE product SET stock = stock - ?, version = version + 1 WHERE id = ? AND version = ?",
            quantity, productID, version,
        )

        if err != nil {
            return err
        }

        // 4. 检查是否更新成功
        affected, _ := result.RowsAffected()
        if affected > 0 {
            return nil  // 成功
        }

        // 5. 版本号不匹配,重试
        time.Sleep(time.Millisecond * 10)
    }

    return errors.New("扣减库存失败,请重试")
}
```

**更简单的CAS方式(不需要version字段)**:

```go
// 扣减库存 - CAS方式
func DeductStockWithCAS(productID int64, quantity int) error {
    maxRetry := 3

    for i := 0; i < maxRetry; i++ {
        // 1. 查询当前库存
        var stock int
        err := db.QueryRow(
            "SELECT stock FROM product WHERE id = ?",
            productID,
        ).Scan(&stock)

        if err != nil {
            return err
        }

        // 2. 判断库存是否充足
        if stock < quantity {
            return errors.New("库存不足")
        }

        // 3. CAS更新(只有stock值没变才更新)
        result, err := db.Exec(
            "UPDATE product SET stock = stock - ? WHERE id = ? AND stock = ?",
            quantity, productID, stock,
        )

        if err != nil {
            return err
        }

        // 4. 检查是否更新成功
        affected, _ := result.RowsAffected()
        if affected > 0 {
            return nil  // 成功
        }

        // 5. stock值已被其他线程修改,重试
        time.Sleep(time.Millisecond * 10)
    }

    return errors.New("扣减库存失败,请重试")
}
```

#### 3.3 方案三: Redis预扣减 + 异步入库 (高并发推荐)

**原理**:
1. 将库存预加载到Redis
2. 使用Redis的原子操作扣减库存
3. 异步将扣减记录写入数据库

**优点**:
- 性能极高(QPS > 10万)
- 天然防超卖(Redis单线程)
- 适合秒杀场景

**缺点**:
- 需要处理Redis与DB的一致性
- 需要考虑Redis故障恢复

**架构图**:

```
用户请求
   ↓
API服务
   ↓
Redis扣减(Lua原子操作)
   ↓ (成功)
发送MQ消息
   ↓
异步消费者
   ↓
写入数据库
```

**实现代码**:

```go
// Lua脚本 - 保证原子性
const deductStockScript = `
local key = KEYS[1]
local quantity = tonumber(ARGV[1])

-- 获取当前库存
local stock = tonumber(redis.call('GET', key))

if not stock then
    return -1  -- 库存不存在
end

if stock < quantity then
    return -2  -- 库存不足
end

-- 扣减库存
local newStock = stock - quantity
redis.call('SET', key, newStock)

return newStock  -- 返回剩余库存
`

// 扣减库存 - Redis预扣减
func DeductStockWithRedis(ctx context.Context, productID int64, quantity int) error {
    // 1. 构造Redis key
    stockKey := fmt.Sprintf("stock:%d", productID)

    // 2. 执行Lua脚本原子扣减
    result, err := redis.Eval(ctx, deductStockScript, []string{stockKey}, quantity).Int()

    if err != nil {
        return err
    }

    // 3. 判断结果
    if result == -1 {
        return errors.New("商品不存在")
    }

    if result == -2 {
        return errors.New("库存不足")
    }

    // 4. 扣减成功,发送MQ异步入库
    event := &StockDeductEvent{
        ProductID: productID,
        Quantity:  quantity,
        UserID:    getUserID(ctx),
        OrderNo:   generateOrderNo(),
        Timestamp: time.Now(),
    }

    mq.Publish("stock.deduct", event)

    return nil
}

// MQ消费者 - 异步写入数据库
func ConsumeStockDeductEvent(event *StockDeductEvent) {
    // 1. 写入数据库
    err := db.Exec(
        "UPDATE product SET stock = stock - ? WHERE id = ?",
        event.Quantity, event.ProductID,
    )

    if err != nil {
        log.Errorf("写入数据库失败: %v", err)
        // 补偿: 恢复Redis库存
        stockKey := fmt.Sprintf("stock:%d", event.ProductID)
        redis.IncrBy(ctx, stockKey, event.Quantity)
        return
    }

    // 2. 创建订单记录
    createOrder(event)
}

// 初始化库存 - 从DB加载到Redis
func InitStock(productID int64) error {
    // 1. 从数据库查询库存
    var stock int
    err := db.QueryRow(
        "SELECT stock FROM product WHERE id = ?",
        productID,
    ).Scan(&stock)

    if err != nil {
        return err
    }

    // 2. 写入Redis
    stockKey := fmt.Sprintf("stock:%d", productID)
    return redis.Set(ctx, stockKey, stock, 0).Err()
}
```

**Redis与DB一致性保证**:

```go
// 定时对账 - 确保Redis与DB一致
func ReconcileStock(productID int64) {
    // 1. 查询Redis库存
    stockKey := fmt.Sprintf("stock:%d", productID)
    redisStock, _ := redis.Get(ctx, stockKey).Int()

    // 2. 查询DB库存
    var dbStock int
    db.QueryRow("SELECT stock FROM product WHERE id = ?", productID).Scan(&dbStock)

    // 3. 比对差异
    if redisStock != dbStock {
        log.Warnf("库存不一致: Redis=%d, DB=%d", redisStock, dbStock)

        // 以DB为准,修正Redis
        redis.Set(ctx, stockKey, dbStock, 0)

        // 告警
        alert("库存不一致", productID, redisStock, dbStock)
    }
}
```

#### 3.4 方案四: 消息队列削峰 (超高并发)

**原理**: 请求先入队,异步串行处理

**优点**:
- 平滑高峰流量
- 保护数据库
- 适合秒杀场景

**缺点**:
- 响应不是实时的
- 用户需要等待结果

**架构图**:

```
10万用户并发请求
   ↓
写入MQ队列
   ↓
消费者串行处理(100 QPS)
   ↓
扣减库存
   ↓
通知用户结果(WebSocket/长轮询)
```

**实现代码**:

```go
// 提交抢购请求
func SubmitPurchaseRequest(ctx context.Context, productID int64, userID int64) (string, error) {
    // 1. 生成请求ID
    requestID := generateRequestID()

    // 2. 写入MQ
    event := &PurchaseRequest{
        RequestID: requestID,
        ProductID: productID,
        UserID:    userID,
        Timestamp: time.Now(),
    }

    err := mq.Publish("purchase.request", event)
    if err != nil {
        return "", err
    }

    // 3. 返回请求ID(用户可轮询结果)
    return requestID, nil
}

// MQ消费者 - 串行处理
func ConsumePurchaseRequest(event *PurchaseRequest) {
    // 1. 扣减库存
    err := DeductStockWithRedis(ctx, event.ProductID, 1)

    // 2. 记录结果到Redis
    resultKey := fmt.Sprintf("purchase:result:%s", event.RequestID)

    if err != nil {
        // 失败
        redis.Set(ctx, resultKey, "FAILED:"+err.Error(), 5*time.Minute)

        // 通知用户
        notifyUser(event.UserID, "抢购失败", err.Error())
    } else {
        // 成功
        redis.Set(ctx, resultKey, "SUCCESS", 5*time.Minute)

        // 创建订单
        createOrder(event)

        // 通知用户
        notifyUser(event.UserID, "抢购成功", "")
    }
}

// 查询抢购结果
func QueryPurchaseResult(requestID string) (string, error) {
    resultKey := fmt.Sprintf("purchase:result:%s", requestID)
    result, err := redis.Get(ctx, resultKey).Result()

    if err == redis.Nil {
        return "PENDING", nil  // 还在处理中
    }

    if err != nil {
        return "", err
    }

    return result, nil
}
```

### 四、数据库设计

```sql
-- 商品表
CREATE TABLE product (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL COMMENT '商品名称',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存数量',
    version INT NOT NULL DEFAULT 0 COMMENT '版本号(乐观锁)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_stock (stock)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品表';

-- 库存流水表(记录每次扣减)
CREATE TABLE stock_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL COMMENT '商品ID',
    quantity INT NOT NULL COMMENT '扣减数量',
    before_stock INT NOT NULL COMMENT '扣减前库存',
    after_stock INT NOT NULL COMMENT '扣减后库存',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    order_no VARCHAR(64) NOT NULL COMMENT '订单号',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_product_id (product_id),
    INDEX idx_order_no (order_no)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='库存流水表';

-- 订单表
CREATE TABLE `order` (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(64) NOT NULL UNIQUE COMMENT '订单号',
    product_id BIGINT NOT NULL COMMENT '商品ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    quantity INT NOT NULL COMMENT '购买数量',
    status VARCHAR(32) NOT NULL COMMENT '订单状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    UNIQUE KEY uk_order_no (order_no)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单表';
```

### 五、关键问题与优化

#### 5.1 如何处理Redis宕机?

**问题**: Redis突然宕机,库存数据丢失

**方案**:
1. **Redis持久化**: 开启AOF持久化,最多丢失1秒数据
2. **Redis主从**: 主节点宕机,从节点自动切换
3. **降级到数据库**: Redis不可用时,降级到数据库乐观锁方案

```go
func DeductStock(productID int64, quantity int) error {
    // 优先使用Redis
    err := DeductStockWithRedis(productID, quantity)

    if err != nil && isRedisUnavailable(err) {
        // Redis不可用,降级到数据库
        log.Warn("Redis不可用,降级到数据库")
        return DeductStockWithOptimisticLock(productID, quantity)
    }

    return err
}
```

#### 5.2 如何处理缓存击穿?

**问题**: 秒杀开始瞬间,10万请求同时打到数据库

**方案**:
1. **提前预热**: 秒杀开始前,将库存加载到Redis
2. **互斥锁**: 缓存失效时,只有一个线程查询数据库

```go
func InitStockWithMutex(productID int64) error {
    stockKey := fmt.Sprintf("stock:%d", productID)

    // 1. 尝试从Redis获取
    stock, err := redis.Get(ctx, stockKey).Int()
    if err == nil {
        return nil  // 缓存存在
    }

    // 2. 缓存不存在,加分布式锁
    lockKey := fmt.Sprintf("lock:stock:%d", productID)
    lock := redis.SetNX(ctx, lockKey, 1, 10*time.Second)

    if !lock.Val() {
        // 其他线程正在加载,等待
        time.Sleep(100 * time.Millisecond)
        return InitStockWithMutex(productID)  // 递归重试
    }

    defer redis.Del(ctx, lockKey)

    // 3. 从数据库加载
    db.QueryRow("SELECT stock FROM product WHERE id = ?", productID).Scan(&stock)

    // 4. 写入Redis
    redis.Set(ctx, stockKey, stock, 1*time.Hour)

    return nil
}
```

#### 5.3 如何防止恶意刷单?

**方案**:
1. **限流**: 每个用户每秒最多请求1次
2. **验证码**: 秒杀前需要输入验证码
3. **风控**: 检测异常IP、异常设备

```go
// 限流中间件
func RateLimitMiddleware(userID int64) error {
    key := fmt.Sprintf("ratelimit:%d", userID)

    // 使用Redis INCR + EXPIRE实现限流
    count, err := redis.Incr(ctx, key).Result()
    if err != nil {
        return err
    }

    if count == 1 {
        redis.Expire(ctx, key, 1*time.Second)
    }

    if count > 10 {  // 每秒最多10次请求
        return errors.New("请求过于频繁")
    }

    return nil
}
```

#### 5.4 如何防止超时订单占用库存?

**问题**: 用户下单后不支付,库存被长时间占用

**方案**: 订单超时自动取消,释放库存

```go
// 创建订单时设置延迟任务
func CreateOrder(productID int64, userID int64) error {
    // 1. 扣减库存
    DeductStock(productID, 1)

    // 2. 创建订单
    orderNo := generateOrderNo()
    createOrderRecord(orderNo, productID, userID)

    // 3. 发送延迟消息(15分钟后执行)
    delayMsg := &OrderTimeoutCheck{
        OrderNo: orderNo,
    }
    mq.PublishDelay("order.timeout", delayMsg, 15*time.Minute)

    return nil
}

// 消费延迟消息
func ConsumeOrderTimeout(msg *OrderTimeoutCheck) {
    // 1. 查询订单状态
    order := dao.GetOrder(msg.OrderNo)

    // 2. 如果还是未支付,取消订单并恢复库存
    if order.Status == "UNPAID" {
        // 取消订单
        dao.UpdateOrderStatus(msg.OrderNo, "CANCELLED")

        // 恢复库存
        RestoreStock(order.ProductID, order.Quantity)
    }
}

// 恢复库存
func RestoreStock(productID int64, quantity int) error {
    // 1. Redis恢复
    stockKey := fmt.Sprintf("stock:%d", productID)
    redis.IncrBy(ctx, stockKey, int64(quantity))

    // 2. DB恢复
    db.Exec("UPDATE product SET stock = stock + ? WHERE id = ?", quantity, productID)

    return nil
}
```

### 六、性能优化

#### 6.1 数据库优化

```sql
-- 1. 为stock字段建立索引
CREATE INDEX idx_stock ON product(stock);

-- 2. 使用LIMIT减少锁范围
SELECT * FROM product WHERE stock > 0 LIMIT 1 FOR UPDATE;

-- 3. 分库分表(商品ID哈希)
-- product_0, product_1, ... product_7
```

#### 6.2 Redis优化

```go
// 1. 使用Pipeline批量操作
pipe := redis.Pipeline()
for _, productID := range productIDs {
    stockKey := fmt.Sprintf("stock:%d", productID)
    pipe.Get(ctx, stockKey)
}
results, _ := pipe.Exec(ctx)

// 2. 使用连接池
redisClient := redis.NewClient(&redis.Options{
    PoolSize: 100,  // 连接池大小
})
```

#### 6.3 应用层优化

```go
// 1. 限流
// 2. 缓存查询结果
// 3. 异步处理非核心逻辑
```

### 七、总结

**核心设计要点**:
1. **低并发场景**: 数据库悲观锁(SELECT FOR UPDATE)
2. **中并发场景**: 数据库乐观锁(CAS/版本号)
3. **高并发场景**: Redis预扣减 + MQ异步入库 (推荐)
4. **超高并发场景**: MQ削峰 + Redis + 限流

**防超卖关键**:
- 使用原子操作(Lua脚本、数据库事务)
- Redis单线程天然串行
- 数据库WHERE条件带上库存判断
- 定时对账Redis与DB

**面试加分项**:
- 能分析不同方案的优缺点和适用场景
- 能说出Redis与DB一致性保证方案
- 能设计完整的秒杀流程
- 能处理边界情况(Redis宕机、订单超时等)
- 能提出性能优化方案

**实际案例**:
淘宝、京东的秒杀系统都采用"Redis预扣减 + MQ异步 + 限流"方案,能支持百万级QPS且零超卖。
