---
title: 设计一个在线游戏匹配系统
tags:
  - 系统设计
status: robot
class: 系统设计
slug: online-game-matchmaking-system-design
ref:
---

## 核心要点提炼

**系统定位**: 支持百万在线玩家的实时匹配系统,提供公平、快速的多人游戏配对

**技术核心**:
- **匹配算法**: 基于ELO/MMR评分的分层匹配,动态扩大匹配范围
- **实时响应**: 低延迟匹配(<5秒),WebSocket实时通知
- **队列管理**: 分层匹配池,优先级队列,防止长时间等待
- **公平性保障**: 技能评分、延迟优化、防作弊机制

**关键指标**: 匹配成功率 >95%、平均匹配时长 <10秒、匹配公平度偏差 <15%

---

## 详细设计方案

### 一、需求分析

#### 1.1 功能需求
- **单排匹配**: 单个玩家匹配其他玩家组队
- **组队匹配**: 预组队伍匹配其他队伍
- **模式选择**: 支持多种游戏模式(竞技、休闲、排位等)
- **区域匹配**: 优先匹配同地区玩家(降低延迟)
- **评分系统**: 基于胜率/技能的MMR(Matchmaking Rating)评分
- **匹配取消**: 玩家可随时取消匹配
- **断线重连**: 匹配成功后掉线可重新加入

#### 1.2 非功能需求
- **低延迟**: P99 匹配时长 < 30 秒
- **高并发**: 支持 50 万+同时匹配用户
- **公平性**: 同队伍平均 MMR 差距 < 15%
- **高可用**: 99.9% 可用性,无单点故障
- **可扩展**: 支持多游戏模式、多区域

#### 1.3 匹配规则示例(以 5v5 竞技游戏为例)
```
基础规则:
- 队伍人数: 每队5人,共10人
- MMR 范围: 初始 ±150 分,每5秒扩大50分,最大±500分
- 延迟限制: 优先 <50ms,最大 <150ms
- 组队限制: 预组队最多3人(防止5人车队碾压)
- 位置分配: 自动分配游戏位置(上/中/下/打野/辅助)
```

---

### 二、核心架构设计

#### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      游戏客户端层                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ 玩家A    │  │ 玩家B    │  │ 玩家C    │  │ 玩家D    │   │
│  │ MMR:1500│  │ MMR:1520│  │ MMR:1480│  │ MMR:1510│   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
│       │             │              │             │          │
│       └─────────────┴──────────────┴─────────────┘          │
│                     │ WebSocket长连接                       │
└─────────────────────┼───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                  匹配网关(Gateway)                           │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  连接管理 | 请求路由 | 状态同步 | 消息推送             │ │
│  └────────────────────┬───────────────────────────────────┘ │
└───────────────────────┼─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│              匹配协调服务(Matchmaking Coordinator)           │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  队列分发 | 房间创建 | 结果通知 | 数据统计             │ │
│  └────────────────────┬───────────────────────────────────┘ │
└───────────────────────┼─────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
┌───────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐
│ 匹配引擎1    │ │ 匹配引擎2   │ │ 匹配引擎N   │
│ (区域:华东)  │ │ (区域:华南) │ │ (区域:美西) │
└──────┬───────┘ └──────┬──────┘ └──────┬─────┘
       │                │               │
       │         ┌──────▼──────┐        │
       │         │ 匹配池       │        │
       └────────>│ (Redis)     │<───────┘
                 │ - 新手池     │
                 │ - 青铜池     │
                 │ - 白银池     │
                 │ - 黄金池     │
                 └──────┬──────┘
                        │
                 ┌──────▼──────┐
                 │ 用户数据库   │
                 │ (MySQL)     │
                 │ - MMR评分   │
                 │ - 匹配历史  │
                 └─────────────┘

┌──────────────────────────────────────────────────────────────┐
│                    游戏服务器集群                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │ 房间1    │  │ 房间2    │  │ 房间3    │  │ 房间N    │    │
│  │ 状态:就绪│  │ 状态:游戏中│ │状态:结束│  │ 状态:空闲│    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└──────────────────────────────────────────────────────────────┘
```

#### 2.2 数据模型设计

##### **1. 玩家信息表**
```sql
CREATE TABLE players (
    player_id BIGINT PRIMARY KEY,
    username VARCHAR(64) NOT NULL,
    mmr INT DEFAULT 1500,           -- 当前MMR评分
    region VARCHAR(32),              -- 所属区域(asia-east, us-west等)
    total_games INT DEFAULT 0,       -- 总场次
    win_games INT DEFAULT 0,         -- 胜场数
    lose_games INT DEFAULT 0,        -- 败场数
    win_rate DECIMAL(5,2) AS (win_games / total_games * 100) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_mmr (mmr),
    INDEX idx_region (region)
) ENGINE=InnoDB;
```

##### **2. 匹配记录表**
```sql
CREATE TABLE match_records (
    match_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    match_uuid VARCHAR(36) UNIQUE NOT NULL,
    game_mode ENUM('ranked','casual','custom') DEFAULT 'ranked',
    region VARCHAR(32),
    avg_mmr INT,                     -- 平均MMR
    status ENUM('matching','ready','playing','finished','cancelled'),
    player_ids JSON,                 -- 参与玩家ID列表
    team_a_ids JSON,                 -- A队玩家ID
    team_b_ids JSON,                 -- B队玩家ID
    team_a_avg_mmr INT,              -- A队平均MMR
    team_b_avg_mmr INT,              -- B队平均MMR
    winner ENUM('team_a','team_b','draw'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    finished_at TIMESTAMP,
    INDEX idx_status_created (status, created_at),
    INDEX idx_player (player_ids(255))  -- JSON字段部分索引
) ENGINE=InnoDB;
```

##### **3. 匹配队列(Redis 数据结构)**
```
数据结构设计:

1. 玩家匹配状态 (Hash)
Key: matchmaking:player:{player_id}
Fields:
  - status: "matching" / "matched" / "cancelled"
  - mmr: 1500
  - region: "asia-east"
  - mode: "ranked"
  - queue_time: 1699999999
  - match_range: 150  (当前匹配范围)

2. 分层匹配池 (Sorted Set - 按MMR排序)
Key: matchmaking:pool:{region}:{mode}:{tier}
Score: MMR 分数
Member: player_id
示例:
  matchmaking:pool:asia-east:ranked:silver
  - 1500: player_123
  - 1520: player_456
  - 1480: player_789

3. 匹配结果通知 (Pub/Sub)
Channel: matchmaking:result:{player_id}
Message: {"match_id": "xxx", "room_id": "xxx", "team": "A"}
```

---

### 三、核心流程实现

#### 3.1 玩家加入匹配流程

```go
// 1. 玩家发起匹配请求
type MatchRequest struct {
    PlayerID   int64  `json:"player_id"`
    GameMode   string `json:"game_mode"`   // ranked/casual
    Region     string `json:"region"`      // asia-east/us-west
    PartyIDs   []int64 `json:"party_ids"`  // 组队玩家ID(空表示单排)
}

// 2. 匹配服务处理
type MatchmakingService struct {
    redis      *redis.Client
    mysql      *sql.DB
    gateway    *GatewayClient
}

func (s *MatchmakingService) JoinMatchmaking(req *MatchRequest) error {
    // 2.1 获取玩家MMR信息
    player, err := s.getPlayerInfo(req.PlayerID)
    if err != nil {
        return err
    }

    // 2.2 校验是否已在匹配中
    if s.isPlayerInMatchmaking(req.PlayerID) {
        return errors.New("player already in matchmaking")
    }

    // 2.3 组队校验
    if len(req.PartyIDs) > 3 {
        return errors.New("party size limit exceeded (max 3)")
    }

    // 2.4 将玩家加入匹配池
    poolKey := fmt.Sprintf("matchmaking:pool:%s:%s:%s",
        req.Region, req.GameMode, s.getTier(player.MMR))

    pipe := s.redis.Pipeline()

    // 加入有序集合(按MMR排序)
    pipe.ZAdd(poolKey, &redis.Z{
        Score:  float64(player.MMR),
        Member: req.PlayerID,
    })

    // 设置玩家匹配状态
    playerKey := fmt.Sprintf("matchmaking:player:%d", req.PlayerID)
    pipe.HMSet(playerKey, map[string]interface{}{
        "status":      "matching",
        "mmr":         player.MMR,
        "region":      req.Region,
        "mode":        req.GameMode,
        "queue_time":  time.Now().Unix(),
        "match_range": 150, // 初始匹配范围 ±150分
    })
    pipe.Expire(playerKey, 10*time.Minute) // 10分钟超时

    _, err = pipe.Exec()
    if err != nil {
        return err
    }

    // 2.5 通知客户端加入成功
    s.gateway.NotifyPlayer(req.PlayerID, "matchmaking_started", nil)

    return nil
}

// MMR 分层函数
func (s *MatchmakingService) getTier(mmr int) string {
    switch {
    case mmr < 1000:
        return "bronze"
    case mmr < 1500:
        return "silver"
    case mmr < 2000:
        return "gold"
    case mmr < 2500:
        return "platinum"
    default:
        return "diamond"
    }
}
```

#### 3.2 匹配引擎核心算法

```go
// 匹配引擎
type MatchingEngine struct {
    redis       *redis.Client
    coordinator *Coordinator
    region      string
    mode        string
}

// 主循环 - 每秒执行一次匹配
func (e *MatchingEngine) Run() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        e.processMatching()
    }
}

func (e *MatchingEngine) processMatching() {
    tiers := []string{"bronze", "silver", "gold", "platinum", "diamond"}

    for _, tier := range tiers {
        poolKey := fmt.Sprintf("matchmaking:pool:%s:%s:%s",
            e.region, e.mode, tier)

        // 获取当前池中所有玩家
        players, err := e.redis.ZRangeWithScores(poolKey, 0, -1).Result()
        if err != nil || len(players) < 10 {
            continue // 不足10人,跳过
        }

        // 尝试匹配
        e.tryMatchPlayers(poolKey, players)
    }
}

// 匹配算法核心
func (e *MatchingEngine) tryMatchPlayers(poolKey string, players []redis.Z) {
    // 1. 按MMR排序(Redis已排序,直接使用)
    // 2. 扩大匹配范围(根据等待时间)
    candidates := e.getEligibleCandidates(players)

    if len(candidates) < 10 {
        return // 候选人不足
    }

    // 3. 贪心算法匹配
    // 目标: 找到10个玩家,使得两队平均MMR最接近
    match := e.greedyMatch(candidates)

    if match != nil {
        // 4. 创建匹配
        e.createMatch(match)

        // 5. 从池中移除已匹配玩家
        e.removePlayersFromPool(poolKey, match.PlayerIDs)
    }
}

// 候选人筛选(考虑等待时间动态扩大范围)
func (e *MatchingEngine) getEligibleCandidates(players []redis.Z) []PlayerCandidate {
    var candidates []PlayerCandidate

    for _, p := range players {
        playerID := p.Member.(string)
        playerKey := fmt.Sprintf("matchmaking:player:%s", playerID)

        // 获取玩家匹配信息
        info, err := e.redis.HGetAll(playerKey).Result()
        if err != nil || info["status"] != "matching" {
            continue
        }

        mmr, _ := strconv.Atoi(info["mmr"])
        queueTime, _ := strconv.ParseInt(info["queue_time"], 10, 64)
        waitTime := time.Now().Unix() - queueTime

        // 动态扩大匹配范围: 每等待5秒,范围扩大50分
        matchRange := 150 + int(waitTime/5)*50
        if matchRange > 500 {
            matchRange = 500 // 最大范围500分
        }

        candidates = append(candidates, PlayerCandidate{
            PlayerID:   playerID,
            MMR:        mmr,
            MatchRange: matchRange,
            WaitTime:   waitTime,
        })
    }

    return candidates
}

// 贪心匹配算法
func (e *MatchingEngine) greedyMatch(candidates []PlayerCandidate) *Match {
    if len(candidates) < 10 {
        return nil
    }

    // 1. 按MMR排序
    sort.Slice(candidates, func(i, j int) bool {
        return candidates[i].MMR < candidates[j].MMR
    })

    // 2. 滑动窗口找到10个玩家,MMR差距在可接受范围内
    for i := 0; i <= len(candidates)-10; i++ {
        window := candidates[i : i+10]

        minMMR := window[0].MMR
        maxMMR := window[9].MMR

        // 检查所有玩家的匹配范围是否覆盖这个区间
        allEligible := true
        avgMMR := 0
        for _, c := range window {
            avgMMR += c.MMR
            if maxMMR-minMMR > c.MatchRange {
                allEligible = false
                break
            }
        }
        avgMMR /= 10

        if allEligible {
            // 3. 分队: 使用"蛇形分配"保证两队平衡
            //    排序: [1,2,3,4,5,6,7,8,9,10]
            //    A队: [1,4,5,8,9]  (奇数位+部分偶数位)
            //    B队: [2,3,6,7,10] (部分奇数位+偶数位)
            teamA, teamB := e.snakeDraft(window)

            return &Match{
                MatchID:     uuid.New().String(),
                PlayerIDs:   e.extractIDs(window),
                TeamA:       teamA,
                TeamB:       teamB,
                AvgMMR:      avgMMR,
                Region:      e.region,
                Mode:        e.mode,
            }
        }
    }

    return nil
}

// 蛇形分配算法
func (e *MatchingEngine) snakeDraft(players []PlayerCandidate) ([]string, []string) {
    // 排序后: MMR从低到高 [P1, P2, P3, P4, P5, P6, P7, P8, P9, P10]
    // 分配顺序: A-B-B-A-A-B-B-A-A-B
    teamA := []string{players[0].PlayerID, players[3].PlayerID, players[4].PlayerID,
                      players[7].PlayerID, players[8].PlayerID}
    teamB := []string{players[1].PlayerID, players[2].PlayerID, players[5].PlayerID,
                      players[6].PlayerID, players[9].PlayerID}

    return teamA, teamB
}

// 创建匹配
func (e *MatchingEngine) createMatch(match *Match) {
    // 1. 申请游戏服务器房间
    roomID, err := e.coordinator.AllocateRoom(match.Region)
    if err != nil {
        log.Errorf("failed to allocate room: %v", err)
        return
    }

    // 2. 更新所有玩家状态
    pipe := e.redis.Pipeline()
    for _, playerID := range match.PlayerIDs {
        playerKey := fmt.Sprintf("matchmaking:player:%s", playerID)
        pipe.HSet(playerKey, "status", "matched")
        pipe.HSet(playerKey, "match_id", match.MatchID)
        pipe.HSet(playerKey, "room_id", roomID)
    }
    pipe.Exec()

    // 3. 持久化匹配记录到数据库
    e.saveMatchRecord(match, roomID)

    // 4. 通知所有玩家匹配成功
    for i, playerID := range match.PlayerIDs {
        team := "A"
        if i >= 5 {
            team = "B"
        }

        e.coordinator.NotifyMatchSuccess(playerID, map[string]interface{}{
            "match_id": match.MatchID,
            "room_id":  roomID,
            "team":     team,
            "players":  match.PlayerIDs,
        })
    }

    log.Infof("Match created: %s, Room: %s, Avg MMR: %d",
        match.MatchID, roomID, match.AvgMMR)
}
```

#### 3.3 取消匹配流程

```go
func (s *MatchmakingService) CancelMatchmaking(playerID int64) error {
    playerKey := fmt.Sprintf("matchmaking:player:%d", playerID)

    // 1. 获取玩家匹配信息
    info, err := s.redis.HGetAll(playerKey).Result()
    if err != nil || len(info) == 0 {
        return errors.New("player not in matchmaking")
    }

    if info["status"] == "matched" {
        return errors.New("match already found, cannot cancel")
    }

    // 2. 从匹配池中移除
    tier := s.getTier(info["mmr"])
    poolKey := fmt.Sprintf("matchmaking:pool:%s:%s:%s",
        info["region"], info["mode"], tier)

    s.redis.ZRem(poolKey, playerID)

    // 3. 删除玩家状态
    s.redis.Del(playerKey)

    // 4. 通知客户端
    s.gateway.NotifyPlayer(playerID, "matchmaking_cancelled", nil)

    return nil
}
```

---

### 四、高级特性实现

#### 4.1 防长时间等待机制

```go
// 背景: 高分段或冷门时段玩家可能长时间匹配不到

// 解决方案1: 动态降低匹配标准
func (e *MatchingEngine) handleLongWait() {
    // 扫描等待超过2分钟的玩家
    longWaitPlayers := e.getLongWaitPlayers(120) // 120秒

    for _, player := range longWaitPlayers {
        // 允许跨段位匹配(钻石可以匹配白金)
        e.expandTierRange(player)

        // 放宽MMR范围到 ±800
        e.updateMatchRange(player.PlayerID, 800)
    }
}

// 解决方案2: AI机器人填充
func (e *MatchingEngine) fillWithBots(match *Match) {
    if len(match.PlayerIDs) >= 6 && len(match.PlayerIDs) < 10 {
        // 6-9人时,用机器人填充剩余位置
        botsNeeded := 10 - len(match.PlayerIDs)

        for i := 0; i < botsNeeded; i++ {
            botID := fmt.Sprintf("bot_%d", i)
            match.PlayerIDs = append(match.PlayerIDs, botID)
        }

        // 重新平衡分队
        match.TeamA, match.TeamB = e.snakeDraft(match.PlayerIDs)
    }
}
```

#### 4.2 防组队作弊机制

```go
// 问题: 高手带低手"炸鱼"(高分玩家带低分玩家打低分局)

// 解决方案: 组队MMR计算惩罚
func (s *MatchmakingService) calculatePartyMMR(partyIDs []int64) int {
    players := s.getPlayers(partyIDs)

    // 1. 计算平均MMR
    totalMMR := 0
    maxMMR := 0
    minMMR := 9999
    for _, p := range players {
        totalMMR += p.MMR
        if p.MMR > maxMMR {
            maxMMR = p.MMR
        }
        if p.MMR < minMMR {
            minMMR = p.MMR
        }
    }
    avgMMR := totalMMR / len(players)

    // 2. 如果队伍内MMR差距过大,施加惩罚
    mmrGap := maxMMR - minMMR
    if mmrGap > 300 {
        // 惩罚系数: 差距每超过100分,整体MMR提升5%
        penalty := float64(mmrGap-300) / 100 * 0.05
        avgMMR = int(float64(avgMMR) * (1 + penalty))
    }

    // 3. 倾向于使用最高分玩家的MMR(防止炸鱼)
    adjustedMMR := int(float64(maxMMR)*0.7 + float64(avgMMR)*0.3)

    return adjustedMMR
}
```

#### 4.3 区域延迟优化

```go
// 基于地理位置选择最优游戏服务器

type RegionLatency struct {
    Region  string
    Latency int // 毫秒
}

func (s *MatchmakingService) selectOptimalRegion(playerIDs []string) string {
    latencyMap := make(map[string][]int)

    // 1. 获取所有玩家到各区域的延迟
    for _, playerID := range playerIDs {
        latencies := s.getPlayerLatencies(playerID)
        for region, latency := range latencies {
            latencyMap[region] = append(latencyMap[region], latency)
        }
    }

    // 2. 计算每个区域的P95延迟(保证95%玩家体验良好)
    bestRegion := ""
    bestP95 := 9999

    for region, latencies := range latencyMap {
        sort.Ints(latencies)
        p95Index := int(float64(len(latencies)) * 0.95)
        p95Latency := latencies[p95Index]

        if p95Latency < bestP95 {
            bestP95 = p95Latency
            bestRegion = region
        }
    }

    return bestRegion
}

// 玩家上线时预测延迟(通过IP地理位置)
func (s *MatchmakingService) measureLatency(playerID string, ip string) {
    regions := []string{"asia-east", "asia-south", "us-west", "us-east", "eu-west"}

    latencies := make(map[string]int)
    for _, region := range regions {
        // 实际项目中可用Ping测试或GeoIP估算
        latency := s.estimateLatency(ip, region)
        latencies[region] = latency
    }

    // 存储到Redis
    key := fmt.Sprintf("player:latency:%s", playerID)
    s.redis.HMSet(key, latencies)
    s.redis.Expire(key, 24*time.Hour)
}
```

#### 4.4 位置分配(角色/英雄分配)

```go
// 以 MOBA 游戏为例: 上单/打野/中单/射手/辅助

type PlayerRole struct {
    PlayerID     string
    PreferRoles  []string  // 偏好位置
    RoleMMR      map[string]int // 各位置单独评分
}

func (e *MatchingEngine) assignRoles(teamPlayers []PlayerRole) map[string]string {
    roles := []string{"top", "jungle", "mid", "adc", "support"}
    assignment := make(map[string]string) // role -> playerID

    // 1. 收集每个位置的候选人及其分数
    candidates := make(map[string][]struct{
        PlayerID string
        Score    int
    })

    for _, role := range roles {
        for _, player := range teamPlayers {
            score := player.RoleMMR[role]

            // 如果是偏好位置,加权重
            for _, preferRole := range player.PreferRoles {
                if preferRole == role {
                    score += 50 // 偏好加分
                }
            }

            candidates[role] = append(candidates[role], struct {
                PlayerID string
                Score    int
            }{player.PlayerID, score})
        }

        // 按分数排序
        sort.Slice(candidates[role], func(i, j int) bool {
            return candidates[role][i].Score > candidates[role][j].Score
        })
    }

    // 2. 使用匈牙利算法或贪心算法分配位置
    assigned := make(map[string]bool)

    // 贪心策略: 优先满足竞争最激烈的位置
    for _, role := range roles {
        for _, candidate := range candidates[role] {
            if !assigned[candidate.PlayerID] {
                assignment[role] = candidate.PlayerID
                assigned[candidate.PlayerID] = true
                break
            }
        }
    }

    return assignment
}
```

---

### 五、MMR 评分系统(ELO Rating)

#### 5.1 ELO 算法实现

```go
// ELO 评分系统(Chess Rating System)
type ELORating struct {
    KFactor float64 // K因子: 决定分数变化幅度
}

func NewELORating() *ELORating {
    return &ELORating{
        KFactor: 32, // 标准K值
    }
}

// 计算期望胜率
func (e *ELORating) expectedScore(ratingA, ratingB int) float64 {
    return 1.0 / (1.0 + math.Pow(10, float64(ratingB-ratingA)/400.0))
}

// 更新评分
func (e *ELORating) updateRating(currentRating int, expectedScore, actualScore float64) int {
    // actualScore: 1.0=胜, 0.5=平, 0.0=负
    delta := e.KFactor * (actualScore - expectedScore)
    newRating := currentRating + int(math.Round(delta))

    // 限制评分范围 [0, 5000]
    if newRating < 0 {
        newRating = 0
    } else if newRating > 5000 {
        newRating = 5000
    }

    return newRating
}

// 实际使用示例
func (s *MatchmakingService) updatePlayerMMR(matchID string) {
    match := s.getMatchRecord(matchID)

    // 计算两队平均MMR
    teamAMMR := 0
    for _, playerID := range match.TeamA {
        player := s.getPlayer(playerID)
        teamAMMR += player.MMR
    }
    teamAMMR /= len(match.TeamA)

    teamBMMR := 0
    for _, playerID := range match.TeamB {
        player := s.getPlayer(playerID)
        teamBMMR += player.MMR
    }
    teamBMMR /= len(match.TeamB)

    elo := NewELORating()

    // A队期望胜率
    expectedA := elo.expectedScore(teamAMMR, teamBMMR)

    // 实际结果
    var actualA float64
    switch match.Winner {
    case "team_a":
        actualA = 1.0
    case "team_b":
        actualA = 0.0
    case "draw":
        actualA = 0.5
    }

    // 更新所有玩家MMR
    for _, playerID := range match.TeamA {
        player := s.getPlayer(playerID)
        newMMR := elo.updateRating(player.MMR, expectedA, actualA)
        s.updatePlayerMMR(playerID, newMMR)
    }

    for _, playerID := range match.TeamB {
        player := s.getPlayer(playerID)
        newMMR := elo.updateRating(player.MMR, 1-expectedA, 1-actualA)
        s.updatePlayerMMR(playerID, newMMR)
    }
}
```

#### 5.2 动态 K 因子(新手保护/高手稳定)

```go
// 根据玩家游戏场次动态调整K因子
func (e *ELORating) getDynamicKFactor(totalGames int) float64 {
    switch {
    case totalGames < 20:
        return 40 // 新手: 快速定位真实水平
    case totalGames < 100:
        return 32 // 成长期: 正常变化
    default:
        return 24 // 稳定期: 减少波动
    }
}
```

---

### 六、高可用和性能优化

#### 6.1 分布式匹配引擎

```go
// 使用分布式锁防止多个匹配引擎重复匹配

func (e *MatchingEngine) processMatchingWithLock() {
    lockKey := fmt.Sprintf("matchmaking:lock:%s:%s", e.region, e.mode)

    // 尝试获取分布式锁(使用Redis SETNX)
    locked, err := e.redis.SetNX(lockKey, "1", 3*time.Second).Result()
    if err != nil || !locked {
        return // 其他引擎正在处理,跳过
    }

    defer e.redis.Del(lockKey)

    // 执行匹配逻辑
    e.processMatching()
}
```

#### 6.2 匹配池预热

```go
// 在高峰前预热匹配池,减少首次匹配延迟

func (s *MatchmakingService) warmupMatchingPool() {
    // 1. 预加载活跃玩家MMR到缓存
    activePlayerIDs := s.getActivePlayers(24 * time.Hour) // 24小时内活跃

    pipe := s.redis.Pipeline()
    for _, playerID := range activePlayerIDs {
        player := s.getPlayer(playerID)
        key := fmt.Sprintf("player:cache:%d", playerID)
        pipe.HMSet(key, map[string]interface{}{
            "mmr":    player.MMR,
            "region": player.Region,
        })
        pipe.Expire(key, 1*time.Hour)
    }
    pipe.Exec()

    // 2. 预分配游戏服务器房间
    s.coordinator.PreallocateRooms(100)
}
```

#### 6.3 监控和降级

```go
// 关键指标监控
type MatchingMetrics struct {
    TotalMatching    int64         // 当前匹配中人数
    MatchSuccessRate float64       // 匹配成功率
    AvgWaitTime      time.Duration // 平均等待时长
    P99WaitTime      time.Duration // P99等待时长
}

// 降级策略
func (s *MatchmakingService) degradeStrategy() {
    metrics := s.getMetrics()

    // 如果匹配池人数过多,放宽匹配条件
    if metrics.TotalMatching > 100000 {
        s.relaxMatchingRules()
    }

    // 如果P99等待时长过长,启用机器人填充
    if metrics.P99WaitTime > 3*time.Minute {
        s.enableBotFill = true
    }

    // 如果服务器资源紧张,暂停接受新匹配
    if s.coordinator.GetAvailableRooms() < 10 {
        s.pauseMatchmaking = true
    }
}
```

---

### 七、容量评估

#### 7.1 场景假设
- **同时在线**: 50 万玩家
- **匹配中玩家**: 10 万(20%在匹配中)
- **峰值匹配请求**: 5000 次/秒
- **平均匹配时长**: 15 秒
- **每局游戏时长**: 30 分钟

#### 7.2 资源估算

##### **Redis (匹配池)**
```
内存占用估算:
- 单个玩家匹配信息: 200 字节
- 10万匹配中玩家: 200字节 * 100000 = 20MB
- 预留10倍冗余: 200MB

推荐配置: Redis Cluster (3主3从),每节点 4GB 内存
```

##### **匹配引擎服务器**
```
处理能力:
- 单服务器处理: 500 QPS(包含数据库查询)
- 峰值 5000 QPS: 需要 10 台服务器

单机配置:
- CPU: 8核
- 内存: 16GB
```

##### **MySQL (玩家数据 + 匹配记录)**
```
存储估算:
- 5000万玩家: 每条记录 1KB = 50GB
- 匹配记录: 每天 100万场 * 2KB = 2GB/天
- 保留 90天历史: 180GB

推荐配置: 主从架构,256GB 内存,2TB SSD
```

##### **游戏服务器**
```
房间需求:
- 同时在线 50万人,每局10人: 50000 个并发房间
- 单服务器支持 100 个房间: 需要 500 台游戏服务器

单机配置:
- CPU: 16核
- 内存: 32GB
- 网络: 10Gbps
```

---

### 八、防作弊和安全

#### 8.1 防刷分检测

```go
// 异常行为检测
func (s *MatchmakingService) detectAbnormalBehavior(playerID int64) bool {
    // 1. 检测连胜/连败异常(可能是代练或故意掉分)
    recentMatches := s.getRecentMatches(playerID, 20)

    winStreak := 0
    loseStreak := 0
    for _, match := range recentMatches {
        if match.IsWin(playerID) {
            winStreak++
            loseStreak = 0
        } else {
            loseStreak++
            winStreak = 0
        }
    }

    if winStreak >= 15 || loseStreak >= 15 {
        // 连胜/连败15场以上,标记异常
        s.flagPlayer(playerID, "abnormal_win_rate")
        return true
    }

    // 2. 检测KDA异常(数据异常好或异常差)
    avgKDA := s.calculateAvgKDA(recentMatches, playerID)
    if avgKDA > 10.0 || avgKDA < 0.3 {
        s.flagPlayer(playerID, "abnormal_kda")
        return true
    }

    // 3. 检测匹配时段异常(深夜大量匹配可能是工作室)
    nightMatches := s.countNightMatches(playerID, 7) // 7天内
    if nightMatches > 50 {
        s.flagPlayer(playerID, "abnormal_time_pattern")
        return true
    }

    return false
}

// 匹配前校验
func (s *MatchmakingService) validatePlayer(playerID int64) error {
    // 检查是否被封禁
    if s.isPlayerBanned(playerID) {
        return errors.New("player is banned")
    }

    // 检查异常行为标记
    if s.detectAbnormalBehavior(playerID) {
        // 不禁止匹配,但降低优先级或延长匹配时间
        s.applyMatchingPenalty(playerID)
    }

    return nil
}
```

#### 8.2 防恶意退出

```go
// 记录玩家退出行为
func (s *MatchmakingService) recordQuitBehavior(playerID int64, matchID string, stage string) {
    key := fmt.Sprintf("player:quit_record:%d", playerID)

    // 记录退出次数
    quitCount, _ := s.redis.Incr(key).Result()
    s.redis.Expire(key, 24*time.Hour)

    // 惩罚机制
    if quitCount >= 3 {
        // 24小时内退出3次,禁止匹配
        s.banPlayer(playerID, 1*time.Hour, "frequent_quit")
    }

    // 扣除信誉分
    s.decreasePlayerCredit(playerID, 10)
}
```

---

## 面试回答要点总结

### 1. 开场破题(1-2分钟)
"游戏匹配系统的核心挑战是**公平性**和**速度**的平衡。我会设计一个**基于MMR评分的分层匹配系统**:
- 使用Redis Sorted Set实现高效的分层匹配池
- 采用动态扩大匹配范围的策略,平衡匹配质量和等待时间
- 使用贪心算法+蛇形分配保证两队实力均衡
- 结合ELO评分系统动态调整玩家实力"

### 2. 核心流程讲解(3-4分钟)
- **加入匹配**: 玩家按MMR分层进入Redis Sorted Set匹配池
- **匹配算法**: 滑动窗口找到10人,使用蛇形分配保证公平
- **动态策略**: 等待时间越长,匹配范围越大(150→500分)
- **结果通知**: WebSocket实时推送匹配结果和房间信息

### 3. 技术难点深入(4-5分钟)
- **公平性保障**: ELO评分系统,组队惩罚机制,位置分配算法
- **性能优化**: 分层匹配池(Bronze/Silver/Gold),分布式匹配引擎,Redis Pipeline批量操作
- **极端场景**: 长时间等待降级机制,机器人填充,防炸鱼算法

### 4. 扩展问题应对
- **如何防止高手炸鱼?** 组队MMR加权(偏向最高分),检测异常胜率
- **如何处理跨区匹配?** 基于IP延迟测试,选择P95延迟最优区域
- **如何应对高峰拥堵?** 放宽匹配条件,机器人填充,分层处理

### 5. 总结(1分钟)
"这个系统的核心是**数据驱动的动态匹配**,通过MMR评分量化玩家实力,通过动态范围扩大平衡速度和公平,通过分层设计提升性能。类似的系统在《英雄联盟》《DOTA2》等游戏中得到验证,能支撑千万级DAU。"

---

## 参考资料
- [ELO Rating System](https://en.wikipedia.org/wiki/Elo_rating_system)
- [Riot Games Matchmaking Blog](https://www.riotgames.com/en/news/dev-matchmaking-real-talk)
- [Valve's DOTA 2 Matchmaking](https://blog.dota2.com/2013/12/matchmaking/)
- [Glicko-2 Rating System](http://www.glicko.net/glicko.html)
