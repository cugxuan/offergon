---
title: 设计一个抢红包系统
tags:
  - 系统设计
status: robot
class: 系统设计
slug: red-envelope-grab-system-design
ref:
---

## 核心要点

**二倍均值法**保证金额随机公平,**Redis+Lua脚本**实现原子抢红包,**乐观锁防止超抢**。**预拆红包**提升性能,**分布式事务**保证资金安全,**限流+防刷**应对高并发。

---

## 详细回答

### 一、核心功能

1. **发红包**:设置总金额、红包个数
2. **抢红包**:先到先得,抢完为止
3. **拆红包**:查看抢到的金额
4. **红包详情**:谁抢了多少,剩余个数

**业务规则**:
- 每人只能抢一次
- 金额随机但公平(避免最后一个人金额过小)
- 所有金额之和=总金额(精确到分)
- 24小时未领取自动退回

### 二、金额分配算法

#### 二倍均值法(推荐)

```go
// 拆分红包金额(单位:分)
func SplitRedPacket(total int64, count int) []int64 {
    amounts := make([]int64, count)
    remaining := total

    for i := 0; i < count-1; i++ {
        // 当前可抢金额范围:[1, remaining/剩余个数*2]
        max := remaining / int64(count-i) * 2
        if max < 1 {
            max = 1
        }

        // 随机金额
        amount := rand.Int63n(max) + 1
        amounts[i] = amount
        remaining -= amount
    }

    // 最后一个人拿剩余的
    amounts[count-1] = remaining

    return amounts
}

// 示例:100元分10个红包
// 第1次:[1, 20] → 10元,剩余90元
// 第2次:[1, 20] → 15元,剩余75元
// ...
// 第10次:剩余3元 → 3元
```

**优点**:
- 金额分布均匀,期望值相等
- 不会出现过大或过小的金额
- 简单高效,O(n)复杂度

### 三、数据库设计

```sql
-- 红包主表
CREATE TABLE red_packet (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,              -- 发红包的人
    total_amount BIGINT NOT NULL,         -- 总金额(分)
    total_count INT NOT NULL,             -- 总个数
    remain_amount BIGINT NOT NULL,        -- 剩余金额
    remain_count INT NOT NULL,            -- 剩余个数
    status TINYINT DEFAULT 1,             -- 1=进行中,2=已抢完,3=已过期
    expire_time BIGINT NOT NULL,          -- 过期时间
    create_time BIGINT NOT NULL,
    INDEX idx_user (user_id, create_time)
) ENGINE=InnoDB;

-- 红包详情表(预拆红包)
CREATE TABLE red_packet_detail (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    packet_id BIGINT NOT NULL,
    amount BIGINT NOT NULL,               -- 金额(分)
    user_id BIGINT DEFAULT 0,             -- 抢到的用户ID(0表示未领取)
    status TINYINT DEFAULT 0,             -- 0=未领取,1=已领取
    grab_time BIGINT DEFAULT 0,           -- 领取时间
    create_time BIGINT NOT NULL,
    INDEX idx_packet (packet_id, status),
    INDEX idx_user (user_id)
) ENGINE=InnoDB;
```

### 四、核心流程实现

#### 1. 发红包(预拆红包)

```go
func CreateRedPacket(userID, totalAmount int64, count int) (int64, error) {
    // 1. 参数校验
    if totalAmount < count || count > 200 {
        return 0, errors.New("参数非法")
    }

    // 2. 扣减用户余额(分布式事务)
    if err := deductBalance(userID, totalAmount); err != nil {
        return 0, err
    }

    // 3. 拆分金额
    amounts := SplitRedPacket(totalAmount, count)

    // 4. 数据库事务
    tx := db.Begin()

    // 插入红包主表
    packet := &RedPacket{
        UserID:       userID,
        TotalAmount:  totalAmount,
        TotalCount:   count,
        RemainAmount: totalAmount,
        RemainCount:  count,
        ExpireTime:   time.Now().Add(24 * time.Hour).Unix(),
    }
    tx.Create(packet)

    // 批量插入详情表(预拆红包)
    details := make([]RedPacketDetail, count)
    for i, amount := range amounts {
        details[i] = RedPacketDetail{
            PacketID: packet.ID,
            Amount:   amount,
        }
    }
    tx.CreateInBatches(details, 100)

    tx.Commit()

    // 5. 写入Redis(提升抢红包性能)
    key := fmt.Sprintf("red_packet:%d", packet.ID)
    redis.HMSet(ctx, key, map[string]interface{}{
        "remain_count":  count,
        "remain_amount": totalAmount,
        "detail_ids":    getDetailIDs(details), // 预拆好的detail_id列表
    })
    redis.Expire(ctx, key, 24*time.Hour)

    return packet.ID, nil
}
```

#### 2. 抢红包(Redis+Lua原子操作)

```go
// Lua脚本:原子性抢红包
const grabRedPacketScript = `
local key = KEYS[1]
local user_id = ARGV[1]

-- 检查是否已抢过
local grabbed_key = key .. ":grabbed:" .. user_id
if redis.call('EXISTS', grabbed_key) == 1 then
    return -1  -- 已抢过
end

-- 检查剩余数量
local remain = redis.call('HGET', key, 'remain_count')
if not remain or tonumber(remain) <= 0 then
    return -2  -- 已抢完
end

-- 弹出一个detail_id
local detail_id = redis.call('LPOP', key .. ':detail_ids')
if not detail_id then
    return -3  -- 异常:没有可用的detail
end

-- 减少剩余数量
redis.call('HINCRBY', key, 'remain_count', -1)

-- 标记用户已抢过(24小时过期)
redis.call('SETEX', grabbed_key, 86400, '1')

return detail_id
`

func GrabRedPacket(packetID, userID int64) (int64, error) {
    // 1. 执行Lua脚本
    key := fmt.Sprintf("red_packet:%d", packetID)
    result := redis.Eval(ctx, grabRedPacketScript,
        []string{key},
        userID,
    ).Val()

    detailID := result.(int64)
    if detailID == -1 {
        return 0, errors.New("您已抢过该红包")
    } else if detailID == -2 {
        return 0, errors.New("红包已抢完")
    } else if detailID < 0 {
        return 0, errors.New("系统异常")
    }

    // 2. 异步更新MySQL
    go func() {
        db.Model(&RedPacketDetail{}).Where("id = ?", detailID).
            Updates(map[string]interface{}{
                "user_id":   userID,
                "status":    1,
                "grab_time": time.Now().Unix(),
            })

        // 更新红包主表
        db.Model(&RedPacket{}).Where("id = ?", packetID).
            UpdateColumn("remain_count", gorm.Expr("remain_count - 1"))
    }()

    // 3. 返回抢到的金额
    detail := getDetailByID(detailID)
    return detail.Amount, nil
}
```

**Lua脚本优势**:
- 原子性:多个Redis操作在一个事务中执行
- 避免竞态条件:不会出现超抢问题
- 性能高:纯内存操作,QPS可达10万+

#### 3. 查询红包详情

```go
func GetRedPacketDetail(packetID int64) (*RedPacketVO, error) {
    // 1. 查询主表
    packet := getRedPacketByID(packetID)

    // 2. 查询已领取的记录
    var details []RedPacketDetail
    db.Where("packet_id = ? AND status = 1", packetID).
        Order("grab_time ASC").
        Find(&details)

    // 3. 批量查询用户信息
    userIDs := make([]int64, len(details))
    for i, d := range details {
        userIDs[i] = d.UserID
    }
    users := getUsersByIDs(userIDs)

    // 4. 组装数据
    records := make([]GrabRecord, len(details))
    for i, d := range details {
        records[i] = GrabRecord{
            User:     users[i],
            Amount:   d.Amount,
            GrabTime: d.GrabTime,
        }
    }

    return &RedPacketVO{
        RedPacket:   packet,
        GrabRecords: records,
    }, nil
}
```

### 五、高并发优化

#### 1. 限流防刷

```go
// 限流:每用户每秒最多抢5次
func checkRateLimit(userID int64) bool {
    key := fmt.Sprintf("grab_limit:%d", userID)
    count := redis.Incr(ctx, key).Val()

    if count == 1 {
        redis.Expire(ctx, key, 1*time.Second)
    }

    return count <= 5
}

// 防刷:检测异常行为
func checkAntiCheat(userID int64) bool {
    // 检查是否是新注册账号(注册时间<1天)
    user := getUserByID(userID)
    if time.Now().Unix()-user.CreateTime < 86400 {
        return false
    }

    // 检查是否有实名认证
    if !user.Verified {
        return false
    }

    return true
}
```

#### 2. 分布式锁(兜底方案)

```go
// Redis分布式锁防止重复抢
func grabWithLock(packetID, userID int64) error {
    lockKey := fmt.Sprintf("lock:grab:%d:%d", packetID, userID)

    // 尝试获取锁(5秒超时)
    locked := redis.SetNX(ctx, lockKey, "1", 5*time.Second).Val()
    if !locked {
        return errors.New("操作过于频繁")
    }
    defer redis.Del(ctx, lockKey)

    // 执行抢红包逻辑
    return doGrabRedPacket(packetID, userID)
}
```

### 六、资金安全保证

#### 1. 分布式事务(TCC)

```go
// Try阶段:冻结金额
func TryCreateRedPacket(userID, amount int64) (string, error) {
    txID := generateTxID()

    // 冻结用户余额
    db.Exec(`
        UPDATE user_account SET
            balance = balance - ?,
            frozen = frozen + ?
        WHERE user_id = ? AND balance >= ?
    `, amount, amount, userID, amount)

    // 记录事务日志
    saveTxLog(txID, "TRY", userID, amount)

    return txID, nil
}

// Confirm阶段:扣减冻结金额,创建红包
func ConfirmCreateRedPacket(txID string) error {
    txLog := getTxLog(txID)

    // 扣减冻结金额
    db.Exec(`
        UPDATE user_account SET frozen = frozen - ?
        WHERE user_id = ?
    `, txLog.Amount, txLog.UserID)

    // 创建红包...

    saveTxLog(txID, "CONFIRM", txLog.UserID, txLog.Amount)
    return nil
}

// Cancel阶段:解冻金额
func CancelCreateRedPacket(txID string) error {
    txLog := getTxLog(txID)

    db.Exec(`
        UPDATE user_account SET
            balance = balance + ?,
            frozen = frozen - ?
        WHERE user_id = ?
    `, txLog.Amount, txLog.Amount, txLog.UserID)

    saveTxLog(txID, "CANCEL", txLog.UserID, txLog.Amount)
    return nil
}
```

#### 2. 对账机制

```go
// 定时对账:检查红包金额是否匹配
func ReconcileRedPacket(packetID int64) error {
    // 查询红包总金额
    packet := getRedPacketByID(packetID)

    // 统计已领取的总金额
    var grabbedTotal int64
    db.Model(&RedPacketDetail{}).
        Where("packet_id = ? AND status = 1", packetID).
        Select("SUM(amount)").
        Scan(&grabbedTotal)

    // 统计未领取的总金额
    var remainTotal int64
    db.Model(&RedPacketDetail{}).
        Where("packet_id = ? AND status = 0", packetID).
        Select("SUM(amount)").
        Scan(&remainTotal)

    // 验证:已领取+未领取=总金额
    if grabbedTotal+remainTotal != packet.TotalAmount {
        // 告警:金额不匹配
        alert("红包金额不一致", packetID)
    }

    return nil
}
```

### 七、过期红包处理

```go
// 定时任务:处理过期红包
func ProcessExpiredRedPackets() {
    now := time.Now().Unix()

    // 查询过期的红包
    var packets []RedPacket
    db.Where("status = 1 AND expire_time < ?", now).
        Find(&packets)

    for _, packet := range packets {
        // 查询未领取的金额
        var remainAmount int64
        db.Model(&RedPacketDetail{}).
            Where("packet_id = ? AND status = 0", packet.ID).
            Select("SUM(amount)").
            Scan(&remainAmount)

        // 退回发红包的人
        if remainAmount > 0 {
            refundBalance(packet.UserID, remainAmount)
        }

        // 更新红包状态
        db.Model(&RedPacket{}).Where("id = ?", packet.ID).
            Update("status", 3)
    }
}
```

### 八、容量评估

- 峰值QPS:10万(春节高峰)
- 红包并发:单个红包1000人同时抢
- Redis存储:100万个红包 × 1KB = 1GB
- MySQL存储:100万个红包 × 200个详情 × 100B = 20GB

### 九、总结

**关键技术**:
1. **二倍均值法**:金额分配公平随机
2. **预拆红包**:发红包时拆分,抢红包时直接分配
3. **Redis+Lua**:原子性抢红包,防止超抢
4. **分布式事务**:TCC保证资金安全
5. **限流防刷**:防止恶意抢红包

**性能优化**:
- Redis承载99%读写操作,MySQL异步持久化
- Lua脚本原子操作,QPS达10万+
- 预拆红包避免实时计算,响应时间<10ms
