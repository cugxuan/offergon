---
title: 设计一个API网关
tags:
  - 系统设计
status: robot
class: 系统设计
slug: api-gateway-design
ref:
---

## 核心要点

**关键特性**:统一入口、路由转发、负载均衡、限流熔断、认证鉴权、协议转换
**技术选型**:Nginx/Kong/APISIX、JWT认证、Redis限流、Hystrix熔断
**难点突破**:高并发性能、动态路由配置、分布式限流、灰度发布、安全防护

---

## 详细回答

### 一、系统概述与核心需求

API网关是微服务架构中的流量入口和统一管理平台,为客户端提供统一的访问接口,对后端微服务进行聚合、转发、保护和治理。

**核心需求**:
1. **流量管理**:统一入口、路由转发、负载均衡、协议转换
2. **安全防护**:认证鉴权、防重放攻击、IP黑白名单、参数校验
3. **流量控制**:限流、熔断、降级、超时重试
4. **监控运维**:日志记录、性能监控、告警通知、链路追踪
5. **服务治理**:灰度发布、A/B测试、版本管理、服务发现
6. **高性能**:百万级QPS、毫秒级延迟、高可用部署

### 二、系统架构设计

```
┌────────────────────────────────────────────────────────────────────┐
│                        客户端层                                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ Web前端  │  │ 移动App  │  │ 第三方   │  │ 内部服务 │           │
│  │ Browser  │  │ iOS/Android│ │ Partner  │  │ Internal │           │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘           │
└───────┼─────────────┼─────────────┼─────────────┼──────────────────┘
        │             │             │             │
        └─────────────┴─────────────┴─────────────┘
                      │  HTTPS
┌─────────────────────▼───────────────────────────────────────────────┐
│                    负载均衡层 (LVS/F5/SLB)                          │
│               L4负载均衡 + 健康检查 + 故障转移                      │
└─────────────────────┬───────────────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┬────────────┐
        │             │             │            │
┌───────▼───────┐ ┌───▼────────┐ ┌─▼──────────┐ │
│ API Gateway 1 │ │API Gateway2│ │API Gateway3│ │  (无状态,水平扩展)
└───────┬───────┘ └───┬────────┘ └─┬──────────┘ │
        │             │             │            │
        │    API网关集群 (核心功能层)             │
        │             │             │            │
┌───────▼─────────────▼─────────────▼────────────▼─────────────────┐
│                      API网关核心功能                             │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │  请求处理流程 (责任链模式)                                  │ │
│  │  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐         │ │
│  │  │前置  │→ │认证  │→ │鉴权  │→ │限流  │→ │路由  │→ ...   │ │
│  │  │处理  │  │Auth  │  │ACL   │  │Rate  │  │Route │         │ │
│  │  └──────┘  └──────┘  └──────┘  └──────┘  └──────┘         │ │
│  │     ↓         ↓         ↓         ↓         ↓              │ │
│  │  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐         │ │
│  │  │日志  │  │监控  │  │缓存  │  │熔断  │  │后置  │         │ │
│  │  │Log   │  │Metric│  │Cache │  │Breaker│ │处理  │         │ │
│  │  └──────┘  └──────┘  └──────┘  └──────┘  └──────┘         │ │
│  └─────────────────────────────────────────────────────────────┘ │
└───────┬─────────────┬─────────────┬─────────────┬──────────────────┘
        │             │             │             │
┌───────▼─────────────▼─────────────▼─────────────▼──────────────────┐
│                   配置与数据存储层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │
│  │ 路由配置     │  │ 限流计数     │  │ 认证信息     │             │
│  │ Etcd/Consul  │  │ Redis        │  │ MySQL/Redis  │             │
│  └──────────────┘  └──────────────┘  └──────────────┘             │
└───────┬─────────────────────────────────────────────────────────────┘
        │
┌───────▼─────────────────────────────────────────────────────────────┐
│                   后端服务层 (微服务集群)                           │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  服务注册中心 (Consul/Nacos/Eureka)                          │  │
│  └─────────┬────────────────────────────────────────────────────┘  │
│            │ 服务发现                                               │
│     ┌──────┼──────┬──────────┬──────────┐                          │
│  ┌──▼─────┐ │ ┌───▼────┐ ┌──▼────┐ ┌───▼────┐                     │
│  │User Svc│ │ │Order Svc│ │Pay Svc│ │Product │                     │
│  │服务1   │ │ │服务2    │ │服务3  │ │服务4   │                     │
│  └────────┘ │ └────────┘ └───────┘ └────────┘                     │
└─────────────┴──────────────────────────────────────────────────────┘
```

### 三、核心功能设计

#### 1. 路由与转发

**动态路由配置**:

```go
// 路由配置结构
type Route struct {
    ID          string            `json:"id"`
    Path        string            `json:"path"`          // 匹配路径
    Method      string            `json:"method"`        // HTTP方法
    Backend     []Backend         `json:"backend"`       // 后端服务列表
    LoadBalancer string           `json:"load_balancer"` // 负载均衡策略
    Timeout     time.Duration     `json:"timeout"`
    Retry       int               `json:"retry"`
    Plugins     []Plugin          `json:"plugins"`       // 插件列表
}

type Backend struct {
    Host    string  `json:"host"`
    Weight  int     `json:"weight"`  // 权重
    Status  string  `json:"status"`  // UP/DOWN
}

// 路由匹配器
type Router struct {
    routes    []*Route
    trie      *PathTrie    // 前缀树快速匹配
    regexMap  map[string]*Route  // 正则匹配
}

// 路由匹配
func (r *Router) Match(req *http.Request) (*Route, error) {
    // 1. 精确匹配
    if route, ok := r.exactMatch(req.URL.Path, req.Method); ok {
        return route, nil
    }

    // 2. 前缀匹配(使用Trie树)
    if route := r.trie.MatchPrefix(req.URL.Path); route != nil {
        return route, nil
    }

    // 3. 正则匹配
    for pattern, route := range r.regexMap {
        if matched, _ := regexp.MatchString(pattern, req.URL.Path); matched {
            return route, nil
        }
    }

    return nil, errors.New("no route matched")
}

// 路由配置示例
routes := []Route{
    {
        ID:     "user-api",
        Path:   "/api/v1/users/*",
        Method: "GET",
        Backend: []Backend{
            {Host: "user-service-1:8080", Weight: 5},
            {Host: "user-service-2:8080", Weight: 3},
            {Host: "user-service-3:8080", Weight: 2},
        },
        LoadBalancer: "weighted_round_robin",
        Timeout:      3 * time.Second,
        Retry:        2,
    },
    {
        ID:     "order-api",
        Path:   "/api/v1/orders",
        Method: "POST",
        Backend: []Backend{
            {Host: "order-service:8080", Weight: 10},
        },
        LoadBalancer: "round_robin",
        Timeout:      5 * time.Second,
    },
}
```

**负载均衡策略**:

```go
// 负载均衡接口
type LoadBalancer interface {
    Select(backends []Backend) (*Backend, error)
}

// 1. 轮询
type RoundRobinBalancer struct {
    current int
    mu      sync.Mutex
}

func (lb *RoundRobinBalancer) Select(backends []Backend) (*Backend, error) {
    lb.mu.Lock()
    defer lb.mu.Unlock()

    if len(backends) == 0 {
        return nil, errors.New("no available backend")
    }

    backend := &backends[lb.current%len(backends)]
    lb.current++

    return backend, nil
}

// 2. 加权轮询
type WeightedRoundRobinBalancer struct {
    current  int
    weights  []int
    totalWeight int
}

func (lb *WeightedRoundRobinBalancer) Select(backends []Backend) (*Backend, error) {
    if len(backends) == 0 {
        return nil, errors.New("no available backend")
    }

    // 构建权重数组
    weights := make([]int, len(backends))
    totalWeight := 0
    for i, b := range backends {
        weights[i] = b.Weight
        totalWeight += b.Weight
    }

    // 加权随机选择
    randomWeight := rand.Intn(totalWeight)
    cumulative := 0

    for i, weight := range weights {
        cumulative += weight
        if randomWeight < cumulative {
            return &backends[i], nil
        }
    }

    return &backends[0], nil
}

// 3. 一致性哈希(根据请求特征选择后端)
type ConsistentHashBalancer struct {
    hashRing *HashRing
}

func (lb *ConsistentHashBalancer) Select(backends []Backend, key string) (*Backend, error) {
    if len(backends) == 0 {
        return nil, errors.New("no available backend")
    }

    // 根据key(如user_id)选择节点
    node := lb.hashRing.Get(key)
    for i := range backends {
        if backends[i].Host == node {
            return &backends[i], nil
        }
    }

    return &backends[0], nil
}

// 4. 最少连接数
type LeastConnectionBalancer struct {
    connections map[string]int
    mu          sync.Mutex
}

func (lb *LeastConnectionBalancer) Select(backends []Backend) (*Backend, error) {
    lb.mu.Lock()
    defer lb.mu.Unlock()

    var minConn int = int(^uint(0) >> 1) // MaxInt
    var selected *Backend

    for i := range backends {
        conn := lb.connections[backends[i].Host]
        if conn < minConn {
            minConn = conn
            selected = &backends[i]
        }
    }

    if selected != nil {
        lb.connections[selected.Host]++
    }

    return selected, nil
}
```

#### 2. 认证与鉴权

**JWT认证**:

```go
type AuthMiddleware struct {
    jwtSecret  []byte
    tokenStore TokenStore
}

// JWT Token结构
type Claims struct {
    UserID   int64    `json:"user_id"`
    Username string   `json:"username"`
    Roles    []string `json:"roles"`
    jwt.StandardClaims
}

// 认证中间件
func (m *AuthMiddleware) Authenticate(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 提取Token
        token := extractToken(r)
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }

        // 2. 校验Token
        claims, err := m.verifyToken(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        // 3. 检查Token是否被吊销
        if m.tokenStore.IsRevoked(token) {
            http.Error(w, "Token revoked", http.StatusUnauthorized)
            return
        }

        // 4. 将用户信息注入上下文
        ctx := context.WithValue(r.Context(), "user", claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func (m *AuthMiddleware) verifyToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return m.jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}

// 生成Token
func (m *AuthMiddleware) GenerateToken(userID int64, username string, roles []string) (string, error) {
    claims := &Claims{
        UserID:   userID,
        Username: username,
        Roles:    roles,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: time.Now().Add(24 * time.Hour).Unix(),
            IssuedAt:  time.Now().Unix(),
            Issuer:    "api-gateway",
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(m.jwtSecret)
}

// RBAC鉴权
type ACLMiddleware struct {
    aclStore ACLStore
}

func (m *ACLMiddleware) Authorize(requiredRoles []string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从上下文获取用户信息
            claims, ok := r.Context().Value("user").(*Claims)
            if !ok {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }

            // 检查是否有所需角色
            if !hasAnyRole(claims.Roles, requiredRoles) {
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}

func hasAnyRole(userRoles, requiredRoles []string) bool {
    roleSet := make(map[string]bool)
    for _, role := range userRoles {
        roleSet[role] = true
    }

    for _, required := range requiredRoles {
        if roleSet[required] {
            return true
        }
    }

    return false
}
```

#### 3. 限流与熔断

**分布式限流(Redis + Lua)**:

```go
type RateLimiter struct {
    redis  *redis.Client
    script string
}

// 令牌桶算法(Redis + Lua脚本)
const luaScript = `
local key = KEYS[1]
local capacity = tonumber(ARGV[1])
local rate = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

local bucket = redis.call('HMGET', key, 'tokens', 'last_time')
local tokens = tonumber(bucket[1]) or capacity
local last_time = tonumber(bucket[2]) or now

-- 计算时间差内产生的token
local delta = math.max(0, now - last_time)
local new_tokens = math.min(capacity, tokens + delta * rate)

if new_tokens >= 1 then
    redis.call('HMSET', key, 'tokens', new_tokens - 1, 'last_time', now)
    redis.call('EXPIRE', key, 60)
    return 1  -- 允许请求
else
    return 0  -- 拒绝请求
end
`

func (rl *RateLimiter) Allow(key string, capacity, rate int) (bool, error) {
    result, err := rl.redis.Eval(
        context.Background(),
        luaScript,
        []string{fmt.Sprintf("ratelimit:%s", key)},
        capacity,
        rate,
        time.Now().Unix(),
    ).Result()

    if err != nil {
        return false, err
    }

    return result.(int64) == 1, nil
}

// 限流中间件
type RateLimitMiddleware struct {
    limiter *RateLimiter
}

func (m *RateLimitMiddleware) Limit(capacity, rate int) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 限流维度:IP + 接口路径
            key := fmt.Sprintf("%s:%s", getClientIP(r), r.URL.Path)

            allowed, err := m.limiter.Allow(key, capacity, rate)
            if err != nil || !allowed {
                w.Header().Set("X-RateLimit-Limit", strconv.Itoa(capacity))
                w.Header().Set("X-RateLimit-Remaining", "0")
                http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

**熔断器(Hystrix模式)**:

```go
type CircuitBreaker struct {
    name          string
    maxRequests   uint32          // 半开状态最大请求数
    interval      time.Duration   // 统计窗口
    timeout       time.Duration   // 请求超时时间
    threshold     float64         // 失败率阈值(如0.5表示50%)

    counts        *Counts
    state         State
    mu            sync.Mutex
}

type State int

const (
    StateClosed State = iota   // 关闭:正常请求
    StateHalfOpen              // 半开:尝试恢复
    StateOpen                  // 打开:拒绝请求
)

type Counts struct {
    Requests        uint32
    TotalSuccesses  uint32
    TotalFailures   uint32
    ConsecutiveSuccesses uint32
    ConsecutiveFailures  uint32
}

func (cb *CircuitBreaker) Execute(fn func() error) error {
    cb.mu.Lock()

    // 1. 检查熔断器状态
    if cb.state == StateOpen {
        cb.mu.Unlock()
        return errors.New("circuit breaker is open")
    }

    // 2. 半开状态下限制请求数
    if cb.state == StateHalfOpen && cb.counts.Requests >= cb.maxRequests {
        cb.mu.Unlock()
        return errors.New("too many requests in half-open state")
    }

    cb.counts.Requests++
    cb.mu.Unlock()

    // 3. 执行请求(带超时)
    done := make(chan error, 1)
    go func() {
        done <- fn()
    }()

    select {
    case err := <-done:
        cb.recordResult(err == nil)
        return err
    case <-time.After(cb.timeout):
        cb.recordResult(false)
        return errors.New("request timeout")
    }
}

func (cb *CircuitBreaker) recordResult(success bool) {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    if success {
        cb.counts.TotalSuccesses++
        cb.counts.ConsecutiveSuccesses++
        cb.counts.ConsecutiveFailures = 0

        // 半开→关闭(连续成功达到阈值)
        if cb.state == StateHalfOpen && cb.counts.ConsecutiveSuccesses >= 5 {
            cb.state = StateClosed
            cb.counts = &Counts{}
        }
    } else {
        cb.counts.TotalFailures++
        cb.counts.ConsecutiveFailures++
        cb.counts.ConsecutiveSuccesses = 0

        // 检查是否需要打开熔断器
        if cb.shouldOpen() {
            cb.state = StateOpen
            go cb.scheduleHalfOpen()
        }
    }
}

func (cb *CircuitBreaker) shouldOpen() bool {
    if cb.counts.Requests < 10 {
        return false  // 请求数太少,不触发熔断
    }

    failureRate := float64(cb.counts.TotalFailures) / float64(cb.counts.Requests)
    return failureRate >= cb.threshold
}

func (cb *CircuitBreaker) scheduleHalfOpen() {
    time.Sleep(30 * time.Second)  // 30秒后尝试恢复

    cb.mu.Lock()
    defer cb.mu.Unlock()

    cb.state = StateHalfOpen
    cb.counts = &Counts{}
}
```

#### 4. 插件化架构

```go
// 插件接口
type Plugin interface {
    Name() string
    Execute(ctx *Context, next func() error) error
}

// 上下文
type Context struct {
    Request    *http.Request
    Response   http.ResponseWriter
    Route      *Route
    Metadata   map[string]interface{}
}

// 插件链
type PluginChain struct {
    plugins []Plugin
}

func (pc *PluginChain) Execute(ctx *Context) error {
    index := 0

    var next func() error
    next = func() error {
        if index >= len(pc.plugins) {
            // 所有插件执行完毕,转发到后端
            return forwardToBackend(ctx)
        }

        plugin := pc.plugins[index]
        index++

        // 执行插件
        return plugin.Execute(ctx, next)
    }

    return next()
}

// 示例插件:日志记录
type LoggingPlugin struct{}

func (p *LoggingPlugin) Name() string {
    return "logging"
}

func (p *LoggingPlugin) Execute(ctx *Context, next func() error) error {
    start := time.Now()

    // 请求前日志
    log.Printf("[%s] %s %s", ctx.Request.Method, ctx.Request.URL.Path, ctx.Request.RemoteAddr)

    // 执行下一个插件
    err := next()

    // 请求后日志
    duration := time.Since(start)
    log.Printf("[%s] %s completed in %v", ctx.Request.Method, ctx.Request.URL.Path, duration)

    return err
}

// 示例插件:请求缓存
type CachePlugin struct {
    cache Cache
    ttl   time.Duration
}

func (p *CachePlugin) Execute(ctx *Context, next func() error) error {
    // 只缓存GET请求
    if ctx.Request.Method != "GET" {
        return next()
    }

    cacheKey := ctx.Request.URL.String()

    // 查询缓存
    if cached, ok := p.cache.Get(cacheKey); ok {
        ctx.Response.Write(cached.([]byte))
        return nil
    }

    // 执行请求
    recorder := &ResponseRecorder{ResponseWriter: ctx.Response}
    ctx.Response = recorder

    err := next()

    // 缓存响应
    if err == nil && recorder.statusCode == 200 {
        p.cache.Set(cacheKey, recorder.body.Bytes(), p.ttl)
    }

    return err
}
```

### 四、高可用设计

#### 1. 网关集群部署

```yaml
┌─────────────────────────────────────┐
│      L4负载均衡 (Keepalived VIP)     │
│         Virtual IP: 10.0.0.100      │
└────────┬──────────────┬─────────────┘
         │              │
    ┌────▼────┐    ┌────▼────┐
    │ LVS 1   │    │ LVS 2   │  (主备模式)
    │(Master) │    │(Backup) │
    └────┬────┘    └─────────┘
         │
    ┌────┼─────┬──────────┐
┌───▼──┐ │ ┌───▼──┐  ┌───▼──┐
│GW-1  │ │ │GW-2  │  │GW-3  │  (API网关集群)
└──────┘ │ └──────┘  └──────┘
```

#### 2. 配置热更新

```go
type ConfigWatcher struct {
    etcdClient *clientv3.Client
    router     *Router
}

func (w *ConfigWatcher) Watch() {
    watchChan := w.etcdClient.Watch(context.Background(), "/gateway/routes", clientv3.WithPrefix())

    for resp := range watchChan {
        for _, ev := range resp.Events {
            switch ev.Type {
            case mvccpb.PUT:
                // 新增或更新路由
                var route Route
                json.Unmarshal(ev.Kv.Value, &route)
                w.router.AddRoute(&route)
                log.Printf("Route updated: %s", route.ID)

            case mvccpb.DELETE:
                // 删除路由
                routeID := extractRouteID(string(ev.Kv.Key))
                w.router.RemoveRoute(routeID)
                log.Printf("Route deleted: %s", routeID)
            }
        }
    }
}
```

### 五、性能优化

#### 1. 连接池复用

```go
var httpClient = &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
        DisableKeepAlives:   false,
    },
    Timeout: 5 * time.Second,
}
```

#### 2. 响应缓存

```go
// 使用Redis缓存热点接口响应
type ResponseCache struct {
    redis *redis.Client
}

func (rc *ResponseCache) Get(key string) ([]byte, bool) {
    val, err := rc.redis.Get(context.Background(), key).Bytes()
    if err != nil {
        return nil, false
    }
    return val, true
}

func (rc *ResponseCache) Set(key string, value []byte, ttl time.Duration) {
    rc.redis.Set(context.Background(), key, value, ttl)
}
```

#### 3. 协议优化

```go
// HTTP/2支持
server := &http.Server{
    Addr:    ":443",
    Handler: handler,
    TLSConfig: &tls.Config{
        NextProtos: []string{"h2", "http/1.1"},
    },
}

server.ListenAndServeTLS("cert.pem", "key.pem")
```

### 六、安全防护

#### 1. 防重放攻击

```go
type ReplayProtection struct {
    redis *redis.Client
}

func (rp *ReplayProtection) Check(nonce, timestamp string) bool {
    // 检查时间戳是否在有效期内(5分钟)
    ts, _ := strconv.ParseInt(timestamp, 10, 64)
    if time.Now().Unix()-ts > 300 {
        return false
    }

    // 检查nonce是否已使用
    key := fmt.Sprintf("nonce:%s", nonce)
    set, _ := rp.redis.SetNX(context.Background(), key, 1, 5*time.Minute).Result()

    return set
}
```

#### 2. SQL注入防护

```go
// 参数校验插件
type ValidationPlugin struct {}

func (p *ValidationPlugin) Execute(ctx *Context, next func() error) error {
    for key, values := range ctx.Request.URL.Query() {
        for _, value := range values {
            if containsSQLKeywords(value) {
                return errors.New("potential SQL injection detected")
            }
        }
    }

    return next()
}

func containsSQLKeywords(s string) bool {
    keywords := []string{"SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "UNION"}
    upper := strings.ToUpper(s)

    for _, keyword := range keywords {
        if strings.Contains(upper, keyword) {
            return true
        }
    }

    return false
}
```

### 七、实际案例

**案例:电商平台API网关**

```
规模:
- 日请求量: 10亿次
- 峰值QPS: 50万
- 后端服务: 200+微服务
- 网关节点: 20台

架构:
- 负载均衡: LVS + Keepalived
- 网关: 自研Go网关(基于fasthttp)
- 配置中心: Etcd集群
- 限流存储: Redis集群
- 服务发现: Consul

性能:
- P99延迟: <10ms
- 可用性: 99.99%
- CPU使用率: 60%
- 内存占用: 2GB/实例

成本:
- 服务器: 20台 * $200 = $4,000/月
- Redis: $500/月
- 总计: $4,500/月
```

### 八、总结

设计API网关的核心要点:

1. **路由转发**: 动态路由 + 多种负载均衡策略
2. **认证鉴权**: JWT认证 + RBAC鉴权
3. **流量控制**: 分布式限流 + 熔断降级
4. **插件化**: 责任链模式 + 热插拔
5. **高性能**: 连接池复用 + 响应缓存 + HTTP/2
6. **高可用**: 集群部署 + 配置热更新
7. **安全防护**: 防重放 + 参数校验 + IP黑白名单
8. **监控运维**: 链路追踪 + 日志记录 + 性能监控

**面试加分项**:
- 提及开源网关对比(Kong vs APISIX vs Tyk vs Zuul)
- 讨论服务网格(Service Mesh)与API网关的区别
- 说明WebSocket/gRPC等协议转换
- 讨论灰度发布与A/B测试实现
- 提及GraphQL网关设计
