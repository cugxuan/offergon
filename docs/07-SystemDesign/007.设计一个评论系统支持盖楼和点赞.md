---
title: 设计一个评论系统(支持盖楼和点赞)
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-comment-system-with-threading-and-likes
ref:
---

## 核心要点

**树形存储 vs 扁平存储权衡**:采用**邻接表+路径枚举**混合方案,用`path`字段快速查询子树。**Redis计数器+定时落库**解决高并发点赞,**布隆过滤器**防止点赞状态查询击穿缓存。分页采用**游标分页**避免深度翻页性能问题。

---

## 详细回答

### 一、核心功能需求

**基础功能**:
1. **发表评论**:对文章/视频发表一级评论
2. **回复评论**:对评论进行回复(盖楼),支持多级嵌套
3. **点赞/取消点赞**:对评论点赞,显示点赞数
4. **评论排序**:按时间/热度排序
5. **分页加载**:瀑布流加载评论
6. **删除评论**:软删除,保留"该评论已删除"占位

**高级功能**:
- 查询点赞状态(当前用户是否已点赞)
- @提到某人(mention)
- 评论审核(敏感词过滤、人工审核)
- 热评置顶

**性能指标**:
- 热门文章评论数:10万+
- 点赞QPS:1万+
- 评论列表加载时间:<200ms
- 点赞响应时间:<100ms

---

### 二、数据库设计

#### 1. 评论表结构设计

**方案对比**:

| **方案** | **查询子树** | **插入** | **深度限制** | **适用场景** |
|---------|-----------|---------|-----------|------------|
| 邻接表(parent_id) | 慢(递归查询) | 快O(1) | 无限制 | 简单场景 |
| 路径枚举(path) | 快(LIKE查询) | 快O(1) | 受VARCHAR限制 | **推荐** |
| 嵌套集(左右值) | 快 | 慢(需更新大量节点) | 无限制 | 读多写少 |
| 闭包表(额外关系表) | 快 | 中等 | 无限制 | 复杂层级 |

**最终方案**:邻接表 + 路径枚举混合

```sql
CREATE TABLE comment (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    object_id BIGINT NOT NULL,           -- 评论对象ID(文章ID/视频ID)
    object_type TINYINT NOT NULL,        -- 对象类型(1=文章,2=视频)
    user_id BIGINT NOT NULL,             -- 评论者ID
    parent_id BIGINT DEFAULT 0,          -- 父评论ID(0表示一级评论)
    root_id BIGINT DEFAULT 0,            -- 根评论ID(快速定位评论树)
    content TEXT NOT NULL,               -- 评论内容
    path VARCHAR(1000) DEFAULT '',       -- 路径枚举: "0/123/456/789"
    level TINYINT DEFAULT 1,             -- 评论层级(1=一级,2=二级...)
    reply_count INT DEFAULT 0,           -- 回复数(冗余字段)
    like_count INT DEFAULT 0,            -- 点赞数(冗余字段)
    status TINYINT DEFAULT 1,            -- 状态(1=正常,2=已删除,3=审核中)
    create_time BIGINT NOT NULL,
    update_time BIGINT NOT NULL,

    INDEX idx_object (object_id, object_type, root_id, create_time),
    INDEX idx_user (user_id, create_time),
    INDEX idx_path (object_id, path(100)),  -- 前缀索引
    INDEX idx_parent (parent_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**字段说明**:
- `root_id`: 如果是一级评论,则`root_id=id`;如果是回复,则`root_id=父评论的root_id`
- `path`: 存储从根到当前节点的完整路径,如`"0/123/456/789"`,查询子树时用`WHERE path LIKE '0/123/%'`
- `level`: 限制最大层级(如3层),超过后全部作为同级回复(类似B站)

#### 2. 点赞表设计

```sql
CREATE TABLE comment_like (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    comment_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    status TINYINT DEFAULT 1,            -- 1=已点赞,0=已取消
    create_time BIGINT NOT NULL,
    update_time BIGINT NOT NULL,

    UNIQUE KEY uk_comment_user (comment_id, user_id),
    INDEX idx_user (user_id, create_time)
) ENGINE=InnoDB;
```

**优化**: 使用**UNIQUE KEY**防止重复点赞,点赞/取消点赞用`ON DUPLICATE KEY UPDATE`

```sql
-- 点赞(幂等操作)
INSERT INTO comment_like (comment_id, user_id, status, create_time, update_time)
VALUES (?, ?, 1, ?, ?)
ON DUPLICATE KEY UPDATE status = 1, update_time = ?;

-- 取消点赞
UPDATE comment_like SET status = 0, update_time = ?
WHERE comment_id = ? AND user_id = ?;
```

#### 3. 分库分表策略

**分片键选择**: 按`object_id`分片(评论对象维度)

**原因**:
- 查询评论列表的主场景是"查询某篇文章的所有评论"
- 按`object_id`分片,同一文章的所有评论在同一个库,避免跨库查询

**分表规则**:
```go
func GetShardID(objectID int64) int {
    return int(objectID % 64) // 64个分表
}

// 示例:文章ID=12345的评论存在comment_45表
// 12345 % 64 = 57 → comment_57
```

**点赞表分片**: 按`comment_id % 64`,与评论表保持一致

---

### 三、核心功能实现

#### 1. 发表评论

```go
func CreateComment(req CreateCommentReq) (int64, error) {
    // 1. 参数校验
    if len(req.Content) > 5000 {
        return 0, errors.New("评论内容过长")
    }

    // 2. 敏感词过滤
    if hasSensitiveWord(req.Content) {
        req.Status = 3 // 进入审核状态
    }

    // 3. 构建path和root_id
    var path string
    var rootID int64
    var level int

    if req.ParentID == 0 {
        // 一级评论
        path = "0"
        rootID = 0 // 先设为0,插入后更新为自己的ID
        level = 1
    } else {
        // 回复评论:查询父评论
        parent := getCommentByID(req.ParentID)
        if parent == nil {
            return 0, errors.New("父评论不存在")
        }

        // 限制最大层级
        if parent.Level >= 3 {
            // 超过3层,直接回复到根评论(扁平化)
            path = parent.Path
            level = parent.Level
        } else {
            path = parent.Path + "/" + strconv.FormatInt(parent.ID, 10)
            level = parent.Level + 1
        }

        rootID = parent.RootID
        if rootID == 0 {
            rootID = parent.ID // 父评论本身是根评论
        }
    }

    // 4. 插入数据库
    comment := &Comment{
        ObjectID:   req.ObjectID,
        ObjectType: req.ObjectType,
        UserID:     req.UserID,
        ParentID:   req.ParentID,
        RootID:     rootID,
        Content:    req.Content,
        Path:       path,
        Level:      level,
        CreateTime: time.Now().Unix(),
    }

    db := getShardDB(req.ObjectID)
    result := db.Create(comment)

    // 5. 如果是一级评论,更新root_id为自己的ID
    if req.ParentID == 0 {
        db.Model(&Comment{}).Where("id = ?", comment.ID).
            Updates(map[string]interface{}{
                "root_id": comment.ID,
                "path":    "0/" + strconv.FormatInt(comment.ID, 10),
            })
    }

    // 6. 异步更新父评论的reply_count
    if req.ParentID > 0 {
        go func() {
            db.Model(&Comment{}).Where("id = ?", req.ParentID).
                UpdateColumn("reply_count", gorm.Expr("reply_count + 1"))
        }()
    }

    // 7. 清除缓存
    deleteCommentListCache(req.ObjectID, req.ObjectType)

    return comment.ID, nil
}
```

#### 2. 查询评论列表(盖楼展示)

**展示策略**:
- 一级评论按**热度排序**(点赞数+回复数)
- 每条一级评论展示**前3条热门回复**
- 点击"查看全部XX条回复"展开完整评论树

```go
func GetCommentList(objectID int64, objectType int, cursor string, limit int) ([]CommentVO, string, error) {
    // 1. 查询一级评论(root_id = id表示是根节点)
    var comments []Comment
    db := getShardDB(objectID)

    query := db.Where("object_id = ? AND object_type = ? AND parent_id = 0 AND status = 1",
        objectID, objectType)

    // 游标分页(基于create_time)
    if cursor != "" {
        cursorTime, _ := strconv.ParseInt(cursor, 10, 64)
        query = query.Where("create_time < ?", cursorTime)
    }

    // 按热度排序(点赞数*2 + 回复数)
    query.Order("(like_count * 2 + reply_count) DESC, create_time DESC").
        Limit(limit + 1).Find(&comments)

    // 判断是否有下一页
    hasMore := len(comments) > limit
    if hasMore {
        comments = comments[:limit]
    }

    // 2. 批量查询每条评论的热门回复(前3条)
    commentIDs := make([]int64, len(comments))
    for i, c := range comments {
        commentIDs[i] = c.ID
    }

    var replies []Comment
    db.Where("root_id IN (?) AND parent_id != 0 AND status = 1", commentIDs).
        Order("like_count DESC, create_time DESC").
        Find(&replies)

    // 3. 组装数据
    replyMap := make(map[int64][]Comment)
    for _, reply := range replies {
        replyMap[reply.RootID] = append(replyMap[reply.RootID], reply)
    }

    result := make([]CommentVO, len(comments))
    for i, comment := range comments {
        result[i] = CommentVO{
            Comment:      comment,
            TopReplies:   replyMap[comment.ID][:min(3, len(replyMap[comment.ID]))],
            HasMoreReply: comment.ReplyCount > 3,
        }
    }

    // 4. 返回下一页游标
    var nextCursor string
    if hasMore {
        nextCursor = strconv.FormatInt(comments[len(comments)-1].CreateTime, 10)
    }

    return result, nextCursor, nil
}
```

#### 3. 查询子评论树(展开全部回复)

```go
func GetCommentTree(rootID int64) ([]Comment, error) {
    // 利用path字段查询整个子树
    root := getCommentByID(rootID)
    if root == nil {
        return nil, errors.New("评论不存在")
    }

    var comments []Comment
    db := getShardDB(root.ObjectID)

    // path LIKE '0/123/%' 查询所有子节点
    pathPrefix := root.Path + "/" + strconv.FormatInt(rootID, 10) + "/%"
    db.Where("object_id = ? AND (id = ? OR path LIKE ?) AND status = 1",
        root.ObjectID, rootID, pathPrefix).
        Order("path ASC, create_time ASC"). // 按路径排序保证树形结构
        Find(&comments)

    return comments, nil
}
```

**Path字段示例**:
```
评论ID  Path                 层级  内容
123     0/123                1     "这是一级评论"
456     0/123/456            2     "这是对123的回复"
789     0/123/456/789        3     "这是对456的回复"
```

查询123的所有回复:
```sql
SELECT * FROM comment
WHERE object_id = 10001
  AND (id = 123 OR path LIKE '0/123/%')
ORDER BY path, create_time;
```

---

### 四、点赞功能高并发优化

#### 1. 问题分析

**场景**: 热门评论被1万人同时点赞

**挑战**:
- 每次点赞都写数据库,DB压力大
- 查询"当前用户是否点赞"需要JOIN查询,性能差
- 点赞数实时统计,缓存一致性问题

#### 2. 解决方案:Redis计数器 + 异步落库

```go
// 点赞操作(写Redis)
func LikeComment(commentID, userID int64) error {
    // 1. 检查是否已点赞(布隆过滤器快速判断)
    if bloomFilter.Exists(fmt.Sprintf("like:%d:%d", commentID, userID)) {
        return errors.New("已点赞")
    }

    // 2. 写Redis(原子操作)
    pipe := redis.Pipeline()

    // 点赞集合(记录谁点了赞)
    likeSetKey := fmt.Sprintf("comment:like:set:%d", commentID)
    pipe.SAdd(ctx, likeSetKey, userID)
    pipe.Expire(ctx, likeSetKey, 7*24*time.Hour)

    // 点赞计数
    likeCountKey := fmt.Sprintf("comment:like:count:%d", commentID)
    pipe.Incr(ctx, likeCountKey)
    pipe.Expire(ctx, likeCountKey, 7*24*time.Hour)

    _, err := pipe.Exec(ctx)

    // 3. 异步写入消息队列(削峰)
    if err == nil {
        mq.Send("comment_like", map[string]interface{}{
            "comment_id": commentID,
            "user_id":    userID,
            "action":     "like",
            "timestamp":  time.Now().Unix(),
        })

        // 加入布隆过滤器
        bloomFilter.Add(fmt.Sprintf("like:%d:%d", commentID, userID))
    }

    return err
}

// 消费者:批量落库(每秒处理一批)
func ConsumeLikeEvents() {
    ticker := time.NewTicker(1 * time.Second)
    buffer := make([]LikeEvent, 0, 1000)

    for {
        select {
        case event := <-likeEventChan:
            buffer = append(buffer, event)

            // 缓冲区满或定时触发
            if len(buffer) >= 1000 {
                batchInsertLikes(buffer)
                buffer = buffer[:0]
            }

        case <-ticker.C:
            if len(buffer) > 0 {
                batchInsertLikes(buffer)
                buffer = buffer[:0]
            }
        }
    }
}

// 批量插入(提升性能)
func batchInsertLikes(events []LikeEvent) {
    // 使用ON DUPLICATE KEY UPDATE保证幂等
    sql := `
        INSERT INTO comment_like (comment_id, user_id, status, create_time, update_time)
        VALUES %s
        ON DUPLICATE KEY UPDATE status = 1, update_time = VALUES(update_time)
    `

    values := make([]string, len(events))
    for i, e := range events {
        values[i] = fmt.Sprintf("(%d, %d, 1, %d, %d)",
            e.CommentID, e.UserID, e.Timestamp, e.Timestamp)
    }

    db.Exec(fmt.Sprintf(sql, strings.Join(values, ",")))

    // 更新评论表的like_count(定时任务统一更新,不在这里做)
}
```

#### 3. 点赞数同步策略

**方案A**: 定时任务(每分钟)同步Redis到MySQL
```go
func SyncLikeCount() {
    // 扫描Redis中所有计数器
    keys := redis.Keys("comment:like:count:*")

    for _, key := range keys {
        commentID := parseCommentID(key)
        count := redis.Get(key).Int()

        // 更新数据库
        db.Model(&Comment{}).Where("id = ?", commentID).
            Update("like_count", count)
    }
}
```

**方案B**: 双写策略(实时写Redis + 异步写MySQL)
```go
// 点赞时
redis.Incr("comment:like:count:123")          // 立即生效
mq.Send("update_like_count", commentID: 123)  // 异步更新DB
```

**最终一致性保证**:
- Redis作为**数据源**,MySQL作为**持久化**
- 服务重启时,从MySQL加载到Redis
- Redis故障时,降级查询MySQL

#### 4. 查询点赞状态优化

**问题**: 查询"当前用户对100条评论的点赞状态"

**朴素方案**:
```sql
SELECT comment_id FROM comment_like
WHERE comment_id IN (1,2,3...100) AND user_id = 123 AND status = 1
```

**优化方案**: Redis Bitmap + 布隆过滤器

```go
// 查询用户对一批评论的点赞状态
func GetLikeStatus(userID int64, commentIDs []int64) map[int64]bool {
    result := make(map[int64]bool)

    // 1. 布隆过滤器快速过滤(减少90%查询)
    needCheck := []int64{}
    for _, cid := range commentIDs {
        key := fmt.Sprintf("like:%d:%d", cid, userID)
        if bloomFilter.Exists(key) {
            needCheck = append(needCheck, cid)
        }
    }

    // 2. 批量查询Redis Set
    pipe := redis.Pipeline()
    for _, cid := range needCheck {
        pipe.SIsMember(ctx, fmt.Sprintf("comment:like:set:%d", cid), userID)
    }
    cmds, _ := pipe.Exec(ctx)

    for i, cmd := range cmds {
        result[needCheck[i]] = cmd.(*redis.BoolCmd).Val()
    }

    return result
}
```

**布隆过滤器误判问题**:
- 布隆过滤器说"存在"可能误判(假阳性)
- 布隆过滤器说"不存在"一定正确
- 误判后再查Redis Set确认,不影响正确性

---

### 五、缓存架构设计

#### 1. 多级缓存策略

```
查询评论列表:
本地缓存(10s) → Redis List(5分钟) → MySQL

查询点赞数:
Redis计数器(实时) → MySQL(定时同步)

查询点赞状态:
布隆过滤器(快速过滤) → Redis Set(精确判断) → MySQL(兜底)
```

#### 2. 缓存Key设计

```bash
# 评论列表缓存(按对象ID+排序方式)
comment:list:{object_type}:{object_id}:hot      # 热度排序
comment:list:{object_type}:{object_id}:time     # 时间排序

# 评论详情缓存
comment:info:{comment_id}

# 点赞集合(记录哪些用户点赞了)
comment:like:set:{comment_id}

# 点赞计数
comment:like:count:{comment_id}

# 回复数计数
comment:reply:count:{comment_id}
```

#### 3. 缓存更新策略

**发表评论**: 删除列表缓存(Cache Aside)
```go
func CreateComment(...) {
    // 写入数据库
    db.Create(comment)

    // 删除缓存
    redis.Del(fmt.Sprintf("comment:list:%d:%d:*", objectType, objectID))
}
```

**点赞**: 实时更新Redis,定时同步MySQL
**删除评论**: 软删除,更新缓存中的状态字段

---

### 六、性能优化技巧

#### 1. 深度分页优化

**问题**: `OFFSET 10000 LIMIT 20`需要扫描10020行

**解决方案**: 游标分页(基于上次查询的最后一条记录)
```go
// 第一页
SELECT * FROM comment
WHERE object_id = 123 AND parent_id = 0
ORDER BY create_time DESC LIMIT 20;

// 第二页(传入上次最后一条的create_time)
SELECT * FROM comment
WHERE object_id = 123 AND parent_id = 0
  AND create_time < 1633024800  -- 上次最后一条的时间
ORDER BY create_time DESC LIMIT 20;
```

#### 2. 热评缓存预热

**策略**: 定时任务提前加载热门文章的评论到Redis

```go
func PreloadHotComments() {
    // 获取热门文章列表(阅读量Top100)
    hotArticles := getHotArticles(100)

    for _, article := range hotArticles {
        // 查询评论列表
        comments := getCommentList(article.ID, 1, "", 20)

        // 写入Redis
        key := fmt.Sprintf("comment:list:1:%d:hot", article.ID)
        redis.Set(key, json.Marshal(comments), 5*time.Minute)
    }
}
```

#### 3. 批量查询用户信息

**问题**: 查询100条评论,需要100次查询用户表

**优化**: 批量查询 + 本地缓存
```go
func GetCommentListWithUser(comments []Comment) []CommentVO {
    // 1. 收集所有user_id
    userIDs := make([]int64, len(comments))
    for i, c := range comments {
        userIDs[i] = c.UserID
    }

    // 2. 批量查询(一次SQL)
    users := getUsersByIDs(userIDs) // SELECT * FROM user WHERE id IN (...)

    // 3. 构建Map
    userMap := make(map[int64]User)
    for _, u := range users {
        userMap[u.ID] = u
    }

    // 4. 组装数据
    result := make([]CommentVO, len(comments))
    for i, c := range comments {
        result[i] = CommentVO{
            Comment: c,
            User:    userMap[c.UserID],
        }
    }

    return result
}
```

---

### 七、敏感词过滤与审核

#### 1. 敏感词检测(AC自动机)

```go
import "github.com/cloudflare/ahocorasick"

var acMatcher *ahocorasick.Matcher

func init() {
    // 加载敏感词库
    words := loadSensitiveWords() // ["暴力", "色情", ...]
    acMatcher = ahocorasick.NewStringMatcher(words)
}

func hasSensitiveWord(content string) bool {
    hits := acMatcher.Match([]byte(content))
    return len(hits) > 0
}

// 替换敏感词
func replaceSensitiveWords(content string) string {
    hits := acMatcher.Match([]byte(content))

    runes := []rune(content)
    for _, hit := range hits {
        for i := hit.Pos(); i < hit.Pos()+len(hit.Match()); i++ {
            runes[i] = '*'
        }
    }

    return string(runes)
}
```

**时间复杂度**: O(n),n为文本长度(与敏感词数量无关)

#### 2. 人工审核队列

```go
func CreateComment(req CreateCommentReq) {
    // 机审:检测敏感词
    if hasSensitiveWord(req.Content) {
        req.Status = 3 // 进入人工审核

        // 推送到审核队列
        auditQueue.Push(AuditTask{
            Type:      "comment",
            CommentID: comment.ID,
            Content:   req.Content,
            Priority:  calculatePriority(req.UserID), // VIP用户优先审核
        })
    }
}
```

---

### 八、系统架构图

```
┌─────────┐
│  客户端  │
└────┬────┘
     │
     ▼
┌─────────────┐      ┌──────────────┐
│   API网关    │─────>│  评论服务     │
│  (鉴权/限流) │      │ (业务逻辑)    │
└─────────────┘      └───────┬───────┘
                             │
          ┌──────────────────┼──────────────────┐
          │                  │                  │
          ▼                  ▼                  ▼
    ┌──────────┐      ┌──────────┐      ┌──────────┐
    │  Redis   │      │  MySQL   │      │  消息队列 │
    │(点赞计数) │      │(评论存储) │      │  (Kafka) │
    └──────────┘      └──────────┘      └─────┬────┘
          │                                    │
          │                                    ▼
          │                            ┌──────────────┐
          │                            │  Worker集群   │
          │                            ├──────────────┤
          │                            │ 点赞落库Worker│
          └───────────────────────────>│ 计数同步Worker│
                                       │ 审核Worker   │
                                       └──────────────┘
```

---

### 九、容量评估

**假设**:
- 日活用户:1000万
- 日均评论量:500万条(人均0.5条)
- 日均点赞量:5000万次(人均5次)
- 热门文章评论数:10万条

**QPS**:
- 发表评论:500万 / 86400 ≈ 58 QPS
- 查询评论:1000万 × 10次 / 86400 ≈ 1157 QPS
- 点赞操作:5000万 / 86400 ≈ 579 QPS

**存储**:
- 评论表:每天500万 × 1KB = 5GB/天 → 1.8TB/年
- 点赞表:每天5000万 × 50B = 2.5GB/天 → 900GB/年
- Redis:10万热门评论 × 20条 × 1KB = 2GB

**分表策略**: 64个分表,每表支持单日80万条评论

---

### 十、总结

**设计要点**:
1. **树形结构存储**:邻接表+路径枚举,查询子树性能O(1)
2. **点赞高并发**:Redis计数器+异步落库,支持万级QPS
3. **点赞状态查询**:布隆过滤器+Redis Set,减少90%数据库查询
4. **分页优化**:游标分页避免深度翻页,性能提升10倍
5. **缓存分层**:本地缓存(10s) + Redis(5分钟) + MySQL,命中率99%
6. **软删除**:保留"该评论已删除"占位,维护评论树结构完整性

**技术选型**:
- 数据库:MySQL(分库分表)
- 缓存:Redis(计数器/Set/List)
- 消息队列:Kafka(削峰填谷)
- 敏感词:AC自动机(Aho-Corasick)
