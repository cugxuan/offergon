---
title: 设计一个优惠券系统
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-coupon-system
ref:
---

## 核心要点

**关键挑战**: 高并发抢券、防作弊、计算规则复杂、使用状态管理
**核心方案**: 发券池 + Redis预占 + 规则引擎 + 状态机
**技术选型**: MySQL + Redis + MQ + 规则引擎
**性能指标**: 支持万级QPS、防止超发、毫秒级计算

---

## 详细回答

### 一、业务场景分析

优惠券系统是电商营销的核心工具,需要支持:
- **发券**: 运营创建优惠券活动,设置发放规则
- **领券**: 用户主动领取优惠券(可能高并发抢券)
- **派券**: 系统根据规则自动发放(新人券、生日券等)
- **用券**: 下单时自动计算优惠金额
- **券管理**: 查询我的优惠券、过期提醒等

**典型场景**:
1. **限量抢券**: 10万用户抢1万张满100减20券
2. **新人券**: 新用户注册自动发放
3. **满减券**: 满100减20,满200减50
4. **折扣券**: 8折券,仅限指定品类
5. **红包**: 随机金额红包
6. **优惠码**: 输入兑换码领取

### 二、系统架构设计

#### 2.1 整体架构

```
┌──────────────────────────────────────────┐
│              优惠券系统                    │
│                                          │
│  ┌────────────┐  ┌────────────┐         │
│  │  券模板    │  │  发券池     │         │
│  │  管理      │  │  管理       │         │
│  └────────────┘  └────────────┘         │
│                                          │
│  ┌────────────┐  ┌────────────┐         │
│  │  领券服务  │  │  用券服务   │         │
│  └────────────┘  └────────────┘         │
│                                          │
│  ┌────────────┐  ┌────────────┐         │
│  │ 规则引擎   │  │  状态机     │         │
│  └────────────┘  └────────────┘         │
└──────────────────────────────────────────┘
       │              │              │
       ↓              ↓              ↓
   MySQL          Redis           MQ
```

#### 2.2 核心模块

**1. 券模板管理**
- 创建优惠券模板(满减/折扣/立减等)
- 设置使用规则(时间、品类、用户等限制)
- 券模板审核与上架

**2. 发券池管理**
- 批量生成优惠券码
- 控制发放总量
- 库存管理(已发/未发)

**3. 领券服务**
- 用户主动领取
- 防止重复领取
- 高并发抢券

**4. 用券服务**
- 计算订单优惠金额
- 券可用性校验
- 券核销

**5. 规则引擎**
- 券使用条件判断
- 多券优先级排序
- 优惠金额计算

### 三、数据库设计

```sql
-- 优惠券模板表
CREATE TABLE coupon_template (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL COMMENT '券名称',
    type VARCHAR(32) NOT NULL COMMENT '券类型: FULL_CUT(满减), DISCOUNT(折扣), DIRECT_CUT(立减)',

    -- 优惠规则
    threshold DECIMAL(10,2) DEFAULT 0 COMMENT '门槛金额(满减券)',
    discount_amount DECIMAL(10,2) DEFAULT 0 COMMENT '优惠金额(满减券/立减券)',
    discount_rate DECIMAL(5,2) DEFAULT 0 COMMENT '折扣率(折扣券,如0.8表示8折)',
    max_discount DECIMAL(10,2) DEFAULT 0 COMMENT '最高优惠(折扣券)',

    -- 发放规则
    total_count INT NOT NULL COMMENT '发行总量(-1表示无限)',
    per_user_limit INT DEFAULT 1 COMMENT '每人限领次数',

    -- 使用规则
    valid_days INT DEFAULT 7 COMMENT '有效天数',
    category_limit VARCHAR(255) DEFAULT NULL COMMENT '限制品类(JSON)',
    product_limit VARCHAR(255) DEFAULT NULL COMMENT '限制商品(JSON)',
    user_level_limit VARCHAR(32) DEFAULT NULL COMMENT '用户等级限制',

    -- 时间
    start_time TIMESTAMP NOT NULL COMMENT '活动开始时间',
    end_time TIMESTAMP NOT NULL COMMENT '活动结束时间',

    status VARCHAR(32) NOT NULL DEFAULT 'DRAFT' COMMENT '状态: DRAFT, ACTIVE, EXPIRED, STOPPED',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_status_time (status, start_time, end_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='优惠券模板表';

-- 优惠券发放池表(记录批次)
CREATE TABLE coupon_batch (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    template_id BIGINT NOT NULL COMMENT '模板ID',
    batch_no VARCHAR(64) NOT NULL UNIQUE COMMENT '批次号',
    total_count INT NOT NULL COMMENT '本批次总量',
    issued_count INT NOT NULL DEFAULT 0 COMMENT '已发放数量',
    used_count INT NOT NULL DEFAULT 0 COMMENT '已使用数量',
    status VARCHAR(32) NOT NULL DEFAULT 'ACTIVE' COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_template_id (template_id),
    UNIQUE KEY uk_batch_no (batch_no)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='优惠券批次表';

-- 用户优惠券表(用户持有的券)
CREATE TABLE user_coupon (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    coupon_code VARCHAR(64) NOT NULL UNIQUE COMMENT '券码',
    template_id BIGINT NOT NULL COMMENT '模板ID',
    batch_id BIGINT NOT NULL COMMENT '批次ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',

    -- 状态
    status VARCHAR(32) NOT NULL DEFAULT 'UNUSED' COMMENT '状态: UNUSED, USED, EXPIRED',

    -- 时间
    receive_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '领取时间',
    expire_time TIMESTAMP NOT NULL COMMENT '过期时间',
    use_time TIMESTAMP NULL COMMENT '使用时间',

    -- 使用信息
    order_no VARCHAR(64) DEFAULT NULL COMMENT '订单号',
    discount_amount DECIMAL(10,2) DEFAULT 0 COMMENT '实际优惠金额',

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_status (user_id, status),
    INDEX idx_template_id (template_id),
    INDEX idx_expire_time (expire_time),
    INDEX idx_order_no (order_no),
    UNIQUE KEY uk_coupon_code (coupon_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户优惠券表';

-- 用户领券记录表(防止重复领取)
CREATE TABLE user_coupon_receive_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    template_id BIGINT NOT NULL COMMENT '模板ID',
    receive_count INT NOT NULL DEFAULT 1 COMMENT '领取次数',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_user_template (user_id, template_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户领券记录表';
```

### 四、核心功能实现

#### 4.1 创建优惠券模板

```go
// 优惠券模板
type CouponTemplate struct {
    ID               int64
    Name             string
    Type             string  // FULL_CUT, DISCOUNT, DIRECT_CUT
    Threshold        float64 // 门槛
    DiscountAmount   float64 // 优惠金额
    DiscountRate     float64 // 折扣率
    MaxDiscount      float64 // 最高优惠
    TotalCount       int     // 总量
    PerUserLimit     int     // 每人限领
    ValidDays        int     // 有效天数
    CategoryLimit    string  // 品类限制(JSON)
    ProductLimit     string  // 商品限制(JSON)
    UserLevelLimit   string  // 用户等级限制
    StartTime        time.Time
    EndTime          time.Time
    Status           string
}

// 创建模板
func CreateCouponTemplate(req *CreateTemplateReq) (*CouponTemplate, error) {
    // 1. 校验参数
    if err := validateTemplate(req); err != nil {
        return nil, err
    }

    // 2. 创建模板记录
    template := &CouponTemplate{
        Name:           req.Name,
        Type:           req.Type,
        Threshold:      req.Threshold,
        DiscountAmount: req.DiscountAmount,
        TotalCount:     req.TotalCount,
        PerUserLimit:   req.PerUserLimit,
        ValidDays:      req.ValidDays,
        StartTime:      req.StartTime,
        EndTime:        req.EndTime,
        Status:         "DRAFT",
    }

    err := db.Create(template).Error
    return template, err
}

// 上架模板(开始发放)
func ActivateCouponTemplate(templateID int64) error {
    // 1. 更新状态
    err := db.Model(&CouponTemplate{}).
        Where("id = ? AND status = ?", templateID, "DRAFT").
        Update("status", "ACTIVE").Error

    if err != nil {
        return err
    }

    // 2. 初始化Redis库存
    stockKey := fmt.Sprintf("coupon:stock:%d", templateID)

    // 查询总量
    var template CouponTemplate
    db.First(&template, templateID)

    // 写入Redis
    redis.Set(ctx, stockKey, template.TotalCount, 0)

    return nil
}
```

#### 4.2 领券服务(高并发抢券)

**方案: Redis预占 + 异步发券**

```go
// Lua脚本 - 原子性领券
const receiveCouponScript = `
local stockKey = KEYS[1]
local receiveKey = KEYS[2]
local userID = ARGV[1]
local perUserLimit = tonumber(ARGV[2])

-- 1. 检查库存
local stock = tonumber(redis.call('GET', stockKey))
if not stock or stock <= 0 then
    return -1  -- 库存不足
end

-- 2. 检查用户领取次数
local userReceiveCount = tonumber(redis.call('HGET', receiveKey, userID)) or 0
if userReceiveCount >= perUserLimit then
    return -2  -- 已达领取上限
end

-- 3. 扣减库存
redis.call('DECR', stockKey)

-- 4. 记录用户领取次数
redis.call('HINCRBY', receiveKey, userID, 1)

return 1  -- 成功
`

// 领券
func ReceiveCoupon(ctx context.Context, templateID int64, userID int64) error {
    // 1. 查询模板信息
    template, err := dao.GetCouponTemplate(templateID)
    if err != nil {
        return err
    }

    // 2. 校验活动时间
    now := time.Now()
    if now.Before(template.StartTime) {
        return errors.New("活动未开始")
    }
    if now.After(template.EndTime) {
        return errors.New("活动已结束")
    }

    // 3. 校验活动状态
    if template.Status != "ACTIVE" {
        return errors.New("活动未开启")
    }

    // 4. 执行Lua脚本原子领券
    stockKey := fmt.Sprintf("coupon:stock:%d", templateID)
    receiveKey := fmt.Sprintf("coupon:receive:%d", templateID)

    result, err := redis.Eval(
        ctx,
        receiveCouponScript,
        []string{stockKey, receiveKey},
        userID,
        template.PerUserLimit,
    ).Int()

    if err != nil {
        return err
    }

    if result == -1 {
        return errors.New("券已抢光")
    }

    if result == -2 {
        return errors.New("您已领取过该券")
    }

    // 5. 发送MQ异步发券
    event := &ReceiveCouponEvent{
        TemplateID: templateID,
        UserID:     userID,
        ReceiveTime: time.Now(),
    }

    mq.Publish("coupon.receive", event)

    return nil
}

// MQ消费者 - 异步发券
func ConsumeReceiveCouponEvent(event *ReceiveCouponEvent) {
    // 1. 生成券码
    couponCode := generateCouponCode()

    // 2. 查询模板
    template, _ := dao.GetCouponTemplate(event.TemplateID)

    // 3. 计算过期时间
    expireTime := event.ReceiveTime.AddDate(0, 0, template.ValidDays)

    // 4. 写入用户券表
    userCoupon := &UserCoupon{
        CouponCode:  couponCode,
        TemplateID:  event.TemplateID,
        UserID:      event.UserID,
        Status:      "UNUSED",
        ReceiveTime: event.ReceiveTime,
        ExpireTime:  expireTime,
    }

    err := db.Create(userCoupon).Error
    if err != nil {
        log.Errorf("发券失败: %v", err)
        // 补偿: 恢复Redis库存
        stockKey := fmt.Sprintf("coupon:stock:%d", event.TemplateID)
        redis.Incr(ctx, stockKey)
        return
    }

    // 5. 更新领取记录
    dao.UpdateReceiveLog(event.UserID, event.TemplateID)

    // 6. 发送通知
    notifyUser(event.UserID, "领券成功", userCoupon)
}

// 生成券码
func generateCouponCode() string {
    // 20位唯一券码: 时间戳(10位) + 随机数(10位)
    timestamp := time.Now().Unix()
    random := rand.Intn(10000000000)
    return fmt.Sprintf("%010d%010d", timestamp, random)
}
```

#### 4.3 用券服务(计算优惠)

```go
// 订单信息
type Order struct {
    UserID       int64
    TotalAmount  float64      // 订单总金额
    Items        []*OrderItem // 订单商品
    CouponCodes  []string     // 使用的券码
}

type OrderItem struct {
    ProductID  int64
    CategoryID int64
    Price      float64
    Quantity   int
}

// 计算订单优惠
func CalculateDiscount(order *Order) (*DiscountResult, error) {
    // 1. 查询用户可用券
    availableCoupons := dao.GetUserAvailableCoupons(order.UserID)

    // 2. 过滤可用券(根据规则)
    validCoupons := filterValidCoupons(availableCoupons, order)

    // 3. 计算每张券的优惠金额
    discountResults := make([]*CouponDiscount, 0)
    for _, coupon := range validCoupons {
        discount := calculateCouponDiscount(coupon, order)
        if discount > 0 {
            discountResults = append(discountResults, &CouponDiscount{
                CouponCode:     coupon.CouponCode,
                DiscountAmount: discount,
            })
        }
    }

    // 4. 按优惠金额排序(推荐最优券)
    sort.Slice(discountResults, func(i, j int) bool {
        return discountResults[i].DiscountAmount > discountResults[j].DiscountAmount
    })

    return &DiscountResult{
        TotalAmount:    order.TotalAmount,
        DiscountAmount: discountResults[0].DiscountAmount,
        FinalAmount:    order.TotalAmount - discountResults[0].DiscountAmount,
        RecommendCoupon: discountResults[0].CouponCode,
        AllCoupons:     discountResults,
    }, nil
}

// 过滤可用券
func filterValidCoupons(coupons []*UserCoupon, order *Order) []*UserCoupon {
    result := make([]*UserCoupon, 0)

    for _, coupon := range coupons {
        // 1. 检查状态
        if coupon.Status != "UNUSED" {
            continue
        }

        // 2. 检查过期时间
        if time.Now().After(coupon.ExpireTime) {
            continue
        }

        // 3. 查询模板规则
        template, _ := dao.GetCouponTemplate(coupon.TemplateID)

        // 4. 检查门槛
        if template.Threshold > 0 && order.TotalAmount < template.Threshold {
            continue
        }

        // 5. 检查品类限制
        if template.CategoryLimit != "" {
            if !checkCategoryLimit(template.CategoryLimit, order.Items) {
                continue
            }
        }

        // 6. 检查商品限制
        if template.ProductLimit != "" {
            if !checkProductLimit(template.ProductLimit, order.Items) {
                continue
            }
        }

        result = append(result, coupon)
    }

    return result
}

// 计算单张券优惠金额
func calculateCouponDiscount(coupon *UserCoupon, order *Order) float64 {
    template, _ := dao.GetCouponTemplate(coupon.TemplateID)

    switch template.Type {
    case "FULL_CUT": // 满减券
        if order.TotalAmount >= template.Threshold {
            return template.DiscountAmount
        }
        return 0

    case "DISCOUNT": // 折扣券
        discount := order.TotalAmount * (1 - template.DiscountRate)
        if template.MaxDiscount > 0 && discount > template.MaxDiscount {
            discount = template.MaxDiscount
        }
        return discount

    case "DIRECT_CUT": // 立减券
        return template.DiscountAmount

    default:
        return 0
    }
}

// 核销优惠券
func UseCoupon(couponCode string, orderNo string, actualDiscount float64) error {
    // 1. 查询券
    coupon, err := dao.GetUserCouponByCode(couponCode)
    if err != nil {
        return err
    }

    // 2. 检查状态
    if coupon.Status != "UNUSED" {
        return errors.New("券已使用")
    }

    // 3. 检查过期
    if time.Now().After(coupon.ExpireTime) {
        return errors.New("券已过期")
    }

    // 4. 更新券状态
    err = db.Model(&UserCoupon{}).
        Where("coupon_code = ? AND status = ?", couponCode, "UNUSED").
        Updates(map[string]interface{}{
            "status":          "USED",
            "use_time":        time.Now(),
            "order_no":        orderNo,
            "discount_amount": actualDiscount,
        }).Error

    return err
}
```

#### 4.4 券状态管理

```go
// 优惠券状态流转
/*
UNUSED (未使用)
   ↓
USED (已使用)

OR

UNUSED (未使用)
   ↓
EXPIRED (已过期)
*/

// 定时任务 - 过期券处理
func ExpireCoupons() {
    // 1. 查询已过期但状态还是UNUSED的券
    now := time.Now()

    // 2. 批量更新状态
    err := db.Model(&UserCoupon{}).
        Where("status = ? AND expire_time < ?", "UNUSED", now).
        Update("status", "EXPIRED").Error

    if err != nil {
        log.Errorf("更新过期券失败: %v", err)
    }
}

// 定时任务 - 券过期提醒
func RemindExpiringSoon() {
    // 1. 查询3天内即将过期的券
    startTime := time.Now()
    endTime := startTime.AddDate(0, 0, 3)

    coupons, err := db.Query(`
        SELECT user_id, coupon_code, expire_time
        FROM user_coupon
        WHERE status = 'UNUSED'
        AND expire_time BETWEEN ? AND ?
    `, startTime, endTime)

    if err != nil {
        return
    }

    // 2. 发送提醒
    for _, coupon := range coupons {
        notifyUser(coupon.UserID, "优惠券即将过期", coupon)
    }
}
```

### 五、关键问题与优化

#### 5.1 如何防止超发?

**方案: Redis预占 + 数据库最终校验**

```go
// 发券时双重校验
func ReceiveCouponWithDoubleCheck(templateID, userID int64) error {
    // 1. Redis预占(快速失败)
    stockKey := fmt.Sprintf("coupon:stock:%d", templateID)
    stock, _ := redis.Decr(ctx, stockKey).Result()

    if stock < 0 {
        redis.Incr(ctx, stockKey) // 恢复
        return errors.New("券已抢光")
    }

    // 2. 数据库校验(最终保障)
    var count int
    db.Model(&UserCoupon{}).
        Where("template_id = ?", templateID).
        Count(&count)

    var template CouponTemplate
    db.First(&template, templateID)

    if count >= template.TotalCount {
        // 超发了,恢复Redis
        redis.Incr(ctx, stockKey)
        return errors.New("券已抢光")
    }

    // 3. 发券...
    return nil
}
```

#### 5.2 如何防止羊毛党?

**方案: 多维度防刷**

```go
// 1. IP限流
func checkIPLimit(ip string, templateID int64) error {
    key := fmt.Sprintf("coupon:ip:%s:%d", ip, templateID)
    count, _ := redis.Incr(ctx, key).Result()

    if count == 1 {
        redis.Expire(ctx, key, 1*time.Hour)
    }

    if count > 10 {
        return errors.New("领取过于频繁")
    }

    return nil
}

// 2. 设备指纹限流
func checkDeviceLimit(deviceID string, templateID int64) error {
    key := fmt.Sprintf("coupon:device:%s:%d", deviceID, templateID)
    count, _ := redis.Incr(ctx, key).Result()

    if count == 1 {
        redis.Expire(ctx, key, 24*time.Hour)
    }

    if count > 5 {
        return errors.New("该设备领取次数过多")
    }

    return nil
}

// 3. 用户等级限制
func checkUserLevel(userID int64, template *CouponTemplate) error {
    if template.UserLevelLimit != "" {
        user := dao.GetUser(userID)
        if !matchUserLevel(user.Level, template.UserLevelLimit) {
            return errors.New("用户等级不符合")
        }
    }
    return nil
}

// 4. 风控检测
func checkRisk(userID int64) error {
    // 调用风控系统
    riskScore := riskSystem.CheckUser(userID)

    if riskScore > 0.8 {
        return errors.New("账号异常,请联系客服")
    }

    return nil
}
```

#### 5.3 如何优化查询性能?

**方案: 多级缓存**

```go
// 1. 缓存模板信息
func GetCouponTemplateWithCache(templateID int64) (*CouponTemplate, error) {
    // 尝试从Redis获取
    cacheKey := fmt.Sprintf("coupon:template:%d", templateID)
    data, err := redis.Get(ctx, cacheKey).Result()

    if err == nil {
        // 缓存命中
        var template CouponTemplate
        json.Unmarshal([]byte(data), &template)
        return &template, nil
    }

    // 缓存未命中,从DB查询
    var template CouponTemplate
    err = db.First(&template, templateID).Error
    if err != nil {
        return nil, err
    }

    // 写入缓存(TTL 1小时)
    data, _ = json.Marshal(template)
    redis.Set(ctx, cacheKey, data, 1*time.Hour)

    return &template, nil
}

// 2. 缓存用户券列表
func GetUserCouponsWithCache(userID int64) ([]*UserCoupon, error) {
    cacheKey := fmt.Sprintf("coupon:user:%d", userID)

    // ... 类似逻辑
}

// 3. 使用索引优化查询
/*
CREATE INDEX idx_user_status ON user_coupon(user_id, status);
CREATE INDEX idx_expire_time ON user_coupon(expire_time);
*/
```

#### 5.4 如何处理优惠叠加?

**方案: 规则引擎**

```go
// 优惠叠加策略
type StackStrategy string

const (
    StackNone      StackStrategy = "NONE"      // 不可叠加
    StackSameType  StackStrategy = "SAME_TYPE" // 同类券可叠加
    StackAll       StackStrategy = "ALL"       // 全部可叠加
)

// 券模板增加字段
type CouponTemplate struct {
    // ...
    StackStrategy StackStrategy // 叠加策略
    Priority      int            // 优先级(数字越大优先级越高)
}

// 计算叠加优惠
func CalculateStackedDiscount(order *Order, couponCodes []string) (*DiscountResult, error) {
    // 1. 查询所有券
    coupons := dao.GetUserCouponsByCodes(couponCodes)

    // 2. 校验叠加规则
    if !checkStackRule(coupons) {
        return nil, errors.New("券不可叠加")
    }

    // 3. 按优先级排序
    sort.Slice(coupons, func(i, j int) bool {
        ti, _ := dao.GetCouponTemplate(coupons[i].TemplateID)
        tj, _ := dao.GetCouponTemplate(coupons[j].TemplateID)
        return ti.Priority > tj.Priority
    })

    // 4. 依次计算优惠
    totalDiscount := 0.0
    remainAmount := order.TotalAmount

    for _, coupon := range coupons {
        discount := calculateCouponDiscount(coupon, &Order{
            TotalAmount: remainAmount,
            Items:       order.Items,
        })

        totalDiscount += discount
        remainAmount -= discount
    }

    return &DiscountResult{
        TotalAmount:    order.TotalAmount,
        DiscountAmount: totalDiscount,
        FinalAmount:    remainAmount,
    }, nil
}
```

### 六、性能优化

#### 6.1 数据库优化

```sql
-- 1. 分表(按用户ID哈希)
-- user_coupon_0, user_coupon_1, ... user_coupon_15

-- 2. 归档历史数据
-- 将已使用且超过3个月的券归档到历史表

-- 3. 读写分离
-- 写操作走主库,查询走从库
```

#### 6.2 缓存优化

```go
// 1. 批量查询优化
func GetCouponsInBatch(couponCodes []string) ([]*UserCoupon, error) {
    // 使用Redis Pipeline批量查询
    pipe := redis.Pipeline()
    for _, code := range couponCodes {
        cacheKey := fmt.Sprintf("coupon:code:%s", code)
        pipe.Get(ctx, cacheKey)
    }
    results, _ := pipe.Exec(ctx)
    // ...
}

// 2. 预热热点数据
func WarmupCouponCache() {
    // 秒杀开始前,预热券模板到Redis
}
```

### 七、总结

**核心设计要点**:
1. **模板与实例分离**: 券模板定义规则,用户券是实例
2. **Redis预占**: 高并发抢券场景使用Redis原子操作
3. **异步发券**: 领券成功后异步生成券码,提升性能
4. **规则引擎**: 灵活的券使用规则和叠加策略
5. **状态机管理**: 券的状态流转(未使用→已使用/已过期)

**防超发关键**:
- Redis库存控制
- 数据库最终校验
- 定时对账Redis与DB

**防刷策略**:
- IP/设备限流
- 用户等级限制
- 风控系统检测
- 验证码/短信验证

**面试加分项**:
- 能设计完整的券模板和规则体系
- 能处理高并发抢券场景
- 能设计灵活的优惠计算规则
- 能提出防刷和防超发方案
- 能考虑券叠加、优先级等复杂场景

**实际案例**:
美团、饿了么的优惠券系统支持满减、折扣、立减、红包等多种券类型,并支持品类限制、用户限制等复杂规则,能承载日均千万级的领券和用券请求。
