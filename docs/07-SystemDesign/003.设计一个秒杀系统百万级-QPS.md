---
title: 设计一个秒杀系统（百万级 QPS）
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-million-qps-seckill-system
ref:
---

## 核心要点

**关键技术**: Redis库存预热、消息队列削峰、分布式锁、CDN静态化、令牌桶限流
**性能目标**: 100万QPS峰值、库存准确性100%、用户体验<3秒
**核心挑战**: 超高并发、库存超卖、热点商品、恶意刷单

## 详细设计方案

### 一、系统架构设计

#### 1.1 整体架构
```
                            ┌──────────────┐
                            │   CDN层      │  静态资源
                            └──────┬───────┘
                                   ↓
┌─────────┐     ┌─────────────────────────────────┐
│  用户    │────→│      Nginx集群(100台)           │  接入层
└─────────┘     └─────────┬───────────────────────┘
                          ↓
              ┌──────────────────────────┐
              │   网关层(限流+鉴权)       │  API Gateway
              └─────────┬────────────────┘
                        ↓
         ┌──────────────┼──────────────┐
         ↓              ↓              ↓
    ┌────────┐    ┌────────┐    ┌────────┐
    │秒杀服务│    │订单服务│    │用户服务│  业务层
    └───┬────┘    └───┬────┘    └────────┘
        ↓             ↓
    ┌────────┐    ┌────────┐
    │Redis集群│    │ MQ队列 │              数据层
    └────────┘    └───┬────┘
                      ↓
                 ┌─────────┐
                 │MySQL集群│
                 └─────────┘
```

#### 1.2 分层设计
- **CDN层**: 静态页面/图片缓存,减少源站压力
- **接入层**: Nginx负载均衡,限流熔断
- **网关层**: 统一鉴权、IP黑名单、令牌验证
- **业务层**: 秒杀核心逻辑、库存扣减
- **数据层**: Redis热数据、MQ削峰、MySQL持久化

### 二、核心流程设计

#### 2.1 秒杀前置准备(T-1小时)

**1. 库存预热到Redis**
```go
// 将DB库存加载到Redis
func PreloadStock(productID int64, stock int) {
    // 1. 使用String类型存储库存数量
    redis.Set(fmt.Sprintf("stock:%d", productID), stock)

    // 2. 使用Set存储库存令牌(防止并发扣减误差)
    for i := 0; i < stock; i++ {
        redis.SAdd(fmt.Sprintf("stock:token:%d", productID),
                   uuid.New().String())
    }

    // 3. 设置商品状态
    redis.HSet(fmt.Sprintf("product:%d", productID), map[string]interface{}{
        "status": "ready",
        "start_time": time.Now().Add(1*time.Hour).Unix(),
        "price": 9.9,
    })
}
```

**2. 页面静态化**
```html
<!-- 商品详情页完全静态化,部署到CDN -->
<div id="product-info">
  <img src="https://cdn.com/product.jpg">
  <div id="countdown">距离开始: <span id="timer"></span></div>
  <button id="buy-btn" disabled>立即抢购</button>
</div>

<script>
// JS轮询服务端时间,前端倒计时
setInterval(() => {
  if (serverTime >= startTime) {
    document.getElementById('buy-btn').disabled = false;
  }
}, 100);
</script>
```

**3. 用户token预发放**
```go
// 提前给登录用户发放秒杀令牌
func IssueSecKillToken(userID int64, productID int64) string {
    token := jwt.Sign(map[string]interface{}{
        "user_id": userID,
        "product_id": productID,
        "expire": time.Now().Add(2 * time.Hour).Unix(),
    })

    // 存储到Redis,用于后续验证
    redis.SetEx(fmt.Sprintf("token:%s", token), userID, 7200)
    return token
}
```

#### 2.2 秒杀主流程

**流程图**:
```
用户请求 → 网关限流 → Token验证 → Redis扣库存 → MQ异步下单 → 返回结果
   ↓          ↓          ↓           ↓            ↓
 100万QPS   10万QPS    5万QPS      1万QPS       数据库
```

**核心代码实现**:
```go
func SecKill(ctx context.Context, req *SecKillRequest) (*SecKillResponse, error) {
    // 1. 参数校验
    if req.Token == "" || req.ProductID == 0 {
        return nil, ErrInvalidParam
    }

    // 2. Token验证(防止重放攻击)
    userID, err := validateToken(req.Token)
    if err != nil {
        return nil, ErrInvalidToken
    }

    // 3. 防重复购买(使用Redis SETNX)
    key := fmt.Sprintf("user:buy:%d:%d", userID, req.ProductID)
    ok := redis.SetNX(key, 1, 3600)
    if !ok {
        return nil, ErrAlreadyBought
    }

    // 4. Redis库存扣减(原子操作)
    stock, err := DecrStock(req.ProductID)
    if err != nil || stock < 0 {
        redis.Del(key) // 回滚防重标记
        return nil, ErrStockOut
    }

    // 5. 发送MQ异步创建订单
    msg := OrderMessage{
        UserID:    userID,
        ProductID: req.ProductID,
        Price:     req.Price,
        Timestamp: time.Now().Unix(),
    }
    mq.Publish("order.create", msg)

    // 6. 返回结果
    return &SecKillResponse{
        Success: true,
        Message: "抢购成功,订单生成中...",
    }, nil
}
```

#### 2.3 库存扣减方案(核心)

**方案一: Redis Decr(推荐)**
```go
func DecrStock(productID int64) (int64, error) {
    key := fmt.Sprintf("stock:%d", productID)

    // Lua脚本保证原子性
    script := `
        local stock = redis.call('GET', KEYS[1])
        if tonumber(stock) <= 0 then
            return -1
        end
        return redis.call('DECR', KEYS[1])
    `

    result, err := redis.Eval(script, []string{key}).Int64()
    if err != nil || result < 0 {
        return -1, ErrStockOut
    }

    return result, nil
}
```

**方案二: Redis Set Pop(更安全)**
```go
func DecrStockByToken(productID int64) (string, error) {
    key := fmt.Sprintf("stock:token:%d", productID)

    // 弹出一个库存令牌
    token, err := redis.SPop(key).Result()
    if err == redis.Nil {
        return "", ErrStockOut
    }

    return token, nil // 返回令牌用于幂等性校验
}
```

**方案三: 分段锁(超高并发)**
```go
// 将库存分成100份,减少锁竞争
func DecrStockSharded(productID int64, userID int64) error {
    shardID := userID % 100 // 用户ID取模分片
    key := fmt.Sprintf("stock:%d:shard:%d", productID, shardID)

    stock, err := redis.Decr(key).Result()
    if err != nil || stock < 0 {
        redis.Incr(key) // 回滚
        return ErrStockOut
    }

    return nil
}
```

### 三、限流策略

#### 3.1 多级限流

**Nginx层限流**:
```nginx
# 限制单个IP每秒10个请求
limit_req_zone $binary_remote_addr zone=seckill:10m rate=10r/s;

server {
    location /api/seckill {
        limit_req zone=seckill burst=20 nodelay;
        proxy_pass http://backend;
    }
}
```

**网关层限流(令牌桶)**:
```go
// 全局限流: 100万QPS
globalLimiter := rate.NewLimiter(1_000_000, 2_000_000)

// 商品维度限流
productLimiters := sync.Map{}

func RateLimit(productID int64) bool {
    // 1. 全局限流
    if !globalLimiter.Allow() {
        return false
    }

    // 2. 商品维度限流(每个商品10万QPS)
    limiter, _ := productLimiters.LoadOrStore(productID,
        rate.NewLimiter(100_000, 200_000))

    return limiter.(*rate.Limiter).Allow()
}
```

**用户限流(滑动窗口)**:
```go
// Redis滑动窗口限流: 用户每秒最多3次请求
func UserRateLimit(userID int64) bool {
    now := time.Now().Unix()
    key := fmt.Sprintf("ratelimit:user:%d", userID)

    script := `
        local current = redis.call('ZCARD', KEYS[1])
        if tonumber(current) >= 3 then
            return 0
        end
        redis.call('ZADD', KEYS[1], ARGV[1], ARGV[2])
        redis.call('ZREMRANGEBYSCORE', KEYS[1], 0, ARGV[1]-1)
        redis.call('EXPIRE', KEYS[1], 2)
        return 1
    `

    result, _ := redis.Eval(script, []string{key}, now, uuid.New()).Int()
    return result == 1
}
```

#### 3.2 验证码防刷

```go
// 高频用户触发验证码
func NeedCaptcha(userID int64) bool {
    key := fmt.Sprintf("user:freq:%d", userID)
    count, _ := redis.Incr(key).Result()

    if count == 1 {
        redis.Expire(key, 60) // 1分钟窗口
    }

    return count > 10 // 超过10次触发验证码
}
```

### 四、消息队列设计

#### 4.1 订单创建队列

**消息结构**:
```go
type OrderMessage struct {
    OrderID   string `json:"order_id"`   // 预生成订单ID
    UserID    int64  `json:"user_id"`
    ProductID int64  `json:"product_id"`
    Price     int64  `json:"price"`      // 分为单位
    StockToken string `json:"stock_token"` // 库存令牌(幂等)
    Timestamp int64  `json:"timestamp"`
}
```

**生产者**:
```go
func PublishOrder(msg OrderMessage) error {
    // 使用Kafka保证高吞吐
    partition := msg.UserID % 100 // 按用户分区

    return kafka.Produce("order.create", partition, msg)
}
```

**消费者**:
```go
func ConsumeOrder() {
    // 启动100个消费者并发处理
    for i := 0; i < 100; i++ {
        go func(consumerID int) {
            for msg := range kafka.Consume("order.create") {
                // 1. 幂等性检查
                if isDuplicate(msg.OrderID) {
                    continue
                }

                // 2. 创建订单
                err := db.Transaction(func(tx *gorm.DB) error {
                    // 扣减MySQL库存(兜底)
                    result := tx.Exec(`UPDATE product
                                       SET stock = stock - 1
                                       WHERE id = ? AND stock > 0`,
                                       msg.ProductID)
                    if result.RowsAffected == 0 {
                        return ErrStockOut
                    }

                    // 创建订单记录
                    order := Order{
                        ID:        msg.OrderID,
                        UserID:    msg.UserID,
                        ProductID: msg.ProductID,
                        Price:     msg.Price,
                        Status:    "pending",
                    }
                    return tx.Create(&order).Error
                })

                if err != nil {
                    // 3. 失败补偿: 回滚Redis库存
                    redis.Incr(fmt.Sprintf("stock:%d", msg.ProductID))
                    log.Errorf("create order failed: %v", err)
                }
            }
        }(i)
    }
}
```

### 五、数据库设计

#### 5.1 商品表
```sql
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    price INT,                    -- 价格(分)
    stock INT,                    -- 库存数量
    seckill_stock INT,            -- 秒杀库存(独立字段)
    seckill_start TIMESTAMP,      -- 秒杀开始时间
    seckill_end TIMESTAMP,        -- 秒杀结束时间
    version INT DEFAULT 0,        -- 乐观锁版本号
    created_at TIMESTAMP,
    INDEX idx_seckill_time (seckill_start, seckill_end)
) ENGINE=InnoDB;
```

#### 5.2 订单表(分库分表)
```sql
-- 按user_id取模分256个表
CREATE TABLE order_0 (
    id BIGINT PRIMARY KEY,        -- Snowflake ID
    user_id BIGINT,
    product_id BIGINT,
    price INT,
    status ENUM('pending', 'paid', 'cancel'),
    created_at TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB;

-- order_1 ~ order_255...
```

#### 5.3 库存流水表(幂等)
```sql
CREATE TABLE stock_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT,
    user_id BIGINT,
    stock_token VARCHAR(64) UNIQUE, -- 库存令牌(唯一索引)
    order_id BIGINT,
    change_amount INT,              -- 变更数量(-1)
    created_at TIMESTAMP,
    INDEX idx_product_user (product_id, user_id)
) ENGINE=InnoDB;
```

### 六、高可用设计

#### 6.1 服务高可用
```go
// 熔断器
breaker := gobreaker.NewCircuitBreaker(gobreaker.Settings{
    Name:        "seckill",
    MaxRequests: 100,
    Interval:    time.Second,
    Timeout:     60 * time.Second,
    ReadyToTrip: func(counts gobreaker.Counts) bool {
        failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
        return counts.Requests >= 10 && failureRatio >= 0.6
    },
})

// 降级策略
func SecKillWithFallback(req *SecKillRequest) (*SecKillResponse, error) {
    result, err := breaker.Execute(func() (interface{}, error) {
        return SecKill(context.Background(), req)
    })

    if err != nil {
        // 降级: 返回排队页面
        return &SecKillResponse{
            Success: false,
            Message: "系统繁忙,已加入排队,请稍后查看订单",
        }, nil
    }

    return result.(*SecKillResponse), nil
}
```

#### 6.2 数据一致性

**Redis与MySQL最终一致**:
```go
// 定时任务对账(每分钟执行)
func ReconcileStock() {
    products, _ := db.Query("SELECT id, stock FROM product WHERE seckill_end > NOW()")

    for _, p := range products {
        redisStock, _ := redis.Get(fmt.Sprintf("stock:%d", p.ID)).Int()
        dbStock := p.Stock

        if redisStock != dbStock {
            log.Warnf("stock mismatch: product=%d, redis=%d, db=%d",
                      p.ID, redisStock, dbStock)

            // 以DB为准修复Redis
            redis.Set(fmt.Sprintf("stock:%d", p.ID), dbStock)
        }
    }
}
```

**分布式事务(TCC模式)**:
```go
// Try阶段: 预扣库存
func TryDecr(productID, userID int64) (string, error) {
    token := uuid.New().String()

    // 记录预扣记录
    redis.HSet(fmt.Sprintf("stock:try:%s", token), map[string]interface{}{
        "product_id": productID,
        "user_id":    userID,
        "status":     "try",
        "expire":     time.Now().Add(30 * time.Second).Unix(),
    })

    return token, DecrStock(productID)
}

// Confirm阶段: 确认扣减
func ConfirmDecr(token string) error {
    redis.HSet(fmt.Sprintf("stock:try:%s", token), "status", "confirm")
    return nil
}

// Cancel阶段: 回滚库存
func CancelDecr(token string) error {
    data, _ := redis.HGetAll(fmt.Sprintf("stock:try:%s", token)).Result()
    productID := data["product_id"]

    redis.Incr(fmt.Sprintf("stock:%d", productID))
    redis.Del(fmt.Sprintf("stock:try:%s", token))
    return nil
}
```

### 七、监控告警

#### 7.1 关键指标
```go
type Metrics struct {
    QPS             int64 // 实时QPS
    SuccessRate     float64 // 成功率
    AvgLatency      int64 // 平均延迟(ms)
    P99Latency      int64 // P99延迟
    StockRemain     int64 // 剩余库存
    MQQueueDepth    int64 // MQ堆积量
    RedisHitRate    float64 // Redis命中率
    ErrorRate       float64 // 错误率
}

// Prometheus监控
var (
    seckillQPS = prometheus.NewCounter(prometheus.CounterOpts{
        Name: "seckill_qps_total",
        Help: "Total seckill requests",
    })

    seckillLatency = prometheus.NewHistogram(prometheus.HistogramOpts{
        Name:    "seckill_latency_ms",
        Help:    "Seckill latency distribution",
        Buckets: []float64{10, 50, 100, 500, 1000, 5000},
    })
)
```

#### 7.2 告警规则
```yaml
alerts:
  - name: 高错误率
    condition: error_rate > 0.05
    duration: 1m
    severity: critical
    action: 短信+电话

  - name: 库存异常
    condition: redis_stock != db_stock
    duration: 30s
    severity: high
    action: 企业微信

  - name: MQ堆积
    condition: mq_queue_depth > 100000
    duration: 2m
    severity: medium
    action: 邮件

  - name: 响应慢
    condition: p99_latency > 3000
    duration: 1m
    severity: high
    action: 企业微信
```

### 八、压测与容量规划

#### 8.1 压测方案
```bash
# 使用JMeter压测
jmeter -n -t seckill.jmx \
       -Jthreads=10000 \
       -Jrampup=60 \
       -Jduration=600 \
       -l result.jtl

# 或使用wrk
wrk -t100 -c10000 -d60s \
    --latency \
    -s seckill.lua \
    https://api.seckill.com/api/seckill
```

#### 8.2 容量评估
```
目标: 100万QPS

1. 服务器配置:
   - Nginx: 100台(单机1万QPS) = 100万QPS
   - 业务服务: 200台(单机5000 QPS) = 100万QPS
   - Redis: 10台主从集群(单机10万QPS) = 100万QPS

2. 网络带宽:
   - 请求大小: 1KB
   - 响应大小: 0.5KB
   - 总带宽: 100万 × 1.5KB = 1.5GB/s = 12Gbps

3. 数据库:
   - MySQL: 16主分片(单机1万TPS) = 16万TPS
   - 配置: 64核128GB内存,2TB SSD

4. 消息队列:
   - Kafka: 10个broker,100个partition
   - 吞吐: 单broker 10万/s = 100万/s
```

## 面试回答要点

1. **架构思路**: "秒杀核心是高并发+库存准确性。我采用三层防护:CDN静态化→网关限流→Redis扣库存→MQ异步下单,将100万QPS削减到1万入库"

2. **库存方案**: "推荐Redis Set存储库存令牌,用SPop原子弹出,天然防超卖。或用Lua脚本执行Decr+判断,保证原子性"

3. **限流策略**: "多级限流:Nginx层IP限流→网关层令牌桶→用户层滑动窗口→验证码兜底,逐层过滤恶意流量"

4. **数据一致性**: "Redis内存库存+MySQL持久化双写。MQ消费时再扣DB库存兜底,定时任务对账修复,保证最终一致"

5. **优化点**: "页面静态化CDN、库存分片减少竞争、MQ削峰、订单分库分表、熔断降级、实时监控告警"
