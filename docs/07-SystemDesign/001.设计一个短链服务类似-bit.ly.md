---
title: 设计一个短链服务（类似 bit.ly）
tags:
  - 系统设计
status: robot
class: 系统设计
slug: design-url-shortener-service
ref:
---

## 核心要点

**关键技术**: Base62编码、分布式ID生成、Redis缓存、布隆过滤器、分库分表
**性能目标**: 读写比100:1、毫秒级响应、QPS 10万+
**核心挑战**: 短链唯一性、高并发读、数据持久化、防刷防滥用

## 详细设计方案

### 一、系统架构设计

#### 1.1 整体架构
```
┌─────────┐      ┌─────────────┐      ┌──────────────┐
│ 客户端   │─────→│  API Gateway │─────→│  短链服务    │
└─────────┘      └─────────────┘      └──────────────┘
                                              │
                     ┌────────────────────────┼────────────────────┐
                     ↓                        ↓                    ↓
              ┌─────────────┐        ┌─────────────┐      ┌─────────────┐
              │ Redis缓存   │        │  MySQL分片  │      │ 监控告警    │
              └─────────────┘        └─────────────┘      └─────────────┘
```

#### 1.2 核心模块
- **短链生成模块**: 负责将长URL转换为短链
- **重定向模块**: 根据短链查找原始URL并跳转
- **存储模块**: 持久化短链映射关系
- **缓存模块**: Redis热点数据缓存
- **统计模块**: 访问量、来源等数据统计

### 二、短链生成策略

#### 2.1 Base62编码方案（推荐）

**编码字符集**: `[a-zA-Z0-9]` 共62个字符
**长度设计**: 6位Base62 = 62^6 ≈ 568亿个短链

**生成流程**:
```go
// 1. 使用分布式ID生成器(如Snowflake)生成唯一ID
id := snowflake.Generate() // 如: 1234567890

// 2. 将ID转换为Base62
shortCode := base62.Encode(id) // 如: "dBvJIj"

// 3. 组装短链
shortURL := "https://s.co/" + shortCode
```

**优点**:
- 生成速度快,无需数据库查询
- 全局唯一,无冲突
- 支持分布式部署
- 可根据短码反向计算ID,便于数据分片

#### 2.2 Hash方案(备选)

使用MurmurHash3对长URL进行哈希,取前6位Base62编码

**冲突处理**:
```go
func generateShortCode(longURL string) string {
    suffix := ""
    for {
        hash := murmur3.Hash(longURL + suffix)
        shortCode := base62.Encode(hash)[:6]

        // 使用布隆过滤器快速判断是否存在
        if !bloomFilter.Exists(shortCode) {
            return shortCode
        }
        suffix++ // 冲突则在URL后加盐重试
    }
}
```

### 三、数据库设计

#### 3.1 短链映射表(url_mapping)

```sql
CREATE TABLE url_mapping (
    id BIGINT PRIMARY KEY,              -- Snowflake生成的ID
    short_code VARCHAR(10) UNIQUE,      -- 短链码
    long_url VARCHAR(2048) NOT NULL,    -- 原始长URL
    user_id BIGINT,                     -- 创建用户ID
    expire_at TIMESTAMP,                -- 过期时间
    created_at TIMESTAMP DEFAULT NOW(), -- 创建时间
    INDEX idx_short_code (short_code),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 3.2 分库分表策略

**分片键**: 使用短链的前2位字符进行Hash分片
```go
// 62*62 = 3844个逻辑分片,映射到16个物理库,每库256张表
shardKey := shortCode[:2]
dbIndex := hash(shardKey) % 16
tableIndex := hash(shardKey) % 256
```

**路由算法**:
```go
type ShardRouter struct {
    dbCount    int // 16个数据库
    tableCount int // 每库256张表
}

func (r *ShardRouter) Route(shortCode string) (dbIdx, tableIdx int) {
    key := shortCode[:2]
    hashVal := crc32.ChecksumIEEE([]byte(key))
    dbIdx = int(hashVal % uint32(r.dbCount))
    tableIdx = int(hashVal % uint32(r.tableCount))
    return
}
```

### 四、缓存设计

#### 4.1 Redis缓存策略

**缓存结构**:
```
Key: "short:{shortCode}"
Value: {
    "long_url": "https://example.com/very/long/url",
    "expire_at": 1735660800
}
TTL: 24小时(热点数据) / 1小时(普通数据)
```

**读流程**:
```go
func Redirect(shortCode string) (string, error) {
    // 1. 查询Redis缓存
    if cached := redis.Get("short:" + shortCode); cached != "" {
        return cached, nil
    }

    // 2. 缓存未命中,查询DB
    dbIdx, tableIdx := shardRouter.Route(shortCode)
    longURL := db[dbIdx].QueryTable(tableIdx, shortCode)

    // 3. 写入缓存(异步)
    go redis.SetEx("short:"+shortCode, longURL, 3600)

    return longURL, nil
}
```

#### 4.2 布隆过滤器防穿透

```go
// 启动时加载所有短码到布隆过滤器
bloomFilter := bloom.New(100_000_000, 0.01) // 1亿容量,1%误判率

// 查询前先判断
if !bloomFilter.Test(shortCode) {
    return nil, ErrNotFound // 一定不存在,直接返回
}
```

### 五、高可用设计

#### 5.1 服务高可用
- **多活部署**: 3个以上数据中心,跨地域部署
- **负载均衡**: Nginx/LVS + 一致性哈希
- **限流降级**: 令牌桶限流,超限返回302临时跳转

#### 5.2 数据高可用
- **MySQL主从**: 1主2从,异步复制
- **Redis集群**: 哨兵模式,自动故障转移
- **冷备份**: 每日全量备份到对象存储

#### 5.3 监控告警
```yaml
监控指标:
  - QPS: 实时请求量
  - 延迟: P50/P95/P99响应时间
  - 缓存命中率: 目标>95%
  - 错误率: 4xx/5xx错误占比
  - DB连接池: 活跃连接/等待队列

告警规则:
  - P99延迟>100ms: 警告
  - 缓存命中率<90%: 警告
  - 错误率>1%: 严重
  - DB主从延迟>5s: 严重
```

### 六、性能优化

#### 6.1 写优化
```go
// 批量写入优化
type WriteBatch struct {
    mappings []URLMapping
    mu       sync.Mutex
}

func (b *WriteBatch) Add(mapping URLMapping) {
    b.mu.Lock()
    b.mappings = append(b.mappings, mapping)
    if len(b.mappings) >= 100 { // 达到100条批量提交
        go b.Flush()
    }
    b.mu.Unlock()
}
```

#### 6.2 读优化
- **CDN加速**: 静态资源和302跳转缓存到CDN
- **本地缓存**: 进程内LRU缓存10万条热点数据
- **预热机制**: 定时任务预加载Top 1000热门短链

#### 6.3 数据库优化
```sql
-- 覆盖索引避免回表
CREATE INDEX idx_short_code_url ON url_mapping(short_code, long_url);

-- 分区表按月分区
ALTER TABLE url_mapping PARTITION BY RANGE (UNIX_TIMESTAMP(created_at));
```

### 七、安全防护

#### 7.1 防刷机制
```go
// IP限流: 令牌桶算法
rateLimiter := rate.NewLimiter(100, 1000) // 100 QPS, 突发1000

// 用户限流: 滑动窗口
redis.Eval(`
    local current = redis.call('INCR', KEYS[1])
    if current == 1 then
        redis.call('EXPIRE', KEYS[1], 60)
    end
    return current
`, "user:"+userID)
```

#### 7.2 恶意URL过滤
```go
// 黑名单检测
blacklist := []string{"phishing.com", "malware.net"}

// URL安全扫描(接入第三方服务)
if securityScanner.IsUnsafe(longURL) {
    return ErrUnsafeURL
}
```

#### 7.3 访问控制
- **域名白名单**: 仅允许指定域名创建短链
- **验证码**: 高频操作触发图形验证码
- **账号系统**: OAuth2.0认证,Token鉴权

### 八、数据统计

#### 8.1 实时统计
```go
// 使用Redis HyperLogLog统计UV
redis.PFAdd("uv:"+shortCode+":"+date, userIP)

// 使用Redis计数器统计PV
redis.Incr("pv:"+shortCode+":"+date)
```

#### 8.2 离线分析
```sql
-- 点击日志表
CREATE TABLE click_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    short_code VARCHAR(10),
    ip VARCHAR(45),
    user_agent VARCHAR(512),
    referer VARCHAR(512),
    clicked_at TIMESTAMP,
    INDEX idx_short_code_time (short_code, clicked_at)
) ENGINE=InnoDB;

-- 每日凌晨聚合到统计表
INSERT INTO daily_stats (short_code, click_count, uv_count, stat_date)
SELECT short_code, COUNT(*), COUNT(DISTINCT ip), DATE(clicked_at)
FROM click_log
WHERE clicked_at >= CURDATE() - INTERVAL 1 DAY
GROUP BY short_code, DATE(clicked_at);
```

### 九、扩展功能

#### 9.1 自定义短链
```go
// 允许用户自定义短码(如: s.co/mylink)
func CreateCustomShort(customCode, longURL string) error {
    // 1. 校验自定义码(6-20位字母数字)
    if !regexp.Match(`^[a-zA-Z0-9]{6,20}$`, customCode) {
        return ErrInvalidCode
    }

    // 2. 唯一性检查(使用Redis SETNX)
    ok := redis.SetNX("short:"+customCode, longURL, 0)
    if !ok {
        return ErrCodeExist
    }

    // 3. 写入DB
    return db.Insert(URLMapping{ShortCode: customCode, LongURL: longURL})
}
```

#### 9.2 短链过期回收
```go
// 定时任务每天清理过期短链
func CleanExpiredLinks() {
    db.Exec(`DELETE FROM url_mapping
             WHERE expire_at < NOW()
             LIMIT 10000`)

    // 释放短码到回收池
    recyclePool.Add(shortCodes)
}
```

#### 9.3 二维码生成
```go
import "github.com/skip2/go-qrcode"

func GenerateQRCode(shortURL string) ([]byte, error) {
    return qrcode.Encode(shortURL, qrcode.Medium, 256)
}
```

### 十、容量规划

#### 10.1 存储容量
```
假设:
- 日新增短链: 1000万
- 平均长URL长度: 200字节
- 保存3年

存储需求:
- 短链记录: 1000万 × 365天 × 3年 × 500字节 ≈ 5.5TB
- 点击日志: 1000万 × 100倍 × 365 × 3 × 200字节 ≈ 220TB
- 建议: MySQL 10TB SSD + 对象存储归档
```

#### 10.2 缓存容量
```
热点数据(访问Top 1%):
- 短链数: 1亿 × 1% = 100万
- 缓存大小: 100万 × 500字节 ≈ 500MB
- Redis配置: 8GB内存(预留buffer)
```

#### 10.3 QPS估算
```
峰值QPS计算:
- 日活短链: 1亿
- 平均点击: 10次/天
- 总请求: 10亿/天
- 峰值QPS: 10亿 / 86400 × 3(峰值系数) ≈ 3.5万

服务器配置:
- 单机QPS: 5000(Go服务)
- 需要机器: 35000 / 5000 ≈ 7台(2倍冗余 = 14台)
```

## 面试回答要点

1. **先明确需求**: "我理解这个系统需要将长URL转换为短链,核心是高并发读和数据唯一性,我会从生成算法、存储、缓存三个维度设计"

2. **算法选择**: "我推荐Snowflake ID + Base62编码,优点是无冲突、支持分布式、可反向计算,6位Base62可支持568亿短链"

3. **性能优化**: "读写比约100:1,通过三级缓存优化读:CDN边缘缓存 → Redis集群 → MySQL分片,缓存命中率可达99%"

4. **高可用**: "关键点是无状态服务、数据多副本、故障自动转移,MySQL一主两从+Redis哨兵,可用性99.99%"

5. **扩展性**: "通过短码前缀进行一致性哈希分片,支持动态扩容;预留自定义短链、二维码、数据分析等扩展"
