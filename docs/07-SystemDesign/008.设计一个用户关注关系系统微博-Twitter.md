---
title: 设计一个用户关注关系系统（微博/Twitter）
tags:
  - 系统设计
status: robot
class: 系统设计
slug: user-follow-system-design
ref:
---

## 核心要点

**关注关系双向存储**:同时维护following和followers两张表,空间换时间。**Redis Set实现共同关注**,**布隆过滤器判断关注状态**。采用**推拉结合模式**生成Feed流,**分库分表按user_id哈希**避免热点用户瓶颈。

---

## 详细回答

### 一、核心功能需求

**基础功能**:
1. 关注用户(Follow)
2. 取消关注(Unfollow)
3. 查询关注列表(Following)
4. 查询粉丝列表(Followers)
5. 判断关注关系(A是否关注B)
6. 查询共同关注

**高级功能**:
- 互相关注(互粉)检测
- 关注推荐(基于共同关注)
- 粉丝分组管理
- 悄悄关注(不通知对方)
- 黑名单(拉黑后不能互相关注)

**性能指标**:
- 大V粉丝数:千万级
- 关注/取关QPS:1000+
- 查询关注列表响应:<100ms
- 判断关注关系:<10ms

---

### 二、数据库设计

#### 1. 关系表设计(双向存储)

**方案对比**:

| **方案** | **查粉丝** | **查关注** | **存储成本** | **推荐** |
|---------|----------|----------|-----------|---------|
| 单向存储(user_id, follow_id) | 慢(需索引扫描) | 快 | 低 | ❌ |
| 双向存储(两张表) | 快 | 快 | 中(2倍) | ✅ **推荐** |
| 双向冗余(一张表双记录) | 快 | 快 | 高(2倍+索引) | ❌ |

**最终方案**: 双向存储(空间换时间)

```sql
-- 关注表(Following):记录用户关注了谁
CREATE TABLE user_following (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,              -- 关注者ID
    following_id BIGINT NOT NULL,         -- 被关注者ID
    status TINYINT DEFAULT 1,             -- 1=已关注,0=已取消
    create_time BIGINT NOT NULL,
    update_time BIGINT NOT NULL,

    UNIQUE KEY uk_user_following (user_id, following_id),
    INDEX idx_user_time (user_id, create_time DESC)
) ENGINE=InnoDB;

-- 粉丝表(Followers):记录用户被谁关注
CREATE TABLE user_followers (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,              -- 被关注者ID
    follower_id BIGINT NOT NULL,          -- 粉丝ID
    status TINYINT DEFAULT 1,
    create_time BIGINT NOT NULL,
    update_time BIGINT NOT NULL,

    UNIQUE KEY uk_user_follower (user_id, follower_id),
    INDEX idx_user_time (user_id, create_time DESC)
) ENGINE=InnoDB;

-- 统计表(冗余计数,提升性能)
CREATE TABLE user_relation_count (
    user_id BIGINT PRIMARY KEY,
    following_count INT DEFAULT 0,        -- 关注数
    follower_count INT DEFAULT 0,         -- 粉丝数
    update_time BIGINT NOT NULL,

    INDEX idx_follower_count (follower_count DESC)  -- 大V排行榜
) ENGINE=InnoDB;
```

**设计要点**:
- **UNIQUE KEY**: 防止重复关注
- **双写**: 关注时同时写入`user_following`和`user_followers`
- **计数冗余**: 避免`COUNT(*)`查询,直接读`user_relation_count`表
- **软删除**: `status=0`表示已取消,保留历史记录(用于反作弊)

#### 2. 分库分表策略

**分片键选择**: 按`user_id`分片

**分表规则**:
```go
func GetShardID(userID int64) int {
    return int(userID % 256) // 256个分表
}

// Following表和Followers表使用相同的user_id分片
// 保证查询"某用户的关注列表"和"某用户的粉丝列表"都在同一个库
```

**跨库查询问题**:
- 问题:查询"A的粉丝"需要扫描所有分表(因为follower_id分散)
- 解决:Followers表按`user_id`(被关注者ID)分片,Following表也按`user_id`(关注者ID)分片
- 两张表分片维度不同,互为镜像

**实际方案**:
```
Following表:按user_id分片
  - 查询"用户123关注了谁":只查shard(123)
  - 查询"谁关注了用户456":需要查所有shard(扫全表)

Followers表:按user_id分片
  - 查询"谁关注了用户456":只查shard(456)
  - 查询"用户123关注了谁":需要查所有shard

结论:两张表互补,避免全表扫描
```

---

### 三、核心功能实现

#### 1. 关注操作(事务保证一致性)

```go
func Follow(userID, followingID int64) error {
    // 1. 参数校验
    if userID == followingID {
        return errors.New("不能关注自己")
    }

    // 2. 检查黑名单
    if isBlacklisted(userID, followingID) {
        return errors.New("对方已将你拉黑")
    }

    // 3. 幂等性检查(Redis布隆过滤器)
    key := fmt.Sprintf("follow:%d:%d", userID, followingID)
    if bloomFilter.Exists(key) {
        // 可能已关注,查MySQL确认
        if isFollowing(userID, followingID) {
            return nil // 幂等返回成功
        }
    }

    // 4. 数据库双写(事务)
    tx := db.Begin()

    // 写入Following表
    tx.Exec(`
        INSERT INTO user_following (user_id, following_id, status, create_time, update_time)
        VALUES (?, ?, 1, ?, ?)
        ON DUPLICATE KEY UPDATE status = 1, update_time = ?
    `, userID, followingID, now, now, now)

    // 写入Followers表
    tx.Exec(`
        INSERT INTO user_followers (user_id, follower_id, status, create_time, update_time)
        VALUES (?, ?, 1, ?, ?)
        ON DUPLICATE KEY UPDATE status = 1, update_time = ?
    `, followingID, userID, now, now, now)

    // 更新计数(使用Redis计数器,异步同步到MySQL)
    tx.Exec(`
        UPDATE user_relation_count SET following_count = following_count + 1
        WHERE user_id = ?
    `, userID)

    tx.Exec(`
        UPDATE user_relation_count SET follower_count = follower_count + 1
        WHERE user_id = ?
    `, followingID)

    if err := tx.Commit(); err != nil {
        return err
    }

    // 5. 写入Redis缓存
    pipe := redis.Pipeline()
    pipe.SAdd(ctx, fmt.Sprintf("following:%d", userID), followingID)
    pipe.SAdd(ctx, fmt.Sprintf("followers:%d", followingID), userID)
    pipe.Incr(ctx, fmt.Sprintf("following_count:%d", userID))
    pipe.Incr(ctx, fmt.Sprintf("follower_count:%d", followingID))
    pipe.Exec(ctx)

    // 6. 布隆过滤器标记
    bloomFilter.Add(key)

    // 7. 异步推送通知
    go sendFollowNotification(followingID, userID)

    return nil
}
```

**优化点**:
- **ON DUPLICATE KEY UPDATE**: 保证幂等性
- **布隆过滤器**: 快速判断是否已关注,减少99%的数据库查询
- **Redis计数器**: 实时更新,定时同步到MySQL
- **异步通知**: 关注成功后,推送消息到被关注者

#### 2. 取消关注

```go
func Unfollow(userID, followingID int64) error {
    // 软删除(保留记录用于反作弊分析)
    tx := db.Begin()

    tx.Exec(`
        UPDATE user_following SET status = 0, update_time = ?
        WHERE user_id = ? AND following_id = ?
    `, now, userID, followingID)

    tx.Exec(`
        UPDATE user_followers SET status = 0, update_time = ?
        WHERE user_id = ? AND follower_id = ?
    `, now, followingID, userID)

    tx.Commit()

    // 删除Redis缓存
    redis.SRem(ctx, fmt.Sprintf("following:%d", userID), followingID)
    redis.SRem(ctx, fmt.Sprintf("followers:%d", followingID), userID)
    redis.Decr(ctx, fmt.Sprintf("following_count:%d", userID))
    redis.Decr(ctx, fmt.Sprintf("follower_count:%d", followingID))

    return nil
}
```

#### 3. 查询关注列表(分页优化)

```go
func GetFollowingList(userID int64, cursor string, limit int) ([]User, string, error) {
    // 1. 从Redis读取(Set类型)
    followingIDs := redis.SMembers(ctx, fmt.Sprintf("following:%d", userID)).Val()

    // 2. 缓存未命中,查数据库
    if len(followingIDs) == 0 {
        var relations []UserFollowing
        db := getShardDB(userID)

        query := db.Where("user_id = ? AND status = 1", userID)

        // 游标分页
        if cursor != "" {
            cursorTime, _ := strconv.ParseInt(cursor, 10, 64)
            query = query.Where("create_time < ?", cursorTime)
        }

        query.Order("create_time DESC").Limit(limit + 1).Find(&relations)

        // 提取following_id列表
        for _, r := range relations {
            followingIDs = append(followingIDs, strconv.FormatInt(r.FollowingID, 10))
        }

        // 回写Redis(异步)
        go func() {
            if len(followingIDs) > 0 {
                redis.SAdd(ctx, fmt.Sprintf("following:%d", userID), followingIDs)
                redis.Expire(ctx, fmt.Sprintf("following:%d", userID), 24*time.Hour)
            }
        }()
    }

    // 3. 批量查询用户信息
    users := getUsersByIDs(followingIDs)

    return users, nextCursor, nil
}
```

#### 4. 判断关注关系(高性能)

```go
func IsFollowing(userID, targetID int64) bool {
    // 1. 布隆过滤器快速过滤(假阳性需再次确认)
    key := fmt.Sprintf("follow:%d:%d", userID, targetID)
    if !bloomFilter.Exists(key) {
        return false // 一定未关注
    }

    // 2. 查询Redis Set
    exists := redis.SIsMember(ctx, fmt.Sprintf("following:%d", userID), targetID).Val()
    if exists {
        return true
    }

    // 3. Redis未命中,查MySQL(并回写缓存)
    var count int64
    db := getShardDB(userID)
    db.Model(&UserFollowing{}).
        Where("user_id = ? AND following_id = ? AND status = 1", userID, targetID).
        Count(&count)

    if count > 0 {
        redis.SAdd(ctx, fmt.Sprintf("following:%d", userID), targetID)
        return true
    }

    return false
}

// 批量判断关注关系(优化N+1查询)
func BatchIsFollowing(userID int64, targetIDs []int64) map[int64]bool {
    result := make(map[int64]bool)

    // 从Redis批量查询
    pipe := redis.Pipeline()
    for _, tid := range targetIDs {
        pipe.SIsMember(ctx, fmt.Sprintf("following:%d", userID), tid)
    }
    cmds, _ := pipe.Exec(ctx)

    for i, cmd := range cmds {
        result[targetIDs[i]] = cmd.(*redis.BoolCmd).Val()
    }

    return result
}
```

#### 5. 共同关注(集合交集)

```go
func GetCommonFollowing(userA, userB int64) []User {
    // Redis集合交集运算
    key := fmt.Sprintf("common_following:%d:%d", min(userA, userB), max(userA, userB))

    // 先查缓存
    commonIDs := redis.SMembers(ctx, key).Val()

    if len(commonIDs) == 0 {
        // 计算交集并缓存
        commonIDs = redis.SInter(ctx,
            fmt.Sprintf("following:%d", userA),
            fmt.Sprintf("following:%d", userB),
        ).Val()

        // 缓存5分钟
        if len(commonIDs) > 0 {
            redis.SAdd(ctx, key, commonIDs)
            redis.Expire(ctx, key, 5*time.Minute)
        }
    }

    // 批量查询用户信息
    return getUsersByIDs(commonIDs)
}
```

---

### 四、缓存架构设计

#### 1. Redis数据结构选择

```bash
# 关注列表(Set类型,支持交并集运算)
following:{user_id} -> Set[following_id1, following_id2, ...]
followers:{user_id} -> Set[follower_id1, follower_id2, ...]

# 计数缓存(String类型)
following_count:{user_id} -> 123
follower_count:{user_id} -> 456

# 共同关注缓存(临时Set,5分钟过期)
common_following:{userA}:{userB} -> Set[user_id1, user_id2, ...]

# 布隆过滤器(Bitmap)
follow_bloom_filter -> Bitmap(10亿bit = 120MB)
```

#### 2. 缓存更新策略

**写操作**: 先写MySQL,再写Redis(保证数据不丢失)
**读操作**: 先读Redis,未命中再读MySQL并回写缓存

**一致性保证**:
- 关注/取关操作在事务中完成MySQL双写
- 事务提交后立即更新Redis
- Redis故障时,降级直接查MySQL

#### 3. 缓存预热策略

```go
// 应用启动时,预热热门用户的关注关系
func PreloadHotUsers() {
    // 加载粉丝数Top1000的用户
    var users []UserRelationCount
    db.Order("follower_count DESC").Limit(1000).Find(&users)

    for _, user := range users {
        // 预加载关注列表到Redis
        var followings []UserFollowing
        db.Where("user_id = ? AND status = 1", user.UserID).Find(&followings)

        pipe := redis.Pipeline()
        for _, f := range followings {
            pipe.SAdd(ctx, fmt.Sprintf("following:%d", user.UserID), f.FollowingID)
        }
        pipe.Exec(ctx)
    }
}
```

---

### 五、性能优化方案

#### 1. 大V用户优化

**问题**: 大V有千万粉丝,查询粉丝列表超时

**解决方案**:

**(1) 分段缓存**:
```go
// 将粉丝列表拆分成多个Set(每100万一个)
followers:{user_id}:0 -> Set[前100万粉丝]
followers:{user_id}:1 -> Set[第2个100万]
...

// 查询时分段读取并合并
func GetFollowers(userID int64, page int) []int64 {
    segment := page / 10000 // 每页100条,100万条数据=1万页
    key := fmt.Sprintf("followers:%d:%d", userID, segment)
    return redis.SMembers(ctx, key).Val()
}
```

**(2) 只缓存活跃粉丝**:
```go
// 只将30天内活跃的粉丝加载到Redis
func LoadActiveFollowers(userID int64) {
    activeTime := time.Now().AddDate(0, 0, -30).Unix()

    var followers []UserFollowers
    db.Where("user_id = ? AND status = 1 AND update_time > ?", userID, activeTime).
        Find(&followers)

    for _, f := range followers {
        redis.SAdd(ctx, fmt.Sprintf("followers:%d", userID), f.FollowerID)
    }
}
```

**(3) 异步加载**:
```go
// 查询粉丝列表时,立即返回第一页,后台异步加载后续页
func GetFollowersAsync(userID int64) <-chan []User {
    ch := make(chan []User, 10)

    go func() {
        defer close(ch)
        for page := 0; page < 100; page++ {
            users := loadFollowersPage(userID, page)
            ch <- users
        }
    }()

    return ch
}
```

#### 2. 反作弊策略

**异常行为检测**:
- 短时间内大量关注(限流:每小时最多关注200人)
- 关注后立即取关(频繁操作封号)
- 批量关注机器人账号(模式识别)

```go
func Follow(userID, followingID int64) error {
    // 限流检查(Redis计数器)
    key := fmt.Sprintf("follow_limit:%d", userID)
    count := redis.Incr(ctx, key).Val()

    if count == 1 {
        redis.Expire(ctx, key, 1*time.Hour)
    }

    if count > 200 {
        return errors.New("操作过于频繁,请稍后再试")
    }

    // 检查是否是机器人批量关注
    if isSuspiciousFollowing(userID, followingID) {
        // 标记用户,进入人工审核
        markSuspiciousUser(userID)
        return errors.New("账号异常,已暂停关注功能")
    }

    // 正常关注逻辑...
}

// 检测异常模式:连续关注的账号注册时间相近、昵称相似
func isSuspiciousFollowing(userID int64, targetID int64) bool {
    // 获取用户最近10次关注的用户ID
    recentFollowings := getRecentFollowings(userID, 10)

    // 批量查询这些用户的注册时间
    users := getUsersByIDs(recentFollowings)

    // 计算注册时间方差,如果太小(都在同一天注册),可能是批量注册的机器人
    variance := calculateTimeVariance(users)
    return variance < 86400 // 1天
}
```

---

### 六、关注推荐算法

#### 1. 基于共同关注推荐

```go
func RecommendFollowing(userID int64) []User {
    // 1. 获取用户关注列表
    followings := getFollowingList(userID)

    // 2. 统计二度好友(朋友的朋友)
    candidateMap := make(map[int64]int) // user_id -> 共同关注数

    for _, followingID := range followings {
        // 获取每个关注对象的关注列表
        secondDegree := getFollowingList(followingID)

        for _, candidate := range secondDegree {
            // 排除自己和已关注的人
            if candidate == userID || isFollowing(userID, candidate) {
                continue
            }

            candidateMap[candidate]++
        }
    }

    // 3. 按共同关注数排序
    candidates := sortByValue(candidateMap) // [(userA, 10), (userB, 8), ...]

    // 4. 批量查询用户信息
    return getUsersByIDs(candidates[:20]) // 返回Top20
}
```

**优化**: 使用Redis缓存推荐结果(每天更新一次)

#### 2. 基于行为的推荐

```go
// 推荐浏览过的用户主页但未关注的用户
func RecommendByBehavior(userID int64) []User {
    // 从用户行为日志中提取最近浏览的用户主页
    viewedUsers := getRecentViewedUsers(userID, 30) // 最近30天

    // 过滤掉已关注的
    candidates := []int64{}
    for _, uid := range viewedUsers {
        if !isFollowing(userID, uid) {
            candidates = append(candidates, uid)
        }
    }

    return getUsersByIDs(candidates[:10])
}
```

---

### 七、系统架构图

```
┌──────────┐
│  客户端   │
└─────┬────┘
      │
      ▼
┌─────────────┐       ┌──────────────┐
│  API网关     │──────>│  关注服务     │
│ (限流/鉴权)  │       │ (业务逻辑)    │
└─────────────┘       └──────┬───────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
   ┌──────────┐        ┌──────────┐       ┌──────────┐
   │  Redis   │        │  MySQL   │       │  消息队列 │
   │(关系缓存) │        │(持久化)   │       │ (Kafka)  │
   └──────────┘        └──────────┘       └─────┬────┘
         │                                       │
         │                                       ▼
         │                              ┌──────────────┐
         │                              │  Worker集群   │
         │                              ├──────────────┤
         └─────────────────────────────>│ 计数同步Worker│
                                        │ 推荐Worker   │
                                        │ 反作弊Worker │
                                        └──────────────┘
```

---

### 八、容量评估

**假设**:
- 用户数:1亿
- 日活:2000万
- 平均关注数:200人
- 平均粉丝数:200人
- 日均关注操作:100万次

**QPS**:
- 关注/取关:100万 / 86400 ≈ 12 QPS
- 查询关注列表:2000万 × 5次 / 86400 ≈ 1157 QPS
- 判断关注关系:2000万 × 20次 / 86400 ≈ 4630 QPS

**存储**:
- Following表:1亿用户 × 200关注 × 50B = 1TB
- Followers表:1亿用户 × 200粉丝 × 50B = 1TB
- Redis:1000万活跃用户 × 200关注 × 8B = 16GB
- 布隆过滤器:200亿关系 × 10bit / 8 = 25GB

**分表策略**: 256个分表,每表支持40万用户

---

### 九、总结

**设计要点**:
1. **双向存储**:Following和Followers两张表,查询O(1)
2. **布隆过滤器**:快速判断关注关系,减少99%数据库查询
3. **Redis Set**:集合交集实现共同关注,性能提升100倍
4. **计数冗余**:避免COUNT查询,缓存计数器实时更新
5. **分库分表**:按user_id哈希,支持亿级用户
6. **反作弊**:限流+行为检测,防止批量关注攻击

**技术选型**:
- 数据库:MySQL(分库分表)
- 缓存:Redis(Set/String/Bloom Filter)
- 消息队列:Kafka(异步通知)
- 限流:Redis计数器+滑动窗口
