---
title: 事件驱动架构（Event-Driven Architecture）
tags:
  - 微服务
status: robot
class: 微服务
slug: event-driven-architecture
ref:
---

## 核心要点

**解耦合**:服务间通过事件异步通信,发布者无需知道订阅者,降低耦合度
**可扩展**:新增订阅者无需修改发布者代码,符合开闭原则
**最终一致性**:通过事件传播保证数据最终一致,牺牲强一致性换取高可用
**关键组件**:事件总线(消息队列)、事件存储、事件处理器、补偿机制

---

## 详细回答

### 一、什么是事件驱动架构

事件驱动架构(EDA)是一种以事件作为核心通信机制的架构模式,系统组件通过产生、检测和响应事件来进行交互。

#### 1. 核心概念

**事件(Event)**:
```
系统中已经发生的重要状态变化,使用过去时命名
- UserRegistered (用户已注册)
- OrderCreated (订单已创建)
- PaymentCompleted (支付已完成)
```

**事件vs命令**:
```
命令(Command): 请求执行某个操作 (CreateOrder)
事件(Event): 通知某事已发生 (OrderCreated)
```

#### 2. 基本架构

```
┌──────────────┐
│ Event源      │
│ (发布者)     │  发布事件
└──────┬───────┘
       │
       ▼
┌─────────────────────────────────┐
│   Event Bus (消息中间件)        │
│   - Kafka                       │
│   - RabbitMQ                    │
│   - NATS                        │
└─────────────┬───────────────────┘
              │ 订阅
      ┌───────┼────────┐
      │       │        │
      ▼       ▼        ▼
┌─────────┐ ┌──────┐ ┌───────┐
│消费者A  │ │消费者B│ │消费者C│
│(订阅者) │ │(订阅者)│ │(订阅者)│
└─────────┘ └──────┘ └───────┘
```

---

### 二、事件驱动的实现模式

#### 1. 发布-订阅模式

**事件定义**:

```go
package events

import "time"

// Event 事件接口
type Event interface {
    EventID() string
    EventType() string
    OccurredAt() time.Time
    AggregateID() string  // 聚合根ID
}

// BaseEvent 事件基础结构
type BaseEvent struct {
    ID         string    `json:"id"`
    Type       string    `json:"type"`
    Timestamp  time.Time `json:"timestamp"`
    Aggregate  string    `json:"aggregate_id"`
    Version    int       `json:"version"`
}

func (e *BaseEvent) EventID() string       { return e.ID }
func (e *BaseEvent) EventType() string     { return e.Type }
func (e *BaseEvent) OccurredAt() time.Time { return e.Timestamp }
func (e *BaseEvent) AggregateID() string   { return e.Aggregate }

// 具体事件示例
type UserRegisteredEvent struct {
    BaseEvent
    UserID   int64  `json:"user_id"`
    Email    string `json:"email"`
    Username string `json:"username"`
}

type OrderCreatedEvent struct {
    BaseEvent
    OrderID   string  `json:"order_id"`
    UserID    int64   `json:"user_id"`
    ProductID int64   `json:"product_id"`
    Amount    float64 `json:"amount"`
}
```

**事件发布器**:

```go
package eventbus

import (
    "context"
    "encoding/json"
    "github.com/segmentio/kafka-go"
)

// EventPublisher 事件发布器
type EventPublisher struct {
    writer *kafka.Writer
}

func NewEventPublisher(brokers []string) *EventPublisher {
    return &EventPublisher{
        writer: &kafka.Writer{
            Addr:                   kafka.TCP(brokers...),
            Balancer:               &kafka.LeastBytes{},
            AllowAutoTopicCreation: true,
            Compression:            kafka.Snappy,
        },
    }
}

// Publish 发布事件
func (p *EventPublisher) Publish(ctx context.Context, event Event) error {
    // 序列化事件
    payload, err := json.Marshal(event)
    if err != nil {
        return err
    }

    // 发送到Kafka
    message := kafka.Message{
        Topic: event.EventType(),           // 按事件类型分Topic
        Key:   []byte(event.AggregateID()), // 按聚合根ID分区
        Value: payload,
        Headers: []kafka.Header{
            {Key: "event_id", Value: []byte(event.EventID())},
            {Key: "event_type", Value: []byte(event.EventType())},
        },
    }

    return p.writer.WriteMessages(ctx, message)
}

func (p *EventPublisher) Close() error {
    return p.writer.Close()
}
```

**事件订阅器**:

```go
package eventbus

import (
    "context"
    "encoding/json"
    "github.com/segmentio/kafka-go"
)

// EventHandler 事件处理器接口
type EventHandler interface {
    Handle(ctx context.Context, event Event) error
}

// EventSubscriber 事件订阅器
type EventSubscriber struct {
    reader   *kafka.Reader
    handlers map[string][]EventHandler
}

func NewEventSubscriber(brokers []string, groupID string, topics []string) *EventSubscriber {
    return &EventSubscriber{
        reader: kafka.NewReader(kafka.ReaderConfig{
            Brokers: brokers,
            GroupID: groupID,
            Topic:   topics[0],  // 简化示例,实际可订阅多个topic
            MinBytes: 1e3,  // 1KB
            MaxBytes: 10e6, // 10MB
        }),
        handlers: make(map[string][]EventHandler),
    }
}

// RegisterHandler 注册事件处理器
func (s *EventSubscriber) RegisterHandler(eventType string, handler EventHandler) {
    s.handlers[eventType] = append(s.handlers[eventType], handler)
}

// Start 启动订阅
func (s *EventSubscriber) Start(ctx context.Context) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            // 读取消息
            msg, err := s.reader.ReadMessage(ctx)
            if err != nil {
                continue
            }

            // 获取事件类型
            eventType := string(msg.Topic)

            // 反序列化事件
            var baseEvent BaseEvent
            if err := json.Unmarshal(msg.Value, &baseEvent); err != nil {
                continue
            }

            // 分发给对应的处理器
            handlers := s.handlers[eventType]
            for _, handler := range handlers {
                // 异步处理,避免阻塞
                go func(h EventHandler) {
                    if err := h.Handle(ctx, &baseEvent); err != nil {
                        // 记录错误,可能需要重试
                        log.Errorf("Failed to handle event: %v", err)
                    }
                }(handler)
            }
        }
    }
}

func (s *EventSubscriber) Close() error {
    return s.reader.Close()
}
```

#### 2. 实际应用示例

**用户注册场景**:

```go
package service

import (
    "context"
    "database/sql"
)

// UserService 用户服务
type UserService struct {
    db        *sql.DB
    publisher *EventPublisher
}

// Register 用户注册
func (s *UserService) Register(ctx context.Context, req *RegisterRequest) error {
    // 1. 业务逻辑:创建用户
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    query := `INSERT INTO users (email, username, password_hash) VALUES (?, ?, ?)`
    result, err := tx.ExecContext(ctx, query, req.Email, req.Username, req.PasswordHash)
    if err != nil {
        return err
    }

    userID, _ := result.LastInsertId()

    if err := tx.Commit(); err != nil {
        return err
    }

    // 2. 发布事件:用户已注册
    event := &UserRegisteredEvent{
        BaseEvent: BaseEvent{
            ID:        generateEventID(),
            Type:      "UserRegistered",
            Timestamp: time.Now(),
            Aggregate: fmt.Sprintf("user:%d", userID),
            Version:   1,
        },
        UserID:   userID,
        Email:    req.Email,
        Username: req.Username,
    }

    // 异步发布,不阻塞主流程
    go func() {
        if err := s.publisher.Publish(context.Background(), event); err != nil {
            log.Errorf("Failed to publish UserRegistered event: %v", err)
        }
    }()

    return nil
}
```

**订阅者:发送欢迎邮件**:

```go
package handlers

type WelcomeEmailHandler struct {
    emailService *EmailService
}

func (h *WelcomeEmailHandler) Handle(ctx context.Context, event Event) error {
    // 类型断言
    userEvent, ok := event.(*UserRegisteredEvent)
    if !ok {
        return fmt.Errorf("invalid event type")
    }

    // 发送欢迎邮件
    return h.emailService.SendWelcomeEmail(ctx, userEvent.Email, userEvent.Username)
}

// 注册处理器
subscriber.RegisterHandler("UserRegistered", &WelcomeEmailHandler{
    emailService: emailService,
})
```

**订阅者:赠送新人积分**:

```go
package handlers

type NewUserPointsHandler struct {
    pointService *PointService
}

func (h *NewUserPointsHandler) Handle(ctx context.Context, event Event) error {
    userEvent, ok := event.(*UserRegisteredEvent)
    if !ok {
        return fmt.Errorf("invalid event type")
    }

    // 赠送100积分
    return h.pointService.AddPoints(ctx, userEvent.UserID, 100, "新用户注册奖励")
}

// 注册处理器
subscriber.RegisterHandler("UserRegistered", &NewUserPointsHandler{
    pointService: pointService,
})
```

---

### 三、Event Sourcing(事件溯源)

事件溯源是将应用状态的所有变更存储为事件序列,而不是直接存储当前状态。

#### 1. 核心理念

```
传统模式: 存储最终状态
users表: id=1, balance=500

Event Sourcing: 存储所有事件
- UserCreated: balance=0
- DepositCompleted: +1000
- PaymentCompleted: -500
→ 当前余额 = 0 + 1000 - 500 = 500
```

#### 2. 实现示例

**事件存储**:

```go
package eventsourcing

type EventStore interface {
    SaveEvent(ctx context.Context, event Event) error
    GetEvents(ctx context.Context, aggregateID string) ([]Event, error)
}

// PostgreSQL实现
type PostgreSQLEventStore struct {
    db *sql.DB
}

func (s *PostgreSQLEventStore) SaveEvent(ctx context.Context, event Event) error {
    payload, _ := json.Marshal(event)

    query := `
        INSERT INTO event_store (
            event_id, event_type, aggregate_id, version, payload, occurred_at
        ) VALUES (?, ?, ?, ?, ?, ?)
    `
    _, err := s.db.ExecContext(ctx, query,
        event.EventID(),
        event.EventType(),
        event.AggregateID(),
        event.Version(),
        payload,
        event.OccurredAt(),
    )
    return err
}

func (s *PostgreSQLEventStore) GetEvents(ctx context.Context, aggregateID string) ([]Event, error) {
    query := `
        SELECT event_id, event_type, payload, occurred_at
        FROM event_store
        WHERE aggregate_id = ?
        ORDER BY version ASC
    `

    rows, err := s.db.QueryContext(ctx, query, aggregateID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var events []Event
    for rows.Next() {
        var eventID, eventType string
        var payload []byte
        var occurredAt time.Time

        rows.Scan(&eventID, &eventType, &payload, &occurredAt)

        // 根据事件类型反序列化
        event := deserializeEvent(eventType, payload)
        events = append(events, event)
    }

    return events, nil
}

// 事件存储表设计
/*
CREATE TABLE event_store (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_id VARCHAR(64) NOT NULL UNIQUE,
    event_type VARCHAR(64) NOT NULL,
    aggregate_id VARCHAR(64) NOT NULL,
    version INT NOT NULL,
    payload JSON NOT NULL,
    occurred_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_aggregate_version (aggregate_id, version),
    UNIQUE KEY uk_aggregate_version (aggregate_id, version)
);
*/
```

**聚合根状态重建**:

```go
package domain

// Account 账户聚合根
type Account struct {
    ID      string
    Balance float64
    Version int
    events  []Event  // 未提交的事件
}

// NewAccountFromEvents 从事件重建账户状态
func NewAccountFromEvents(events []Event) *Account {
    account := &Account{ID: events[0].AggregateID()}

    for _, event := range events {
        account.Apply(event)
    }

    return account
}

// Apply 应用事件到聚合根
func (a *Account) Apply(event Event) {
    switch e := event.(type) {
    case *AccountCreatedEvent:
        a.ID = e.AccountID
        a.Balance = e.InitialBalance
        a.Version = e.Version

    case *DepositCompletedEvent:
        a.Balance += e.Amount
        a.Version = e.Version

    case *WithdrawalCompletedEvent:
        a.Balance -= e.Amount
        a.Version = e.Version
    }
}

// Deposit 存款
func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return fmt.Errorf("invalid amount")
    }

    // 创建事件
    event := &DepositCompletedEvent{
        BaseEvent: BaseEvent{
            ID:        generateEventID(),
            Type:      "DepositCompleted",
            Timestamp: time.Now(),
            Aggregate: a.ID,
            Version:   a.Version + 1,
        },
        Amount: amount,
    }

    // 应用事件到本地状态
    a.Apply(event)

    // 记录未提交的事件
    a.events = append(a.events, event)

    return nil
}

// Withdraw 取款
func (a *Account) Withdraw(amount float64) error {
    if amount <= 0 {
        return fmt.Errorf("invalid amount")
    }

    if a.Balance < amount {
        return fmt.Errorf("insufficient balance")
    }

    event := &WithdrawalCompletedEvent{
        BaseEvent: BaseEvent{
            ID:        generateEventID(),
            Type:      "WithdrawalCompleted",
            Timestamp: time.Now(),
            Aggregate: a.ID,
            Version:   a.Version + 1,
        },
        Amount: amount,
    }

    a.Apply(event)
    a.events = append(a.events, event)

    return nil
}

// GetUncommittedEvents 获取未提交的事件
func (a *Account) GetUncommittedEvents() []Event {
    return a.events
}

// ClearUncommittedEvents 清空未提交的事件
func (a *Account) ClearUncommittedEvents() {
    a.events = nil
}
```

**仓储层**:

```go
package repository

type AccountRepository struct {
    eventStore EventStore
}

// Save 保存账户(保存事件)
func (r *AccountRepository) Save(ctx context.Context, account *Account) error {
    // 获取未提交的事件
    events := account.GetUncommittedEvents()

    // 保存到事件存储
    for _, event := range events {
        if err := r.eventStore.SaveEvent(ctx, event); err != nil {
            return err
        }
    }

    // 清空未提交事件
    account.ClearUncommittedEvents()

    return nil
}

// GetByID 获取账户(从事件重建)
func (r *AccountRepository) GetByID(ctx context.Context, accountID string) (*Account, error) {
    // 从事件存储获取所有事件
    events, err := r.eventStore.GetEvents(ctx, accountID)
    if err != nil {
        return nil, err
    }

    if len(events) == 0 {
        return nil, fmt.Errorf("account not found")
    }

    // 从事件重建账户状态
    return NewAccountFromEvents(events), nil
}
```

#### 3. Event Sourcing + CQRS

通常结合CQRS(命令查询职责分离)使用:

```
写模型(Command): 存储事件到Event Store
读模型(Query): 监听事件更新物化视图

┌─────────────┐
│ Command     │ 写入
│ (Event Store)│ ──────┐
└─────────────┘        │
                       │ 事件流
                       ▼
┌─────────────┐   ┌──────────────┐
│ Event Bus   │──→│ Event Handler│
└─────────────┘   └──────┬───────┘
                         │ 更新
                         ▼
                  ┌──────────────┐
                  │ Read Model   │  查询优化
                  │ (物化视图)    │
                  └──────────────┘
```

---

### 四、事件驱动的优缺点

#### 优点

```
✅ 服务解耦: 发布者和订阅者无需直接依赖
✅ 可扩展性: 新增订阅者不影响现有系统
✅ 弹性: 订阅者失败不影响发布者
✅ 审计追溯: Event Sourcing保留完整历史
✅ 时间旅行: 可重放事件到任意时间点
✅ 异步处理: 提升系统吞吐量
```

#### 缺点

```
❌ 最终一致性: 数据同步有延迟
❌ 调试困难: 异步链路追踪复杂
❌ 事件顺序: 需处理乱序和重复
❌ Schema演进: 事件结构变更需兼容
❌ 运维复杂: 需维护消息队列
❌ 数据膨胀: Event Store数据增长快
```

---

### 五、事件驱动的最佳实践

#### 1. 事件设计原则

```
✅ 使用过去时命名: UserRegistered, OrderCreated
✅ 包含完整上下文: 事件应携带足够信息,订阅者无需回查
✅ 不可变: 事件发布后不应修改
✅ 幂等性: 处理器需支持重复消费
✅ 版本化: 预留版本字段,支持Schema演进
```

#### 2. 事件Schema演进

```go
// V1版本
type UserRegisteredEventV1 struct {
    BaseEvent
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
}

// V2版本: 新增Email字段
type UserRegisteredEventV2 struct {
    BaseEvent
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    Email    string `json:"email,omitempty"`  // 兼容V1
}

// 订阅者兼容处理
func (h *Handler) Handle(ctx context.Context, event Event) error {
    switch event.Version() {
    case 1:
        // 处理V1事件
        return h.handleV1(ctx, event)
    case 2:
        // 处理V2事件
        return h.handleV2(ctx, event)
    default:
        return fmt.Errorf("unsupported version")
    }
}
```

#### 3. 幂等性保证

```go
type EventHandler struct {
    db *sql.DB
}

func (h *EventHandler) Handle(ctx context.Context, event Event) error {
    // 检查事件是否已处理
    processed, err := h.isEventProcessed(ctx, event.EventID())
    if err != nil {
        return err
    }
    if processed {
        // 已处理,直接返回
        return nil
    }

    // 开启事务
    tx, err := h.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 业务逻辑
    if err := h.processEvent(ctx, tx, event); err != nil {
        return err
    }

    // 标记事件已处理(同一事务)
    query := `INSERT INTO processed_events (event_id, processed_at) VALUES (?, NOW())`
    if _, err := tx.ExecContext(ctx, query, event.EventID()); err != nil {
        return err
    }

    return tx.Commit()
}
```

#### 4. Dead Letter Queue(死信队列)

```go
func (h *EventHandler) Handle(ctx context.Context, event Event) error {
    maxRetries := 3

    for attempt := 0; attempt < maxRetries; attempt++ {
        err := h.processEvent(ctx, event)
        if err == nil {
            return nil
        }

        // 指数退避
        time.Sleep(time.Duration(math.Pow(2, float64(attempt))) * time.Second)
    }

    // 重试失败,发送到死信队列
    return h.sendToDeadLetterQueue(ctx, event, "max retries exceeded")
}

func (h *EventHandler) sendToDeadLetterQueue(ctx context.Context, event Event, reason string) error {
    dlqEvent := DeadLetterEvent{
        OriginalEvent: event,
        Reason:        reason,
        FailedAt:      time.Now(),
        RetryCount:    3,
    }

    return h.dlqPublisher.Publish(ctx, "dead-letter-queue", dlqEvent)
}
```

---

### 六、常用工具和框架

| 工具 | 类型 | 特点 |
|------|------|------|
| **Kafka** | 消息队列 | 高吞吐、持久化、分区 |
| **RabbitMQ** | 消息队列 | 灵活路由、死信队列 |
| **NATS** | 消息队列 | 轻量级、高性能 |
| **EventStoreDB** | 事件存储 | 专为Event Sourcing设计 |
| **Axon** | 框架 | Java CQRS+ES框架 |
| **EventFlow** | 框架 | .NET CQRS+ES框架 |
| **go-cqrs** | 框架 | Go CQRS+ES框架 |

---

### 七、事件驱动架构适用场景

#### 适合场景

```
✅ 微服务间解耦通信
✅ 审计和溯源要求高(金融、医疗)
✅ 需要时间旅行功能(回溯历史状态)
✅ 复杂业务流程(订单、工作流)
✅ 需要高可扩展性
✅ 异步处理场景(邮件、通知)
```

#### 不适合场景

```
❌ 强一致性要求(如库存扣减)
❌ 简单CRUD操作
❌ 实时性要求高(毫秒级响应)
❌ 团队缺乏异步编程经验
❌ 数据量小的单体应用
```

---

### 八、总结

事件驱动架构通过异步事件实现服务解耦,是构建大规模分布式系统的重要模式。结合Event Sourcing和CQRS,可以构建具备审计追溯、高扩展性的系统。但也需要处理最终一致性、事件顺序等复杂问题,需根据业务特点权衡使用。
