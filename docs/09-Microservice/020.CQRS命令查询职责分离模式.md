---
title: CQRS（命令查询职责分离）模式
tags:
  - 微服务
status: robot
class: 微服务
slug: cqrs-command-query-responsibility-segregation
ref:
---

## 核心要点

**职责分离**:将数据的读(Query)和写(Command)操作分离到不同的模型,优化各自性能
**读写分离**:写模型保证一致性,读模型优化查询性能,使用不同的数据存储
**最终一致性**:通过事件同步读写模型,牺牲强一致性换取高性能和可扩展性
**适用场景**:复杂业务逻辑、高并发读写比差异大、需要多视图展示的系统

---

## 详细回答

### 一、CQRS的核心概念

CQRS (Command Query Responsibility Segregation) 是一种将系统的命令(修改数据)和查询(读取数据)职责分离的架构模式。

#### 1. 传统CRUD vs CQRS

**传统CRUD**:
```
┌────────────┐
│  应用层     │
└─────┬──────┘
      │ 读写共用
      ▼
┌────────────┐
│  数据模型   │
└─────┬──────┘
      │
      ▼
┌────────────┐
│  数据库     │
└────────────┘
```

**CQRS模式**:
```
┌─────────────┐         ┌──────────────┐
│ Command     │         │ Query        │
│ (写操作)     │         │ (读操作)      │
└──────┬──────┘         └──────┬───────┘
       │                       │
       ▼                       ▼
┌──────────────┐      ┌────────────────┐
│ Write Model  │──────│ Read Model     │
│ (Domain)     │ 事件 │ (View/DTO)     │
└──────┬───────┘      └────────┬───────┘
       │                       │
       ▼                       ▼
┌──────────────┐      ┌────────────────┐
│ 写数据库      │      │ 读数据库        │
│ (MySQL)      │      │ (Redis/ES)     │
└──────────────┘      └────────────────┘
```

#### 2. 命令(Command)与查询(Query)

**命令(Command)**:
```go
// 命令:改变系统状态的操作
type CreateOrderCommand struct {
    OrderID   string
    UserID    int64
    ProductID int64
    Quantity  int
    Amount    float64
}

type UpdateOrderStatusCommand struct {
    OrderID string
    Status  string
}
```

**查询(Query)**:
```go
// 查询:不改变系统状态,只返回数据
type GetOrderQuery struct {
    OrderID string
}

type ListUserOrdersQuery struct {
    UserID   int64
    Page     int
    PageSize int
}
```

---

### 二、CQRS实现示例

#### 1. 命令端实现

**命令处理器**:

```go
package command

import (
    "context"
    "database/sql"
)

// CommandBus 命令总线
type CommandBus interface {
    Dispatch(ctx context.Context, cmd Command) error
}

// Command 命令接口
type Command interface {
    CommandName() string
}

// CommandHandler 命令处理器接口
type CommandHandler interface {
    Handle(ctx context.Context, cmd Command) error
}

// CreateOrderCommand 创建订单命令
type CreateOrderCommand struct {
    OrderID   string
    UserID    int64
    ProductID int64
    Quantity  int
    Amount    float64
}

func (c *CreateOrderCommand) CommandName() string {
    return "CreateOrder"
}

// CreateOrderHandler 创建订单处理器
type CreateOrderHandler struct {
    db            *sql.DB
    eventPublisher EventPublisher
}

func (h *CreateOrderHandler) Handle(ctx context.Context, cmd Command) error {
    createCmd, ok := cmd.(*CreateOrderCommand)
    if !ok {
        return fmt.Errorf("invalid command type")
    }

    // 1. 业务逻辑验证
    if err := h.validateOrder(ctx, createCmd); err != nil {
        return err
    }

    // 2. 开启事务
    tx, err := h.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 3. 写入写模型(规范化设计)
    orderQuery := `
        INSERT INTO orders (order_id, user_id, status, created_at)
        VALUES (?, ?, 'PENDING', NOW())
    `
    _, err = tx.ExecContext(ctx, orderQuery, createCmd.OrderID, createCmd.UserID)
    if err != nil {
        return err
    }

    itemQuery := `
        INSERT INTO order_items (order_id, product_id, quantity, price)
        VALUES (?, ?, ?, ?)
    `
    _, err = tx.ExecContext(ctx, itemQuery,
        createCmd.OrderID,
        createCmd.ProductID,
        createCmd.Quantity,
        createCmd.Amount,
    )
    if err != nil {
        return err
    }

    // 4. 提交事务
    if err := tx.Commit(); err != nil {
        return err
    }

    // 5. 发布事件(异步更新读模型)
    event := &OrderCreatedEvent{
        OrderID:   createCmd.OrderID,
        UserID:    createCmd.UserID,
        ProductID: createCmd.ProductID,
        Quantity:  createCmd.Quantity,
        Amount:    createCmd.Amount,
        CreatedAt: time.Now(),
    }

    go h.eventPublisher.Publish(ctx, event)

    return nil
}

func (h *CreateOrderHandler) validateOrder(ctx context.Context, cmd *CreateOrderCommand) error {
    // 业务规则验证
    if cmd.Quantity <= 0 {
        return fmt.Errorf("invalid quantity")
    }
    if cmd.Amount <= 0 {
        return fmt.Errorf("invalid amount")
    }
    return nil
}
```

**写模型数据库设计**:
```sql
-- 写模型:规范化设计,保证数据一致性
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL UNIQUE,
    user_id BIGINT NOT NULL,
    status VARCHAR(32) NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_user_id (user_id)
);

CREATE TABLE order_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    INDEX idx_order_id (order_id),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);
```

#### 2. 查询端实现

**查询处理器**:

```go
package query

import (
    "context"
    "encoding/json"
    "github.com/go-redis/redis/v8"
)

// QueryBus 查询总线
type QueryBus interface {
    Execute(ctx context.Context, query Query) (interface{}, error)
}

// Query 查询接口
type Query interface {
    QueryName() string
}

// QueryHandler 查询处理器接口
type QueryHandler interface {
    Handle(ctx context.Context, query Query) (interface{}, error)
}

// GetOrderQuery 获取订单查询
type GetOrderQuery struct {
    OrderID string
}

func (q *GetOrderQuery) QueryName() string {
    return "GetOrder"
}

// OrderView 订单视图(读模型)
type OrderView struct {
    OrderID     string    `json:"order_id"`
    UserID      int64     `json:"user_id"`
    UserName    string    `json:"user_name"`     // 反规范化:冗余用户名
    ProductID   int64     `json:"product_id"`
    ProductName string    `json:"product_name"`  // 反规范化:冗余产品名
    Quantity    int       `json:"quantity"`
    TotalAmount float64   `json:"total_amount"`  // 反规范化:计算好的总价
    Status      string    `json:"status"`
    CreatedAt   time.Time `json:"created_at"`
}

// GetOrderHandler 获取订单处理器
type GetOrderHandler struct {
    redis *redis.Client
    db    *sql.DB  // 作为缓存未命中时的fallback
}

func (h *GetOrderHandler) Handle(ctx context.Context, query Query) (interface{}, error) {
    getQuery, ok := query.(*GetOrderQuery)
    if !ok {
        return nil, fmt.Errorf("invalid query type")
    }

    // 1. 优先从Redis读取(读模型缓存)
    key := fmt.Sprintf("order:%s", getQuery.OrderID)
    cached, err := h.redis.Get(ctx, key).Result()
    if err == nil {
        var view OrderView
        if err := json.Unmarshal([]byte(cached), &view); err == nil {
            return &view, nil
        }
    }

    // 2. Redis未命中,从读模型数据库查询
    view, err := h.getOrderFromReadDB(ctx, getQuery.OrderID)
    if err != nil {
        return nil, err
    }

    // 3. 写入缓存
    data, _ := json.Marshal(view)
    h.redis.Set(ctx, key, data, 1*time.Hour)

    return view, nil
}

func (h *GetOrderHandler) getOrderFromReadDB(ctx context.Context, orderID string) (*OrderView, error) {
    // 从读模型查询(反规范化的宽表)
    query := `
        SELECT order_id, user_id, user_name, product_id, product_name,
               quantity, total_amount, status, created_at
        FROM order_view
        WHERE order_id = ?
    `

    var view OrderView
    err := h.db.QueryRowContext(ctx, query, orderID).Scan(
        &view.OrderID,
        &view.UserID,
        &view.UserName,
        &view.ProductID,
        &view.ProductName,
        &view.Quantity,
        &view.TotalAmount,
        &view.Status,
        &view.CreatedAt,
    )

    return &view, err
}
```

**读模型数据库设计**:
```sql
-- 读模型:反规范化设计,优化查询性能
CREATE TABLE order_view (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL UNIQUE,
    user_id BIGINT NOT NULL,
    user_name VARCHAR(128),          -- 冗余字段
    product_id BIGINT NOT NULL,
    product_name VARCHAR(256),       -- 冗余字段
    product_image_url VARCHAR(512),  -- 冗余字段
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(10,2),      -- 预计算字段
    status VARCHAR(32),
    created_at TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);

-- 或者使用Elasticsearch存储读模型
```

#### 3. 事件处理器(同步读写模型)

```go
package eventhandler

import (
    "context"
    "database/sql"
)

// OrderCreatedEventHandler 订单创建事件处理器
type OrderCreatedEventHandler struct {
    readDB    *sql.DB
    redis     *redis.Client
    userRepo  UserRepository
    productRepo ProductRepository
}

func (h *OrderCreatedEventHandler) Handle(ctx context.Context, event Event) error {
    orderEvent, ok := event.(*OrderCreatedEvent)
    if !ok {
        return fmt.Errorf("invalid event type")
    }

    // 1. 获取关联数据(用户、产品信息)
    user, err := h.userRepo.GetByID(ctx, orderEvent.UserID)
    if err != nil {
        return err
    }

    product, err := h.productRepo.GetByID(ctx, orderEvent.ProductID)
    if err != nil {
        return err
    }

    // 2. 更新读模型(反规范化)
    query := `
        INSERT INTO order_view (
            order_id, user_id, user_name, product_id, product_name, product_image_url,
            quantity, unit_price, total_amount, status, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `

    _, err = h.readDB.ExecContext(ctx, query,
        orderEvent.OrderID,
        orderEvent.UserID,
        user.Name,                    // 冗余用户名
        orderEvent.ProductID,
        product.Name,                 // 冗余产品名
        product.ImageURL,             // 冗余产品图片
        orderEvent.Quantity,
        product.Price,
        orderEvent.Amount,            // 预计算总价
        "PENDING",
        orderEvent.CreatedAt,
    )

    if err != nil {
        return err
    }

    // 3. 写入缓存
    view := &OrderView{
        OrderID:     orderEvent.OrderID,
        UserID:      orderEvent.UserID,
        UserName:    user.Name,
        ProductID:   orderEvent.ProductID,
        ProductName: product.Name,
        Quantity:    orderEvent.Quantity,
        TotalAmount: orderEvent.Amount,
        Status:      "PENDING",
        CreatedAt:   orderEvent.CreatedAt,
    }

    data, _ := json.Marshal(view)
    h.redis.Set(ctx, fmt.Sprintf("order:%s", orderEvent.OrderID), data, 1*time.Hour)

    return nil
}
```

---

### 三、CQRS的进阶实践

#### 1. CQRS + Event Sourcing

结合事件溯源,写模型存储事件流:

```go
package cqrs

// 写模型:基于Event Sourcing
type Order struct {
    ID      string
    UserID  int64
    Status  string
    events  []Event  // 未提交的事件
}

func (o *Order) CreateOrder(productID int64, quantity int, amount float64) error {
    // 业务逻辑验证
    if quantity <= 0 {
        return fmt.Errorf("invalid quantity")
    }

    // 创建事件
    event := &OrderCreatedEvent{
        OrderID:   o.ID,
        UserID:    o.UserID,
        ProductID: productID,
        Quantity:  quantity,
        Amount:    amount,
    }

    // 应用事件
    o.Apply(event)
    o.events = append(o.events, event)

    return nil
}

func (o *Order) Apply(event Event) {
    switch e := event.(type) {
    case *OrderCreatedEvent:
        o.ID = e.OrderID
        o.UserID = e.UserID
        o.Status = "PENDING"
    case *OrderPaidEvent:
        o.Status = "PAID"
    }
}

// 从事件重建聚合根
func NewOrderFromEvents(events []Event) *Order {
    order := &Order{}
    for _, event := range events {
        order.Apply(event)
    }
    return order
}
```

#### 2. 多种读模型

针对不同查询场景创建不同的读模型:

```go
// 读模型1: 用户订单列表(分页查询优化)
type UserOrderListView struct {
    OrderID     string
    ProductName string
    TotalAmount float64
    Status      string
    CreatedAt   time.Time
}

// 读模型2: 订单详情(详细信息)
type OrderDetailView struct {
    OrderID       string
    User          UserInfo
    Items         []OrderItemView
    TotalAmount   float64
    ShippingInfo  ShippingInfo
    PaymentInfo   PaymentInfo
    Status        string
}

// 读模型3: 订单统计(分析查询)
type OrderStatisticsView struct {
    Date        string
    TotalOrders int
    TotalAmount float64
    TopProducts []ProductSalesView
}
```

#### 3. 读写模型一致性策略

**强一致性(同步更新)**:
```go
func (h *CreateOrderHandler) Handle(ctx context.Context, cmd Command) error {
    // 写模型
    tx, _ := h.writeDB.BeginTx(ctx, nil)
    // ...写入orders表
    tx.Commit()

    // 同步更新读模型
    h.readDB.Exec("INSERT INTO order_view ...")

    return nil
}
```

**最终一致性(异步更新)**:
```go
func (h *CreateOrderHandler) Handle(ctx context.Context, cmd Command) error {
    // 写模型
    tx, _ := h.writeDB.BeginTx(ctx, nil)
    // ...写入orders表
    tx.Commit()

    // 异步发布事件
    go h.eventPublisher.Publish(ctx, &OrderCreatedEvent{...})

    return nil
}

// 事件处理器异步更新读模型
func (h *EventHandler) Handle(ctx context.Context, event Event) error {
    // 更新读模型
    h.readDB.Exec("INSERT INTO order_view ...")
}
```

---

### 四、CQRS的优缺点

#### 优点

```
✅ 读写分离:针对读写特点各自优化
✅ 性能提升:读模型反规范化,避免JOIN查询
✅ 可扩展性:读写可独立扩展(读多写少场景)
✅ 灵活性:可针对不同查询场景创建多种读模型
✅ 简化复杂查询:预计算、冗余数据简化查询逻辑
✅ 适合DDD:Command对应领域操作,Query对应视图
```

#### 缺点

```
❌ 复杂度增加:需维护读写两套模型
❌ 最终一致性:读模型有延迟,需处理数据不一致
❌ 学习曲线:团队需要理解CQRS理念
❌ 运维成本:需要维护更多的数据存储
❌ 数据冗余:读模型冗余存储增加存储成本
❌ 代码量增加:Command/Query/Event等增加代码量
```

---

### 五、CQRS适用场景

#### 适合场景

```
✅ 读写比例差异大(如10:1的读多写少场景)
✅ 复杂业务逻辑(DDD领域驱动设计)
✅ 需要多种视图展示(订单列表、详情、统计等)
✅ 高并发场景(读写分离扩展)
✅ 需要审计追溯(结合Event Sourcing)
✅ 微服务架构(服务间读写分离)
```

**案例**:
- 电商订单系统(下单写少,查询多)
- 社交媒体平台(发帖少,浏览多)
- 数据分析平台(写入日志,分析查询)

#### 不适合场景

```
❌ 简单CRUD应用
❌ 读写比例接近1:1
❌ 强一致性要求(如银行转账实时余额)
❌ 团队规模小,无法承担额外复杂度
❌ 数据量小的内部系统
```

---

### 六、CQRS实施建议

#### 1. 渐进式引入

```
阶段1: 在应用层分离Command和Query逻辑
阶段2: 读写使用不同的DTO/ViewModel
阶段3: 引入读缓存(Redis)优化查询
阶段4: 物理分离读写数据库
阶段5: 引入Event Sourcing(可选)
```

#### 2. 读模型设计原则

```
✅ 反规范化:冗余关联数据,避免JOIN
✅ 预计算:提前计算好总价、数量等
✅ 多视图:针对不同场景创建不同读模型
✅ 缓存优先:热点数据放入Redis/Memcached
✅ 搜索引擎:复杂查询使用Elasticsearch
```

#### 3. 一致性处理

**最终一致性延迟处理**:
```go
// 写入后立即查询可能读不到最新数据
orderID := createOrder(ctx, cmd)

// 方案1: 重试读取
var order *OrderView
for i := 0; i < 3; i++ {
    order, err = getOrder(ctx, orderID)
    if err == nil {
        break
    }
    time.Sleep(100 * time.Millisecond)
}

// 方案2: 直接返回写模型数据
return &OrderView{
    OrderID: orderID,
    // ... 从Command构造
}

// 方案3: 通知用户数据同步中
return &Response{
    OrderID: orderID,
    Message: "订单创建成功,详情稍后可查询",
}
```

#### 4. 监控和告警

```
📊 关键指标:
- 读写模型数据一致性延迟
- 事件处理失败率
- 读模型缓存命中率
- 查询响应时间P99

🚨 告警:
- 读写数据不一致超过阈值(如5分钟)
- 事件积压超过1000条
- 读模型更新失败
```

---

### 七、CQRS框架和工具

| 工具/框架 | 语言 | 特点 |
|----------|------|------|
| **Axon Framework** | Java | 成熟的CQRS+ES框架 |
| **MediatR** | .NET | 轻量级CQRS实现 |
| **go-cqrs** | Go | Go的CQRS实现 |
| **Eventuate** | Java | 微服务CQRS+ES平台 |
| **Commanded** | Elixir | Elixir CQRS框架 |
| **CQRS Lite** | .NET | 轻量级CQRS库 |

---

### 八、总结

CQRS通过分离读写职责,针对不同场景优化性能。适合读写比例差异大、复杂业务逻辑的系统。结合Event Sourcing可实现完整的事件驱动架构,但也带来了复杂度和最终一致性的挑战,需根据业务场景权衡使用。
