---
title: CQRSï¼ˆå‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»ï¼‰æ¨¡å¼
tags:
  - å¾®æœåŠ¡
status: robot
class: å¾®æœåŠ¡
slug: cqrs-command-query-responsibility-segregation
ref:
---

## æ ¸å¿ƒè¦ç‚¹

**èŒè´£åˆ†ç¦»**:å°†æ•°æ®çš„è¯»(Query)å’Œå†™(Command)æ“ä½œåˆ†ç¦»åˆ°ä¸åŒçš„æ¨¡å‹,ä¼˜åŒ–å„è‡ªæ€§èƒ½
**è¯»å†™åˆ†ç¦»**:å†™æ¨¡å‹ä¿è¯ä¸€è‡´æ€§,è¯»æ¨¡å‹ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½,ä½¿ç”¨ä¸åŒçš„æ•°æ®å­˜å‚¨
**æœ€ç»ˆä¸€è‡´æ€§**:é€šè¿‡äº‹ä»¶åŒæ­¥è¯»å†™æ¨¡å‹,ç‰ºç‰²å¼ºä¸€è‡´æ€§æ¢å–é«˜æ€§èƒ½å’Œå¯æ‰©å±•æ€§
**é€‚ç”¨åœºæ™¯**:å¤æ‚ä¸šåŠ¡é€»è¾‘ã€é«˜å¹¶å‘è¯»å†™æ¯”å·®å¼‚å¤§ã€éœ€è¦å¤šè§†å›¾å±•ç¤ºçš„ç³»ç»Ÿ

---

## è¯¦ç»†å›ç­”

### ä¸€ã€CQRSçš„æ ¸å¿ƒæ¦‚å¿µ

CQRS (Command Query Responsibility Segregation) æ˜¯ä¸€ç§å°†ç³»ç»Ÿçš„å‘½ä»¤(ä¿®æ”¹æ•°æ®)å’ŒæŸ¥è¯¢(è¯»å–æ•°æ®)èŒè´£åˆ†ç¦»çš„æ¶æ„æ¨¡å¼ã€‚

#### 1. ä¼ ç»ŸCRUD vs CQRS

**ä¼ ç»ŸCRUD**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨å±‚     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚ è¯»å†™å…±ç”¨
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®æ¨¡å‹   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®åº“     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**CQRSæ¨¡å¼**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Command     â”‚         â”‚ Query        â”‚
â”‚ (å†™æ“ä½œ)     â”‚         â”‚ (è¯»æ“ä½œ)      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                       â”‚
       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Write Model  â”‚â”€â”€â”€â”€â”€â”€â”‚ Read Model     â”‚
â”‚ (Domain)     â”‚ äº‹ä»¶ â”‚ (View/DTO)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                       â”‚
       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å†™æ•°æ®åº“      â”‚      â”‚ è¯»æ•°æ®åº“        â”‚
â”‚ (MySQL)      â”‚      â”‚ (Redis/ES)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. å‘½ä»¤(Command)ä¸æŸ¥è¯¢(Query)

**å‘½ä»¤(Command)**:
```go
// å‘½ä»¤:æ”¹å˜ç³»ç»ŸçŠ¶æ€çš„æ“ä½œ
type CreateOrderCommand struct {
    OrderID   string
    UserID    int64
    ProductID int64
    Quantity  int
    Amount    float64
}

type UpdateOrderStatusCommand struct {
    OrderID string
    Status  string
}
```

**æŸ¥è¯¢(Query)**:
```go
// æŸ¥è¯¢:ä¸æ”¹å˜ç³»ç»ŸçŠ¶æ€,åªè¿”å›æ•°æ®
type GetOrderQuery struct {
    OrderID string
}

type ListUserOrdersQuery struct {
    UserID   int64
    Page     int
    PageSize int
}
```

---

### äºŒã€CQRSå®ç°ç¤ºä¾‹

#### 1. å‘½ä»¤ç«¯å®ç°

**å‘½ä»¤å¤„ç†å™¨**:

```go
package command

import (
    "context"
    "database/sql"
)

// CommandBus å‘½ä»¤æ€»çº¿
type CommandBus interface {
    Dispatch(ctx context.Context, cmd Command) error
}

// Command å‘½ä»¤æ¥å£
type Command interface {
    CommandName() string
}

// CommandHandler å‘½ä»¤å¤„ç†å™¨æ¥å£
type CommandHandler interface {
    Handle(ctx context.Context, cmd Command) error
}

// CreateOrderCommand åˆ›å»ºè®¢å•å‘½ä»¤
type CreateOrderCommand struct {
    OrderID   string
    UserID    int64
    ProductID int64
    Quantity  int
    Amount    float64
}

func (c *CreateOrderCommand) CommandName() string {
    return "CreateOrder"
}

// CreateOrderHandler åˆ›å»ºè®¢å•å¤„ç†å™¨
type CreateOrderHandler struct {
    db            *sql.DB
    eventPublisher EventPublisher
}

func (h *CreateOrderHandler) Handle(ctx context.Context, cmd Command) error {
    createCmd, ok := cmd.(*CreateOrderCommand)
    if !ok {
        return fmt.Errorf("invalid command type")
    }

    // 1. ä¸šåŠ¡é€»è¾‘éªŒè¯
    if err := h.validateOrder(ctx, createCmd); err != nil {
        return err
    }

    // 2. å¼€å¯äº‹åŠ¡
    tx, err := h.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 3. å†™å…¥å†™æ¨¡å‹(è§„èŒƒåŒ–è®¾è®¡)
    orderQuery := `
        INSERT INTO orders (order_id, user_id, status, created_at)
        VALUES (?, ?, 'PENDING', NOW())
    `
    _, err = tx.ExecContext(ctx, orderQuery, createCmd.OrderID, createCmd.UserID)
    if err != nil {
        return err
    }

    itemQuery := `
        INSERT INTO order_items (order_id, product_id, quantity, price)
        VALUES (?, ?, ?, ?)
    `
    _, err = tx.ExecContext(ctx, itemQuery,
        createCmd.OrderID,
        createCmd.ProductID,
        createCmd.Quantity,
        createCmd.Amount,
    )
    if err != nil {
        return err
    }

    // 4. æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
        return err
    }

    // 5. å‘å¸ƒäº‹ä»¶(å¼‚æ­¥æ›´æ–°è¯»æ¨¡å‹)
    event := &OrderCreatedEvent{
        OrderID:   createCmd.OrderID,
        UserID:    createCmd.UserID,
        ProductID: createCmd.ProductID,
        Quantity:  createCmd.Quantity,
        Amount:    createCmd.Amount,
        CreatedAt: time.Now(),
    }

    go h.eventPublisher.Publish(ctx, event)

    return nil
}

func (h *CreateOrderHandler) validateOrder(ctx context.Context, cmd *CreateOrderCommand) error {
    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if cmd.Quantity <= 0 {
        return fmt.Errorf("invalid quantity")
    }
    if cmd.Amount <= 0 {
        return fmt.Errorf("invalid amount")
    }
    return nil
}
```

**å†™æ¨¡å‹æ•°æ®åº“è®¾è®¡**:
```sql
-- å†™æ¨¡å‹:è§„èŒƒåŒ–è®¾è®¡,ä¿è¯æ•°æ®ä¸€è‡´æ€§
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL UNIQUE,
    user_id BIGINT NOT NULL,
    status VARCHAR(32) NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_user_id (user_id)
);

CREATE TABLE order_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    INDEX idx_order_id (order_id),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);
```

#### 2. æŸ¥è¯¢ç«¯å®ç°

**æŸ¥è¯¢å¤„ç†å™¨**:

```go
package query

import (
    "context"
    "encoding/json"
    "github.com/go-redis/redis/v8"
)

// QueryBus æŸ¥è¯¢æ€»çº¿
type QueryBus interface {
    Execute(ctx context.Context, query Query) (interface{}, error)
}

// Query æŸ¥è¯¢æ¥å£
type Query interface {
    QueryName() string
}

// QueryHandler æŸ¥è¯¢å¤„ç†å™¨æ¥å£
type QueryHandler interface {
    Handle(ctx context.Context, query Query) (interface{}, error)
}

// GetOrderQuery è·å–è®¢å•æŸ¥è¯¢
type GetOrderQuery struct {
    OrderID string
}

func (q *GetOrderQuery) QueryName() string {
    return "GetOrder"
}

// OrderView è®¢å•è§†å›¾(è¯»æ¨¡å‹)
type OrderView struct {
    OrderID     string    `json:"order_id"`
    UserID      int64     `json:"user_id"`
    UserName    string    `json:"user_name"`     // åè§„èŒƒåŒ–:å†—ä½™ç”¨æˆ·å
    ProductID   int64     `json:"product_id"`
    ProductName string    `json:"product_name"`  // åè§„èŒƒåŒ–:å†—ä½™äº§å“å
    Quantity    int       `json:"quantity"`
    TotalAmount float64   `json:"total_amount"`  // åè§„èŒƒåŒ–:è®¡ç®—å¥½çš„æ€»ä»·
    Status      string    `json:"status"`
    CreatedAt   time.Time `json:"created_at"`
}

// GetOrderHandler è·å–è®¢å•å¤„ç†å™¨
type GetOrderHandler struct {
    redis *redis.Client
    db    *sql.DB  // ä½œä¸ºç¼“å­˜æœªå‘½ä¸­æ—¶çš„fallback
}

func (h *GetOrderHandler) Handle(ctx context.Context, query Query) (interface{}, error) {
    getQuery, ok := query.(*GetOrderQuery)
    if !ok {
        return nil, fmt.Errorf("invalid query type")
    }

    // 1. ä¼˜å…ˆä»Redisè¯»å–(è¯»æ¨¡å‹ç¼“å­˜)
    key := fmt.Sprintf("order:%s", getQuery.OrderID)
    cached, err := h.redis.Get(ctx, key).Result()
    if err == nil {
        var view OrderView
        if err := json.Unmarshal([]byte(cached), &view); err == nil {
            return &view, nil
        }
    }

    // 2. Redisæœªå‘½ä¸­,ä»è¯»æ¨¡å‹æ•°æ®åº“æŸ¥è¯¢
    view, err := h.getOrderFromReadDB(ctx, getQuery.OrderID)
    if err != nil {
        return nil, err
    }

    // 3. å†™å…¥ç¼“å­˜
    data, _ := json.Marshal(view)
    h.redis.Set(ctx, key, data, 1*time.Hour)

    return view, nil
}

func (h *GetOrderHandler) getOrderFromReadDB(ctx context.Context, orderID string) (*OrderView, error) {
    // ä»è¯»æ¨¡å‹æŸ¥è¯¢(åè§„èŒƒåŒ–çš„å®½è¡¨)
    query := `
        SELECT order_id, user_id, user_name, product_id, product_name,
               quantity, total_amount, status, created_at
        FROM order_view
        WHERE order_id = ?
    `

    var view OrderView
    err := h.db.QueryRowContext(ctx, query, orderID).Scan(
        &view.OrderID,
        &view.UserID,
        &view.UserName,
        &view.ProductID,
        &view.ProductName,
        &view.Quantity,
        &view.TotalAmount,
        &view.Status,
        &view.CreatedAt,
    )

    return &view, err
}
```

**è¯»æ¨¡å‹æ•°æ®åº“è®¾è®¡**:
```sql
-- è¯»æ¨¡å‹:åè§„èŒƒåŒ–è®¾è®¡,ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
CREATE TABLE order_view (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL UNIQUE,
    user_id BIGINT NOT NULL,
    user_name VARCHAR(128),          -- å†—ä½™å­—æ®µ
    product_id BIGINT NOT NULL,
    product_name VARCHAR(256),       -- å†—ä½™å­—æ®µ
    product_image_url VARCHAR(512),  -- å†—ä½™å­—æ®µ
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(10,2),      -- é¢„è®¡ç®—å­—æ®µ
    status VARCHAR(32),
    created_at TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);

-- æˆ–è€…ä½¿ç”¨Elasticsearchå­˜å‚¨è¯»æ¨¡å‹
```

#### 3. äº‹ä»¶å¤„ç†å™¨(åŒæ­¥è¯»å†™æ¨¡å‹)

```go
package eventhandler

import (
    "context"
    "database/sql"
)

// OrderCreatedEventHandler è®¢å•åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
type OrderCreatedEventHandler struct {
    readDB    *sql.DB
    redis     *redis.Client
    userRepo  UserRepository
    productRepo ProductRepository
}

func (h *OrderCreatedEventHandler) Handle(ctx context.Context, event Event) error {
    orderEvent, ok := event.(*OrderCreatedEvent)
    if !ok {
        return fmt.Errorf("invalid event type")
    }

    // 1. è·å–å…³è”æ•°æ®(ç”¨æˆ·ã€äº§å“ä¿¡æ¯)
    user, err := h.userRepo.GetByID(ctx, orderEvent.UserID)
    if err != nil {
        return err
    }

    product, err := h.productRepo.GetByID(ctx, orderEvent.ProductID)
    if err != nil {
        return err
    }

    // 2. æ›´æ–°è¯»æ¨¡å‹(åè§„èŒƒåŒ–)
    query := `
        INSERT INTO order_view (
            order_id, user_id, user_name, product_id, product_name, product_image_url,
            quantity, unit_price, total_amount, status, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `

    _, err = h.readDB.ExecContext(ctx, query,
        orderEvent.OrderID,
        orderEvent.UserID,
        user.Name,                    // å†—ä½™ç”¨æˆ·å
        orderEvent.ProductID,
        product.Name,                 // å†—ä½™äº§å“å
        product.ImageURL,             // å†—ä½™äº§å“å›¾ç‰‡
        orderEvent.Quantity,
        product.Price,
        orderEvent.Amount,            // é¢„è®¡ç®—æ€»ä»·
        "PENDING",
        orderEvent.CreatedAt,
    )

    if err != nil {
        return err
    }

    // 3. å†™å…¥ç¼“å­˜
    view := &OrderView{
        OrderID:     orderEvent.OrderID,
        UserID:      orderEvent.UserID,
        UserName:    user.Name,
        ProductID:   orderEvent.ProductID,
        ProductName: product.Name,
        Quantity:    orderEvent.Quantity,
        TotalAmount: orderEvent.Amount,
        Status:      "PENDING",
        CreatedAt:   orderEvent.CreatedAt,
    }

    data, _ := json.Marshal(view)
    h.redis.Set(ctx, fmt.Sprintf("order:%s", orderEvent.OrderID), data, 1*time.Hour)

    return nil
}
```

---

### ä¸‰ã€CQRSçš„è¿›é˜¶å®è·µ

#### 1. CQRS + Event Sourcing

ç»“åˆäº‹ä»¶æº¯æº,å†™æ¨¡å‹å­˜å‚¨äº‹ä»¶æµ:

```go
package cqrs

// å†™æ¨¡å‹:åŸºäºEvent Sourcing
type Order struct {
    ID      string
    UserID  int64
    Status  string
    events  []Event  // æœªæäº¤çš„äº‹ä»¶
}

func (o *Order) CreateOrder(productID int64, quantity int, amount float64) error {
    // ä¸šåŠ¡é€»è¾‘éªŒè¯
    if quantity <= 0 {
        return fmt.Errorf("invalid quantity")
    }

    // åˆ›å»ºäº‹ä»¶
    event := &OrderCreatedEvent{
        OrderID:   o.ID,
        UserID:    o.UserID,
        ProductID: productID,
        Quantity:  quantity,
        Amount:    amount,
    }

    // åº”ç”¨äº‹ä»¶
    o.Apply(event)
    o.events = append(o.events, event)

    return nil
}

func (o *Order) Apply(event Event) {
    switch e := event.(type) {
    case *OrderCreatedEvent:
        o.ID = e.OrderID
        o.UserID = e.UserID
        o.Status = "PENDING"
    case *OrderPaidEvent:
        o.Status = "PAID"
    }
}

// ä»äº‹ä»¶é‡å»ºèšåˆæ ¹
func NewOrderFromEvents(events []Event) *Order {
    order := &Order{}
    for _, event := range events {
        order.Apply(event)
    }
    return order
}
```

#### 2. å¤šç§è¯»æ¨¡å‹

é’ˆå¯¹ä¸åŒæŸ¥è¯¢åœºæ™¯åˆ›å»ºä¸åŒçš„è¯»æ¨¡å‹:

```go
// è¯»æ¨¡å‹1: ç”¨æˆ·è®¢å•åˆ—è¡¨(åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–)
type UserOrderListView struct {
    OrderID     string
    ProductName string
    TotalAmount float64
    Status      string
    CreatedAt   time.Time
}

// è¯»æ¨¡å‹2: è®¢å•è¯¦æƒ…(è¯¦ç»†ä¿¡æ¯)
type OrderDetailView struct {
    OrderID       string
    User          UserInfo
    Items         []OrderItemView
    TotalAmount   float64
    ShippingInfo  ShippingInfo
    PaymentInfo   PaymentInfo
    Status        string
}

// è¯»æ¨¡å‹3: è®¢å•ç»Ÿè®¡(åˆ†ææŸ¥è¯¢)
type OrderStatisticsView struct {
    Date        string
    TotalOrders int
    TotalAmount float64
    TopProducts []ProductSalesView
}
```

#### 3. è¯»å†™æ¨¡å‹ä¸€è‡´æ€§ç­–ç•¥

**å¼ºä¸€è‡´æ€§(åŒæ­¥æ›´æ–°)**:
```go
func (h *CreateOrderHandler) Handle(ctx context.Context, cmd Command) error {
    // å†™æ¨¡å‹
    tx, _ := h.writeDB.BeginTx(ctx, nil)
    // ...å†™å…¥ordersè¡¨
    tx.Commit()

    // åŒæ­¥æ›´æ–°è¯»æ¨¡å‹
    h.readDB.Exec("INSERT INTO order_view ...")

    return nil
}
```

**æœ€ç»ˆä¸€è‡´æ€§(å¼‚æ­¥æ›´æ–°)**:
```go
func (h *CreateOrderHandler) Handle(ctx context.Context, cmd Command) error {
    // å†™æ¨¡å‹
    tx, _ := h.writeDB.BeginTx(ctx, nil)
    // ...å†™å…¥ordersè¡¨
    tx.Commit()

    // å¼‚æ­¥å‘å¸ƒäº‹ä»¶
    go h.eventPublisher.Publish(ctx, &OrderCreatedEvent{...})

    return nil
}

// äº‹ä»¶å¤„ç†å™¨å¼‚æ­¥æ›´æ–°è¯»æ¨¡å‹
func (h *EventHandler) Handle(ctx context.Context, event Event) error {
    // æ›´æ–°è¯»æ¨¡å‹
    h.readDB.Exec("INSERT INTO order_view ...")
}
```

---

### å››ã€CQRSçš„ä¼˜ç¼ºç‚¹

#### ä¼˜ç‚¹

```
âœ… è¯»å†™åˆ†ç¦»:é’ˆå¯¹è¯»å†™ç‰¹ç‚¹å„è‡ªä¼˜åŒ–
âœ… æ€§èƒ½æå‡:è¯»æ¨¡å‹åè§„èŒƒåŒ–,é¿å…JOINæŸ¥è¯¢
âœ… å¯æ‰©å±•æ€§:è¯»å†™å¯ç‹¬ç«‹æ‰©å±•(è¯»å¤šå†™å°‘åœºæ™¯)
âœ… çµæ´»æ€§:å¯é’ˆå¯¹ä¸åŒæŸ¥è¯¢åœºæ™¯åˆ›å»ºå¤šç§è¯»æ¨¡å‹
âœ… ç®€åŒ–å¤æ‚æŸ¥è¯¢:é¢„è®¡ç®—ã€å†—ä½™æ•°æ®ç®€åŒ–æŸ¥è¯¢é€»è¾‘
âœ… é€‚åˆDDD:Commandå¯¹åº”é¢†åŸŸæ“ä½œ,Queryå¯¹åº”è§†å›¾
```

#### ç¼ºç‚¹

```
âŒ å¤æ‚åº¦å¢åŠ :éœ€ç»´æŠ¤è¯»å†™ä¸¤å¥—æ¨¡å‹
âŒ æœ€ç»ˆä¸€è‡´æ€§:è¯»æ¨¡å‹æœ‰å»¶è¿Ÿ,éœ€å¤„ç†æ•°æ®ä¸ä¸€è‡´
âŒ å­¦ä¹ æ›²çº¿:å›¢é˜Ÿéœ€è¦ç†è§£CQRSç†å¿µ
âŒ è¿ç»´æˆæœ¬:éœ€è¦ç»´æŠ¤æ›´å¤šçš„æ•°æ®å­˜å‚¨
âŒ æ•°æ®å†—ä½™:è¯»æ¨¡å‹å†—ä½™å­˜å‚¨å¢åŠ å­˜å‚¨æˆæœ¬
âŒ ä»£ç é‡å¢åŠ :Command/Query/Eventç­‰å¢åŠ ä»£ç é‡
```

---

### äº”ã€CQRSé€‚ç”¨åœºæ™¯

#### é€‚åˆåœºæ™¯

```
âœ… è¯»å†™æ¯”ä¾‹å·®å¼‚å¤§(å¦‚10:1çš„è¯»å¤šå†™å°‘åœºæ™¯)
âœ… å¤æ‚ä¸šåŠ¡é€»è¾‘(DDDé¢†åŸŸé©±åŠ¨è®¾è®¡)
âœ… éœ€è¦å¤šç§è§†å›¾å±•ç¤º(è®¢å•åˆ—è¡¨ã€è¯¦æƒ…ã€ç»Ÿè®¡ç­‰)
âœ… é«˜å¹¶å‘åœºæ™¯(è¯»å†™åˆ†ç¦»æ‰©å±•)
âœ… éœ€è¦å®¡è®¡è¿½æº¯(ç»“åˆEvent Sourcing)
âœ… å¾®æœåŠ¡æ¶æ„(æœåŠ¡é—´è¯»å†™åˆ†ç¦»)
```

**æ¡ˆä¾‹**:
- ç”µå•†è®¢å•ç³»ç»Ÿ(ä¸‹å•å†™å°‘,æŸ¥è¯¢å¤š)
- ç¤¾äº¤åª’ä½“å¹³å°(å‘å¸–å°‘,æµè§ˆå¤š)
- æ•°æ®åˆ†æå¹³å°(å†™å…¥æ—¥å¿—,åˆ†ææŸ¥è¯¢)

#### ä¸é€‚åˆåœºæ™¯

```
âŒ ç®€å•CRUDåº”ç”¨
âŒ è¯»å†™æ¯”ä¾‹æ¥è¿‘1:1
âŒ å¼ºä¸€è‡´æ€§è¦æ±‚(å¦‚é“¶è¡Œè½¬è´¦å®æ—¶ä½™é¢)
âŒ å›¢é˜Ÿè§„æ¨¡å°,æ— æ³•æ‰¿æ‹…é¢å¤–å¤æ‚åº¦
âŒ æ•°æ®é‡å°çš„å†…éƒ¨ç³»ç»Ÿ
```

---

### å…­ã€CQRSå®æ–½å»ºè®®

#### 1. æ¸è¿›å¼å¼•å…¥

```
é˜¶æ®µ1: åœ¨åº”ç”¨å±‚åˆ†ç¦»Commandå’ŒQueryé€»è¾‘
é˜¶æ®µ2: è¯»å†™ä½¿ç”¨ä¸åŒçš„DTO/ViewModel
é˜¶æ®µ3: å¼•å…¥è¯»ç¼“å­˜(Redis)ä¼˜åŒ–æŸ¥è¯¢
é˜¶æ®µ4: ç‰©ç†åˆ†ç¦»è¯»å†™æ•°æ®åº“
é˜¶æ®µ5: å¼•å…¥Event Sourcing(å¯é€‰)
```

#### 2. è¯»æ¨¡å‹è®¾è®¡åŸåˆ™

```
âœ… åè§„èŒƒåŒ–:å†—ä½™å…³è”æ•°æ®,é¿å…JOIN
âœ… é¢„è®¡ç®—:æå‰è®¡ç®—å¥½æ€»ä»·ã€æ•°é‡ç­‰
âœ… å¤šè§†å›¾:é’ˆå¯¹ä¸åŒåœºæ™¯åˆ›å»ºä¸åŒè¯»æ¨¡å‹
âœ… ç¼“å­˜ä¼˜å…ˆ:çƒ­ç‚¹æ•°æ®æ”¾å…¥Redis/Memcached
âœ… æœç´¢å¼•æ“:å¤æ‚æŸ¥è¯¢ä½¿ç”¨Elasticsearch
```

#### 3. ä¸€è‡´æ€§å¤„ç†

**æœ€ç»ˆä¸€è‡´æ€§å»¶è¿Ÿå¤„ç†**:
```go
// å†™å…¥åç«‹å³æŸ¥è¯¢å¯èƒ½è¯»ä¸åˆ°æœ€æ–°æ•°æ®
orderID := createOrder(ctx, cmd)

// æ–¹æ¡ˆ1: é‡è¯•è¯»å–
var order *OrderView
for i := 0; i < 3; i++ {
    order, err = getOrder(ctx, orderID)
    if err == nil {
        break
    }
    time.Sleep(100 * time.Millisecond)
}

// æ–¹æ¡ˆ2: ç›´æ¥è¿”å›å†™æ¨¡å‹æ•°æ®
return &OrderView{
    OrderID: orderID,
    // ... ä»Commandæ„é€ 
}

// æ–¹æ¡ˆ3: é€šçŸ¥ç”¨æˆ·æ•°æ®åŒæ­¥ä¸­
return &Response{
    OrderID: orderID,
    Message: "è®¢å•åˆ›å»ºæˆåŠŸ,è¯¦æƒ…ç¨åå¯æŸ¥è¯¢",
}
```

#### 4. ç›‘æ§å’Œå‘Šè­¦

```
ğŸ“Š å…³é”®æŒ‡æ ‡:
- è¯»å†™æ¨¡å‹æ•°æ®ä¸€è‡´æ€§å»¶è¿Ÿ
- äº‹ä»¶å¤„ç†å¤±è´¥ç‡
- è¯»æ¨¡å‹ç¼“å­˜å‘½ä¸­ç‡
- æŸ¥è¯¢å“åº”æ—¶é—´P99

ğŸš¨ å‘Šè­¦:
- è¯»å†™æ•°æ®ä¸ä¸€è‡´è¶…è¿‡é˜ˆå€¼(å¦‚5åˆ†é’Ÿ)
- äº‹ä»¶ç§¯å‹è¶…è¿‡1000æ¡
- è¯»æ¨¡å‹æ›´æ–°å¤±è´¥
```

---

### ä¸ƒã€CQRSæ¡†æ¶å’Œå·¥å…·

| å·¥å…·/æ¡†æ¶ | è¯­è¨€ | ç‰¹ç‚¹ |
|----------|------|------|
| **Axon Framework** | Java | æˆç†Ÿçš„CQRS+ESæ¡†æ¶ |
| **MediatR** | .NET | è½»é‡çº§CQRSå®ç° |
| **go-cqrs** | Go | Goçš„CQRSå®ç° |
| **Eventuate** | Java | å¾®æœåŠ¡CQRS+ESå¹³å° |
| **Commanded** | Elixir | Elixir CQRSæ¡†æ¶ |
| **CQRS Lite** | .NET | è½»é‡çº§CQRSåº“ |

---

### å…«ã€æ€»ç»“

CQRSé€šè¿‡åˆ†ç¦»è¯»å†™èŒè´£,é’ˆå¯¹ä¸åŒåœºæ™¯ä¼˜åŒ–æ€§èƒ½ã€‚é€‚åˆè¯»å†™æ¯”ä¾‹å·®å¼‚å¤§ã€å¤æ‚ä¸šåŠ¡é€»è¾‘çš„ç³»ç»Ÿã€‚ç»“åˆEvent Sourcingå¯å®ç°å®Œæ•´çš„äº‹ä»¶é©±åŠ¨æ¶æ„,ä½†ä¹Ÿå¸¦æ¥äº†å¤æ‚åº¦å’Œæœ€ç»ˆä¸€è‡´æ€§çš„æŒ‘æˆ˜,éœ€æ ¹æ®ä¸šåŠ¡åœºæ™¯æƒè¡¡ä½¿ç”¨ã€‚
