---
title: API 网关的功能和常见实现（Kong/APISIX）
tags:
  - 微服务
status: robot
class: 微服务
slug: api-gateway-features-and-implementations-kong-apisix
ref:
---

## 核心要点

- **API网关定位**:微服务架构的统一入口,负责路由、认证、限流、监控等横切关注点
- **核心功能**:流量管理、安全防护、协议转换、可观测性、服务编排
- **Kong vs APISIX**:Lua生态成熟 vs 云原生高性能,插件丰富 vs 动态配置,商业支持好 vs 国产开源活跃

---

## 一、什么是API网关

### 1.1 微服务架构痛点

在微服务架构中,客户端直接调用多个服务会面临:

```
客户端问题:
- 需要维护多个服务地址
- 每个服务都要实现认证逻辑
- 跨域、协议不一致
- 缺乏统一监控

服务端问题:
- 重复实现认证、限流等逻辑
- 难以统一管理API版本
- 安全风险(暴露内部服务)
```

### 1.2 API网关的作用

API网关作为**唯一入口**,统一处理横切关注点:

```
                    [客户端]
                       │
                   单一入口
                       ↓
              ┌────────────────┐
              │   API 网关     │  ← 统一处理
              │ - 认证授权     │
              │ - 限流熔断     │
              │ - 路由转发     │
              │ - 协议转换     │
              └────────┬───────┘
                       │
        ┌──────────────┼──────────────┐
        ↓              ↓               ↓
   [服务A]         [服务B]         [服务C]
    内网            内网             内网
```

**核心价值**:
- **解耦**:客户端不感知后端服务变化
- **复用**:横切关注点集中实现
- **安全**:内部服务不直接暴露
- **监控**:统一流量观测点

---

## 二、API网关核心功能

### 2.1 路由与负载均衡

**功能**:根据请求特征转发到对应的后端服务

```yaml
# APISIX 路由配置示例
routes:
  - uri: /api/users/*
    upstream:
      type: roundrobin  # 负载均衡算法
      nodes:
        "192.168.1.10:8080": 1
        "192.168.1.11:8080": 1
        "192.168.1.12:8080": 2  # 权重更高

  - uri: /api/orders/*
    upstream:
      type: chash  # 一致性哈希(根据客户端IP)
      key: remote_addr
      nodes:
        "192.168.1.20:8080": 1
        "192.168.1.21:8080": 1
```

**路由匹配规则**:
- **URI路径**: `/api/v1/users`
- **HTTP方法**: `GET`, `POST`, `PUT`, `DELETE`
- **请求头**: `X-API-Version: v2`
- **查询参数**: `?region=us-west`
- **IP地址**: 来源IP白名单

**负载均衡算法**:
- `roundrobin`: 轮询(默认)
- `chash`: 一致性哈希(会话保持)
- `least_conn`: 最小连接数
- `ewma`: 指数加权移动平均(考虑延迟)

### 2.2 认证与鉴权

**常见认证方式**:

```yaml
# Kong 认证插件配置
plugins:
  - name: jwtUtils
    config:
      secret_is_base64: false
      claims_to_verify:
        - exp  # 验证过期时间

  - name: key-auth  # API Key认证
    config:
      key_names:
        - apikey
      hide_credentials: true

  - name: oauth2  # OAuth2认证
    config:
      scopes:
        - email
        - profile
      mandatory_scope: true
```

**鉴权流程**:

```
1. 客户端请求 → 携带 JWT Token
2. 网关验证 Token 签名和有效期
3. 提取 Token 中的用户信息(userID, role)
4. 检查用户权限(RBAC/ABAC)
5. 通过:转发到后端  失败:返回401/403
```

**Go语言实现示例**:

```go
// 自定义认证中间件
func JWTAuthMiddleware(secret string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 提取 Token
            authHeader := r.Header.Get("Authorization")
            if !strings.HasPrefix(authHeader, "Bearer ") {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }

            tokenString := strings.TrimPrefix(authHeader, "Bearer ")

            // 验证 Token
            token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
                return []byte(secret), nil
            })

            if err != nil || !token.Valid {
                http.Error(w, "Invalid token", http.StatusUnauthorized)
                return
            }

            // 提取用户信息
            claims := token.Claims.(jwt.MapClaims)
            userID := claims["user_id"].(string)

            // 注入到上下文
            ctx := context.WithValue(r.Context(), "userID", userID)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

### 2.3 限流与熔断

**限流策略**:

```yaml
# APISIX 限流配置
plugins:
  limit-req:
    rate: 100        # 每秒100次
    burst: 50        # 允许突发50次
    key: remote_addr # 按IP限流
    rejected_code: 429

  limit-count:
    count: 1000      # 时间窗口内最大请求数
    time_window: 60  # 60秒
    key: consumer_name  # 按用户限流
```

**熔断配置**:

```yaml
# Kong 熔断插件
plugins:
  - name: circuit-breaker
    config:
      error_threshold: 50     # 错误率50%触发熔断
      volume_threshold: 10    # 最小请求数
      window_seconds: 60      # 统计窗口60秒
      break_seconds: 30       # 熔断持续30秒
```

### 2.4 协议转换与聚合

**协议转换**:

```
HTTP/1.1 → HTTP/2
HTTP     → gRPC
REST     → GraphQL
WebSocket → HTTP
```

**请求聚合示例**:

```yaml
# APISIX 批量请求配置
plugins:
  batch-requests:
    timeout: 1000  # 超时时间(ms)

# 客户端发送批量请求
POST /apisix/batch-requests
{
  "pipeline": [
    {"path": "/api/user/profile", "method": "GET"},
    {"path": "/api/user/orders", "method": "GET"},
    {"path": "/api/user/wallet", "method": "GET"}
  ]
}

# 网关聚合响应返回
[
  {"status": 200, "body": {...}},  # profile
  {"status": 200, "body": {...}},  # orders
  {"status": 200, "body": {...}}   # wallet
]
```

### 2.5 可观测性

**日志记录**:

```yaml
# Kong 日志插件
plugins:
  - name: file-log
    config:
      path: /var/log/kong/access.log

  - name: http-log
    config:
      http_endpoint: http://logstash:8080
      method: POST
```

**监控指标**:

- **请求量**: QPS、请求总数
- **延迟**: P50、P95、P99
- **错误率**: 4xx、5xx错误占比
- **流量**: 入站/出站带宽
- **上游状态**: 后端服务健康度

**链路追踪**:

```yaml
# APISIX OpenTelemetry 配置
plugins:
  opentelemetry:
    sampler:
      name: always_on  # 采样策略
    resource:
      service.name: api-gateway
    collector:
      address: jaeger:4318
      request_timeout: 3
```

### 2.6 安全防护

**IP黑白名单**:

```yaml
plugins:
  ip-restriction:
    whitelist:
      - 192.168.1.0/24
      - 10.0.0.1
    blacklist:
      - 123.45.67.89
```

**请求体大小限制**:

```yaml
plugins:
  request-size-limiting:
    allowed_payload_size: 10  # 10MB
```

**SQL注入/XSS防护**:

```yaml
plugins:
  waf:
    rules:
      - rule_id: 942100  # SQL注入检测
        action: deny
      - rule_id: 941100  # XSS检测
        action: deny
```

**CORS配置**:

```yaml
plugins:
  cors:
    allow_origins: "https://example.com"
    allow_methods: "GET,POST,PUT,DELETE"
    allow_headers: "Authorization,Content-Type"
    max_age: 3600
```

---

## 三、Kong 详解

### 3.1 Kong 架构

```
        ┌─────────────────────────────┐
        │       Kong Admin API        │  ← 管理接口(8001端口)
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │        Kong Core            │
        │  - 路由引擎(OpenResty)      │
        │  - 插件系统                  │
        │  - 负载均衡                  │
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │     数据存储层               │
        │  - PostgreSQL / Cassandra   │  ← 存储配置
        └─────────────────────────────┘
```

**核心技术栈**:
- **OpenResty**: Nginx + Lua JIT(高性能)
- **数据库**: PostgreSQL(推荐) 或 Cassandra
- **管理界面**: Kong Manager(企业版) / Konga(开源)

### 3.2 Kong 插件生态

**官方插件分类**:

| 分类 | 插件示例 |
|------|---------|
| **认证** | JWT, Key Auth, OAuth2, LDAP, Basic Auth |
| **安全** | IP Restriction, Bot Detection, CORS, ACL |
| **流量控制** | Rate Limiting, Request Size Limiting |
| **分析监控** | Prometheus, Datadog, StatsD, Zipkin |
| **转换** | Request Transformer, Response Transformer, GRPC-Gateway |
| **日志** | File Log, HTTP Log, Syslog, Kafka Log |

**自定义插件开发**:

```lua
-- Kong 自定义插件示例 (Lua)
local CustomPlugin = {
  VERSION = "1.0.0",
  PRIORITY = 1000,
}

function CustomPlugin:access(conf)
  -- 在请求到达上游之前执行
  local userID = kong.request.get_header("X-User-ID")
  if not userID then
    return kong.response.exit(401, {message = "Missing User ID"})
  end

  -- 调用外部服务验证
  local res = http.get("http://auth-service/validate?user=" .. userID)
  if res.status ~= 200 then
    return kong.response.exit(403, {message = "Forbidden"})
  end

  -- 添加自定义header
  kong.service.request.set_header("X-Verified-User", userID)
end

return CustomPlugin
```

### 3.3 Kong 配置示例

**声明式配置文件**:

```yaml
# kong.yaml
_format_version: "3.0"

services:
  - name: user-service
    url: http://user-api:8080
    routes:
      - name: user-route
        paths:
          - /api/users
        methods:
          - GET
          - POST
    plugins:
      - name: jwtUtils
      - name: rate-limiting
        config:
          minute: 100
          policy: local

  - name: order-service
    url: http://order-api:8080
    routes:
      - name: order-route
        paths:
          - /api/orders
    plugins:
      - name: key-auth
      - name: prometheus
```

**使用声明式配置**:

```bash
# 导入配置
kong config db_import kong.yaml

# 或使用DB-less模式(无数据库)
KONG_DATABASE=off \
KONG_DECLARATIVE_CONFIG=kong.yaml \
kong start
```

### 3.4 Kong 优缺点

**优点**:
- ✅ 生态成熟,插件丰富(50+官方插件)
- ✅ 性能优秀(基于OpenResty)
- ✅ 企业版功能强大(Kong Enterprise)
- ✅ 社区活跃,文档完善
- ✅ 支持DB-less模式(适合云原生)

**缺点**:
- ❌ 需要数据库(PostgreSQL/Cassandra)
- ❌ 插件开发需要懂Lua
- ❌ 企业版收费较贵
- ❌ 动态配置更新较慢(依赖数据库轮询)

---

## 四、Apache APISIX 详解

### 4.1 APISIX 架构

```
        ┌─────────────────────────────┐
        │     APISIX Dashboard        │  ← Web管理界面
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │      APISIX Admin API       │  ← 管理接口
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │       APISIX Core           │
        │  - 动态路由(etcd监听)       │
        │  - 插件热加载                │
        │  - Service Mesh支持          │
        └──────────────┬──────────────┘
                       │
        ┌──────────────▼──────────────┐
        │         etcd 集群            │  ← 配置中心(秒级生效)
        └─────────────────────────────┘
```

**核心特性**:
- **动态配置**: 基于etcd,配置变更秒级生效
- **高性能**: 单核QPS可达23000
- **云原生**: Kubernetes友好,支持控制平面/数据平面分离
- **多协议**: HTTP(S), gRPC, TCP/UDP, MQTT, Kafka

### 4.2 APISIX 插件生态

**内置插件**(80+):

| 分类 | 插件示例 |
|------|---------|
| **认证鉴权** | jwt-auth, key-auth, wolf-rbac, opa |
| **安全防护** | ip-restriction, ua-restriction, csrf, waf |
| **流量管理** | limit-req, limit-count, traffic-split, proxy-rewrite |
| **可观测性** | prometheus, skywalking, opentelemetry, zipkin |
| **Serverless** | serverless-pre-function, serverless-post-function, aws-lambda |
| **其他** | grpc-transcode, dubbo-proxy, kafka-logger, redirect |

**动态插件加载**:

```bash
# 热加载外部插件(无需重启)
curl http://127.0.0.1:9180/apisix/admin/plugins/reload -X PUT
```

### 4.3 APISIX 配置示例

**路由配置**:

```bash
# 通过Admin API配置
curl http://127.0.0.1:9180/apisix/admin/routes/1 -X PUT -d '
{
  "uri": "/api/users/*",
  "methods": ["GET", "POST"],
  "upstream": {
    "type": "roundrobin",
    "nodes": {
      "192.168.1.10:8080": 1,
      "192.168.1.11:8080": 1
    },
    "timeout": {
      "connect": 6,
      "send": 6,
      "read": 6
    }
  },
  "plugins": {
    "limit-req": {
      "rate": 100,
      "burst": 50,
      "key": "remote_addr"
    },
    "prometheus": {}
  }
}'
```

**流量分割(金丝雀发布)**:

```yaml
# 90% 流量到 v1, 10% 流量到 v2
routes:
  - uri: /api/orders
    plugins:
      traffic-split:
        rules:
          - weighted_upstreams:
              - upstream:
                  name: order-service-v1
                  type: roundrobin
                  nodes:
                    "192.168.1.20:8080": 1
                weight: 90
              - upstream:
                  name: order-service-v2
                  type: roundrobin
                  nodes:
                    "192.168.1.30:8080": 1
                weight: 10
```

**Serverless插件**(在网关层执行Lua代码):

```yaml
routes:
  - uri: /api/hello
    plugins:
      serverless-pre-function:
        phase: rewrite
        functions:
          - "return function(conf, ctx)
               local core = require('apisix.core')
               core.log.warn('Custom logic executed')
               ngx.var.my_custom_var = 'value'
             end"
```

### 4.4 APISIX 优缺点

**优点**:
- ✅ 动态配置,秒级生效(基于etcd)
- ✅ 高性能,单核QPS超过Kong
- ✅ 云原生,Kubernetes集成好
- ✅ 国产开源,中文文档友好
- ✅ 活跃开发,Apache顶级项目
- ✅ 支持控制平面/数据平面分离

**缺点**:
- ❌ 生态相对Kong较新
- ❌ 需要维护etcd集群
- ❌ 企业级支持不如Kong成熟
- ❌ 部分高级功能需要商业版

---

## 五、Kong vs APISIX 对比

### 5.1 核心对比

| 维度 | Kong | APISIX |
|------|------|--------|
| **性能** | 单核QPS ~15000 | 单核QPS ~23000 |
| **配置存储** | PostgreSQL/Cassandra | etcd |
| **配置生效** | 分钟级(数据库轮询) | 秒级(etcd watch) |
| **插件数量** | 50+ | 80+ |
| **插件开发** | Lua | Lua / Java / Go(wasm) |
| **协议支持** | HTTP, gRPC, WebSocket | HTTP, gRPC, TCP/UDP, MQTT, Kafka |
| **Service Mesh** | ❌ | ✅ (数据平面模式) |
| **可观测性** | Prometheus, Zipkin | Prometheus, SkyWalking, OpenTelemetry |
| **社区** | 28k+ stars (成熟) | 14k+ stars (快速增长) |
| **商业支持** | Kong Inc. (强) | API7.ai (中) |
| **云原生** | 支持Kubernetes | 原生Kubernetes,控制/数据平面分离 |
| **学习曲线** | 中等 | 较陡 |

### 5.2 性能对比

**基准测试**(单核,8路由,16个upstream):

```
Kong:     14,000 QPS
APISIX:   23,000 QPS
提升:     ~64%
```

**延迟对比**(P99):

```
Kong:     12ms
APISIX:   6ms
```

### 5.3 选型建议

**选择 Kong 的场景**:
- ✅ 需要成熟稳定的企业级支持
- ✅ 团队熟悉Lua生态
- ✅ 需要丰富的第三方集成
- ✅ 对配置实时性要求不高
- ✅ 预算充足(企业版功能)

**选择 APISIX 的场景**:
- ✅ 追求极致性能
- ✅ 需要动态配置(秒级生效)
- ✅ 云原生/Kubernetes环境
- ✅ 需要Service Mesh能力
- ✅ 国内团队,中文支持好
- ✅ 需要多协议支持(TCP/MQTT等)

---

## 六、生产环境最佳实践

### 6.1 高可用部署

**Kong 高可用架构**:

```
         ┌──────────┐
         │ 负载均衡 │ (Nginx/HAProxy)
         └────┬─────┘
              │
     ┌────────┼────────┐
     ↓        ↓        ↓
 [Kong1]  [Kong2]  [Kong3]  ← 无状态,水平扩展
     │        │        │
     └────────┼────────┘
              ↓
      [PostgreSQL主从]  ← 有状态,主从复制
```

**APISIX 高可用架构**:

```
         ┌──────────┐
         │ 负载均衡 │
         └────┬─────┘
              │
     ┌────────┼────────┐
     ↓        ↓        ↓
[APISIX1][APISIX2][APISIX3]  ← 数据平面
     │        │        │
     └────────┼────────┘
              ↓
      [etcd 集群]  ← 3/5/7节点
              ↑
       [Dashboard]  ← 控制平面
```

### 6.2 监控告警

**关键指标**:

```yaml
# Prometheus 监控规则
groups:
  - name: api_gateway_alerts
    rules:
      # 错误率告警
      - alert: HighErrorRate
        expr: rate(kong_http_status{code=~"5.."}[5m]) > 0.05
        for: 5m
        annotations:
          summary: "API网关5xx错误率过高"

      # 延迟告警
      - alert: HighLatency
        expr: histogram_quantile(0.99, kong_latency_bucket) > 1000
        for: 5m
        annotations:
          summary: "P99延迟超过1秒"

      # 上游服务健康度
      - alert: UpstreamDown
        expr: kong_upstream_target_health == 0
        for: 1m
        annotations:
          summary: "后端服务不可用"
```

### 6.3 安全加固

**最小权限原则**:

```yaml
# Kong RBAC配置(企业版)
roles:
  - name: developer
    permissions:
      - resource: routes
        actions: [read]
      - resource: services
        actions: [read]

  - name: admin
    permissions:
      - resource: "*"
        actions: [create, read, update, delete]
```

**TLS/mTLS配置**:

```yaml
# APISIX mTLS配置
ssl:
  - sni: api.example.com
    cert: /path/to/server.crt
    key: /path/to/server.key
    client:
      ca: /path/to/ca.crt
      verify: true  # 启用双向认证
```

### 6.4 性能优化

**缓存策略**:

```yaml
# APISIX 缓存插件
plugins:
  proxy-cache:
    cache_ttl: 60          # 缓存60秒
    cache_zone: disk_cache_one
    cache_key:
      - $host
      - $request_uri
    cache_bypass:
      - $arg_bypass
```

**连接池优化**:

```yaml
# Kong upstream配置
upstreams:
  - name: backend
    slots: 10000
    algorithm: consistent-hashing
    healthchecks:
      active:
        http_path: /health
        healthy:
          interval: 5
          successes: 2
        unhealthy:
          interval: 5
          http_failures: 3
```

### 6.5 灰度发布集成

```yaml
# APISIX 金丝雀发布
routes:
  - uri: /api/*
    plugins:
      traffic-split:
        rules:
          - match:
              - vars:
                  - ["http_x-canary", "==", "true"]  # 特定用户
            weighted_upstreams:
              - upstream_id: service-v2
                weight: 100
          - weighted_upstreams:
              - upstream_id: service-v1
                weight: 90
              - upstream_id: service-v2
                weight: 10
```

---

## 七、总结

### 7.1 API网关核心能力

```
流量管理: 路由、负载均衡、熔断、限流
安全防护: 认证、鉴权、IP控制、WAF
协议转换: HTTP→gRPC、聚合、缓存
可观测性: 日志、监控、链路追踪
```

### 7.2 技术选型总结

| 场景 | 推荐方案 |
|------|---------|
| **企业级稳定性** | Kong Enterprise |
| **高性能要求** | APISIX |
| **云原生环境** | APISIX (Kubernetes集成好) |
| **预算有限** | APISIX 或 Kong OSS |
| **多协议支持** | APISIX (TCP/MQTT等) |
| **Service Mesh** | APISIX 数据平面模式 |

### 7.3 关键要点

1. **网关不是银弹**:避免把所有逻辑放入网关,保持轻量
2. **高可用优先**:网关是单点,必须做好容灾
3. **性能监控**:网关是瓶颈点,需重点监控
4. **插件谨慎使用**:每个插件都会增加延迟
5. **配置版本化**:使用声明式配置,纳入Git管理

### 7.4 其他网关方案

- **Nginx + Lua**: 轻量,适合简单场景
- **Envoy**: Service Mesh数据平面,复杂但强大
- **Traefik**: Cloud Native,自动发现,适合容器环境
- **Tyk**: Go语言实现,Dashboard功能强大
- **Amazon API Gateway**: 云服务,完全托管

---

**参考资料**:
- [Kong官方文档](https://docs.konghq.com/)
- [APISIX官方文档](https://apisix.apache.org/docs/)
- [API网关模式 - Microsoft](https://docs.microsoft.com/en-us/azure/architecture/microservices/design/gateway)
