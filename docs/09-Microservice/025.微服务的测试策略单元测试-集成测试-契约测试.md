---
title: 微服务的测试策略(单元测试/集成测试/契约测试)
tags:
  - 微服务
status: robot
class: 微服务
slug: microservice-testing-strategies-unit-integration-contract
ref:
---

## 核心要点

**微服务测试金字塔包括:单元测试(70%)、集成测试(20%)、端到端测试(10%)**,核心原则是**快速反馈、隔离测试、自动化**。关键技术包括:**契约测试(Pact)解决服务间协议验证、Mock/Stub隔离依赖、测试容器(Testcontainers)提供真实环境**。重点是**左移测试(Shift-Left)、测试覆盖率(80%+)、CI/CD集成自动化测试**。

---

## 详细回答

### 一、微服务测试金字塔

传统测试金字塔在微服务架构下的演进:

```
         ┌──────────────┐
         │  端到端测试   │  10%  - 最慢、最脆弱、最昂贵
         │  (E2E Test)  │
         └──────────────┘
       ┌────────────────────┐
       │    集成测试         │  20%  - 验证服务间交互
       │ (Integration Test) │
       └────────────────────┘
    ┌──────────────────────────┐
    │      单元测试             │  70%  - 最快、最稳定、最便宜
    │    (Unit Test)           │
    └──────────────────────────┘
```

**微服务测试新增:**
- **契约测试(Contract Test)** - 验证服务间API契约
- **组件测试(Component Test)** - 测试单个微服务
- **混沌测试(Chaos Test)** - 测试系统韧性

### 二、单元测试(Unit Test)

#### 1. 什么是单元测试

**目标:**测试最小可测试单元(函数、方法),**隔离所有外部依赖**。

**特点:**
- ✅ 快速(毫秒级)
- ✅ 无外部依赖(数据库、网络、文件)
- ✅ 可重复执行
- ✅ 覆盖率高(目标80%+)

#### 2. Go单元测试实践

**示例:订单服务单元测试**

```go
// order_service.go
package service

import (
    "context"
    "errors"
)

type OrderService struct {
    repo           OrderRepository
    inventoryClient InventoryClient
    paymentClient  PaymentClient
}

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 1. 参数验证
    if err := s.validateRequest(req); err != nil {
        return nil, err
    }

    // 2. 检查库存
    available, err := s.inventoryClient.CheckStock(ctx, req.ProductID, req.Quantity)
    if err != nil {
        return nil, err
    }
    if !available {
        return nil, errors.New("insufficient stock")
    }

    // 3. 创建订单
    order := &Order{
        UserID:    req.UserID,
        ProductID: req.ProductID,
        Quantity:  req.Quantity,
        Amount:    req.Quantity * req.UnitPrice,
        Status:    "PENDING",
    }

    if err := s.repo.Save(ctx, order); err != nil {
        return nil, err
    }

    return order, nil
}

func (s *OrderService) validateRequest(req *CreateOrderRequest) error {
    if req.UserID == "" {
        return errors.New("user_id is required")
    }
    if req.Quantity <= 0 {
        return errors.New("quantity must be positive")
    }
    return nil
}
```

**单元测试(使用Mock):**

```go
// order_service_test.go
package service

import (
    "context"
    "errors"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock实现
type MockOrderRepository struct {
    mock.Mock
}

func (m *MockOrderRepository) Save(ctx context.Context, order *Order) error {
    args := m.Called(ctx, order)
    return args.Error(0)
}

type MockInventoryClient struct {
    mock.Mock
}

func (m *MockInventoryClient) CheckStock(ctx context.Context, productID string, quantity int) (bool, error) {
    args := m.Called(ctx, productID, quantity)
    return args.Bool(0), args.Error(1)
}

// 测试用例
func TestCreateOrder_Success(t *testing.T) {
    // Arrange (准备)
    mockRepo := new(MockOrderRepository)
    mockInventory := new(MockInventoryClient)

    service := &OrderService{
        repo:           mockRepo,
        inventoryClient: mockInventory,
    }

    req := &CreateOrderRequest{
        UserID:    "user-123",
        ProductID: "product-456",
        Quantity:  2,
        UnitPrice: 100.0,
    }

    // 设置Mock期望
    mockInventory.On("CheckStock", mock.Anything, "product-456", 2).Return(true, nil)
    mockRepo.On("Save", mock.Anything, mock.AnythingOfType("*Order")).Return(nil)

    // Act (执行)
    order, err := service.CreateOrder(context.Background(), req)

    // Assert (断言)
    assert.NoError(t, err)
    assert.NotNil(t, order)
    assert.Equal(t, "user-123", order.UserID)
    assert.Equal(t, "product-456", order.ProductID)
    assert.Equal(t, 200.0, order.Amount)
    assert.Equal(t, "PENDING", order.Status)

    // 验证Mock被正确调用
    mockInventory.AssertExpectations(t)
    mockRepo.AssertExpectations(t)
}

func TestCreateOrder_InsufficientStock(t *testing.T) {
    mockRepo := new(MockOrderRepository)
    mockInventory := new(MockInventoryClient)

    service := &OrderService{
        repo:           mockRepo,
        inventoryClient: mockInventory,
    }

    req := &CreateOrderRequest{
        UserID:    "user-123",
        ProductID: "product-456",
        Quantity:  10,
        UnitPrice: 100.0,
    }

    // 库存不足
    mockInventory.On("CheckStock", mock.Anything, "product-456", 10).Return(false, nil)

    order, err := service.CreateOrder(context.Background(), req)

    assert.Error(t, err)
    assert.Nil(t, order)
    assert.Equal(t, "insufficient stock", err.Error())

    // 不应该调用Save
    mockRepo.AssertNotCalled(t, "Save")
}

func TestCreateOrder_ValidationError(t *testing.T) {
    service := &OrderService{}

    testCases := []struct {
        name    string
        req     *CreateOrderRequest
        wantErr string
    }{
        {
            name: "missing user_id",
            req: &CreateOrderRequest{
                ProductID: "product-456",
                Quantity:  1,
            },
            wantErr: "user_id is required",
        },
        {
            name: "invalid quantity",
            req: &CreateOrderRequest{
                UserID:    "user-123",
                ProductID: "product-456",
                Quantity:  0,
            },
            wantErr: "quantity must be positive",
        },
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            _, err := service.CreateOrder(context.Background(), tc.req)
            assert.Error(t, err)
            assert.Equal(t, tc.wantErr, err.Error())
        })
    }
}
```

#### 3. 表驱动测试(Table-Driven Tests)

Go中推荐的测试模式:

```go
func TestCalculateDiscount(t *testing.T) {
    tests := []struct {
        name     string
        amount   float64
        userType string
        want     float64
    }{
        {"VIP用户打8折", 100.0, "VIP", 80.0},
        {"普通用户打9折", 100.0, "NORMAL", 90.0},
        {"新用户不打折", 100.0, "NEW", 100.0},
        {"金额为0", 0.0, "VIP", 0.0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := CalculateDiscount(tt.amount, tt.userType)
            assert.Equal(t, tt.want, got)
        })
    }
}
```

#### 4. 测试覆盖率

```bash
# 运行测试并生成覆盖率报告
go test ./... -coverprofile=coverage.out

# 查看覆盖率
go tool cover -func=coverage.out

# 生成HTML报告
go tool cover -html=coverage.out -o coverage.html
```

**目标覆盖率:**
- 核心业务逻辑: 90%+
- 整体项目: 80%+
- 工具类函数: 95%+

### 三、集成测试(Integration Test)

#### 1. 什么是集成测试

**目标:**测试多个组件的交互,包括**真实的数据库、消息队列、缓存**等。

**特点:**
- 比单元测试慢(秒级)
- 需要外部依赖
- 测试真实集成场景

#### 2. 使用Testcontainers进行集成测试

Testcontainers提供轻量级、一次性的Docker容器,用于测试。

```go
package integration

import (
    "context"
    "database/sql"
    "testing"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
    _ "github.com/go-sql-driver/mysql"
)

func TestOrderRepository_Integration(t *testing.T) {
    ctx := context.Background()

    // 启动MySQL容器
    mysqlContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: testcontainers.ContainerRequest{
            Image:        "mysql:8.0",
            ExposedPorts: []string{"3306/tcp"},
            Env: map[string]string{
                "MYSQL_ROOT_PASSWORD": "password",
                "MYSQL_DATABASE":      "testdb",
            },
            WaitingFor: wait.ForLog("port: 3306  MySQL Community Server"),
        },
        Started: true,
    })
    if err != nil {
        t.Fatal(err)
    }
    defer mysqlContainer.Terminate(ctx)

    // 获取MySQL连接信息
    host, _ := mysqlContainer.Host(ctx)
    port, _ := mysqlContainer.MappedPort(ctx, "3306")

    dsn := fmt.Sprintf("root:password@tcp(%s:%s)/testdb?parseTime=true", host, port.Port())
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        t.Fatal(err)
    }
    defer db.Close()

    // 初始化表结构
    _, err = db.Exec(`
        CREATE TABLE orders (
            id VARCHAR(36) PRIMARY KEY,
            user_id VARCHAR(36) NOT NULL,
            product_id VARCHAR(36) NOT NULL,
            quantity INT NOT NULL,
            amount DECIMAL(10,2) NOT NULL,
            status VARCHAR(20) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `)
    if err != nil {
        t.Fatal(err)
    }

    // 测试OrderRepository
    repo := NewOrderRepository(db)

    order := &Order{
        ID:        "order-001",
        UserID:    "user-123",
        ProductID: "product-456",
        Quantity:  2,
        Amount:    200.0,
        Status:    "PENDING",
    }

    // 测试Save
    err = repo.Save(ctx, order)
    assert.NoError(t, err)

    // 测试GetByID
    retrieved, err := repo.GetByID(ctx, "order-001")
    assert.NoError(t, err)
    assert.Equal(t, order.UserID, retrieved.UserID)
    assert.Equal(t, order.Amount, retrieved.Amount)

    // 测试Update
    order.Status = "PAID"
    err = repo.Update(ctx, order)
    assert.NoError(t, err)

    updated, _ := repo.GetByID(ctx, "order-001")
    assert.Equal(t, "PAID", updated.Status)
}
```

#### 3. 测试Redis集成

```go
func TestCacheService_Integration(t *testing.T) {
    ctx := context.Background()

    // 启动Redis容器
    redisContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: testcontainers.ContainerRequest{
            Image:        "redis:7-alpine",
            ExposedPorts: []string{"6379/tcp"},
            WaitingFor:   wait.ForLog("Ready to accept connections"),
        },
        Started: true,
    })
    if err != nil {
        t.Fatal(err)
    }
    defer redisContainer.Terminate(ctx)

    host, _ := redisContainer.Host(ctx)
    port, _ := redisContainer.MappedPort(ctx, "6379")

    // 创建Redis客户端
    redisClient := redis.NewClient(&redis.Options{
        Addr: fmt.Sprintf("%s:%s", host, port.Port()),
    })
    defer redisClient.Close()

    cacheService := NewCacheService(redisClient)

    // 测试Set和Get
    err = cacheService.Set(ctx, "user:123", "John Doe", 5*time.Minute)
    assert.NoError(t, err)

    value, err := cacheService.Get(ctx, "user:123")
    assert.NoError(t, err)
    assert.Equal(t, "John Doe", value)

    // 测试过期
    time.Sleep(6 * time.Minute)
    _, err = cacheService.Get(ctx, "user:123")
    assert.Error(t, err)
}
```

### 四、契约测试(Contract Test)

#### 1. 什么是契约测试

**问题:**微服务A调用微服务B,如何确保API契约不会被破坏?

传统方案:端到端测试 → 慢、脆弱、难维护
契约测试:**消费者驱动契约测试(Consumer-Driven Contract Test)**

**核心思想:**
1. 消费者(Consumer)定义期望的API契约
2. 提供者(Provider)验证是否满足契约

#### 2. 使用Pact进行契约测试

**场景:订单服务(Consumer)调用库存服务(Provider)**

**消费者端测试(订单服务):**

```go
package pact

import (
    "fmt"
    "testing"
    "github.com/pact-foundation/pact-go/dsl"
)

func TestInventoryClient_CheckStock(t *testing.T) {
    // 创建Pact
    pact := &dsl.Pact{
        Consumer: "order-service",
        Provider: "inventory-service",
        Host:     "localhost",
    }
    defer pact.Teardown()

    // 定义期望的交互
    pact.
        AddInteraction().
        Given("Product product-123 has 10 items in stock").  // 前置条件
        UponReceiving("A request to check stock").           // 请求描述
        WithRequest(dsl.Request{                             // 请求规范
            Method: "GET",
            Path:   dsl.String("/api/inventory/product-123"),
            Headers: dsl.MapMatcher{
                "Content-Type": dsl.String("application/json"),
            },
        }).
        WillRespondWith(dsl.Response{                        // 期望响应
            Status: 200,
            Headers: dsl.MapMatcher{
                "Content-Type": dsl.String("application/json"),
            },
            Body: dsl.Match(&InventoryResponse{
                ProductID: "product-123",
                Available: true,
                Quantity:  10,
            }),
        })

    // 运行测试
    err := pact.Verify(func() error {
        // 实际调用库存服务客户端
        client := NewInventoryClient(fmt.Sprintf("http://localhost:%d", pact.Server.Port))
        resp, err := client.CheckStock("product-123", 5)

        if err != nil {
            return err
        }

        if !resp.Available {
            return fmt.Errorf("expected available=true, got false")
        }

        return nil
    })

    if err != nil {
        t.Fatal(err)
    }

    // 生成Pact文件(pacts/order-service-inventory-service.json)
    pact.WritePact()
}
```

**提供者端验证(库存服务):**

```go
package pact

import (
    "fmt"
    "net/http"
    "testing"
    "github.com/pact-foundation/pact-go/dsl"
    "github.com/pact-foundation/pact-go/types"
)

func TestInventoryService_Provider(t *testing.T) {
    // 启动实际的库存服务
    go func() {
        router := setupInventoryRoutes()
        http.ListenAndServe(":8080", router)
    }()

    // 配置Pact验证
    pact := dsl.Pact{
        Provider: "inventory-service",
    }

    // 设置状态(对应消费者的Given)
    pact.VerifyProvider(t, types.VerifyRequest{
        ProviderBaseURL: "http://localhost:8080",
        PactURLs:        []string{"../pacts/order-service-inventory-service.json"},

        StateHandlers: types.StateHandlers{
            // 设置测试数据状态
            "Product product-123 has 10 items in stock": func() error {
                // 初始化测试数据:product-123有10个库存
                return setupTestData("product-123", 10)
            },
        },

        // 请求过滤器(添加认证等)
        RequestFilter: func(next http.Handler) http.Handler {
            return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                // 添加测试JWT token
                r.Header.Set("Authorization", "Bearer test-token")
                next.ServeHTTP(w, r)
            })
        },
    })
}
```

**CI/CD集成:**

```yaml
# .github/workflows/ci.yml
name: Pact Tests

on: [push, pull_request]

jobs:
  consumer-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run consumer tests
        run: go test ./pact/consumer/...

      - name: Publish pacts to Pact Broker
        run: |
          pact-broker publish ./pacts \
            --consumer-app-version=$GITHUB_SHA \
            --broker-base-url=$PACT_BROKER_URL \
            --broker-token=$PACT_BROKER_TOKEN

  provider-tests:
    runs-on: ubuntu-latest
    needs: consumer-tests
    steps:
      - uses: actions/checkout@v2
      - name: Verify provider
        run: go test ./pact/provider/...
```

### 五、组件测试(Component Test)

测试单个微服务的所有层级(API → 业务逻辑 → 数据库),但**Mock外部依赖**。

```go
func TestOrderAPI_ComponentTest(t *testing.T) {
    // 1. 启动真实数据库(Testcontainers)
    db := setupTestDatabase(t)
    defer db.Close()

    // 2. Mock外部服务
    mockInventory := new(MockInventoryClient)
    mockPayment := new(MockPaymentClient)

    // 3. 创建完整的应用实例
    app := &Application{
        orderService: NewOrderService(
            NewOrderRepository(db),
            mockInventory,
            mockPayment,
        ),
    }

    // 4. 启动HTTP服务器
    server := httptest.NewServer(app.Handler())
    defer server.Close()

    // 5. 执行端到端API测试
    mockInventory.On("CheckStock", mock.Anything, "product-123", 2).Return(true, nil)
    mockPayment.On("Charge", mock.Anything, 200.0).Return(nil)

    resp, err := http.Post(
        server.URL+"/api/orders",
        "application/json",
        strings.NewReader(`{
            "user_id": "user-123",
            "product_id": "product-123",
            "quantity": 2,
            "unit_price": 100.0
        }`),
    )

    assert.NoError(t, err)
    assert.Equal(t, http.StatusCreated, resp.StatusCode)

    var order Order
    json.NewDecoder(resp.Body).Decode(&order)
    assert.NotEmpty(t, order.ID)
    assert.Equal(t, "PENDING", order.Status)
}
```

### 六、端到端测试(E2E Test)

测试完整的用户场景,涉及多个微服务。

```go
package e2e

import (
    "testing"
    "github.com/playwright-community/playwright-go"
)

func TestOrderFlow_E2E(t *testing.T) {
    // 1. 启动所有微服务(使用docker-compose)
    setupMicroservices(t)
    defer teardownMicroservices()

    // 2. 使用Playwright进行UI自动化测试
    pw, err := playwright.Run()
    if err != nil {
        t.Fatal(err)
    }
    defer pw.Stop()

    browser, err := pw.Chromium.Launch()
    if err != nil {
        t.Fatal(err)
    }
    defer browser.Close()

    page, err := browser.NewPage()
    if err != nil {
        t.Fatal(err)
    }

    // 3. 执行用户操作
    // 登录
    page.Goto("http://localhost:3000/login")
    page.Fill("#username", "testuser")
    page.Fill("#password", "password123")
    page.Click("#login-button")

    // 选择商品
    page.Goto("http://localhost:3000/products")
    page.Click("#product-123")
    page.Click("#add-to-cart")

    // 下单
    page.Goto("http://localhost:3000/checkout")
    page.Click("#place-order")

    // 4. 验证结果
    page.WaitForSelector("#order-success")
    orderID := page.TextContent("#order-id")
    assert.NotEmpty(t, orderID)

    // 验证数据库
    order := getOrderFromDB(orderID)
    assert.Equal(t, "PAID", order.Status)
}
```

### 七、性能测试和压测

```go
func BenchmarkCreateOrder(b *testing.B) {
    service := setupService()

    req := &CreateOrderRequest{
        UserID:    "user-123",
        ProductID: "product-456",
        Quantity:  1,
        UnitPrice: 100.0,
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        service.CreateOrder(context.Background(), req)
    }
}

// 运行: go test -bench=. -benchmem
// 结果:
// BenchmarkCreateOrder-8   5000  234567 ns/op  1024 B/op  10 allocs/op
```

**使用k6进行负载测试:**

```javascript
// load_test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '30s', target: 100 },  // 30秒内增加到100并发
    { duration: '1m', target: 100 },   // 保持1分钟
    { duration: '30s', target: 0 },    // 30秒内降到0
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95%请求<500ms
    http_req_failed: ['rate<0.01'],    // 错误率<1%
  },
};

export default function () {
  const payload = JSON.stringify({
    user_id: 'user-123',
    product_id: 'product-456',
    quantity: 1,
    unit_price: 100.0,
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer test-token',
    },
  };

  let res = http.post('http://localhost:8080/api/orders', payload, params);

  check(res, {
    'status is 201': (r) => r.status === 201,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });

  sleep(1);
}
```

```bash
# 运行负载测试
k6 run load_test.js
```

### 八、测试最佳实践

#### 1. 测试隔离

```go
// ❌ 错误:测试间共享状态
var globalCounter int

func TestIncrement(t *testing.T) {
    globalCounter++
    assert.Equal(t, 1, globalCounter)  // 第二次运行会失败
}

// ✅ 正确:每个测试独立
func TestIncrement(t *testing.T) {
    counter := 0
    counter++
    assert.Equal(t, 1, counter)
}
```

#### 2. 使用测试夹具(Test Fixtures)

```go
func setupTestDB(t *testing.T) *sql.DB {
    db, _ := sql.Open("mysql", "root:password@tcp(localhost:3306)/testdb")

    // 清理旧数据
    db.Exec("TRUNCATE TABLE orders")

    // 插入测试数据
    db.Exec("INSERT INTO orders VALUES ('order-1', 'user-1', 'product-1', 1, 100, 'PAID')")

    t.Cleanup(func() {
        db.Close()
    })

    return db
}
```

#### 3. 并行测试

```go
func TestOrderService(t *testing.T) {
    t.Run("CreateOrder", func(t *testing.T) {
        t.Parallel()  // 并行运行
        // 测试逻辑
    })

    t.Run("GetOrder", func(t *testing.T) {
        t.Parallel()
        // 测试逻辑
    })
}

// 运行: go test -parallel=4
```

#### 4. 测试金字塔比例

```
项目测试用例分布:
- 单元测试: 500个(70%)
- 集成测试: 150个(20%)
- 契约测试: 50个(7%)
- E2E测试: 20个(3%)

总计: 720个测试用例
执行时间: 单元(1分钟) + 集成(5分钟) + E2E(10分钟) = 16分钟
```

### 九、CI/CD测试流程

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-go@v2
        with:
          go-version: '1.21'

      - name: Run unit tests
        run: |
          go test ./... -v -coverprofile=coverage.out
          go tool cover -func=coverage.out

      - name: Check coverage
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "Coverage $COVERAGE% is below 80%"
            exit 1
          fi

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: password
          MYSQL_DATABASE: testdb
        ports:
          - 3306:3306

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v2
      - name: Run integration tests
        run: go test ./test/integration/... -v

  contract-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - uses: actions/checkout@v2
      - name: Run contract tests
        run: go test ./test/contract/... -v

      - name: Publish pacts
        run: pact-broker publish ./pacts --broker-base-url=$PACT_BROKER_URL

  e2e-tests:
    runs-on: ubuntu-latest
    needs: [integration-tests, contract-tests]
    steps:
      - uses: actions/checkout@v2

      - name: Start services
        run: docker-compose up -d

      - name: Run E2E tests
        run: go test ./test/e2e/... -v

      - name: Cleanup
        if: always()
        run: docker-compose down
```

### 总结

微服务测试策略的核心要点:

1. **单元测试(70%)** - 快速反馈,隔离依赖,高覆盖率
2. **集成测试(20%)** - 真实环境,验证集成点
3. **契约测试** - 消费者驱动,防止API破坏性变更
4. **组件测试** - 测试单个微服务的完整功能
5. **E2E测试(10%)** - 关键用户场景,最少数量

关键原则:
- **测试金字塔** - 底层测试越多越好
- **左移测试(Shift-Left)** - 尽早发现问题
- **自动化优先** - 所有测试集成到CI/CD
- **快速反馈** - 单元测试<1分钟,集成测试<5分钟
- **测试隔离** - 每个测试独立,可重复执行
- **覆盖率目标** - 核心业务逻辑90%+,整体80%+
