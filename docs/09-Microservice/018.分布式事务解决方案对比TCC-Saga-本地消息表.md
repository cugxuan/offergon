---
title: åˆ†å¸ƒå¼äº‹åŠ¡è§£å†³æ–¹æ¡ˆå¯¹æ¯”ï¼ˆTCC/Saga/æœ¬åœ°æ¶ˆæ¯è¡¨ï¼‰
tags:
  - åˆ†å¸ƒå¼
  - å¾®æœåŠ¡
status: robot
class: å¾®æœåŠ¡
slug: distributed-transaction-solutions
ref:
---

## æ ¸å¿ƒè¦ç‚¹

**CAPå®šç†é™åˆ¶**:åˆ†å¸ƒå¼ç³»ç»Ÿæ— æ³•åŒæ—¶ä¿è¯ä¸€è‡´æ€§ã€å¯ç”¨æ€§ã€åˆ†åŒºå®¹é”™,å¿…é¡»æƒè¡¡
**TCCæ¨¡å¼**:Try-Confirm-Cancelä¸¤é˜¶æ®µæäº¤å˜ç§,å¼ºä¸€è‡´æ€§,ä¸šåŠ¡ä¾µå…¥å¤§,é€‚åˆé‡‘èåœºæ™¯
**Sagaæ¨¡å¼**:é•¿äº‹åŠ¡æ‹†åˆ†+è¡¥å¿æœºåˆ¶,æœ€ç»ˆä¸€è‡´æ€§,ä¸šåŠ¡ä¾µå…¥ä¸­ç­‰,é€‚åˆè®¢å•æµç¨‹
**æœ¬åœ°æ¶ˆæ¯è¡¨**:åŸºäºäº‹ä»¶é©±åŠ¨+å®šæ—¶è½®è¯¢,æœ€ç»ˆä¸€è‡´æ€§,ä¸šåŠ¡ä¾µå…¥å°,é€‚åˆå¼‚æ­¥åœºæ™¯

---

## è¯¦ç»†å›ç­”

### ä¸€ã€åˆ†å¸ƒå¼äº‹åŠ¡çš„æŒ‘æˆ˜

åœ¨å•ä½“åº”ç”¨ä¸­,ä¾é æ•°æ®åº“çš„ACIDç‰¹æ€§ä¿è¯äº‹åŠ¡:

```sql
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

ä½†åœ¨å¾®æœåŠ¡æ¶æ„ä¸‹,ä¸€æ¬¡ä¸šåŠ¡æ“ä½œå¯èƒ½è·¨è¶Šå¤šä¸ªæœåŠ¡å’Œæ•°æ®åº“:

```
è®¢å•æœåŠ¡: åˆ›å»ºè®¢å•
åº“å­˜æœåŠ¡: æ‰£å‡åº“å­˜
æ”¯ä»˜æœåŠ¡: æ‰£æ¬¾
ç§¯åˆ†æœåŠ¡: å¢åŠ ç§¯åˆ†
```

**é¢ä¸´çš„é—®é¢˜**:
```
âŒ ä¸åŒæœåŠ¡ä½¿ç”¨ç‹¬ç«‹æ•°æ®åº“,æ— æ³•ç”¨æ•°æ®åº“äº‹åŠ¡ä¿è¯
âŒ ç½‘ç»œä¸å¯é ,æœåŠ¡è°ƒç”¨å¯èƒ½å¤±è´¥æˆ–è¶…æ—¶
âŒ éƒ¨åˆ†æˆåŠŸéƒ¨åˆ†å¤±è´¥å¯¼è‡´æ•°æ®ä¸ä¸€è‡´
âŒ ä¼ ç»Ÿ2PC(ä¸¤é˜¶æ®µæäº¤)æ€§èƒ½å·®ä¸”å­˜åœ¨é˜»å¡é—®é¢˜
```

---

### äºŒã€TCCæ¨¡å¼è¯¦è§£

TCCæ˜¯Try-Confirm-Cancelçš„ç¼©å†™,ä¸€ç§æ”¹è¿›çš„ä¸¤é˜¶æ®µæäº¤æ–¹æ¡ˆã€‚

#### 1. æ ¸å¿ƒåŸç†

```
é˜¶æ®µä¸€ Try: é¢„ç•™èµ„æº(å†»ç»“ä½™é¢ã€é”å®šåº“å­˜)
é˜¶æ®µäºŒ Confirm: ç¡®è®¤æ“ä½œ(çœŸæ­£æ‰£æ¬¾ã€æ‰£åº“å­˜)
å¼‚å¸¸æ—¶ Cancel: å–æ¶ˆæ“ä½œ(è§£å†»ä½™é¢ã€é‡Šæ”¾åº“å­˜)
```

#### 2. å®Œæ•´æµç¨‹ç¤ºä¾‹

**ä¸šåŠ¡åœºæ™¯**:ç”¨æˆ·ä¸‹å•,æ‰£æ¬¾100å…ƒå¹¶æ‰£åº“å­˜1ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è®¢å•æœåŠ¡     â”‚  åè°ƒè€…
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€ Tryé˜¶æ®µ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                                       â”‚
       â–¼                                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚è´¦æˆ·æœåŠ¡ â”‚                            â”‚åº“å­˜æœåŠ¡ â”‚
  â”‚Try:     â”‚                            â”‚Try:     â”‚
  â”‚å†»ç»“100å…ƒâ”‚                            â”‚é”å®š1ä»¶  â”‚
  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
       â”‚  æˆåŠŸ                                 â”‚ æˆåŠŸ
       â”‚                                       â”‚
       â”œâ”€ Confirmé˜¶æ®µ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚                                       â”‚
       â–¼                                       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚è´¦æˆ·æœåŠ¡ â”‚                            â”‚åº“å­˜æœåŠ¡ â”‚
  â”‚Confirm: â”‚                            â”‚Confirm: â”‚
  â”‚æ‰£å‡100å…ƒâ”‚                            â”‚æ‰£å‡1ä»¶  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

// å¦‚æœä»»ä½•ä¸€ä¸ªTryå¤±è´¥,åˆ™è°ƒç”¨æ‰€æœ‰çš„Cancel
```

#### 3. Goè¯­è¨€å®ç°ç¤ºä¾‹

```go
package tcc

import (
    "context"
    "database/sql"
    "fmt"
)

// TCCCoordinator TCCåè°ƒå™¨
type TCCCoordinator struct {
    db          *sql.DB
    accountSvc  *AccountService
    inventorySvc *InventoryService
}

// ExecuteTransaction æ‰§è¡ŒTCCäº‹åŠ¡
func (c *TCCCoordinator) ExecuteTransaction(ctx context.Context, orderID string, userID int64, productID int64, amount int) error {
    // 1. Tryé˜¶æ®µ: é¢„ç•™èµ„æº
    txID := generateTxID()

    // Try: å†»ç»“è´¦æˆ·ä½™é¢
    err := c.accountSvc.TryFreeze(ctx, txID, userID, amount)
    if err != nil {
        return fmt.Errorf("è´¦æˆ·å†»ç»“å¤±è´¥: %w", err)
    }

    // Try: é”å®šåº“å­˜
    err = c.inventorySvc.TryLock(ctx, txID, productID, 1)
    if err != nil {
        // å›æ»šå·²å†»ç»“çš„è´¦æˆ·
        c.accountSvc.CancelFreeze(ctx, txID, userID)
        return fmt.Errorf("åº“å­˜é”å®šå¤±è´¥: %w", err)
    }

    // 2. Confirmé˜¶æ®µ: ç¡®è®¤æ“ä½œ
    err = c.accountSvc.ConfirmDeduct(ctx, txID, userID)
    if err != nil {
        // å›æ»šæ‰€æœ‰æ“ä½œ
        c.accountSvc.CancelFreeze(ctx, txID, userID)
        c.inventorySvc.CancelLock(ctx, txID, productID)
        return fmt.Errorf("è´¦æˆ·æ‰£æ¬¾å¤±è´¥: %w", err)
    }

    err = c.inventorySvc.ConfirmDeduct(ctx, txID, productID)
    if err != nil {
        // æ­¤æ—¶è´¦æˆ·å·²æ‰£æ¬¾,éœ€è¦äººå·¥ä»‹å…¥æˆ–è¡¥å¿
        return fmt.Errorf("åº“å­˜æ‰£å‡å¤±è´¥: %w", err)
    }

    return nil
}

// AccountService è´¦æˆ·æœåŠ¡å®ç°
type AccountService struct {
    db *sql.DB
}

// TryFreeze å†»ç»“ä½™é¢
func (s *AccountService) TryFreeze(ctx context.Context, txID string, userID int64, amount int) error {
    // æ•°æ®åº“è®¾è®¡: accountsè¡¨å¢åŠ  frozen_balanceå­—æ®µ
    query := `
        UPDATE accounts
        SET balance = balance - ?,
            frozen_balance = frozen_balance + ?
        WHERE user_id = ? AND balance >= ?
    `
    result, err := s.db.ExecContext(ctx, query, amount, amount, userID, amount)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("ä½™é¢ä¸è¶³")
    }

    // è®°å½•TCCäº‹åŠ¡æ—¥å¿—
    s.recordTCCLog(ctx, txID, "account", "TRY", userID, amount)
    return nil
}

// ConfirmDeduct ç¡®è®¤æ‰£æ¬¾
func (s *AccountService) ConfirmDeduct(ctx context.Context, txID string, userID int64) error {
    // ä»frozen_balanceè½¬ä¸ºçœŸæ­£æ‰£é™¤
    query := `
        UPDATE accounts
        SET frozen_balance = frozen_balance - (
            SELECT amount FROM tcc_logs WHERE tx_id = ? AND resource = 'account'
        )
        WHERE user_id = ?
    `
    _, err := s.db.ExecContext(ctx, query, txID, userID)
    if err != nil {
        return err
    }

    s.updateTCCLog(ctx, txID, "CONFIRM")
    return nil
}

// CancelFreeze å–æ¶ˆå†»ç»“
func (s *AccountService) CancelFreeze(ctx context.Context, txID string, userID int64) error {
    // é‡Šæ”¾å†»ç»“çš„é‡‘é¢
    query := `
        UPDATE accounts
        SET balance = balance + frozen_balance,
            frozen_balance = 0
        WHERE user_id = ?
    `
    _, err := s.db.ExecContext(ctx, query, userID)
    if err != nil {
        return err
    }

    s.updateTCCLog(ctx, txID, "CANCEL")
    return nil
}

// TCCäº‹åŠ¡æ—¥å¿—è¡¨è®¾è®¡
/*
CREATE TABLE tcc_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tx_id VARCHAR(64) NOT NULL,
    resource VARCHAR(32) NOT NULL,  -- account/inventory
    phase VARCHAR(16) NOT NULL,     -- TRY/CONFIRM/CANCEL
    user_id BIGINT,
    product_id BIGINT,
    amount INT,
    status VARCHAR(16),             -- PENDING/SUCCESS/FAILED
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_tx_id (tx_id)
);
*/
```

#### 4. TCCä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**:
- âœ… å¼ºä¸€è‡´æ€§,æ¥è¿‘ä¼ ç»Ÿäº‹åŠ¡çš„ACIDä¿è¯
- âœ… æ— é•¿æ—¶é—´é”,æ€§èƒ½ä¼˜äº2PC
- âœ… å„é˜¶æ®µå¯ç‹¬ç«‹é‡è¯•

**ç¼ºç‚¹**:
- âŒ ä¸šåŠ¡ä¾µå…¥æ€§æå¤§,æ¯ä¸ªæ“ä½œéœ€å®ç°Try/Confirm/Cancelä¸‰ä¸ªæ¥å£
- âŒ å¼€å‘æˆæœ¬é«˜,ä»£ç å¤æ‚åº¦å¢åŠ 
- âŒ Cancelæ“ä½œå¿…é¡»æˆåŠŸ,éœ€è¦å¤„ç†å¹‚ç­‰å’Œå¼‚å¸¸æƒ…å†µ

---

### ä¸‰ã€Sagaæ¨¡å¼è¯¦è§£

Sagaå°†é•¿äº‹åŠ¡æ‹†åˆ†ä¸ºä¸€ç³»åˆ—æœ¬åœ°çŸ­äº‹åŠ¡,é€šè¿‡è¡¥å¿æœºåˆ¶ä¿è¯æœ€ç»ˆä¸€è‡´æ€§ã€‚

#### 1. æ ¸å¿ƒåŸç†

```
æ­£å‘æµç¨‹: T1 â†’ T2 â†’ T3 â†’ T4
è¡¥å¿æµç¨‹: C4 â†’ C3 â†’ C2 â†’ C1
```

æ¯ä¸ªäº‹åŠ¡Tiéƒ½æœ‰å¯¹åº”çš„è¡¥å¿äº‹åŠ¡Ci,å¦‚æœTiå¤±è´¥,åˆ™ä¾æ¬¡æ‰§è¡Œå·²å®Œæˆäº‹åŠ¡çš„è¡¥å¿ã€‚

#### 2. ä¸¤ç§ç¼–æ’æ–¹å¼

**æ–¹å¼ä¸€: äº‹ä»¶ç¼–æ’(Choreography)**

å„æœåŠ¡ç›‘å¬äº‹ä»¶,å»ä¸­å¿ƒåŒ–:

```
OrderService: åˆ›å»ºè®¢å• â†’ å‘å¸ƒOrderCreatedäº‹ä»¶
InventoryService: ç›‘å¬äº‹ä»¶ â†’ æ‰£åº“å­˜ â†’ å‘å¸ƒInventoryDeductedäº‹ä»¶
PaymentService: ç›‘å¬äº‹ä»¶ â†’ æ‰£æ¬¾ â†’ å‘å¸ƒPaymentSucceededäº‹ä»¶
PointService: ç›‘å¬äº‹ä»¶ â†’ åŠ ç§¯åˆ† â†’ å‘å¸ƒPointAddedäº‹ä»¶

// å¦‚æœPaymentServiceæ‰£æ¬¾å¤±è´¥
PaymentService: å‘å¸ƒPaymentFailedäº‹ä»¶
InventoryService: ç›‘å¬äº‹ä»¶ â†’ è¡¥å¿åº“å­˜
OrderService: ç›‘å¬äº‹ä»¶ â†’ å–æ¶ˆè®¢å•
```

**æ–¹å¼äºŒ: å‘½ä»¤ç¼–æ’(Orchestration)**

ç”±åè°ƒå™¨é›†ä¸­æ§åˆ¶æµç¨‹:

```go
package saga

import (
    "context"
    "fmt"
)

// SagaOrchestrator Sagaåè°ƒå™¨
type SagaOrchestrator struct {
    orderSvc     *OrderService
    inventorySvc *InventoryService
    paymentSvc   *PaymentService
    pointSvc     *PointService
}

// CreateOrder Sagaæµç¨‹: ä¸‹å•
func (o *SagaOrchestrator) CreateOrder(ctx context.Context, req *CreateOrderRequest) error {
    var (
        orderID     string
        inventoryOK bool
        paymentOK   bool
    )

    // Step 1: åˆ›å»ºè®¢å•
    orderID, err := o.orderSvc.CreateOrder(ctx, req)
    if err != nil {
        return fmt.Errorf("åˆ›å»ºè®¢å•å¤±è´¥: %w", err)
    }

    // Step 2: æ‰£å‡åº“å­˜
    err = o.inventorySvc.DeductInventory(ctx, req.ProductID, req.Quantity)
    if err != nil {
        // è¡¥å¿: å–æ¶ˆè®¢å•
        o.orderSvc.CancelOrder(ctx, orderID)
        return fmt.Errorf("æ‰£å‡åº“å­˜å¤±è´¥: %w", err)
    }
    inventoryOK = true

    // Step 3: æ‰£æ¬¾
    err = o.paymentSvc.Deduct(ctx, req.UserID, req.Amount)
    if err != nil {
        // è¡¥å¿: å›é€€åº“å­˜ + å–æ¶ˆè®¢å•
        if inventoryOK {
            o.inventorySvc.RestoreInventory(ctx, req.ProductID, req.Quantity)
        }
        o.orderSvc.CancelOrder(ctx, orderID)
        return fmt.Errorf("æ‰£æ¬¾å¤±è´¥: %w", err)
    }
    paymentOK = true

    // Step 4: å¢åŠ ç§¯åˆ†
    err = o.pointSvc.AddPoints(ctx, req.UserID, req.Amount/10)
    if err != nil {
        // è¡¥å¿: é€€æ¬¾ + å›é€€åº“å­˜ + å–æ¶ˆè®¢å•
        if paymentOK {
            o.paymentSvc.Refund(ctx, req.UserID, req.Amount)
        }
        if inventoryOK {
            o.inventorySvc.RestoreInventory(ctx, req.ProductID, req.Quantity)
        }
        o.orderSvc.CancelOrder(ctx, orderID)
        return fmt.Errorf("å¢åŠ ç§¯åˆ†å¤±è´¥: %w", err)
    }

    return nil
}

// è¡¥å¿æ“ä½œå®ç°
type InventoryService struct {
    db *sql.DB
}

func (s *InventoryService) DeductInventory(ctx context.Context, productID int64, quantity int) error {
    query := `UPDATE inventory SET stock = stock - ? WHERE product_id = ? AND stock >= ?`
    result, err := s.db.ExecContext(ctx, query, quantity, productID, quantity)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("åº“å­˜ä¸è¶³")
    }
    return nil
}

// è¡¥å¿æ“ä½œ: æ¢å¤åº“å­˜
func (s *InventoryService) RestoreInventory(ctx context.Context, productID int64, quantity int) error {
    query := `UPDATE inventory SET stock = stock + ? WHERE product_id = ?`
    _, err := s.db.ExecContext(ctx, query, quantity, productID)
    return err
}
```

#### 3. SagaçŠ¶æ€æœºæ¨¡å¼

ä½¿ç”¨çŠ¶æ€æœºç®¡ç†å¤æ‚æµç¨‹:

```go
package saga

type SagaState string

const (
    StateOrderCreated      SagaState = "ORDER_CREATED"
    StateInventoryDeducted SagaState = "INVENTORY_DEDUCTED"
    StatePaymentCompleted  SagaState = "PAYMENT_COMPLETED"
    StatePointAdded        SagaState = "POINT_ADDED"
    StateCompleted         SagaState = "COMPLETED"
    StateCompensating      SagaState = "COMPENSATING"
    StateFailed            SagaState = "FAILED"
)

// SagaStateMachine SagaçŠ¶æ€æœº
type SagaStateMachine struct {
    sagaID       string
    currentState SagaState
    db           *sql.DB
}

func (sm *SagaStateMachine) Execute(ctx context.Context, req *CreateOrderRequest) error {
    // æŒä¹…åŒ–Sagaæ‰§è¡ŒçŠ¶æ€
    sm.persistState(ctx, sm.currentState)

    switch sm.currentState {
    case StateOrderCreated:
        err := sm.executeInventoryDeduction(ctx, req)
        if err != nil {
            sm.startCompensation(ctx)
            return err
        }
        sm.currentState = StateInventoryDeducted
        return sm.Execute(ctx, req)

    case StateInventoryDeducted:
        err := sm.executePayment(ctx, req)
        if err != nil {
            sm.startCompensation(ctx)
            return err
        }
        sm.currentState = StatePaymentCompleted
        return sm.Execute(ctx, req)

    case StatePaymentCompleted:
        err := sm.executePointAddition(ctx, req)
        if err != nil {
            sm.startCompensation(ctx)
            return err
        }
        sm.currentState = StateCompleted
        return nil

    default:
        return fmt.Errorf("unknown state: %s", sm.currentState)
    }
}

func (sm *SagaStateMachine) startCompensation(ctx context.Context) {
    sm.currentState = StateCompensating

    // æ ¹æ®å½“å‰çŠ¶æ€æ‰§è¡Œç›¸åº”çš„è¡¥å¿æ“ä½œ
    switch sm.currentState {
    case StatePaymentCompleted:
        sm.compensatePayment(ctx)
        fallthrough
    case StateInventoryDeducted:
        sm.compensateInventory(ctx)
        fallthrough
    case StateOrderCreated:
        sm.compensateOrder(ctx)
    }

    sm.currentState = StateFailed
}

// Sagaæ‰§è¡Œæ—¥å¿—è¡¨è®¾è®¡
/*
CREATE TABLE saga_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    saga_id VARCHAR(64) NOT NULL UNIQUE,
    saga_type VARCHAR(32) NOT NULL,
    current_state VARCHAR(32) NOT NULL,
    payload JSON,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_saga_id (saga_id)
);
*/
```

#### 4. Sagaä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**:
- âœ… ä¸šåŠ¡ä¾µå…¥æ€§ä¸­ç­‰,åªéœ€å®ç°æ­£å‘å’Œè¡¥å¿é€»è¾‘
- âœ… é€‚åˆé•¿æµç¨‹ä¸šåŠ¡(å¦‚è®¢å•æµç¨‹)
- âœ… æ¯ä¸ªæ­¥éª¤ç«‹å³æäº¤,ä¸é”èµ„æº

**ç¼ºç‚¹**:
- âŒ åªèƒ½ä¿è¯æœ€ç»ˆä¸€è‡´æ€§,ä¸­é—´çŠ¶æ€å¯¹ç”¨æˆ·å¯è§
- âŒ è¡¥å¿é€»è¾‘å¤æ‚,éœ€è¦ä»”ç»†è®¾è®¡
- âŒ æ— æ³•å›æ»šå·²å¯¹å¤–æš´éœ²çš„çŠ¶æ€(å¦‚å·²å‘é€çš„çŸ­ä¿¡)

---

### å››ã€æœ¬åœ°æ¶ˆæ¯è¡¨æ¨¡å¼è¯¦è§£

åŸºäºäº‹ä»¶é©±åŠ¨ + å®šæ—¶è½®è¯¢,ä¿è¯æ¶ˆæ¯æœ€ç»ˆä¸€å®šä¼šè¢«æ¶ˆè´¹ã€‚

#### 1. æ ¸å¿ƒåŸç†

```
1. ä¸šåŠ¡æ“ä½œ + å†™æœ¬åœ°æ¶ˆæ¯è¡¨åœ¨åŒä¸€ä¸ªæœ¬åœ°äº‹åŠ¡
2. å®šæ—¶ä»»åŠ¡æ‰«ææœªå‘é€çš„æ¶ˆæ¯
3. å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
4. ä¸‹æ¸¸æ¶ˆè´¹æ¶ˆæ¯å¹¶æ›´æ–°è‡ªå·±çš„æ•°æ®
```

#### 2. å®ç°ç¤ºä¾‹

```go
package localmessage

import (
    "context"
    "database/sql"
    "encoding/json"
    "time"
)

// LocalMessageService æœ¬åœ°æ¶ˆæ¯æœåŠ¡
type LocalMessageService struct {
    db            *sql.DB
    messageQueue  MessageQueue
}

// PublishWithMessage å‘å¸ƒæ¶ˆæ¯(ä¸ä¸šåŠ¡æ“ä½œåœ¨åŒä¸€äº‹åŠ¡)
func (s *LocalMessageService) PublishWithMessage(ctx context.Context, tx *sql.Tx, event *Event) error {
    // å°†äº‹ä»¶åºåˆ—åŒ–
    payload, err := json.Marshal(event.Data)
    if err != nil {
        return err
    }

    // æ’å…¥æœ¬åœ°æ¶ˆæ¯è¡¨
    query := `
        INSERT INTO local_messages (message_id, topic, payload, status, retry_count, created_at)
        VALUES (?, ?, ?, 'PENDING', 0, NOW())
    `
    _, err = tx.ExecContext(ctx, query, event.ID, event.Topic, payload)
    return err
}

// SendPendingMessages å®šæ—¶ä»»åŠ¡: å‘é€å¾…å‘é€çš„æ¶ˆæ¯
func (s *LocalMessageService) SendPendingMessages(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            s.processPendingMessages(ctx)
        }
    }
}

func (s *LocalMessageService) processPendingMessages(ctx context.Context) {
    // æŸ¥è¯¢å¾…å‘é€çš„æ¶ˆæ¯ (å¸¦é”)
    query := `
        SELECT message_id, topic, payload, retry_count
        FROM local_messages
        WHERE status = 'PENDING'
        AND retry_count < 5
        ORDER BY created_at ASC
        LIMIT 100
        FOR UPDATE SKIP LOCKED
    `

    rows, err := s.db.QueryContext(ctx, query)
    if err != nil {
        return
    }
    defer rows.Close()

    for rows.Next() {
        var msg LocalMessage
        rows.Scan(&msg.MessageID, &msg.Topic, &msg.Payload, &msg.RetryCount)

        // å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
        err := s.messageQueue.Publish(ctx, msg.Topic, msg.Payload)
        if err != nil {
            // æ›´æ–°é‡è¯•æ¬¡æ•°
            s.updateRetryCount(ctx, msg.MessageID)
            continue
        }

        // æ ‡è®°ä¸ºå·²å‘é€
        s.markAsSent(ctx, msg.MessageID)
    }
}

func (s *LocalMessageService) markAsSent(ctx context.Context, messageID string) {
    query := `UPDATE local_messages SET status = 'SENT', sent_at = NOW() WHERE message_id = ?`
    s.db.ExecContext(ctx, query, messageID)
}

func (s *LocalMessageService) updateRetryCount(ctx context.Context, messageID string) {
    query := `UPDATE local_messages SET retry_count = retry_count + 1, updated_at = NOW() WHERE message_id = ?`
    s.db.ExecContext(ctx, query, messageID)
}

// æœ¬åœ°æ¶ˆæ¯è¡¨è®¾è®¡
/*
CREATE TABLE local_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    message_id VARCHAR(64) NOT NULL UNIQUE,
    topic VARCHAR(64) NOT NULL,
    payload JSON NOT NULL,
    status VARCHAR(16) NOT NULL,   -- PENDING/SENT/FAILED
    retry_count INT DEFAULT 0,
    created_at TIMESTAMP,
    sent_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_status_created (status, created_at)
);
*/

// ä½¿ç”¨ç¤ºä¾‹: è®¢å•æœåŠ¡åˆ›å»ºè®¢å•
type OrderService struct {
    db             *sql.DB
    messageService *LocalMessageService
}

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) error {
    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. åˆ›å»ºè®¢å•
    query := `INSERT INTO orders (user_id, product_id, amount, status) VALUES (?, ?, ?, 'PENDING')`
    result, err := tx.ExecContext(ctx, query, req.UserID, req.ProductID, req.Amount)
    if err != nil {
        return err
    }

    orderID, _ := result.LastInsertId()

    // 2. å†™å…¥æœ¬åœ°æ¶ˆæ¯è¡¨ (åŒä¸€äº‹åŠ¡)
    event := &Event{
        ID:    generateEventID(),
        Topic: "order.created",
        Data: map[string]interface{}{
            "order_id":   orderID,
            "user_id":    req.UserID,
            "product_id": req.ProductID,
            "amount":     req.Amount,
        },
    }

    err = s.messageService.PublishWithMessage(ctx, tx, event)
    if err != nil {
        return err
    }

    // 3. æäº¤äº‹åŠ¡
    return tx.Commit()
}
```

#### 3. æ¶ˆè´¹ç«¯å¹‚ç­‰å¤„ç†

```go
package consumer

type InventoryConsumer struct {
    db *sql.DB
}

// ConsumeOrderCreatedEvent æ¶ˆè´¹è®¢å•åˆ›å»ºäº‹ä»¶
func (c *InventoryConsumer) ConsumeOrderCreatedEvent(ctx context.Context, event *Event) error {
    // å¹‚ç­‰æ€§æ£€æŸ¥: ä½¿ç”¨æ¶ˆæ¯IDå»é‡
    exists, err := c.checkMessageProcessed(ctx, event.ID)
    if err != nil {
        return err
    }
    if exists {
        // å·²å¤„ç†è¿‡,ç›´æ¥è¿”å›
        return nil
    }

    // å¼€å¯äº‹åŠ¡
    tx, err := c.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. æ‰£å‡åº“å­˜
    query := `UPDATE inventory SET stock = stock - ? WHERE product_id = ? AND stock >= ?`
    result, err := tx.ExecContext(ctx, query, event.Data["quantity"], event.Data["product_id"], event.Data["quantity"])
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("åº“å­˜ä¸è¶³")
    }

    // 2. è®°å½•æ¶ˆæ¯å·²å¤„ç† (åŒä¸€äº‹åŠ¡)
    query = `INSERT INTO processed_messages (message_id, processed_at) VALUES (?, NOW())`
    _, err = tx.ExecContext(ctx, query, event.ID)
    if err != nil {
        return err
    }

    // 3. æäº¤äº‹åŠ¡
    return tx.Commit()
}

func (c *InventoryConsumer) checkMessageProcessed(ctx context.Context, messageID string) (bool, error) {
    var count int
    query := `SELECT COUNT(*) FROM processed_messages WHERE message_id = ?`
    err := c.db.QueryRowContext(ctx, query, messageID).Scan(&count)
    return count > 0, err
}

// æ¶ˆæ¯æ¶ˆè´¹è®°å½•è¡¨
/*
CREATE TABLE processed_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    message_id VARCHAR(64) NOT NULL UNIQUE,
    processed_at TIMESTAMP,
    INDEX idx_message_id (message_id)
);
*/
```

#### 4. æœ¬åœ°æ¶ˆæ¯è¡¨ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**:
- âœ… ä¸šåŠ¡ä¾µå…¥æ€§æœ€å°,åˆ©ç”¨æœ¬åœ°äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
- âœ… å®ç°ç®€å•,ä¸ä¾èµ–åˆ†å¸ƒå¼äº‹åŠ¡æ¡†æ¶
- âœ… æ¶ˆæ¯å¯é æ€§é«˜,ä¸€å®šä¼šè¢«å‘é€

**ç¼ºç‚¹**:
- âŒ åªèƒ½ä¿è¯æœ€ç»ˆä¸€è‡´æ€§,æœ‰å»¶è¿Ÿ
- âŒ éœ€è¦å®šæ—¶ä»»åŠ¡æ‰«æ,å¢åŠ ç³»ç»Ÿå¤æ‚åº¦
- âŒ æ¶ˆæ¯è¡¨å¯èƒ½æˆä¸ºæ€§èƒ½ç“¶é¢ˆ

---

### äº”ã€ä¸‰ç§æ–¹æ¡ˆå¯¹æ¯”

| ç»´åº¦ | TCC | Saga | æœ¬åœ°æ¶ˆæ¯è¡¨ |
|------|-----|------|----------|
| **ä¸€è‡´æ€§** | å¼ºä¸€è‡´æ€§ | æœ€ç»ˆä¸€è‡´æ€§ | æœ€ç»ˆä¸€è‡´æ€§ |
| **ä¸šåŠ¡ä¾µå…¥** | é«˜(ä¸‰ä¸ªæ¥å£) | ä¸­(è¡¥å¿é€»è¾‘) | ä½(äº‹ä»¶å‘å¸ƒ) |
| **å¼€å‘å¤æ‚åº¦** | é«˜ | ä¸­ | ä½ |
| **æ€§èƒ½** | ä¸­ç­‰(ä¸¤é˜¶æ®µ) | é«˜(æ— é”) | é«˜(å¼‚æ­¥) |
| **é€‚ç”¨åœºæ™¯** | é‡‘èè½¬è´¦ | è®¢å•æµç¨‹ | ç§¯åˆ†å‘æ”¾ |
| **å›æ»šèƒ½åŠ›** | å®Œæ•´å›æ»š | è¡¥å¿å›æ»š | ä¸æ”¯æŒå›æ»š |
| **ä¸­é—´çŠ¶æ€** | ä¸å¯è§(å†»ç»“) | å¯è§ | å¯è§ |
| **å®æ—¶æ€§** | é«˜(åŒæ­¥) | ä¸­(åŒæ­¥) | ä½(å¼‚æ­¥) |
| **æ¡†æ¶æ”¯æŒ** | Seata-TCC | Seata-Saga | è‡ªç ” |

---

### å…­ã€é€‰å‹å»ºè®®

#### 1. é‡‘èåœºæ™¯ â†’ TCC

```
âœ… è½¬è´¦ã€æ”¯ä»˜ç­‰å¼ºä¸€è‡´æ€§è¦æ±‚
âœ… å¯¹ä¸­é—´çŠ¶æ€ä¸å¯è§æœ‰ä¸¥æ ¼è¦æ±‚
âœ… å¯ä»¥æ¥å—è¾ƒé«˜çš„å¼€å‘æˆæœ¬
```

**æ¡ˆä¾‹**:é“¶è¡Œè½¬è´¦,å¿…é¡»ä¿è¯è½¬å‡ºå’Œè½¬å…¥åŒæ—¶æˆåŠŸæˆ–å¤±è´¥

#### 2. ç”µå•†è®¢å• â†’ Saga

```
âœ… è®¢å•æµç¨‹æ¶‰åŠå¤šä¸ªæœåŠ¡
âœ… å…è®¸ä¸­é—´çŠ¶æ€å¯¹ç”¨æˆ·å¯è§
âœ… è¡¥å¿é€»è¾‘ç›¸å¯¹ç®€å•
```

**æ¡ˆä¾‹**:ä¸‹å• â†’ æ‰£åº“å­˜ â†’ æ‰£æ¬¾ â†’ å‘è´§,ä»»ä¸€æ­¥éª¤å¤±è´¥å¯è¡¥å¿

#### 3. ç§¯åˆ†ã€é€šçŸ¥ â†’ æœ¬åœ°æ¶ˆæ¯è¡¨

```
âœ… å…è®¸ä¸€å®šå»¶è¿Ÿ
âœ… ä¸éœ€è¦ç«‹å³åé¦ˆç»“æœ
âœ… ä¸éœ€è¦å›æ»šèƒ½åŠ›
```

**æ¡ˆä¾‹**:ç”¨æˆ·æ³¨å†Œåå‘é€æ¬¢è¿é‚®ä»¶ã€èµ é€æ–°äººç§¯åˆ†

---

### ä¸ƒã€å®æˆ˜ç»éªŒæ€»ç»“

#### 1. å¹‚ç­‰æ€§è®¾è®¡

æ‰€æœ‰åˆ†å¸ƒå¼äº‹åŠ¡æ–¹æ¡ˆéƒ½å¿…é¡»ä¿è¯å¹‚ç­‰:

```go
// ä½¿ç”¨å”¯ä¸€IDå»é‡
func (s *Service) ProcessOrder(ctx context.Context, orderID string) error {
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    if s.isProcessed(ctx, orderID) {
        return nil
    }

    // ä¸šåŠ¡é€»è¾‘
    // ...

    // æ ‡è®°å·²å¤„ç†
    s.markProcessed(ctx, orderID)
    return nil
}
```

#### 2. è¶…æ—¶å’Œé‡è¯•ç­–ç•¥

```go
// æŒ‡æ•°é€€é¿é‡è¯•
func retryWithBackoff(fn func() error) error {
    backoff := 1 * time.Second
    maxRetries := 5

    for i := 0; i < maxRetries; i++ {
        err := fn()
        if err == nil {
            return nil
        }

        time.Sleep(backoff)
        backoff *= 2  // æŒ‡æ•°å¢é•¿
    }

    return fmt.Errorf("max retries exceeded")
}
```

#### 3. ç›‘æ§å’Œå‘Šè­¦

```
ğŸ“Š å…³é”®æŒ‡æ ‡:
- TCCäº‹åŠ¡æˆåŠŸç‡/å¤±è´¥ç‡
- Sagaè¡¥å¿æ‰§è¡Œæ¬¡æ•°
- æœ¬åœ°æ¶ˆæ¯è¡¨ç§¯å‹æ•°é‡
- äº‹åŠ¡è¶…æ—¶æ¬¡æ•°

ğŸš¨ å‘Šè­¦è§„åˆ™:
- äº‹åŠ¡å¤±è´¥ç‡ > 5%
- æ¶ˆæ¯ç§¯å‹ > 1000æ¡
- è¡¥å¿å¤±è´¥(éœ€äººå·¥ä»‹å…¥)
```

#### 4. å¸¸è§æ¡†æ¶

- **Seata**: é˜¿é‡Œå¼€æº,æ”¯æŒAT/TCC/Sagaå¤šç§æ¨¡å¼
- **DTM**: è½»é‡çº§Goåˆ†å¸ƒå¼äº‹åŠ¡ç®¡ç†å™¨
- **Eventuate Tram**: åŸºäºäº‹ä»¶çš„Sagaæ¡†æ¶
- **Apache ServiceComb Pack**: Sagaåè°ƒå™¨

---

### å…«ã€æœ€ä½³å®è·µ

```
âœ… ä¼˜å…ˆè€ƒè™‘ä¸šåŠ¡å»ºæ¨¡,é¿å…åˆ†å¸ƒå¼äº‹åŠ¡
âœ… èƒ½å¼‚æ­¥å°±å¼‚æ­¥,é™ä½å¯¹å¼ºä¸€è‡´æ€§çš„ä¾èµ–
âœ… è¡¥å¿é€»è¾‘å¿…é¡»æˆåŠŸ,éœ€è¦å……åˆ†æµ‹è¯•
âœ… è®°å½•è¯¦ç»†çš„äº‹åŠ¡æ—¥å¿—,ä¾¿äºæ’æŸ¥é—®é¢˜
âœ… è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´,é¿å…é•¿æ—¶é—´é˜»å¡
âœ… æ‰€æœ‰æ“ä½œè®¾è®¡ä¸ºå¹‚ç­‰,æ”¯æŒé‡è¯•
âœ… å…³é”®èŠ‚ç‚¹å¢åŠ äººå·¥å®¡æ ¸æœºåˆ¶
```
