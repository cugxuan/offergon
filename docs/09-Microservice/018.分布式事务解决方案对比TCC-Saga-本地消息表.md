---
title: 分布式事务解决方案对比（TCC/Saga/本地消息表）
tags:
  - 分布式
  - 微服务
status: robot
class: 微服务
slug: distributed-transaction-solutions
ref:
---

## 核心要点

**CAP定理限制**:分布式系统无法同时保证一致性、可用性、分区容错,必须权衡
**TCC模式**:Try-Confirm-Cancel两阶段提交变种,强一致性,业务侵入大,适合金融场景
**Saga模式**:长事务拆分+补偿机制,最终一致性,业务侵入中等,适合订单流程
**本地消息表**:基于事件驱动+定时轮询,最终一致性,业务侵入小,适合异步场景

---

## 详细回答

### 一、分布式事务的挑战

在单体应用中,依靠数据库的ACID特性保证事务:

```sql
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

但在微服务架构下,一次业务操作可能跨越多个服务和数据库:

```
订单服务: 创建订单
库存服务: 扣减库存
支付服务: 扣款
积分服务: 增加积分
```

**面临的问题**:
```
❌ 不同服务使用独立数据库,无法用数据库事务保证
❌ 网络不可靠,服务调用可能失败或超时
❌ 部分成功部分失败导致数据不一致
❌ 传统2PC(两阶段提交)性能差且存在阻塞问题
```

---

### 二、TCC模式详解

TCC是Try-Confirm-Cancel的缩写,一种改进的两阶段提交方案。

#### 1. 核心原理

```
阶段一 Try: 预留资源(冻结余额、锁定库存)
阶段二 Confirm: 确认操作(真正扣款、扣库存)
异常时 Cancel: 取消操作(解冻余额、释放库存)
```

#### 2. 完整流程示例

**业务场景**:用户下单,扣款100元并扣库存1件

```
┌─────────────┐
│ 订单服务     │  协调者
└──────┬──────┘
       │
       ├─ Try阶段 ─────────────────────────────┐
       │                                       │
       ▼                                       ▼
  ┌─────────┐                            ┌─────────┐
  │账户服务 │                            │库存服务 │
  │Try:     │                            │Try:     │
  │冻结100元│                            │锁定1件  │
  └────┬────┘                            └────┬────┘
       │  成功                                 │ 成功
       │                                       │
       ├─ Confirm阶段 ──────────────────────────┤
       │                                       │
       ▼                                       ▼
  ┌─────────┐                            ┌─────────┐
  │账户服务 │                            │库存服务 │
  │Confirm: │                            │Confirm: │
  │扣减100元│                            │扣减1件  │
  └─────────┘                            └─────────┘

// 如果任何一个Try失败,则调用所有的Cancel
```

#### 3. Go语言实现示例

```go
package tcc

import (
    "context"
    "database/sql"
    "fmt"
)

// TCCCoordinator TCC协调器
type TCCCoordinator struct {
    db          *sql.DB
    accountSvc  *AccountService
    inventorySvc *InventoryService
}

// ExecuteTransaction 执行TCC事务
func (c *TCCCoordinator) ExecuteTransaction(ctx context.Context, orderID string, userID int64, productID int64, amount int) error {
    // 1. Try阶段: 预留资源
    txID := generateTxID()

    // Try: 冻结账户余额
    err := c.accountSvc.TryFreeze(ctx, txID, userID, amount)
    if err != nil {
        return fmt.Errorf("账户冻结失败: %w", err)
    }

    // Try: 锁定库存
    err = c.inventorySvc.TryLock(ctx, txID, productID, 1)
    if err != nil {
        // 回滚已冻结的账户
        c.accountSvc.CancelFreeze(ctx, txID, userID)
        return fmt.Errorf("库存锁定失败: %w", err)
    }

    // 2. Confirm阶段: 确认操作
    err = c.accountSvc.ConfirmDeduct(ctx, txID, userID)
    if err != nil {
        // 回滚所有操作
        c.accountSvc.CancelFreeze(ctx, txID, userID)
        c.inventorySvc.CancelLock(ctx, txID, productID)
        return fmt.Errorf("账户扣款失败: %w", err)
    }

    err = c.inventorySvc.ConfirmDeduct(ctx, txID, productID)
    if err != nil {
        // 此时账户已扣款,需要人工介入或补偿
        return fmt.Errorf("库存扣减失败: %w", err)
    }

    return nil
}

// AccountService 账户服务实现
type AccountService struct {
    db *sql.DB
}

// TryFreeze 冻结余额
func (s *AccountService) TryFreeze(ctx context.Context, txID string, userID int64, amount int) error {
    // 数据库设计: accounts表增加 frozen_balance字段
    query := `
        UPDATE accounts
        SET balance = balance - ?,
            frozen_balance = frozen_balance + ?
        WHERE user_id = ? AND balance >= ?
    `
    result, err := s.db.ExecContext(ctx, query, amount, amount, userID, amount)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("余额不足")
    }

    // 记录TCC事务日志
    s.recordTCCLog(ctx, txID, "account", "TRY", userID, amount)
    return nil
}

// ConfirmDeduct 确认扣款
func (s *AccountService) ConfirmDeduct(ctx context.Context, txID string, userID int64) error {
    // 从frozen_balance转为真正扣除
    query := `
        UPDATE accounts
        SET frozen_balance = frozen_balance - (
            SELECT amount FROM tcc_logs WHERE tx_id = ? AND resource = 'account'
        )
        WHERE user_id = ?
    `
    _, err := s.db.ExecContext(ctx, query, txID, userID)
    if err != nil {
        return err
    }

    s.updateTCCLog(ctx, txID, "CONFIRM")
    return nil
}

// CancelFreeze 取消冻结
func (s *AccountService) CancelFreeze(ctx context.Context, txID string, userID int64) error {
    // 释放冻结的金额
    query := `
        UPDATE accounts
        SET balance = balance + frozen_balance,
            frozen_balance = 0
        WHERE user_id = ?
    `
    _, err := s.db.ExecContext(ctx, query, userID)
    if err != nil {
        return err
    }

    s.updateTCCLog(ctx, txID, "CANCEL")
    return nil
}

// TCC事务日志表设计
/*
CREATE TABLE tcc_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tx_id VARCHAR(64) NOT NULL,
    resource VARCHAR(32) NOT NULL,  -- account/inventory
    phase VARCHAR(16) NOT NULL,     -- TRY/CONFIRM/CANCEL
    user_id BIGINT,
    product_id BIGINT,
    amount INT,
    status VARCHAR(16),             -- PENDING/SUCCESS/FAILED
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_tx_id (tx_id)
);
*/
```

#### 4. TCC优缺点

**优点**:
- ✅ 强一致性,接近传统事务的ACID保证
- ✅ 无长时间锁,性能优于2PC
- ✅ 各阶段可独立重试

**缺点**:
- ❌ 业务侵入性极大,每个操作需实现Try/Confirm/Cancel三个接口
- ❌ 开发成本高,代码复杂度增加
- ❌ Cancel操作必须成功,需要处理幂等和异常情况

---

### 三、Saga模式详解

Saga将长事务拆分为一系列本地短事务,通过补偿机制保证最终一致性。

#### 1. 核心原理

```
正向流程: T1 → T2 → T3 → T4
补偿流程: C4 → C3 → C2 → C1
```

每个事务Ti都有对应的补偿事务Ci,如果Ti失败,则依次执行已完成事务的补偿。

#### 2. 两种编排方式

**方式一: 事件编排(Choreography)**

各服务监听事件,去中心化:

```
OrderService: 创建订单 → 发布OrderCreated事件
InventoryService: 监听事件 → 扣库存 → 发布InventoryDeducted事件
PaymentService: 监听事件 → 扣款 → 发布PaymentSucceeded事件
PointService: 监听事件 → 加积分 → 发布PointAdded事件

// 如果PaymentService扣款失败
PaymentService: 发布PaymentFailed事件
InventoryService: 监听事件 → 补偿库存
OrderService: 监听事件 → 取消订单
```

**方式二: 命令编排(Orchestration)**

由协调器集中控制流程:

```go
package saga

import (
    "context"
    "fmt"
)

// SagaOrchestrator Saga协调器
type SagaOrchestrator struct {
    orderSvc     *OrderService
    inventorySvc *InventoryService
    paymentSvc   *PaymentService
    pointSvc     *PointService
}

// CreateOrder Saga流程: 下单
func (o *SagaOrchestrator) CreateOrder(ctx context.Context, req *CreateOrderRequest) error {
    var (
        orderID     string
        inventoryOK bool
        paymentOK   bool
    )

    // Step 1: 创建订单
    orderID, err := o.orderSvc.CreateOrder(ctx, req)
    if err != nil {
        return fmt.Errorf("创建订单失败: %w", err)
    }

    // Step 2: 扣减库存
    err = o.inventorySvc.DeductInventory(ctx, req.ProductID, req.Quantity)
    if err != nil {
        // 补偿: 取消订单
        o.orderSvc.CancelOrder(ctx, orderID)
        return fmt.Errorf("扣减库存失败: %w", err)
    }
    inventoryOK = true

    // Step 3: 扣款
    err = o.paymentSvc.Deduct(ctx, req.UserID, req.Amount)
    if err != nil {
        // 补偿: 回退库存 + 取消订单
        if inventoryOK {
            o.inventorySvc.RestoreInventory(ctx, req.ProductID, req.Quantity)
        }
        o.orderSvc.CancelOrder(ctx, orderID)
        return fmt.Errorf("扣款失败: %w", err)
    }
    paymentOK = true

    // Step 4: 增加积分
    err = o.pointSvc.AddPoints(ctx, req.UserID, req.Amount/10)
    if err != nil {
        // 补偿: 退款 + 回退库存 + 取消订单
        if paymentOK {
            o.paymentSvc.Refund(ctx, req.UserID, req.Amount)
        }
        if inventoryOK {
            o.inventorySvc.RestoreInventory(ctx, req.ProductID, req.Quantity)
        }
        o.orderSvc.CancelOrder(ctx, orderID)
        return fmt.Errorf("增加积分失败: %w", err)
    }

    return nil
}

// 补偿操作实现
type InventoryService struct {
    db *sql.DB
}

func (s *InventoryService) DeductInventory(ctx context.Context, productID int64, quantity int) error {
    query := `UPDATE inventory SET stock = stock - ? WHERE product_id = ? AND stock >= ?`
    result, err := s.db.ExecContext(ctx, query, quantity, productID, quantity)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("库存不足")
    }
    return nil
}

// 补偿操作: 恢复库存
func (s *InventoryService) RestoreInventory(ctx context.Context, productID int64, quantity int) error {
    query := `UPDATE inventory SET stock = stock + ? WHERE product_id = ?`
    _, err := s.db.ExecContext(ctx, query, quantity, productID)
    return err
}
```

#### 3. Saga状态机模式

使用状态机管理复杂流程:

```go
package saga

type SagaState string

const (
    StateOrderCreated      SagaState = "ORDER_CREATED"
    StateInventoryDeducted SagaState = "INVENTORY_DEDUCTED"
    StatePaymentCompleted  SagaState = "PAYMENT_COMPLETED"
    StatePointAdded        SagaState = "POINT_ADDED"
    StateCompleted         SagaState = "COMPLETED"
    StateCompensating      SagaState = "COMPENSATING"
    StateFailed            SagaState = "FAILED"
)

// SagaStateMachine Saga状态机
type SagaStateMachine struct {
    sagaID       string
    currentState SagaState
    db           *sql.DB
}

func (sm *SagaStateMachine) Execute(ctx context.Context, req *CreateOrderRequest) error {
    // 持久化Saga执行状态
    sm.persistState(ctx, sm.currentState)

    switch sm.currentState {
    case StateOrderCreated:
        err := sm.executeInventoryDeduction(ctx, req)
        if err != nil {
            sm.startCompensation(ctx)
            return err
        }
        sm.currentState = StateInventoryDeducted
        return sm.Execute(ctx, req)

    case StateInventoryDeducted:
        err := sm.executePayment(ctx, req)
        if err != nil {
            sm.startCompensation(ctx)
            return err
        }
        sm.currentState = StatePaymentCompleted
        return sm.Execute(ctx, req)

    case StatePaymentCompleted:
        err := sm.executePointAddition(ctx, req)
        if err != nil {
            sm.startCompensation(ctx)
            return err
        }
        sm.currentState = StateCompleted
        return nil

    default:
        return fmt.Errorf("unknown state: %s", sm.currentState)
    }
}

func (sm *SagaStateMachine) startCompensation(ctx context.Context) {
    sm.currentState = StateCompensating

    // 根据当前状态执行相应的补偿操作
    switch sm.currentState {
    case StatePaymentCompleted:
        sm.compensatePayment(ctx)
        fallthrough
    case StateInventoryDeducted:
        sm.compensateInventory(ctx)
        fallthrough
    case StateOrderCreated:
        sm.compensateOrder(ctx)
    }

    sm.currentState = StateFailed
}

// Saga执行日志表设计
/*
CREATE TABLE saga_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    saga_id VARCHAR(64) NOT NULL UNIQUE,
    saga_type VARCHAR(32) NOT NULL,
    current_state VARCHAR(32) NOT NULL,
    payload JSON,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_saga_id (saga_id)
);
*/
```

#### 4. Saga优缺点

**优点**:
- ✅ 业务侵入性中等,只需实现正向和补偿逻辑
- ✅ 适合长流程业务(如订单流程)
- ✅ 每个步骤立即提交,不锁资源

**缺点**:
- ❌ 只能保证最终一致性,中间状态对用户可见
- ❌ 补偿逻辑复杂,需要仔细设计
- ❌ 无法回滚已对外暴露的状态(如已发送的短信)

---

### 四、本地消息表模式详解

基于事件驱动 + 定时轮询,保证消息最终一定会被消费。

#### 1. 核心原理

```
1. 业务操作 + 写本地消息表在同一个本地事务
2. 定时任务扫描未发送的消息
3. 发送到消息队列
4. 下游消费消息并更新自己的数据
```

#### 2. 实现示例

```go
package localmessage

import (
    "context"
    "database/sql"
    "encoding/json"
    "time"
)

// LocalMessageService 本地消息服务
type LocalMessageService struct {
    db            *sql.DB
    messageQueue  MessageQueue
}

// PublishWithMessage 发布消息(与业务操作在同一事务)
func (s *LocalMessageService) PublishWithMessage(ctx context.Context, tx *sql.Tx, event *Event) error {
    // 将事件序列化
    payload, err := json.Marshal(event.Data)
    if err != nil {
        return err
    }

    // 插入本地消息表
    query := `
        INSERT INTO local_messages (message_id, topic, payload, status, retry_count, created_at)
        VALUES (?, ?, ?, 'PENDING', 0, NOW())
    `
    _, err = tx.ExecContext(ctx, query, event.ID, event.Topic, payload)
    return err
}

// SendPendingMessages 定时任务: 发送待发送的消息
func (s *LocalMessageService) SendPendingMessages(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            s.processPendingMessages(ctx)
        }
    }
}

func (s *LocalMessageService) processPendingMessages(ctx context.Context) {
    // 查询待发送的消息 (带锁)
    query := `
        SELECT message_id, topic, payload, retry_count
        FROM local_messages
        WHERE status = 'PENDING'
        AND retry_count < 5
        ORDER BY created_at ASC
        LIMIT 100
        FOR UPDATE SKIP LOCKED
    `

    rows, err := s.db.QueryContext(ctx, query)
    if err != nil {
        return
    }
    defer rows.Close()

    for rows.Next() {
        var msg LocalMessage
        rows.Scan(&msg.MessageID, &msg.Topic, &msg.Payload, &msg.RetryCount)

        // 发送到消息队列
        err := s.messageQueue.Publish(ctx, msg.Topic, msg.Payload)
        if err != nil {
            // 更新重试次数
            s.updateRetryCount(ctx, msg.MessageID)
            continue
        }

        // 标记为已发送
        s.markAsSent(ctx, msg.MessageID)
    }
}

func (s *LocalMessageService) markAsSent(ctx context.Context, messageID string) {
    query := `UPDATE local_messages SET status = 'SENT', sent_at = NOW() WHERE message_id = ?`
    s.db.ExecContext(ctx, query, messageID)
}

func (s *LocalMessageService) updateRetryCount(ctx context.Context, messageID string) {
    query := `UPDATE local_messages SET retry_count = retry_count + 1, updated_at = NOW() WHERE message_id = ?`
    s.db.ExecContext(ctx, query, messageID)
}

// 本地消息表设计
/*
CREATE TABLE local_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    message_id VARCHAR(64) NOT NULL UNIQUE,
    topic VARCHAR(64) NOT NULL,
    payload JSON NOT NULL,
    status VARCHAR(16) NOT NULL,   -- PENDING/SENT/FAILED
    retry_count INT DEFAULT 0,
    created_at TIMESTAMP,
    sent_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_status_created (status, created_at)
);
*/

// 使用示例: 订单服务创建订单
type OrderService struct {
    db             *sql.DB
    messageService *LocalMessageService
}

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) error {
    // 开启事务
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. 创建订单
    query := `INSERT INTO orders (user_id, product_id, amount, status) VALUES (?, ?, ?, 'PENDING')`
    result, err := tx.ExecContext(ctx, query, req.UserID, req.ProductID, req.Amount)
    if err != nil {
        return err
    }

    orderID, _ := result.LastInsertId()

    // 2. 写入本地消息表 (同一事务)
    event := &Event{
        ID:    generateEventID(),
        Topic: "order.created",
        Data: map[string]interface{}{
            "order_id":   orderID,
            "user_id":    req.UserID,
            "product_id": req.ProductID,
            "amount":     req.Amount,
        },
    }

    err = s.messageService.PublishWithMessage(ctx, tx, event)
    if err != nil {
        return err
    }

    // 3. 提交事务
    return tx.Commit()
}
```

#### 3. 消费端幂等处理

```go
package consumer

type InventoryConsumer struct {
    db *sql.DB
}

// ConsumeOrderCreatedEvent 消费订单创建事件
func (c *InventoryConsumer) ConsumeOrderCreatedEvent(ctx context.Context, event *Event) error {
    // 幂等性检查: 使用消息ID去重
    exists, err := c.checkMessageProcessed(ctx, event.ID)
    if err != nil {
        return err
    }
    if exists {
        // 已处理过,直接返回
        return nil
    }

    // 开启事务
    tx, err := c.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. 扣减库存
    query := `UPDATE inventory SET stock = stock - ? WHERE product_id = ? AND stock >= ?`
    result, err := tx.ExecContext(ctx, query, event.Data["quantity"], event.Data["product_id"], event.Data["quantity"])
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("库存不足")
    }

    // 2. 记录消息已处理 (同一事务)
    query = `INSERT INTO processed_messages (message_id, processed_at) VALUES (?, NOW())`
    _, err = tx.ExecContext(ctx, query, event.ID)
    if err != nil {
        return err
    }

    // 3. 提交事务
    return tx.Commit()
}

func (c *InventoryConsumer) checkMessageProcessed(ctx context.Context, messageID string) (bool, error) {
    var count int
    query := `SELECT COUNT(*) FROM processed_messages WHERE message_id = ?`
    err := c.db.QueryRowContext(ctx, query, messageID).Scan(&count)
    return count > 0, err
}

// 消息消费记录表
/*
CREATE TABLE processed_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    message_id VARCHAR(64) NOT NULL UNIQUE,
    processed_at TIMESTAMP,
    INDEX idx_message_id (message_id)
);
*/
```

#### 4. 本地消息表优缺点

**优点**:
- ✅ 业务侵入性最小,利用本地事务保证一致性
- ✅ 实现简单,不依赖分布式事务框架
- ✅ 消息可靠性高,一定会被发送

**缺点**:
- ❌ 只能保证最终一致性,有延迟
- ❌ 需要定时任务扫描,增加系统复杂度
- ❌ 消息表可能成为性能瓶颈

---

### 五、三种方案对比

| 维度 | TCC | Saga | 本地消息表 |
|------|-----|------|----------|
| **一致性** | 强一致性 | 最终一致性 | 最终一致性 |
| **业务侵入** | 高(三个接口) | 中(补偿逻辑) | 低(事件发布) |
| **开发复杂度** | 高 | 中 | 低 |
| **性能** | 中等(两阶段) | 高(无锁) | 高(异步) |
| **适用场景** | 金融转账 | 订单流程 | 积分发放 |
| **回滚能力** | 完整回滚 | 补偿回滚 | 不支持回滚 |
| **中间状态** | 不可见(冻结) | 可见 | 可见 |
| **实时性** | 高(同步) | 中(同步) | 低(异步) |
| **框架支持** | Seata-TCC | Seata-Saga | 自研 |

---

### 六、选型建议

#### 1. 金融场景 → TCC

```
✅ 转账、支付等强一致性要求
✅ 对中间状态不可见有严格要求
✅ 可以接受较高的开发成本
```

**案例**:银行转账,必须保证转出和转入同时成功或失败

#### 2. 电商订单 → Saga

```
✅ 订单流程涉及多个服务
✅ 允许中间状态对用户可见
✅ 补偿逻辑相对简单
```

**案例**:下单 → 扣库存 → 扣款 → 发货,任一步骤失败可补偿

#### 3. 积分、通知 → 本地消息表

```
✅ 允许一定延迟
✅ 不需要立即反馈结果
✅ 不需要回滚能力
```

**案例**:用户注册后发送欢迎邮件、赠送新人积分

---

### 七、实战经验总结

#### 1. 幂等性设计

所有分布式事务方案都必须保证幂等:

```go
// 使用唯一ID去重
func (s *Service) ProcessOrder(ctx context.Context, orderID string) error {
    // 检查是否已处理
    if s.isProcessed(ctx, orderID) {
        return nil
    }

    // 业务逻辑
    // ...

    // 标记已处理
    s.markProcessed(ctx, orderID)
    return nil
}
```

#### 2. 超时和重试策略

```go
// 指数退避重试
func retryWithBackoff(fn func() error) error {
    backoff := 1 * time.Second
    maxRetries := 5

    for i := 0; i < maxRetries; i++ {
        err := fn()
        if err == nil {
            return nil
        }

        time.Sleep(backoff)
        backoff *= 2  // 指数增长
    }

    return fmt.Errorf("max retries exceeded")
}
```

#### 3. 监控和告警

```
📊 关键指标:
- TCC事务成功率/失败率
- Saga补偿执行次数
- 本地消息表积压数量
- 事务超时次数

🚨 告警规则:
- 事务失败率 > 5%
- 消息积压 > 1000条
- 补偿失败(需人工介入)
```

#### 4. 常见框架

- **Seata**: 阿里开源,支持AT/TCC/Saga多种模式
- **DTM**: 轻量级Go分布式事务管理器
- **Eventuate Tram**: 基于事件的Saga框架
- **Apache ServiceComb Pack**: Saga协调器

---

### 八、最佳实践

```
✅ 优先考虑业务建模,避免分布式事务
✅ 能异步就异步,降低对强一致性的依赖
✅ 补偿逻辑必须成功,需要充分测试
✅ 记录详细的事务日志,便于排查问题
✅ 设置合理的超时时间,避免长时间阻塞
✅ 所有操作设计为幂等,支持重试
✅ 关键节点增加人工审核机制
```
