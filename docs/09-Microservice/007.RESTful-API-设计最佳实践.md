---
title: RESTful API 设计最佳实践
tags:
  - 微服务
status: robot
class: 微服务
slug: restful-api-design-best-practices
ref:
---

## 核心要点

**RESTful核心原则**：资源导向(URI表示资源)、统一接口(HTTP动词)、无状态、可缓存、分层系统
**URL设计**：使用名词复数表示资源、层级关系清晰、避免动词、使用连字符分隔
**HTTP方法**：GET(查询)、POST(创建)、PUT(完整更新)、PATCH(部分更新)、DELETE(删除)
**最佳实践**：版本管理(URL或Header)、统一错误响应、HATEOAS链接、分页/过滤/排序、幂等性设计

---

## 详细回答

### 一、REST基础概念

#### 什么是REST?

REST（Representational State Transfer，表述性状态转移）是Roy Fielding在2000年博士论文中提出的架构风格。

**核心约束**：
1. **客户端-服务器分离**：前后端解耦
2. **无状态**：每个请求包含所有必要信息
3. **可缓存**：响应标明是否可缓存
4. **统一接口**：资源通过标准HTTP方法操作
5. **分层系统**：客户端无需知道中间层（CDN、负载均衡）
6. **按需代码**（可选）：服务器可发送可执行代码

#### RESTful vs RPC

| 特性 | RESTful | RPC(gRPC) |
|------|---------|-----------|
| **关注点** | 资源(Resource) | 动作(Action) |
| **URL设计** | `/users/123` | `/getUserById` |
| **协议** | HTTP/1.1 | HTTP/2 |
| **数据格式** | JSON(文本) | Protobuf(二进制) |
| **可读性** | 人类可读 | 需工具解析 |
| **性能** | 中等 | 高 |
| **浏览器支持** | 原生支持 | 需grpc-web |
| **适用场景** | 对外API、Web服务 | 内部微服务 |

### 二、URL设计最佳实践

#### 1. 使用名词表示资源(禁用动词)

```
✅ 正确:
GET    /users              # 获取用户列表
GET    /users/123          # 获取ID为123的用户
POST   /users              # 创建用户
PUT    /users/123          # 更新用户123
DELETE /users/123          # 删除用户123

❌ 错误:
GET    /getUsers           # 动词getUsers
POST   /createUser         # 动词createUser
POST   /users/delete/123   # URL中包含delete动词
```

#### 2. 使用复数名词

```
✅ 正确:
/users              # 复数
/orders
/products

❌ 错误:
/user               # 单数（不一致）
/getUser
```

**例外**：单例资源使用单数
```
GET /user/profile   # 当前登录用户的个人资料(单例)
GET /system/config  # 系统配置(单例)
```

#### 3. 资源嵌套表示关系

```
✅ 正确:
GET /users/123/orders          # 用户123的所有订单
GET /users/123/orders/456      # 用户123的订单456
POST /users/123/orders         # 为用户123创建订单

❌ 避免过深嵌套(>3层):
GET /users/123/orders/456/items/789/reviews/111  # 太深
应改为:
GET /order-items/789/reviews/111
```

#### 4. 使用连字符分隔多单词

```
✅ 正确:
/order-items        # kebab-case
/shipping-addresses

❌ 错误:
/orderItems         # camelCase(URL不区分大小写)
/order_items        # snake_case(不推荐用于URL)
```

#### 5. 小写字母

```
✅ 正确:
/users/123/orders

❌ 错误:
/Users/123/Orders   # 大写字母(URL区分大小写可能导致问题)
```

#### 6. 查询参数用于过滤/排序/分页

```
✅ 正确:
GET /users?role=admin&status=active     # 过滤
GET /users?sort=created_at&order=desc   # 排序
GET /users?page=2&size=20               # 分页
GET /users?fields=id,name,email         # 字段过滤

❌ 错误:
GET /users/active                       # 不要用URL路径过滤
GET /users/sort/created_at/desc         # 排序不应在路径中
```

### 三、HTTP方法使用规范

#### 1. GET - 获取资源

**特性**：
- 幂等(Idempotent)：多次调用结果相同
- 安全(Safe)：不修改资源
- 可缓存

```go
// 获取用户列表
GET /users
响应: 200 OK
[
  {"id": 1, "name": "张三"},
  {"id": 2, "name": "李四"}
]

// 获取单个用户
GET /users/123
响应: 200 OK
{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com"
}

// 资源不存在
GET /users/999
响应: 404 Not Found
{
  "error": "User not found",
  "code": "USER_NOT_FOUND"
}
```

#### 2. POST - 创建资源

**特性**：
- 非幂等：多次调用创建多个资源
- 不安全：修改服务器状态

```go
POST /users
请求体:
{
  "name": "王五",
  "email": "wangwu@example.com"
}

成功响应: 201 Created
Location: /users/124
{
  "id": 124,
  "name": "王五",
  "email": "wangwu@example.com",
  "created_at": "2025-01-15T10:30:00Z"
}

失败响应: 400 Bad Request
{
  "error": "Invalid email format",
  "field": "email",
  "code": "INVALID_EMAIL"
}
```

#### 3. PUT - 完整更新资源

**特性**：
- 幂等：多次调用结果相同
- 替换整个资源

```go
PUT /users/123
请求体:
{
  "name": "张三(更新)",
  "email": "new_email@example.com",
  "age": 30,
  "address": "北京市朝阳区"
}

响应: 200 OK
{
  "id": 123,
  "name": "张三(更新)",
  "email": "new_email@example.com",
  "age": 30,
  "address": "北京市朝阳区",
  "updated_at": "2025-01-15T10:35:00Z"
}

注意: PUT应该替换整个资源，缺失的字段会被删除或设为默认值
```

#### 4. PATCH - 部分更新资源

**特性**：
- 幂等(设计良好时)
- 只更新指定字段

```go
PATCH /users/123
请求体:
{
  "email": "new_email@example.com"  # 只更新email
}

响应: 200 OK
{
  "id": 123,
  "name": "张三",              # 保持不变
  "email": "new_email@example.com",  # 已更新
  "age": 25,                   # 保持不变
  "updated_at": "2025-01-15T10:40:00Z"
}
```

**PATCH高级用法**：JSON Patch (RFC 6902)
```json
PATCH /users/123
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/email", "value": "new@example.com" },
  { "op": "add", "path": "/tags/-", "value": "vip" },
  { "op": "remove", "path": "/tmp_field" }
]
```

#### 5. DELETE - 删除资源

**特性**：
- 幂等：删除已删除的资源返回同样结果

```go
DELETE /users/123

成功响应: 204 No Content  # 无响应体
或
响应: 200 OK
{
  "message": "User deleted successfully"
}

重复删除:
DELETE /users/123  # 第二次删除

响应: 404 Not Found  # 或返回204(幂等设计)
{
  "error": "User not found"
}
```

#### 6. HEAD - 获取资源元数据

```
HEAD /users/123

响应: 200 OK
Content-Length: 256
Last-Modified: Mon, 15 Jan 2025 10:30:00 GMT
ETag: "abc123"

(无响应体,只有headers)
```

**用途**：
- 检查资源是否存在
- 获取资源大小(下载前)
- 检查资源是否被修改(ETag)

### 四、HTTP状态码使用规范

#### 1xx - 信息性状态码(少用)
```
100 Continue         # 客户端应继续发送请求体
```

#### 2xx - 成功状态码
```
200 OK              # 请求成功(GET、PUT、PATCH)
201 Created         # 资源创建成功(POST)
202 Accepted        # 请求已接受,但处理未完成(异步任务)
204 No Content      # 成功但无返回内容(DELETE)
```

#### 3xx - 重定向状态码
```
301 Moved Permanently    # 永久重定向
302 Found                # 临时重定向
304 Not Modified         # 资源未修改(配合ETag使用)
```

#### 4xx - 客户端错误
```
400 Bad Request          # 请求参数错误
401 Unauthorized         # 未认证(缺少token)
403 Forbidden            # 已认证但无权限
404 Not Found            # 资源不存在
405 Method Not Allowed   # HTTP方法不支持
409 Conflict             # 资源冲突(如用户名已存在)
422 Unprocessable Entity # 请求格式正确但语义错误
429 Too Many Requests    # 请求过于频繁(限流)
```

#### 5xx - 服务器错误
```
500 Internal Server Error  # 服务器内部错误
502 Bad Gateway            # 网关错误
503 Service Unavailable    # 服务不可用(维护中)
504 Gateway Timeout        # 网关超时
```

**示例：统一错误响应格式**
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input parameters",
    "details": [
      {
        "field": "email",
        "message": "Email format is invalid"
      },
      {
        "field": "age",
        "message": "Age must be between 0 and 150"
      }
    ],
    "timestamp": "2025-01-15T10:30:00Z",
    "request_id": "req-abc-123"
  }
}
```

### 五、版本管理

#### 方式1：URL路径版本(推荐)

```
GET /v1/users/123
GET /v2/users/123

优点:
✅ 简单直观
✅ 浏览器易访问
✅ 缓存友好

缺点:
❌ URL变化可能导致客户端断链
```

#### 方式2：请求头版本

```
GET /users/123
Accept: application/vnd.myapi.v1+json

优点:
✅ URL保持不变
✅ 符合REST规范

缺点:
❌ 浏览器测试不便
❌ 缓存复杂
```

#### 方式3：查询参数版本(不推荐)

```
GET /users/123?version=1

缺点:
❌ 污染URL
❌ 缓存键复杂
```

**版本策略建议**：
- **URL版本**：适合大版本迭代(v1 → v2)
- **请求头版本**：适合小版本迭代(v1.1 → v1.2)
- **向后兼容优先**：尽量避免破坏性变更

### 六、分页、过滤、排序

#### 1. 分页

**基于偏移量(Offset-based)**：
```
GET /users?page=2&size=20

响应:
{
  "data": [...],
  "pagination": {
    "page": 2,
    "size": 20,
    "total": 150,
    "pages": 8
  }
}

优点: 简单,可跳转任意页
缺点: 数据实时变化时可能重复/漏数据
```

**基于游标(Cursor-based,推荐大数据集)**：
```
GET /users?cursor=eyJpZCI6MTIzfQ==&limit=20

响应:
{
  "data": [...],
  "pagination": {
    "next_cursor": "eyJpZCI6MTQzfQ==",
    "has_more": true
  }
}

优点: 数据一致性好,性能高
缺点: 无法跳页
```

#### 2. 过滤

```
# 单条件
GET /users?status=active

# 多条件(AND)
GET /users?status=active&role=admin

# 范围查询
GET /orders?created_at_gte=2025-01-01&created_at_lte=2025-01-31

# 包含查询(IN)
GET /users?id=1,2,3,4

# 模糊搜索
GET /products?name_contains=iPhone
```

#### 3. 排序

```
# 单字段排序
GET /users?sort=created_at&order=desc

# 多字段排序
GET /users?sort=role,created_at&order=asc,desc

# 简洁写法
GET /users?sort=-created_at,+name   # -表示desc,+表示asc
```

#### 4. 字段选择(减少流量)

```
# 只返回指定字段
GET /users?fields=id,name,email

响应:
[
  {"id": 1, "name": "张三", "email": "zhangsan@example.com"},
  {"id": 2, "name": "李四", "email": "lisi@example.com"}
]
```

### 七、HATEOAS(超媒体驱动)

HATEOAS（Hypermedia As The Engine Of Application State）是REST的最高成熟度级别。

**示例**：
```json
GET /users/123

{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "_links": {
    "self": { "href": "/users/123" },
    "orders": { "href": "/users/123/orders" },
    "update": { "href": "/users/123", "method": "PUT" },
    "delete": { "href": "/users/123", "method": "DELETE" }
  }
}
```

**优点**：
- 客户端无需硬编码URL
- API可演化,客户端自动适配

**缺点**：
- 响应体增大
- 实际应用较少(大多数API停留在Level 2)

### 八、幂等性设计

#### 为什么需要幂等?

```
场景: 用户点击"支付"按钮
客户端: POST /orders/123/pay
网络抖动 → 客户端超时 → 用户再次点击
客户端: POST /orders/123/pay (重复请求)

问题: 订单被扣款两次 ❌
```

#### 实现幂等的方法

**方式1：使用幂等键(Idempotency-Key)**

```
POST /orders
Idempotency-Key: uuid-abc-def-123
{
  "user_id": 456,
  "amount": 9999
}

服务端逻辑:
1. 检查Idempotency-Key是否已存在
2. 如果存在,返回之前的结果(幂等)
3. 如果不存在,创建订单并保存Idempotency-Key
```

```go
// Go实现示例
func CreateOrder(c *gin.Context) {
    idempotencyKey := c.GetHeader("Idempotency-Key")
    if idempotencyKey == "" {
        c.JSON(400, gin.H{"error": "Missing Idempotency-Key"})
        return
    }

    // 检查Redis缓存
    cachedResult, err := redis.Get(ctx, "idempotency:"+idempotencyKey).Result()
    if err == nil {
        // 幂等:返回缓存的结果
        c.JSON(200, cachedResult)
        return
    }

    // 创建订单
    order := createOrder(...)

    // 缓存结果(24小时过期)
    redis.Set(ctx, "idempotency:"+idempotencyKey, order, 24*time.Hour)

    c.JSON(201, order)
}
```

**方式2：基于资源状态检查**

```
POST /orders/123/pay

服务端逻辑:
if order.Status == "PAID" {
    return 200  # 已支付,幂等返回成功
}
order.Status = "PAID"
processPayment()
return 200
```

### 九、安全性设计

#### 1. 使用HTTPS

```
✅ https://api.example.com/users
❌ http://api.example.com/users  # 明文传输,不安全
```

#### 2. 认证(Authentication)

**Bearer Token (JWT)**:
```
GET /users/123
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

服务端验证:
1. 解析JWT
2. 验证签名
3. 检查过期时间
4. 提取用户信息
```

**API Key**:
```
GET /users/123
X-API-Key: your-api-key-here

适用场景: 服务间认证、第三方集成
```

#### 3. 授权(Authorization)

```
GET /users/123/salary  # 查询用户123的工资

检查:
1. 用户是否已认证? (401 Unauthorized)
2. 用户是否有权限查看123的工资? (403 Forbidden)
   - 管理员: ✅
   - 用户123本人: ✅
   - 其他用户: ❌

if currentUser.Role != "admin" && currentUser.ID != 123 {
    return 403
}
```

#### 4. 限流(Rate Limiting)

```
响应头:
X-RateLimit-Limit: 1000       # 每小时限制1000次
X-RateLimit-Remaining: 995    # 剩余995次
X-RateLimit-Reset: 1642234567 # 重置时间(Unix时间戳)

超出限制:
429 Too Many Requests
{
  "error": "Rate limit exceeded",
  "retry_after": 3600
}
```

```go
// Go实现(基于令牌桶)
import "golang.org/x/time/rate"

var limiter = rate.NewLimiter(10, 100)  // 每秒10个请求,桶容量100

func RateLimitMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        if !limiter.Allow() {
            c.JSON(429, gin.H{
                "error": "Too many requests",
                "retry_after": 1,
            })
            c.Abort()
            return
        }
        c.Next()
    }
}
```

### 十、实战案例

#### 案例：设计用户订单API

**资源结构**：
```
/users                     # 用户集合
/users/{userId}            # 单个用户
/users/{userId}/orders     # 用户的订单列表
/orders                    # 所有订单(管理员)
/orders/{orderId}          # 单个订单
/orders/{orderId}/items    # 订单商品
/products                  # 商品列表
```

**API设计**：

```
# 1. 获取用户123的订单列表(分页+过滤)
GET /users/123/orders?status=PAID&page=1&size=20&sort=-created_at

响应: 200 OK
{
  "data": [
    {
      "id": "ORD001",
      "status": "PAID",
      "total_amount": 9999,
      "created_at": "2025-01-15T10:00:00Z",
      "_links": {
        "self": { "href": "/orders/ORD001" },
        "items": { "href": "/orders/ORD001/items" }
      }
    }
  ],
  "pagination": {
    "page": 1,
    "size": 20,
    "total": 50,
    "pages": 3
  }
}

# 2. 创建订单
POST /users/123/orders
Content-Type: application/json
Idempotency-Key: uuid-123-456

{
  "items": [
    {"product_id": "P001", "quantity": 2},
    {"product_id": "P002", "quantity": 1}
  ],
  "shipping_address": {
    "province": "北京市",
    "city": "朝阳区",
    "street": "xxx路xxx号"
  }
}

响应: 201 Created
Location: /orders/ORD002
{
  "id": "ORD002",
  "status": "PENDING",
  "total_amount": 15999,
  "created_at": "2025-01-15T11:00:00Z"
}

# 3. 支付订单(幂等操作)
POST /orders/ORD002/pay
Idempotency-Key: pay-uuid-789

响应: 200 OK
{
  "id": "ORD002",
  "status": "PAID",
  "payment_time": "2025-01-15T11:05:00Z"
}

# 重复支付(幂等)
POST /orders/ORD002/pay  # 相同Idempotency-Key

响应: 200 OK (返回相同结果,不重复扣款)

# 4. 取消订单
DELETE /orders/ORD002  # 或 POST /orders/ORD002/cancel

响应: 200 OK
{
  "id": "ORD002",
  "status": "CANCELLED",
  "cancelled_at": "2025-01-15T11:10:00Z"
}

# 5. 部分更新订单地址
PATCH /orders/ORD002
{
  "shipping_address": {
    "street": "新地址xxx号"
  }
}

响应: 200 OK (只更新地址,其他字段不变)
```

### 总结

**RESTful API设计黄金法则**：
1. **资源导向**：URL表示资源,HTTP方法表示操作
2. **统一接口**：GET/POST/PUT/PATCH/DELETE含义明确
3. **无状态**：每个请求自包含所有信息
4. **合理的HTTP状态码**：2xx成功、4xx客户端错误、5xx服务器错误
5. **版本管理**：支持平滑升级
6. **幂等性**：避免重复操作产生副作用
7. **安全性**：HTTPS+认证+授权+限流

**实践建议**：
- 小团队：遵循核心原则即可(Level 2)
- 大团队：制定API规范文档,代码审查
- 对外API：提供OpenAPI文档(Swagger)
- 向后兼容优先：尽量不破坏现有客户端
