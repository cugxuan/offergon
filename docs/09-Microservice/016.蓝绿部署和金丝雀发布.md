---
title: 蓝绿部署和金丝雀发布
tags:
  - 微服务
status: robot
class: 微服务
slug: blue-green-vs-canary-deployment
ref:
---

## 核心要点

**蓝绿部署**:维护两套完全相同的环境,通过切换流量实现秒级回滚,零停机发布
**金丝雀发布**:逐步增加新版本流量比例,小范围验证后再扩大范围,降低影响面
**主要区别**:蓝绿是瞬时切换,金丝雀是渐进式放量;蓝绿需双倍资源,金丝雀资源利用更高效

---

## 详细回答

### 一、蓝绿部署 (Blue-Green Deployment)

#### 1. 核心原理

蓝绿部署维护**两套完全相同的生产环境**:
- **蓝环境**: 当前正在运行的生产环境 (v1)
- **绿环境**: 新版本部署的环境 (v2)

部署流程:
```
1. 蓝环境提供服务 (100% 流量)
2. 在绿环境部署新版本 (0% 流量)
3. 在绿环境进行测试验证
4. 切换流量到绿环境 (100% 流量)
5. 蓝环境保留作为回滚备份
```

#### 2. 流量切换机制

**方式一: 负载均衡器切换**
```yaml
# 初始状态: 流量指向蓝环境
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
    version: blue  # 流量到蓝环境
  ports:
  - port: 8080
    targetPort: 8080

---
# 切换后: 流量指向绿环境
spec:
  selector:
    app: user-service
    version: green  # 流量切换到绿环境
```

**方式二: DNS 切换**
```bash
# 修改 DNS 记录,将域名指向新 IP
# 缺点: DNS 缓存导致切换不够快
user-service.example.com → 10.0.1.100 (蓝环境)
user-service.example.com → 10.0.1.200 (绿环境)
```

**方式三: Istio VirtualService 切换**
```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - route:
    - destination:
        host: user-service
        subset: green  # 一键切换到绿环境
      weight: 100
```

#### 3. Go 语言实现蓝绿部署控制器

```go
package deployment

import (
    "context"
    "fmt"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/kubernetes"
)

// BlueGreenDeployer 蓝绿部署控制器
type BlueGreenDeployer struct {
    client    *kubernetes.Clientset
    namespace string
}

// SwitchTraffic 切换流量到目标环境
func (d *BlueGreenDeployer) SwitchTraffic(ctx context.Context, serviceName, targetEnv string) error {
    // 1. 验证目标环境健康状态
    healthy, err := d.checkHealthStatus(ctx, serviceName, targetEnv)
    if err != nil || !healthy {
        return fmt.Errorf("target environment %s is not healthy", targetEnv)
    }

    // 2. 更新 Service selector 切换流量
    service, err := d.client.CoreV1().Services(d.namespace).Get(ctx, serviceName, metav1.GetOptions{})
    if err != nil {
        return err
    }

    // 修改 selector 指向目标环境
    service.Spec.Selector["version"] = targetEnv

    _, err = d.client.CoreV1().Services(d.namespace).Update(ctx, service, metav1.UpdateOptions{})
    if err != nil {
        return err
    }

    // 3. 验证切换后的流量状态
    return d.verifyTrafficSwitch(ctx, serviceName, targetEnv)
}

// Rollback 回滚到上一个环境
func (d *BlueGreenDeployer) Rollback(ctx context.Context, serviceName, previousEnv string) error {
    fmt.Printf("Rolling back to %s environment\n", previousEnv)
    return d.SwitchTraffic(ctx, serviceName, previousEnv)
}

// checkHealthStatus 检查目标环境健康状态
func (d *BlueGreenDeployer) checkHealthStatus(ctx context.Context, serviceName, env string) (bool, error) {
    // 检查 Deployment 的 Ready 副本数
    deployment, err := d.client.AppsV1().Deployments(d.namespace).Get(
        ctx,
        fmt.Sprintf("%s-%s", serviceName, env),
        metav1.GetOptions{},
    )
    if err != nil {
        return false, err
    }

    // 所有副本都 Ready 才认为健康
    return deployment.Status.ReadyReplicas == deployment.Status.Replicas, nil
}
```

#### 4. 蓝绿部署优缺点

**优点**:
- **快速回滚**: 秒级切回旧版本,只需修改路由
- **零停机**: 用户无感知的无缝切换
- **完整测试**: 可以在绿环境进行充分的生产环境测试

**缺点**:
- **资源成本高**: 需要 2 倍的服务器资源
- **数据库迁移复杂**: 需要保证新旧版本对数据库 Schema 兼容
- **瞬时切换风险**: 如果新版本有问题,会瞬间影响所有用户

---

### 二、金丝雀发布 (Canary Deployment)

#### 1. 核心原理

金丝雀发布是**渐进式**的发布策略,逐步将流量从旧版本迁移到新版本:

```
阶段 1: 95% v1 + 5%  v2  (观察 30 分钟)
阶段 2: 80% v1 + 20% v2  (观察 1 小时)
阶段 3: 50% v1 + 50% v2  (观察 2 小时)
阶段 4: 20% v1 + 80% v2  (观察 1 小时)
阶段 5: 0%  v1 + 100% v2 (全量发布)
```

**命名由来**: 矿工下井前会带金丝雀,因为金丝雀对有毒气体敏感,如果金丝雀死亡则说明环境危险。类比到软件发布,先让小部分用户"试毒"。

#### 2. Kubernetes + Istio 实现金丝雀发布

```yaml
# 部署 v1 和 v2 两个版本
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service-v1
spec:
  replicas: 9  # 90% 流量
  selector:
    matchLabels:
      app: user-service
      version: v1
  template:
    metadata:
      labels:
        app: user-service
        version: v1
    spec:
      containers:
      - name: user-service
        image: user-service:v1.0.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service-v2
spec:
  replicas: 1  # 10% 流量
  selector:
    matchLabels:
      app: user-service
      version: v2
  template:
    metadata:
      labels:
        app: user-service
        version: v2
    spec:
      containers:
      - name: user-service
        image: user-service:v2.0.0

---
# Istio VirtualService 控制流量分配
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - match:
    - headers:
        x-canary:
          exact: "true"
    route:
    - destination:
        host: user-service
        subset: v2  # 带特殊 header 的请求强制路由到 v2
  - route:
    - destination:
        host: user-service
        subset: v1
      weight: 90  # 90% 流量到 v1
    - destination:
        host: user-service
        subset: v2
      weight: 10  # 10% 流量到 v2

---
# DestinationRule 定义 subset
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: user-service
spec:
  host: user-service
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

#### 3. Go 语言实现自动化金丝雀发布

```go
package deployment

import (
    "context"
    "fmt"
    "time"
)

// CanaryDeployer 金丝雀发布控制器
type CanaryDeployer struct {
    client          K8sClient
    monitoring      MonitoringService
    notifier        NotificationService
}

// CanaryStage 金丝雀发布阶段
type CanaryStage struct {
    Weight          int           // 新版本流量百分比
    Duration        time.Duration // 观察时长
    SuccessCriteria Criteria      // 成功标准
}

// Criteria 成功标准
type Criteria struct {
    MaxErrorRate     float64 // 最大错误率 (如 0.05 = 5%)
    MaxLatencyP99    int     // P99 延迟上限 (ms)
    MinSuccessRate   float64 // 最小成功率
}

// ExecuteCanaryRelease 执行金丝雀发布
func (d *CanaryDeployer) ExecuteCanaryRelease(ctx context.Context, serviceName string) error {
    // 定义发布阶段
    stages := []CanaryStage{
        {Weight: 5, Duration: 30 * time.Minute, SuccessCriteria: defaultCriteria()},
        {Weight: 20, Duration: 1 * time.Hour, SuccessCriteria: defaultCriteria()},
        {Weight: 50, Duration: 2 * time.Hour, SuccessCriteria: defaultCriteria()},
        {Weight: 80, Duration: 1 * time.Hour, SuccessCriteria: defaultCriteria()},
        {Weight: 100, Duration: 24 * time.Hour, SuccessCriteria: defaultCriteria()},
    }

    // 执行每个阶段
    for i, stage := range stages {
        fmt.Printf("Starting canary stage %d: %d%% traffic\n", i+1, stage.Weight)

        // 1. 调整流量权重
        if err := d.updateTrafficWeight(ctx, serviceName, stage.Weight); err != nil {
            return d.rollback(ctx, serviceName, err)
        }

        // 2. 观察期: 监控指标
        if err := d.observeAndValidate(ctx, serviceName, stage); err != nil {
            return d.rollback(ctx, serviceName, err)
        }

        d.notifier.SendNotification(fmt.Sprintf(
            "✅ Canary stage %d completed successfully (%d%% traffic)",
            i+1, stage.Weight,
        ))
    }

    fmt.Println("🎉 Canary release completed successfully!")
    return nil
}

// observeAndValidate 观察并验证阶段指标
func (d *CanaryDeployer) observeAndValidate(
    ctx context.Context,
    serviceName string,
    stage CanaryStage,
) error {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    deadline := time.Now().Add(stage.Duration)

    for time.Now().Before(deadline) {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            // 获取新版本的监控指标
            metrics, err := d.monitoring.GetMetrics(ctx, serviceName, "v2")
            if err != nil {
                return fmt.Errorf("failed to get metrics: %w", err)
            }

            // 验证指标是否满足成功标准
            if !d.validateMetrics(metrics, stage.SuccessCriteria) {
                return fmt.Errorf("metrics validation failed: error_rate=%.2f%%, p99=%dms",
                    metrics.ErrorRate*100, metrics.LatencyP99)
            }
        }
    }

    return nil
}

// validateMetrics 验证指标
func (d *CanaryDeployer) validateMetrics(metrics *Metrics, criteria Criteria) bool {
    if metrics.ErrorRate > criteria.MaxErrorRate {
        return false
    }
    if metrics.LatencyP99 > criteria.MaxLatencyP99 {
        return false
    }
    if metrics.SuccessRate < criteria.MinSuccessRate {
        return false
    }
    return true
}

// rollback 自动回滚
func (d *CanaryDeployer) rollback(ctx context.Context, serviceName string, reason error) error {
    fmt.Printf("🚨 Canary release failed, rolling back: %v\n", reason)

    // 将流量全部切回 v1
    if err := d.updateTrafficWeight(ctx, serviceName, 0); err != nil {
        return fmt.Errorf("rollback failed: %w", err)
    }

    d.notifier.SendAlert(fmt.Sprintf("❌ Canary release rolled back: %v", reason))
    return reason
}

func defaultCriteria() Criteria {
    return Criteria{
        MaxErrorRate:   0.05,  // 5%
        MaxLatencyP99:  1000,  // 1000ms
        MinSuccessRate: 0.95,  // 95%
    }
}
```

#### 4. 基于用户特征的金丝雀发布

除了流量比例,还可以基于用户特征定向发布:

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  # 规则 1: 内部员工使用新版本
  - match:
    - headers:
        x-user-type:
          exact: "internal"
    route:
    - destination:
        host: user-service
        subset: v2

  # 规则 2: VIP 用户使用新版本
  - match:
    - headers:
        x-user-tier:
          exact: "vip"
    route:
    - destination:
        host: user-service
        subset: v2

  # 规则 3: 北京地区用户使用新版本
  - match:
    - headers:
        x-region:
          exact: "beijing"
    route:
    - destination:
        host: user-service
        subset: v2

  # 默认规则: 其他用户使用旧版本
  - route:
    - destination:
        host: user-service
        subset: v1
```

#### 5. 金丝雀发布优缺点

**优点**:
- **风险可控**: 逐步放量,问题影响范围小
- **资源高效**: 不需要双倍资源,按需增加副本
- **灵活**: 可以基于用户特征、地域等维度精细化发布

**缺点**:
- **发布周期长**: 完整发布可能需要几小时到几天
- **监控要求高**: 需要实时监控各项指标
- **复杂度高**: 需要自动化工具支持

---

### 三、蓝绿部署 vs 金丝雀发布对比

| 维度 | 蓝绿部署 | 金丝雀发布 |
|------|---------|-----------|
| **切换方式** | 瞬时切换 (0% → 100%) | 渐进式切换 (5% → 20% → 50% → 100%) |
| **回滚速度** | 秒级 (修改路由即可) | 秒级 (调整流量权重) |
| **资源成本** | 高 (需要 2 倍资源) | 低 (逐步增加副本) |
| **风险程度** | 中等 (瞬时影响所有用户) | 低 (逐步验证,影响面小) |
| **发布时长** | 快 (几分钟) | 慢 (几小时到几天) |
| **测试环境** | 完整的生产环境副本 | 生产环境的一部分流量 |
| **适用场景** | 需要快速回滚的场景 | 需要逐步验证的场景 |
| **技术复杂度** | 低 | 中等 |
| **数据库兼容** | 需要新旧版本兼容同一 Schema | 需要新旧版本兼容同一 Schema |

---

### 四、实际应用场景选择

#### 1. 适合蓝绿部署的场景

```
✅ 大版本升级,需要快速回滚能力
✅ 有充足的基础设施资源
✅ 需要在生产环境进行完整测试
✅ 用户量不大,瞬时切换风险可控
✅ 数据库变更较少
```

**案例**: 电商平台大促前的系统升级,需要快速回滚保障。

#### 2. 适合金丝雀发布的场景

```
✅ 用户量大,需要降低发布风险
✅ 资源受限,无法支撑双倍环境
✅ 新功能需要逐步验证效果
✅ 对不同用户群体进行 A/B 测试
✅ 复杂系统,需要长时间观察
```

**案例**: 推荐算法升级,需要逐步验证用户转化率和留存率。

#### 3. 混合策略

在实际生产中,可以结合两种策略:

```
阶段 1: 在预发环境使用蓝绿部署进行验证
阶段 2: 在生产环境使用金丝雀发布逐步放量
阶段 3: 全量后保留旧版本环境,作为蓝绿回滚备份
```

---

### 五、最佳实践

#### 1. 自动化发布流程

```go
// 完整的发布流程编排
type ReleaseOrchestrator struct {
    blueGreen *BlueGreenDeployer
    canary    *CanaryDeployer
}

func (o *ReleaseOrchestrator) SmartRelease(ctx context.Context, config ReleaseConfig) error {
    // 1. 根据配置选择发布策略
    if config.Strategy == "blue-green" {
        return o.blueGreen.Deploy(ctx, config)
    }

    // 2. 金丝雀发布
    if err := o.canary.ExecuteCanaryRelease(ctx, config.ServiceName); err != nil {
        // 失败自动回滚
        return err
    }

    // 3. 全量后清理旧版本资源
    return o.cleanupOldVersion(ctx, config.ServiceName)
}
```

#### 2. 监控和告警

关键指标:
```
- 错误率 (2xx/4xx/5xx)
- 响应延迟 (P50/P90/P95/P99)
- QPS/TPS
- 资源使用率 (CPU/Memory)
- 业务指标 (转化率、成功率)
```

自动回滚触发条件:
```
- 错误率 > 旧版本 1.5 倍
- P99 延迟 > 旧版本 1.2 倍
- 业务指标下降 > 10%
- 出现致命错误
```

#### 3. 数据库版本兼容

```sql
-- 使用渐进式 Schema 变更
-- 阶段 1: 添加新字段 (兼容旧版本)
ALTER TABLE users ADD COLUMN email VARCHAR(255);

-- 阶段 2: 数据迁移 (后台任务)
UPDATE users SET email = CONCAT(username, '@example.com') WHERE email IS NULL;

-- 阶段 3: 旧版本下线后,删除旧字段
ALTER TABLE users DROP COLUMN old_email;
```

#### 4. 工具推荐

- **Kubernetes**: 原生支持 Deployment 滚动更新
- **Istio**: 流量管理和金丝雀发布
- **Flagger**: 自动化金丝雀发布 (支持 Istio/Linkerd/NGINX)
- **ArgoCD**: GitOps 蓝绿/金丝雀发布
- **Spinnaker**: Netflix 开源的持续交付平台
