---
title: é™æµç®—æ³•(ä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ã€æ»‘åŠ¨çª—å£)
tags:
  - å¾®æœåŠ¡
status: robot
class: å¾®æœåŠ¡
slug: rate-limiting-algorithms
ref:
---

## æ ¸å¿ƒè¦ç‚¹

- **é™æµç›®çš„**:ä¿æŠ¤ç³»ç»Ÿèµ„æº,é˜²æ­¢è¿‡è½½,ä¿è¯æœåŠ¡å¯ç”¨æ€§
- **ä»¤ç‰Œæ¡¶**:å…è®¸çªå‘æµé‡,é€‚åˆåº”å¯¹æµé‡æ³¢åŠ¨åœºæ™¯
- **æ¼æ¡¶**:å¼ºåˆ¶å›ºå®šé€Ÿç‡,é€‚åˆéœ€è¦å¹³æ»‘æµé‡çš„åœºæ™¯
- **æ»‘åŠ¨çª—å£**:ç²¾ç¡®ç»Ÿè®¡,è§£å†³å›ºå®šçª—å£ä¸´ç•Œé—®é¢˜,å®ç°å¤æ‚åº¦è¾ƒé«˜

---

## ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦é™æµ

### 1.1 ç³»ç»Ÿè¿‡è½½é—®é¢˜

ç³»ç»Ÿçš„å¤„ç†èƒ½åŠ›æ˜¯æœ‰é™çš„,è¶…è¿‡æ‰¿è½½èƒ½åŠ›ä¼šå¯¼è‡´:

```
è¯·æ±‚é‡ vs ç³»ç»Ÿæ‰¿è½½
æ­£å¸¸: 1000 QPS â‰¤ ç³»ç»Ÿå®¹é‡ 2000 QPS â†’ æ­£å¸¸å“åº”
è¿‡è½½: 5000 QPS > ç³»ç»Ÿå®¹é‡ 2000 QPS â†’
      - å“åº”å˜æ…¢
      - å†…å­˜æº¢å‡º
      - æ•°æ®åº“è¿æ¥è€—å°½
      - ç³»ç»Ÿå´©æºƒ
```

**å…¸å‹åœºæ™¯**:
- **æµé‡çªå¢**:ä¿ƒé”€æ´»åŠ¨ã€çƒ­ç‚¹äº‹ä»¶
- **æ¶æ„æ”»å‡»**:DDoSã€çˆ¬è™«ã€åˆ·å•
- **èµ„æºä¿æŠ¤**:ä¿æŠ¤æ•°æ®åº“ã€ç¬¬ä¸‰æ–¹APIé…é¢
- **æˆæœ¬æ§åˆ¶**:äº‘æœåŠ¡æŒ‰è°ƒç”¨è®¡è´¹

### 1.2 é™æµçš„ä½œç”¨

- **è¿‡è½½ä¿æŠ¤**:ä¿è¯ç³»ç»Ÿç¨³å®š,é¿å…é›ªå´©
- **èµ„æºåˆ†é…**:ä¿è¯æ ¸å¿ƒä¸šåŠ¡ä¼˜å…ˆ
- **æˆæœ¬æ§åˆ¶**:é¿å…è¶…é¢è´¹ç”¨
- **å…¬å¹³æ€§**:é˜²æ­¢å•ä¸ªç”¨æˆ·å ç”¨è¿‡å¤šèµ„æº

---

## äºŒã€å›ºå®šçª—å£è®¡æ•°å™¨(æœ€ç®€å•ä½†æœ‰ç¼ºé™·)

### 2.1 åŸç†

å°†æ—¶é—´åˆ’åˆ†ä¸ºå›ºå®šçª—å£(å¦‚1åˆ†é’Ÿ),ç»Ÿè®¡çª—å£å†…çš„è¯·æ±‚æ•°:

```
çª—å£1: [00:00-01:00]  å…è®¸100æ¬¡  â†’ å·²ä½¿ç”¨50æ¬¡  âœ… å…è®¸
çª—å£2: [01:00-02:00]  å…è®¸100æ¬¡  â†’ å·²ä½¿ç”¨100æ¬¡ âŒ æ‹’ç»
çª—å£3: [02:00-03:00]  å…è®¸100æ¬¡  â†’ å·²ä½¿ç”¨0æ¬¡   âœ… å…è®¸(é‡ç½®)
```

### 2.2 å®ç°ä»£ç 

```go
type FixedWindowLimiter struct {
    limit      int           // é™æµé˜ˆå€¼
    window     time.Duration // æ—¶é—´çª—å£
    counter    int           // å½“å‰è®¡æ•°
    windowTime int64         // çª—å£å¼€å§‹æ—¶é—´
    mu         sync.Mutex
}

func (l *FixedWindowLimiter) Allow() bool {
    l.mu.Lock()
    defer l.mu.Unlock()

    now := time.Now().Unix()
    windowKey := now / int64(l.window.Seconds()) // è®¡ç®—å½“å‰çª—å£

    // æ–°çª—å£,é‡ç½®è®¡æ•°
    if windowKey != l.windowTime {
        l.windowTime = windowKey
        l.counter = 0
    }

    // æ£€æŸ¥æ˜¯å¦è¶…é™
    if l.counter >= l.limit {
        return false
    }

    l.counter++
    return true
}
```

### 2.3 ä¸´ç•Œé—®é¢˜

**è‡´å‘½ç¼ºé™·**:çª—å£è¾¹ç•Œå¯èƒ½æ‰¿å—2å€æµé‡

```
æ—¶é—´çº¿:  |--------çª—å£1--------|--------çª—å£2--------|
         00:00              01:00               02:00
è¯·æ±‚åˆ†å¸ƒ:         [99æ¬¡]  [99æ¬¡]
                      â†‘      â†‘
                  00:59    01:01
é—®é¢˜: åœ¨1åˆ†é’Ÿå†…(00:30-01:30)å®é™…é€šè¿‡äº†198æ¬¡è¯·æ±‚,æ˜¯é™åˆ¶çš„2å€!
```

**è§£å†³æ–¹æ¡ˆ**:ä½¿ç”¨æ»‘åŠ¨çª—å£ç®—æ³•

---

## ä¸‰ã€æ¼æ¡¶ç®—æ³•(Leaky Bucket)

### 3.1 åŸç†

æ°´æµå…¥æ¡¶,ä»¥æ’å®šé€Ÿç‡æµå‡º,æ¡¶æ»¡åˆ™æº¢å‡º(æ‹’ç»è¯·æ±‚):

```
            è¯·æ±‚æµå…¥(ä¸å®šé€Ÿ)
                â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   æ¼æ¡¶å®¹é‡   â”‚  â† æ¡¶æ»¡åˆ™æº¢å‡º(æ‹’ç»)
         â”‚ â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ â”‚
         â”‚ â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ â”‚
         â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
         æ’å®šé€Ÿç‡æµå‡º(å¤„ç†)
```

**å…³é”®ç‰¹æ€§**:
- è¯·æ±‚ä»¥ä»»æ„é€Ÿç‡è¿›å…¥
- ä»¥å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚
- æ¡¶æœ‰å®¹é‡ä¸Šé™(ç¼“å†²åŒº)
- **å¼ºåˆ¶å¹³æ»‘è¾“å‡ºæµé‡**

### 3.2 å®ç°ä»£ç 

```go
type LeakyBucket struct {
    capacity   int           // æ¡¶å®¹é‡
    rate       time.Duration // æ¼æ°´é€Ÿç‡(å¤„ç†é—´éš”)
    water      int           // å½“å‰æ°´é‡
    lastLeakMs int64         // ä¸Šæ¬¡æ¼æ°´æ—¶é—´
    mu         sync.Mutex
}

func (lb *LeakyBucket) Allow() bool {
    lb.mu.Lock()
    defer lb.mu.Unlock()

    now := time.Now().UnixMilli()

    // è®¡ç®—è·ç¦»ä¸Šæ¬¡æ¼æ°´çš„æ—¶é—´,æ¼æ‰çš„æ°´é‡
    elapsed := now - lb.lastLeakMs
    leaked := int(elapsed / lb.rate.Milliseconds())

    // æ›´æ–°æ¡¶å†…æ°´é‡
    lb.water = max(0, lb.water-leaked)
    lb.lastLeakMs = now

    // æ£€æŸ¥æ˜¯å¦æº¢å‡º
    if lb.water >= lb.capacity {
        return false // æ¡¶æ»¡,æ‹’ç»
    }

    lb.water++ // åŠ æ°´
    return true
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 3.3 ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**:
- âœ… å¼ºåˆ¶æµé‡å¹³æ»‘,ä¿æŠ¤åç«¯æœåŠ¡
- âœ… å®ç°ç®€å•,å†…å­˜å ç”¨å°
- âœ… é€‚åˆéœ€è¦ç¨³å®šè¾“å‡ºçš„åœºæ™¯(å¦‚è§†é¢‘æµ)

**ç¼ºç‚¹**:
- âŒ æ— æ³•åº”å¯¹çªå‘æµé‡(å³ä½¿ç³»ç»Ÿæœ‰ä½™åŠ›)
- âŒ å¯èƒ½æµªè´¹ç³»ç»Ÿèµ„æº(ç©ºé—²æ—¶ä¹Ÿé™æµ)

**é€‚ç”¨åœºæ™¯**:
- å¯¹ç¬¬ä¸‰æ–¹APIçš„è°ƒç”¨(ä¸¥æ ¼éµå®ˆé€Ÿç‡é™åˆ¶)
- æ¶ˆæ¯é˜Ÿåˆ—æ¶ˆè´¹(é¿å…ä¸‹æ¸¸è¿‡è½½)
- æ•°æ®åº“å†™å…¥(å¹³æ»‘å†™å…¥å‹åŠ›)

---

## å››ã€ä»¤ç‰Œæ¡¶ç®—æ³•(Token Bucket)

### 4.1 åŸç†

ä»¥æ’å®šé€Ÿç‡ç”Ÿæˆä»¤ç‰Œæ”¾å…¥æ¡¶,è¯·æ±‚æ¶ˆè€—ä»¤ç‰Œ,æ¡¶æ»¡åˆ™ä»¤ç‰Œæº¢å‡º:

```
       ä»¥å›ºå®šé€Ÿç‡ç”Ÿæˆä»¤ç‰Œ(å¦‚10ä¸ª/ç§’)
                â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  ä»¤ç‰Œæ¡¶å®¹é‡  â”‚  â† æ¡¶æ»¡,æ–°ä»¤ç‰Œä¸¢å¼ƒ
         â”‚ ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ â”‚
         â”‚ ğŸª™ğŸª™ğŸª™       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
         è¯·æ±‚è·å–ä»¤ç‰Œ(ä¸å®šé€Ÿ)
         æœ‰ä»¤ç‰Œ:é€šè¿‡  æ— ä»¤ç‰Œ:æ‹’ç»
```

**ä¸æ¼æ¡¶çš„å…³é”®åŒºåˆ«**:
- æ¼æ¡¶:å¼ºåˆ¶**è¾“å‡ºé€Ÿç‡**æ’å®š
- ä»¤ç‰Œæ¡¶:é™åˆ¶**å¹³å‡é€Ÿç‡**,å…è®¸çªå‘

### 4.2 å®ç°ä»£ç 

```go
type TokenBucket struct {
    capacity    int           // æ¡¶å®¹é‡(æœ€å¤§ä»¤ç‰Œæ•°)
    rate        time.Duration // ç”Ÿæˆä»¤ç‰Œé—´éš”
    tokens      int           // å½“å‰ä»¤ç‰Œæ•°
    lastTokenMs int64         // ä¸Šæ¬¡ç”Ÿæˆä»¤ç‰Œæ—¶é—´
    mu          sync.Mutex
}

func (tb *TokenBucket) Allow() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()

    now := time.Now().UnixMilli()

    // è®¡ç®—éœ€è¦ç”Ÿæˆçš„ä»¤ç‰Œæ•°
    elapsed := now - tb.lastTokenMs
    tokensToAdd := int(elapsed / tb.rate.Milliseconds())

    // æ›´æ–°ä»¤ç‰Œæ•°(ä¸è¶…è¿‡å®¹é‡)
    tb.tokens = min(tb.capacity, tb.tokens+tokensToAdd)
    tb.lastTokenMs = now

    // æ£€æŸ¥æ˜¯å¦æœ‰ä»¤ç‰Œ
    if tb.tokens <= 0 {
        return false // æ— ä»¤ç‰Œ,æ‹’ç»
    }

    tb.tokens-- // æ¶ˆè€—ä»¤ç‰Œ
    return true
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 4.3 çªå‘æµé‡å¤„ç†

**ç¤ºä¾‹**:é€Ÿç‡10ä¸ª/ç§’,å®¹é‡100

```
åœºæ™¯1: ç³»ç»Ÿç©ºé—²1å°æ—¶
- ç§¯ç´¯ä»¤ç‰Œ:100ä¸ª(å·²æ»¡)
- çªå‘è¯·æ±‚:100ä¸ª â†’ å…¨éƒ¨é€šè¿‡ âœ…
- ä¹‹å:æ¢å¤10ä¸ª/ç§’é€Ÿç‡

åœºæ™¯2: æŒç»­é«˜æµé‡
- ä»¤ç‰Œè€—å°½:0ä¸ª
- æ–°è¯·æ±‚:åªèƒ½ä»¥10ä¸ª/ç§’é€šè¿‡(ç”Ÿæˆé€Ÿç‡)
```

**è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé€‚åˆWebåº”ç”¨**:
- å…è®¸çŸ­æ—¶çªå‘(ç”¨æˆ·ç‚¹å‡»)
- é•¿æœŸé™åˆ¶å¹³å‡é€Ÿç‡

### 4.4 Go å®˜æ–¹åº“ä½¿ç”¨

```go
import "golang.org/x/time/rate"

func main() {
    // åˆ›å»ºé™æµå™¨: æ¯ç§’10ä¸ªä»¤ç‰Œ,æ¡¶å®¹é‡100
    limiter := rate.NewLimiter(rate.Limit(10), 100)

    // æ–¹å¼1: é˜»å¡ç­‰å¾…ä»¤ç‰Œ
    err := limiter.Wait(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    // æ–¹å¼2: éé˜»å¡æ£€æŸ¥
    if limiter.Allow() {
        // å¤„ç†è¯·æ±‚
    } else {
        // æ‹’ç»è¯·æ±‚
    }

    // æ–¹å¼3: é¢„ç•™ä»¤ç‰Œ(ç”¨äºæ‰¹é‡æ“ä½œ)
    reservation := limiter.Reserve()
    if !reservation.OK() {
        // æ— æ³•æ»¡è¶³
    }
    time.Sleep(reservation.Delay()) // ç­‰å¾…åˆ°å¯ç”¨æ—¶é—´
}
```

### 4.5 ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**:
- âœ… å…è®¸çªå‘æµé‡,å……åˆ†åˆ©ç”¨ç³»ç»Ÿèµ„æº
- âœ… é™åˆ¶é•¿æœŸå¹³å‡é€Ÿç‡
- âœ… åº”ç”¨å¹¿æ³›,ç”Ÿæ€å®Œå–„

**ç¼ºç‚¹**:
- âŒ çªå‘æµé‡å¯èƒ½å†²å‡»åç«¯
- âŒ éœ€è¦åˆç†è®¾ç½®æ¡¶å®¹é‡

**é€‚ç”¨åœºæ™¯**:
- Web APIé™æµ(æœ€å¸¸è§)
- ç”¨æˆ·çº§åˆ«é™æµ
- éœ€è¦åº”å¯¹çªå‘æµé‡çš„åœºæ™¯

---

## äº”ã€æ»‘åŠ¨çª—å£ç®—æ³•(Sliding Window)

### 5.1 å›ºå®šçª—å£é—®é¢˜å›é¡¾

å›ºå®šçª—å£åœ¨è¾¹ç•Œå¤„å¯èƒ½æ‰¿å—2å€æµé‡:

```
å›ºå®šçª—å£:
|-----çª—å£1(100æ¬¡)-----|-----çª—å£2(100æ¬¡)-----|
          [99æ¬¡][99æ¬¡]
              â†‘    â†‘
           ä¸´ç•ŒåŒºåŸŸ: å®é™…1åˆ†é’Ÿå†…198æ¬¡
```

### 5.2 æ»‘åŠ¨çª—å£æ—¥å¿—

**åŸç†**:è®°å½•æ¯ä¸ªè¯·æ±‚çš„æ—¶é—´æˆ³,ç»Ÿè®¡æœ€è¿‘Nç§’çš„è¯·æ±‚æ•°

```
å½“å‰æ—¶é—´: 10:00:50
é™åˆ¶: 100æ¬¡/åˆ†é’Ÿ

è¯·æ±‚æ—¥å¿—: [10:00:01, 10:00:15, ..., 10:00:48, 10:00:50]
           â†‘ è¶…è¿‡1åˆ†é’Ÿ,æ¸…ç†
è®¡ç®—: 10:00:50 - 60ç§’ = 09:59:50
ç»Ÿè®¡: 09:59:50 ~ 10:00:50 ä¹‹é—´çš„è¯·æ±‚æ•°
```

**å®ç°ä»£ç **:

```go
type SlidingWindowLog struct {
    limit      int
    window     time.Duration
    requests   []int64 // è¯·æ±‚æ—¶é—´æˆ³é˜Ÿåˆ—
    mu         sync.Mutex
}

func (sw *SlidingWindowLog) Allow() bool {
    sw.mu.Lock()
    defer sw.mu.Unlock()

    now := time.Now().UnixMilli()
    windowStart := now - sw.window.Milliseconds()

    // æ¸…ç†è¿‡æœŸè¯·æ±‚
    validIdx := 0
    for i, reqTime := range sw.requests {
        if reqTime > windowStart {
            validIdx = i
            break
        }
    }
    sw.requests = sw.requests[validIdx:]

    // æ£€æŸ¥æ˜¯å¦è¶…é™
    if len(sw.requests) >= sw.limit {
        return false
    }

    sw.requests = append(sw.requests, now)
    return true
}
```

**ä¼˜ç¼ºç‚¹**:
- âœ… éå¸¸ç²¾ç¡®,æ— ä¸´ç•Œé—®é¢˜
- âŒ å†…å­˜å ç”¨é«˜(å­˜å‚¨æ¯ä¸ªè¯·æ±‚)
- âŒ é«˜å¹¶å‘æ€§èƒ½å·®

### 5.3 æ»‘åŠ¨çª—å£è®¡æ•°(ä¼˜åŒ–ç‰ˆ)

**åŸç†**:å°†æ—¶é—´åˆ†ä¸ºå¤šä¸ªå°çª—å£,æ»‘åŠ¨æ—¶åŠ æƒè®¡ç®—

```
å¤§çª—å£: 1åˆ†é’Ÿ,åˆ†ä¸º6ä¸ªå°çª—å£(æ¯ä¸ª10ç§’)

å½“å‰æ—¶é—´: 10:00:55
|--10s--|--10s--|--10s--|--10s--|--10s--|--10s--|
 [20]    [15]    [30]    [25]    [10]    [5æ¬¡] â† å½“å‰
  â†‘                                        â†‘
æ¸…ç†                                    10:00:50-10:00:59

è®¡ç®—:
- å½“å‰çª—å£(10:00:50-10:00:59): 5æ¬¡(æƒé‡100%)
- ä¸Šä¸ªçª—å£(10:00:40-10:00:49): 10æ¬¡(æƒé‡50% â†’ 5æ¬¡)
- æ€»è®¡: 5 + 5 = 10æ¬¡
```

**å®ç°ä»£ç **:

```go
type SlidingWindowCounter struct {
    limit       int
    window      time.Duration
    slotNum     int              // åˆ‡ç‰‡æ•°é‡
    slotWindow  time.Duration    // æ¯ä¸ªåˆ‡ç‰‡çš„æ—¶é—´
    slots       []int            // æ¯ä¸ªåˆ‡ç‰‡çš„è®¡æ•°
    slotTime    []int64          // æ¯ä¸ªåˆ‡ç‰‡çš„å¼€å§‹æ—¶é—´
    mu          sync.Mutex
}

func NewSlidingWindowCounter(limit int, window time.Duration, slotNum int) *SlidingWindowCounter {
    return &SlidingWindowCounter{
        limit:      limit,
        window:     window,
        slotNum:    slotNum,
        slotWindow: window / time.Duration(slotNum),
        slots:      make([]int, slotNum),
        slotTime:   make([]int64, slotNum),
    }
}

func (sw *SlidingWindowCounter) Allow() bool {
    sw.mu.Lock()
    defer sw.mu.Unlock()

    now := time.Now().UnixMilli()
    windowStart := now - sw.window.Milliseconds()

    // è®¡ç®—å½“å‰slotç´¢å¼•
    currentSlot := int((now / sw.slotWindow.Milliseconds()) % int64(sw.slotNum))

    // æ¸…ç†è¿‡æœŸslot
    for i := 0; i < sw.slotNum; i++ {
        if sw.slotTime[i] < windowStart {
            sw.slots[i] = 0
        }
    }

    // ç»Ÿè®¡çª—å£å†…æ€»è¯·æ±‚æ•°
    var count int
    for i := 0; i < sw.slotNum; i++ {
        slotStart := sw.slotTime[i]
        if slotStart >= windowStart {
            // å½“å‰çª—å£å†…çš„slot,å…¨éƒ¨è®¡å…¥
            count += sw.slots[i]
        } else if slotStart+sw.slotWindow.Milliseconds() > windowStart {
            // è·¨çª—å£çš„slot,æŒ‰æ¯”ä¾‹è®¡ç®—
            ratio := float64(slotStart+sw.slotWindow.Milliseconds()-windowStart) /
                     float64(sw.slotWindow.Milliseconds())
            count += int(float64(sw.slots[i]) * ratio)
        }
    }

    // æ£€æŸ¥æ˜¯å¦è¶…é™
    if count >= sw.limit {
        return false
    }

    // æ›´æ–°å½“å‰slot
    slotStartTime := (now / sw.slotWindow.Milliseconds()) * sw.slotWindow.Milliseconds()
    if sw.slotTime[currentSlot] != slotStartTime {
        sw.slotTime[currentSlot] = slotStartTime
        sw.slots[currentSlot] = 0
    }
    sw.slots[currentSlot]++

    return true
}
```

**ä¼˜ç¼ºç‚¹**:
- âœ… å†…å­˜å¯æ§(å›ºå®šslotæ•°é‡)
- âœ… è¾ƒé«˜ç²¾åº¦(æ¯”å›ºå®šçª—å£å¥½)
- âŒ å®ç°å¤æ‚
- âŒ çª—å£è¾¹ç•Œä»æœ‰å°è¯¯å·®(å–å†³äºslotæ•°é‡)

---

## å…­ã€ç®—æ³•å¯¹æ¯”ä¸é€‰å‹

### 6.1 æ ¸å¿ƒå¯¹æ¯”

| ç®—æ³• | çªå‘æµé‡ | æµé‡å¹³æ»‘ | ç²¾ç¡®åº¦ | å†…å­˜ | å®ç°å¤æ‚åº¦ |
|------|----------|----------|--------|------|-----------|
| **å›ºå®šçª—å£** | âŒ ä¸´ç•Œé—®é¢˜ | âœ… | âš ï¸ ä¸´ç•Œ2å€ | âœ… ä½ | â­ ç®€å• |
| **æ¼æ¡¶** | âŒ ä¸å…è®¸ | âœ…âœ… å¼ºåˆ¶å¹³æ»‘ | âœ… | âœ… ä½ | â­â­ ä¸­ç­‰ |
| **ä»¤ç‰Œæ¡¶** | âœ…âœ… å…è®¸ | âš ï¸ å¹³å‡é™åˆ¶ | âœ… | âœ… ä½ | â­â­ ä¸­ç­‰ |
| **æ»‘åŠ¨çª—å£æ—¥å¿—** | âœ… | âœ… | âœ…âœ… éå¸¸ç²¾ç¡® | âŒ é«˜ | â­â­â­ å¤æ‚ |
| **æ»‘åŠ¨çª—å£è®¡æ•°** | âœ… | âœ… | âœ… è¾ƒç²¾ç¡® | âœ… å¯æ§ | â­â­â­ å¤æ‚ |

### 6.2 é€‰å‹å»ºè®®

**åœºæ™¯1: Web APIé™æµ**
- **æ¨è**: ä»¤ç‰Œæ¡¶
- åŸå› : å…è®¸çªå‘,ç”¨æˆ·ä½“éªŒå¥½

**åœºæ™¯2: è°ƒç”¨ç¬¬ä¸‰æ–¹API**
- **æ¨è**: æ¼æ¡¶
- åŸå› : ä¸¥æ ¼éµå®ˆé€Ÿç‡é™åˆ¶,é¿å…è¶…é¢

**åœºæ™¯3: é«˜ç²¾åº¦è®¡è´¹åœºæ™¯**
- **æ¨è**: æ»‘åŠ¨çª—å£æ—¥å¿—
- åŸå› : ç²¾ç¡®ç»Ÿè®¡,æ— ä¸´ç•Œé—®é¢˜

**åœºæ™¯4: é«˜å¹¶å‘ç½‘å…³**
- **æ¨è**: ä»¤ç‰Œæ¡¶ æˆ– æ»‘åŠ¨çª—å£è®¡æ•°
- åŸå› : æ€§èƒ½å¥½,å†…å­˜å¯æ§

**åœºæ™¯5: èµ„æºå—é™è®¾å¤‡**
- **æ¨è**: å›ºå®šçª—å£
- åŸå› : å®ç°ç®€å•,èµ„æºå ç”¨æœ€å°(å¯æ¥å—ä¸´ç•Œé—®é¢˜)

### 6.3 åˆ†å¸ƒå¼é™æµ

ä»¥ä¸Šç®—æ³•éƒ½æ˜¯å•æœºé™æµ,åˆ†å¸ƒå¼åœºæ™¯éœ€è¦:

**æ–¹æ¡ˆ1: Redis + Luaè„šæœ¬**

```lua
-- ä»¤ç‰Œæ¡¶ Lua è„šæœ¬
local key = KEYS[1]
local capacity = tonumber(ARGV[1])
local rate = tonumber(ARGV[2])
local requested = tonumber(ARGV[3])

local info = redis.call('HMGET', key, 'tokens', 'timestamp')
local tokens = tonumber(info[1]) or capacity
local last = tonumber(info[2]) or 0
local now = tonumber(ARGV[4])

-- è®¡ç®—æ–°å¢ä»¤ç‰Œ
local delta = math.max(0, now - last)
local new_tokens = math.min(capacity, tokens + delta * rate)

-- æ£€æŸ¥æ˜¯å¦è¶³å¤Ÿ
if new_tokens >= requested then
    new_tokens = new_tokens - requested
    redis.call('HMSET', key, 'tokens', new_tokens, 'timestamp', now)
    redis.call('EXPIRE', key, 10)
    return 1
else
    return 0
end
```

**æ–¹æ¡ˆ2: ç½‘å…³é›†ä¸­é™æµ**
- Kongã€APISIXç­‰ç½‘å…³ç»Ÿä¸€é™æµ
- é¿å…æ¯ä¸ªæœåŠ¡å®ä¾‹å•ç‹¬å®ç°

**æ–¹æ¡ˆ3: Sentinel é›†ç¾¤æµæ§**
- Token Serveræ¨¡å¼
- æ‰€æœ‰å®ä¾‹è¿æ¥åŒä¸€Token Server

---

## ä¸ƒã€ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ

### 7.1 å¤šçº§é™æµ

```go
// ç»„åˆå¤šç§ç­–ç•¥
type MultiLevelLimiter struct {
    globalLimiter *rate.Limiter      // å…¨å±€ä»¤ç‰Œæ¡¶
    userLimiters  map[string]*rate.Limiter // ç”¨æˆ·çº§åˆ«
    ipLimiters    map[string]*rate.Limiter // IPçº§åˆ«
    mu            sync.RWMutex
}

func (ml *MultiLevelLimiter) Allow(userID, ip string) bool {
    // ç¬¬ä¸€çº§: å…¨å±€é™æµ
    if !ml.globalLimiter.Allow() {
        return false
    }

    // ç¬¬äºŒçº§: ç”¨æˆ·é™æµ
    ml.mu.RLock()
    userLimiter, ok := ml.userLimiters[userID]
    ml.mu.RUnlock()

    if ok && !userLimiter.Allow() {
        return false
    }

    // ç¬¬ä¸‰çº§: IPé™æµ(é˜²åˆ·)
    ml.mu.RLock()
    ipLimiter, ok := ml.ipLimiters[ip]
    ml.mu.RUnlock()

    if ok && !ipLimiter.Allow() {
        return false
    }

    return true
}
```

### 7.2 åŠ¨æ€è°ƒæ•´é™æµé˜ˆå€¼

```go
type AdaptiveLimiter struct {
    limiter   *rate.Limiter
    baseRate  float64
    maxRate   float64
    cpuWatch  *CPUWatcher
}

func (al *AdaptiveLimiter) adjust() {
    cpu := al.cpuWatch.GetUsage()

    switch {
    case cpu > 80:
        // CPUé«˜è´Ÿè½½,é™ä½é™æµ
        newRate := al.baseRate * 0.5
        al.limiter.SetLimit(rate.Limit(newRate))
    case cpu < 50:
        // CPUç©ºé—²,æé«˜é™æµ
        newRate := min(al.baseRate*1.5, al.maxRate)
        al.limiter.SetLimit(rate.Limit(newRate))
    }
}
```

### 7.3 ä¼˜é›…é™çº§

```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
    if !limiter.Allow() {
        // è¢«é™æµ,è¿”å›å‹å¥½æç¤º
        w.Header().Set("X-RateLimit-Limit", "100")
        w.Header().Set("X-RateLimit-Remaining", "0")
        w.Header().Set("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(time.Minute).Unix()))
        w.Header().Set("Retry-After", "60")

        http.Error(w, "Rate limit exceeded. Please retry after 60 seconds.",
                   http.StatusTooManyRequests)
        return
    }

    // æ­£å¸¸å¤„ç†
    processRequest(w, r)
}
```

### 7.4 ç›‘æ§å‘Šè­¦

```go
type LimiterMetrics struct {
    total    int64 // æ€»è¯·æ±‚æ•°
    allowed  int64 // é€šè¿‡æ•°
    rejected int64 // æ‹’ç»æ•°
}

func (lm *LimiterMetrics) Record(allowed bool) {
    atomic.AddInt64(&lm.total, 1)
    if allowed {
        atomic.AddInt64(&lm.allowed, 1)
    } else {
        atomic.AddInt64(&lm.rejected, 1)

        // æ‹’ç»ç‡è¶…è¿‡30%å‘Šè­¦
        rejectRate := float64(lm.rejected) / float64(lm.total)
        if rejectRate > 0.3 {
            alert.Send("é™æµæ‹’ç»ç‡è¿‡é«˜: " + fmt.Sprintf("%.2f%%", rejectRate*100))
        }
    }
}
```

---

## å…«ã€æ€»ç»“

### 8.1 é€‰æ‹©å»ºè®®é€ŸæŸ¥

```
éœ€è¦å¹³æ»‘æµé‡(ä¿æŠ¤åç«¯) â†’ æ¼æ¡¶
éœ€è¦åº”å¯¹çªå‘æµé‡ â†’ ä»¤ç‰Œæ¡¶
éœ€è¦é«˜ç²¾åº¦ç»Ÿè®¡ â†’ æ»‘åŠ¨çª—å£
èµ„æºå—é™/ç®€å•åœºæ™¯ â†’ å›ºå®šçª—å£
```

### 8.2 å…³é”®è¦ç‚¹

1. **é™æµæ˜¯ä¸»åŠ¨é˜²æŠ¤**,ç†”æ–­æ˜¯è¢«åŠ¨é˜²æŠ¤,ä¸¤è€…é…åˆä½¿ç”¨
2. **ä»¤ç‰Œæ¡¶æœ€å¸¸ç”¨**,é€‚åˆç»å¤§å¤šæ•°Webåœºæ™¯
3. **åˆ†å¸ƒå¼é™æµ**éœ€è¦Redisç­‰ä¸­å¿ƒåŒ–ç»„ä»¶
4. **å¤šçº§é™æµ**:å…¨å±€ + ç”¨æˆ· + IP,å±‚å±‚ä¿æŠ¤
5. **ä¼˜é›…é™çº§**:æä¾›å‹å¥½é”™è¯¯ä¿¡æ¯å’Œé‡è¯•å»ºè®®

### 8.3 é¿å…çš„å‘

1. âŒ é™æµé˜ˆå€¼è®¾ç½®è¿‡ä½,å½±å“æ­£å¸¸ä¸šåŠ¡
2. âŒ æ²¡æœ‰åŒºåˆ†ä¸åŒç”¨æˆ·/æ¥å£,ä¸€åˆ€åˆ‡é™æµ
3. âŒ é™æµåç›´æ¥è¿”å›500,åº”è¿”å›429(Too Many Requests)
4. âŒ æ²¡æœ‰ç›‘æ§é™æµæŒ‡æ ‡,æ— æ³•åŠæ—¶è°ƒæ•´
5. âŒ åˆ†å¸ƒå¼åœºæ™¯ç”¨æœ¬åœ°é™æµ,å¯¼è‡´æ€»æµé‡è¶…é™

---

**å‚è€ƒèµ„æ–™**:
- [Cloudflare - Rate Limiting](https://blog.cloudflare.com/counting-things-a-lot-of-different-things/)
- [Go rate package](https://pkg.go.dev/golang.org/x/time/rate)
- [Redis INCR patterns](https://redis.io/commands/incr#pattern-rate-limiter)
