---
title: 微服务的安全认证(OAuth2/JWT)
tags:
  - 微服务
status: robot
class: 微服务
slug: microservices-security-authentication-oauth2-jwt
ref:
---

## 核心要点

**微服务安全认证的核心是解决"谁在访问"和"有权访问什么"两大问题**。主流方案包括:**JWT(无状态Token)用于服务间认证、OAuth2(授权框架)用于第三方授权**。关键技术点包括:**Token的签名验证、刷新机制、权限控制(RBAC/ABAC)、API网关统一认证**。安全要点是**Token加密传输、短生命周期+刷新Token、敏感操作二次验证**。

---

## 详细回答

### 一、微服务认证授权的挑战

传统单体应用使用Session保存用户状态,但在微服务架构下面临问题:

**传统Session方案的问题:**
1. **Session共享困难** - 多个服务需要共享Session存储(Redis)
2. **水平扩展受限** - Session亲和性导致负载均衡复杂
3. **跨语言困难** - 不同语言的Session格式不统一
4. **服务间调用** - 内部服务调用如何传递身份信息

**微服务认证方案需要满足:**
- ✅ 无状态 - 服务可以独立扩展
- ✅ 标准化 - 跨语言、跨平台
- ✅ 安全 - 防篡改、防重放攻击
- ✅ 性能 - 低延迟验证

### 二、JWT(JSON Web Token)详解

#### 1. JWT的结构

JWT由三部分组成,用`.`分隔:

```
Header.Payload.Signature
```

**示例JWT:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiMTIzIiwicm9sZSI6ImFkbWluIiwiZXhwIjoxNzA1MzIwMDAwfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**解析后:**

```json
// Header (算法和类型)
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload (载荷数据)
{
  "user_id": "123",
  "username": "john",
  "role": "admin",
  "exp": 1705320000,  // 过期时间
  "iat": 1705233600,  // 签发时间
  "iss": "auth-service"  // 签发者
}

// Signature (签名)
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

#### 2. JWT的工作流程

```
┌─────────┐                          ┌──────────────┐
│ Client  │                          │ Auth Service │
└────┬────┘                          └──────┬───────┘
     │                                      │
     │ 1. POST /login (username+password)   │
     ├─────────────────────────────────────>│
     │                                      │
     │                              2. 验证用户
     │                              3. 生成JWT
     │                                      │
     │ 4. 返回JWT Token                     │
     │<─────────────────────────────────────┤
     │                                      │
     │                                      │
┌────┴────┐                          ┌─────┴──────┐
│ Client  │                          │   Order    │
│(存储JWT)│                          │  Service   │
└────┬────┘                          └─────┬──────┘
     │                                     │
     │ 5. GET /orders                      │
     │    Header: Authorization: Bearer JWT│
     ├────────────────────────────────────>│
     │                                     │
     │                            6. 验证JWT签名
     │                            7. 提取user_id
     │                            8. 查询订单
     │                                     │
     │ 9. 返回订单数据                      │
     │<────────────────────────────────────┤
     │                                     │
```

#### 3. Go实现JWT认证

**生成和验证JWT:**

```go
package auth

import (
    "errors"
    "time"
    "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("your-secret-key-change-in-production")

// JWT Claims结构
type Claims struct {
    UserID   string   `json:"user_id"`
    Username string   `json:"username"`
    Role     string   `json:"role"`
    Permissions []string `json:"permissions"`
    jwt.RegisteredClaims
}

// 生成Access Token(短期有效)
func GenerateAccessToken(userID, username, role string, permissions []string) (string, error) {
    claims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        Permissions: permissions,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(15 * time.Minute)), // 15分钟过期
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "auth-service",
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// 生成Refresh Token(长期有效)
func GenerateRefreshToken(userID string) (string, error) {
    claims := &Claims{
        UserID: userID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)), // 7天过期
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "auth-service",
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// 验证Token
func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名算法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, errors.New("invalid signing method")
        }
        return jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}

// 从Token中提取用户ID
func ExtractUserID(tokenString string) (string, error) {
    claims, err := ValidateToken(tokenString)
    if err != nil {
        return "", err
    }
    return claims.UserID, nil
}
```

**HTTP中间件验证JWT:**

```go
package middleware

import (
    "context"
    "net/http"
    "strings"
)

func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从Header提取Token
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Missing authorization header", http.StatusUnauthorized)
            return
        }

        // Bearer Token格式: "Bearer <token>"
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
            return
        }

        tokenString := parts[1]

        // 验证Token
        claims, err := auth.ValidateToken(tokenString)
        if err != nil {
            http.Error(w, "Invalid token: "+err.Error(), http.StatusUnauthorized)
            return
        }

        // 将用户信息注入Context
        ctx := context.WithValue(r.Context(), "user_id", claims.UserID)
        ctx = context.WithValue(ctx, "username", claims.Username)
        ctx = context.WithValue(ctx, "role", claims.Role)
        ctx = context.WithValue(ctx, "permissions", claims.Permissions)

        // 传递给下一个Handler
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 权限检查中间件(基于RBAC)
func RequirePermission(permission string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            permissions := r.Context().Value("permissions").([]string)

            // 检查权限
            hasPermission := false
            for _, p := range permissions {
                if p == permission || p == "*" { // *表示超级管理员
                    hasPermission = true
                    break
                }
            }

            if !hasPermission {
                http.Error(w, "Forbidden: insufficient permissions", http.StatusForbidden)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

**登录和Token刷新接口:**

```go
package handler

import (
    "encoding/json"
    "net/http"
)

type LoginRequest struct {
    Username string `json:"username"`
    Password string `json:"password"`
}

type LoginResponse struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    ExpiresIn    int    `json:"expires_in"` // 秒
}

func LoginHandler(w http.ResponseWriter, r *http.Request) {
    var req LoginRequest
    json.NewDecoder(r.Body).Decode(&req)

    // 验证用户名密码(实际应查询数据库)
    user, err := userService.Authenticate(req.Username, req.Password)
    if err != nil {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }

    // 生成Token
    accessToken, _ := auth.GenerateAccessToken(user.ID, user.Username, user.Role, user.Permissions)
    refreshToken, _ := auth.GenerateRefreshToken(user.ID)

    // 返回Token
    json.NewEncoder(w).Encode(LoginResponse{
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        ExpiresIn:    900, // 15分钟
    })
}

// Token刷新接口
func RefreshTokenHandler(w http.ResponseWriter, r *http.Request) {
    var req struct {
        RefreshToken string `json:"refresh_token"`
    }
    json.NewDecoder(r.Body).Decode(&req)

    // 验证Refresh Token
    claims, err := auth.ValidateToken(req.RefreshToken)
    if err != nil {
        http.Error(w, "Invalid refresh token", http.StatusUnauthorized)
        return
    }

    // 查询最新用户信息
    user, err := userService.GetByID(claims.UserID)
    if err != nil {
        http.Error(w, "User not found", http.StatusUnauthorized)
        return
    }

    // 生成新的Access Token
    newAccessToken, _ := auth.GenerateAccessToken(user.ID, user.Username, user.Role, user.Permissions)

    json.NewEncoder(w).Encode(LoginResponse{
        AccessToken:  newAccessToken,
        RefreshToken: req.RefreshToken, // Refresh Token可以继续使用
        ExpiresIn:    900,
    })
}
```

#### 4. JWT在微服务间传递

**gRPC服务间调用传递JWT:**

```go
package grpc_client

import (
    "context"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

// gRPC客户端拦截器 - 自动注入JWT
func JWTClientInterceptor(token string) grpc.UnaryClientInterceptor {
    return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
        // 将JWT注入metadata
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

// gRPC服务端拦截器 - 验证JWT
func JWTServerInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    // 从metadata提取JWT
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.Unauthenticated, "missing metadata")
    }

    tokens := md.Get("authorization")
    if len(tokens) == 0 {
        return nil, status.Error(codes.Unauthenticated, "missing authorization token")
    }

    tokenString := strings.TrimPrefix(tokens[0], "Bearer ")

    // 验证JWT
    claims, err := auth.ValidateToken(tokenString)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "invalid token")
    }

    // 注入用户信息到context
    ctx = context.WithValue(ctx, "user_id", claims.UserID)
    ctx = context.WithValue(ctx, "role", claims.Role)

    return handler(ctx, req)
}
```

### 三、OAuth2授权框架

#### 1. OAuth2的四种授权模式

OAuth2主要用于**第三方应用授权**,允许用户授权第三方访问其资源,而不暴露密码。

**1. 授权码模式(Authorization Code) - 最安全,适用于Web应用**

```
┌────────┐                                  ┌─────────────┐
│ Client │                                  │   GitHub    │
│  App   │                                  │(授权服务器)  │
└───┬────┘                                  └──────┬──────┘
    │                                              │
    │ 1. 跳转到GitHub授权页面                       │
    │    GET /oauth/authorize?                     │
    │        client_id=xxx&                        │
    │        redirect_uri=http://myapp.com/callback│
    │        response_type=code&                   │
    │        scope=user:email                      │
    ├─────────────────────────────────────────────>│
    │                                              │
    │                                     2. 用户登录并授权
    │                                              │
    │ 3. 重定向回应用,携带授权码                     │
    │    http://myapp.com/callback?code=abc123     │
    │<─────────────────────────────────────────────┤
    │                                              │
    │ 4. 用授权码换取Access Token                   │
    │    POST /oauth/token                         │
    │    code=abc123&                              │
    │    client_id=xxx&                            │
    │    client_secret=yyy&                        │
    │    grant_type=authorization_code             │
    ├─────────────────────────────────────────────>│
    │                                              │
    │ 5. 返回Access Token                          │
    │    { "access_token": "token123",             │
    │      "token_type": "Bearer",                 │
    │      "expires_in": 3600 }                    │
    │<─────────────────────────────────────────────┤
    │                                              │
    │                                  ┌───────────┴────┐
    │ 6. 使用Token访问资源             │  GitHub API    │
    │    GET /user                     │ (资源服务器)    │
    │    Authorization: Bearer token123│                │
    ├─────────────────────────────────>│                │
    │                                  │                │
    │ 7. 返回用户信息                   │                │
    │<─────────────────────────────────┤                │
    │                                  └────────────────┘
```

**2. 客户端凭证模式(Client Credentials) - 服务间调用**

```go
// 微服务A调用微服务B的场景
func GetAccessToken() (string, error) {
    data := url.Values{}
    data.Set("grant_type", "client_credentials")
    data.Set("client_id", "service-a")
    data.Set("client_secret", "secret-key")
    data.Set("scope", "order:read order:write")

    resp, err := http.PostForm("http://auth-service/oauth/token", data)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()

    var result struct {
        AccessToken string `json:"access_token"`
        ExpiresIn   int    `json:"expires_in"`
    }
    json.NewDecoder(resp.Body).Decode(&result)

    return result.AccessToken, nil
}
```

**3. 密码模式(Resource Owner Password) - 已废弃,不推荐**

**4. 隐式模式(Implicit) - 已废弃,使用PKCE代替**

#### 2. OAuth2实现示例(Go)

使用`golang.org/x/oauth2`库实现第三方登录:

```go
package oauth

import (
    "context"
    "encoding/json"
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/github"
    "net/http"
)

var githubOAuthConfig = &oauth2.Config{
    ClientID:     "your-github-client-id",
    ClientSecret: "your-github-client-secret",
    RedirectURL:  "http://localhost:8080/callback",
    Scopes:       []string{"user:email"},
    Endpoint:     github.Endpoint,
}

// 步骤1: 跳转到GitHub授权页
func HandleGitHubLogin(w http.ResponseWriter, r *http.Request) {
    // 生成随机state防止CSRF攻击
    state := generateRandomState()
    saveStateToSession(r, state)

    url := githubOAuthConfig.AuthCodeURL(state, oauth2.AccessTypeOffline)
    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// 步骤2: GitHub回调,用授权码换Token
func HandleGitHubCallback(w http.ResponseWriter, r *http.Request) {
    // 验证state防止CSRF
    state := r.URL.Query().Get("state")
    if !verifyState(r, state) {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }

    code := r.URL.Query().Get("code")

    // 用授权码换取Access Token
    token, err := githubOAuthConfig.Exchange(context.Background(), code)
    if err != nil {
        http.Error(w, "Failed to exchange token", http.StatusInternalServerError)
        return
    }

    // 使用Token获取用户信息
    client := githubOAuthConfig.Client(context.Background(), token)
    resp, err := client.Get("https://api.github.com/user")
    if err != nil {
        http.Error(w, "Failed to get user info", http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()

    var githubUser struct {
        ID    int    `json:"id"`
        Login string `json:"login"`
        Email string `json:"email"`
    }
    json.NewDecoder(resp.Body).Decode(&githubUser)

    // 创建或更新本地用户
    user := userService.FindOrCreateByGitHub(githubUser.ID, githubUser.Login, githubUser.Email)

    // 生成本地JWT Token
    jwtToken, _ := auth.GenerateAccessToken(user.ID, user.Username, user.Role, user.Permissions)

    // 返回JWT给前端
    json.NewEncoder(w).Encode(map[string]string{
        "token": jwtToken,
    })
}
```

### 四、权限控制(RBAC vs ABAC)

#### 1. RBAC(基于角色的访问控制)

**模型:**
- **用户** → **角色** → **权限**
- 例: `张三` → `管理员` → `订单:删除`

**数据库设计:**

```sql
-- 用户表
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL
);

-- 角色表
CREATE TABLE roles (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL  -- admin, editor, viewer
);

-- 权限表
CREATE TABLE permissions (
    id VARCHAR(36) PRIMARY KEY,
    resource VARCHAR(50) NOT NULL,  -- order, user, product
    action VARCHAR(20) NOT NULL     -- create, read, update, delete
);

-- 用户-角色关联
CREATE TABLE user_roles (
    user_id VARCHAR(36),
    role_id VARCHAR(36),
    PRIMARY KEY (user_id, role_id)
);

-- 角色-权限关联
CREATE TABLE role_permissions (
    role_id VARCHAR(36),
    permission_id VARCHAR(36),
    PRIMARY KEY (role_id, permission_id)
);
```

**Go实现权限检查:**

```go
func HasPermission(ctx context.Context, resource, action string) bool {
    userID := ctx.Value("user_id").(string)

    // 查询用户的所有权限
    permissions := permissionService.GetUserPermissions(userID)

    for _, p := range permissions {
        if (p.Resource == resource || p.Resource == "*") &&
           (p.Action == action || p.Action == "*") {
            return true
        }
    }

    return false
}

// 使用示例
func DeleteOrder(ctx context.Context, orderID string) error {
    if !HasPermission(ctx, "order", "delete") {
        return errors.New("forbidden: insufficient permissions")
    }

    // 执行删除逻辑
    return orderRepo.Delete(orderID)
}
```

#### 2. ABAC(基于属性的访问控制)

更细粒度的权限控制,基于**用户属性、资源属性、环境属性**:

**策略示例:**

```json
{
  "effect": "allow",
  "principal": {
    "department": "sales",
    "level": "senior"
  },
  "action": "read",
  "resource": {
    "type": "order",
    "region": "cn-north"
  },
  "condition": {
    "time": "09:00-18:00",
    "ip_range": "10.0.0.0/8"
  }
}
```

**Go实现(使用Casbin):**

```go
package abac

import (
    "github.com/casbin/casbin/v2"
)

var enforcer *casbin.Enforcer

func init() {
    // 加载策略模型和规则
    enforcer, _ = casbin.NewEnforcer("model.conf", "policy.csv")
}

// model.conf (ABAC模型定义)
/*
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub_rule, obj, act

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = eval(p.sub_rule) && r.obj == p.obj && r.act == p.act
*/

// policy.csv (策略规则)
/*
p, r.sub.department == "sales" && r.sub.level >= 3, order, read
p, r.sub.role == "admin", *, *
*/

func Authorize(user User, resource string, action string) bool {
    // 构造请求
    sub := map[string]interface{}{
        "department": user.Department,
        "level":      user.Level,
        "role":       user.Role,
    }

    ok, _ := enforcer.Enforce(sub, resource, action)
    return ok
}
```

### 五、安全最佳实践

#### 1. Token安全

```go
// ✅ 使用HTTPS传输Token
// ✅ 使用HttpOnly Cookie防止XSS攻击
http.SetCookie(w, &http.Cookie{
    Name:     "refresh_token",
    Value:    refreshToken,
    HttpOnly: true,  // JS无法访问
    Secure:   true,  // 仅HTTPS传输
    SameSite: http.SameSiteStrictMode,  // 防CSRF
    MaxAge:   7 * 24 * 3600,
})

// ✅ Access Token短过期时间(15分钟)
// ✅ Refresh Token长过期时间(7天),存储在安全地方

// ✅ 敏感操作使用短期Token或二次验证
func DeleteAccount(ctx context.Context, password string) error {
    userID := ctx.Value("user_id").(string)

    // 二次验证密码
    if !userService.VerifyPassword(userID, password) {
        return errors.New("password verification failed")
    }

    return userService.DeleteAccount(userID)
}
```

#### 2. 防止重放攻击

```go
// 使用nonce(一次性随机数)
type Claims struct {
    UserID string `json:"user_id"`
    Nonce  string `json:"nonce"`  // 随机字符串
    jwt.RegisteredClaims
}

// 验证Token时检查nonce是否已使用
func ValidateToken(tokenString string) (*Claims, error) {
    claims, err := parseToken(tokenString)
    if err != nil {
        return nil, err
    }

    // 检查nonce是否在黑名单(Redis)
    if redis.Exists("used_nonce:" + claims.Nonce) {
        return nil, errors.New("token replay detected")
    }

    // 将nonce加入黑名单(过期时间=Token过期时间)
    ttl := time.Until(claims.ExpiresAt.Time)
    redis.Set("used_nonce:"+claims.Nonce, "1", ttl)

    return claims, nil
}
```

#### 3. API限流

```go
// 基于用户的限流(防止滥用)
func RateLimitMiddleware(next http.Handler) http.Handler {
    limiter := rate.NewLimiter(rate.Limit(10), 20) // 每秒10个请求,桶容量20

    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        userID := r.Context().Value("user_id").(string)

        if !limiter.Allow() {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    })
}
```

### 六、API网关统一认证

在微服务架构中,**API网关负责统一认证**,避免每个服务重复验证:

```
┌────────┐       ┌───────────────┐       ┌─────────────┐
│ Client │──────>│  API Gateway  │──────>│   Service   │
└────────┘       │  (验证JWT)     │       │  (信任网关) │
                 └───────────────┘       └─────────────┘
```

**Kong API网关配置JWT插件:**

```bash
# 为服务启用JWT插件
curl -X POST http://localhost:8001/services/order-service/plugins \
  --data "name=jwt" \
  --data "config.secret_is_base64=false"

# 创建Consumer并分配JWT凭证
curl -X POST http://localhost:8001/consumers \
  --data "username=mobile-app"

curl -X POST http://localhost:8001/consumers/mobile-app/jwt \
  --data "key=mobile-app-key" \
  --data "secret=your-secret-key"
```

**网关验证后传递用户信息给后端:**

```
# 网关在Header中注入用户信息
X-User-ID: 123
X-Username: john
X-Role: admin
```

### 总结

微服务安全认证的核心要点:

1. **JWT用于无状态认证** - 轻量、跨语言、易扩展
2. **OAuth2用于第三方授权** - 标准化、安全、广泛支持
3. **Access Token + Refresh Token** - 平衡安全性和用户体验
4. **权限控制** - RBAC满足大多数场景,ABAC用于复杂需求
5. **网关统一认证** - 减少服务复杂度,统一安全策略
6. **安全加固** - HTTPS、短过期时间、防重放、限流

关键原则:**最小权限、纵深防御、零信任架构**。
