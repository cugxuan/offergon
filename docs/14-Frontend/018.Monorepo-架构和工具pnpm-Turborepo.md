---
title: Monorepo 架构和工具（pnpm、Turborepo）
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: monorepo-architecture-tools-pnpm-turborepo
ref:
---

## 核心要点

**Monorepo** 是将多个项目放在单一代码仓库中管理的架构模式。**pnpm** 通过内容寻址和符号链接优化依赖安装,**Turborepo** 通过任务编排和增量构建加速 Monorepo 工作流。核心优势:代码共享、统一工具链、原子化提交,挑战在于构建性能和依赖管理。

---

## 详细回答

### 一、Monorepo vs Multirepo

#### 架构对比

**Multirepo(传统方案):**
```
github.com/company/web-admin      (独立仓库)
github.com/company/web-user       (独立仓库)
github.com/company/mobile-app     (独立仓库)
github.com/company/shared-utils   (独立仓库)
```

**Monorepo(单体仓库):**
```
github.com/company/monorepo
├── apps/
│   ├── web-admin/
│   ├── web-user/
│   └── mobile-app/
├── packages/
│   ├── shared-utils/
│   ├── ui-components/
│   └── eslint-config/
└── package.json
```

#### 优劣势对比

| 维度 | Monorepo | Multirepo |
|-----|----------|-----------|
| **代码共享** | 直接引用本地包,实时同步 | 需发布 npm 包,存在版本滞后 |
| **依赖管理** | 统一版本,避免依赖地狱 | 各仓库独立,可能版本冲突 |
| **原子化提交** | 跨项目修改一次提交 | 需多个 PR,存在中间态 |
| **CI/CD** | 需增量构建,复杂度高 | 独立构建,简单直接 |
| **权限控制** | 仓库级别,粒度粗 | 项目级别,粒度细 |
| **Git 操作** | 单次 clone 获取全部代码 | 只克隆需要的仓库 |

**适用场景:**
- **Monorepo:** 多项目紧密关联(如 Web/Mobile 共享组件库)、需要统一工具链
- **Multirepo:** 项目独立性强、团队跨地域分布、需要细粒度权限控制

---

### 二、pnpm:高性能包管理器

#### 核心原理

**传统 npm/yarn 的问题:**
```
node_modules/
├── lodash/               (项目 A 依赖)
│   └── node_modules/
│       └── chalk/        (lodash 依赖)
└── express/              (项目 A 依赖)
    └── node_modules/
        └── chalk/        (express 也依赖,重复安装!)
```

**pnpm 的解决方案:内容寻址存储 + 硬链接**

```bash
# 全局存储(~/.pnpm-store/)
~/.pnpm-store/v3/files/
├── 00/
│   └── 1a2b3c... (chalk@4.1.0 的实际文件)
└── 01/
    └── 4d5e6f... (lodash@4.17.21 的实际文件)

# 项目中的 node_modules(符号链接)
node_modules/
├── .pnpm/                        # 真实依赖存储
│   ├── chalk@4.1.0/
│   │   └── node_modules/
│   │       └── chalk/ -> ~/.pnpm-store/...
│   └── lodash@4.17.21/
│       └── node_modules/
│           └── lodash/ -> ~/.pnpm-store/...
├── chalk -> .pnpm/chalk@4.1.0/node_modules/chalk
└── lodash -> .pnpm/lodash@4.17.21/node_modules/lodash
```

**关键优势:**
1. **节省磁盘空间:** 同一版本包全局只存一份(节省 70%+空间)
2. **安装速度快:** 硬链接创建远快于文件复制
3. **严格的依赖隔离:** 只能访问 `package.json` 声明的依赖(避免幽灵依赖)

#### pnpm Workspace(Monorepo 支持)

**配置文件 `pnpm-workspace.yaml`:**

```yaml
packages:
  - 'apps/*'        # 应用目录
  - 'packages/*'    # 共享包目录
  - 'tools/*'       # 工具脚本
```

**根目录 `package.json`:**

```json
{
  "name": "monorepo-root",
  "private": true,
  "scripts": {
    "dev": "pnpm --filter \"./apps/*\" dev",
    "build": "pnpm -r --stream build",
    "test": "pnpm -r test"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "eslint": "^8.40.0"
  }
}
```

**子包引用(apps/web/package.json):**

```json
{
  "name": "@company/web",
  "dependencies": {
    "@company/ui-components": "workspace:*",  // 引用本地包
    "react": "^18.2.0"
  }
}
```

**关键命令:**

```bash
# 给所有子包安装依赖
pnpm install

# 给特定包安装依赖
pnpm --filter @company/web add lodash

# 运行所有包的 build 脚本(拓扑排序)
pnpm -r build

# 只运行 apps 目录下的 dev 脚本
pnpm --filter "./apps/*" dev

# 运行依赖了 ui-components 的包的测试
pnpm --filter ...@company/ui-components test
```

---

### 三、Turborepo:任务编排引擎

#### 核心能力

**问题:** Monorepo 中执行 `pnpm -r build` 会按拓扑顺序串行构建,耗时巨大

**Turborepo 的解决方案:**
1. **任务编排:** 分析依赖图,并行执行无依赖关系的任务
2. **增量构建:** 缓存任务输出,未变更的包跳过构建
3. **远程缓存:** 团队共享构建缓存,避免重复计算

#### 配置文件 `turbo.json`

```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],        // 依赖包先构建
      "outputs": ["dist/**", ".next/**"],
      "cache": true                    // 启用缓存
    },
    "test": {
      "dependsOn": ["build"],          // 本包构建完再测试
      "inputs": ["src/**", "tests/**"],
      "cache": true
    },
    "lint": {
      "cache": true,
      "outputs": []
    },
    "dev": {
      "cache": false,                  // 开发模式不缓存
      "persistent": true               // 长时运行任务
    }
  },
  "globalDependencies": [
    "tsconfig.json",                   // 这些文件变更使所有缓存失效
    ".eslintrc.js"
  ]
}
```

**依赖符号说明:**
- `^build`: 所有**依赖包**的 build 任务(拓扑依赖)
- `build`: 当前包自己的 build 任务

**执行流程示例:**

```bash
turbo run build

# 分析依赖图:
# shared-utils (无依赖) → ui-components (依赖 shared-utils) → web-admin (依赖 ui-components)

# 执行顺序:
# 1. 并行构建 shared-utils(缓存未命中,执行构建)
# 2. 构建 ui-components(缓存命中,跳过!)
# 3. 构建 web-admin(缓存未命中,执行构建)

# 输出:
>>> turbo run build
• Packages in scope: @company/shared-utils, @company/ui-components, @company/web-admin
• Running build in 3 packages
• Remote caching enabled

@company/shared-utils:build: cache miss, executing...
@company/ui-components:build: cache hit, replaying output...
@company/web-admin:build: cache miss, executing...

Tasks: 2 successful, 1 cached, 3 total
Cached: 1 task, 12.3s saved
```

#### 远程缓存(Remote Cache)

**配置 Vercel Remote Cache:**

```json
// turbo.json
{
  "remoteCache": {
    "signature": true  // 验证缓存完整性
  }
}
```

```bash
# 登录 Vercel
npx turbo login

# 链接项目
npx turbo link

# 之后的构建会自动上传/下载缓存
turbo run build
```

**自建缓存服务器:**

```bash
# 使用 turborepo-remote-cache
docker run -d \
  -p 3000:3000 \
  -e TURBO_TOKEN=your-secret-token \
  ducktors/turborepo-remote-cache

# 配置环境变量
export TURBO_API=http://localhost:3000
export TURBO_TOKEN=your-secret-token
```

---

### 四、实战项目结构

#### 完整的 Monorepo 示例

```
my-monorepo/
├── apps/
│   ├── web/                      # Next.js 主站
│   │   ├── package.json
│   │   ├── src/
│   │   └── tsconfig.json
│   ├── admin/                    # React 管理后台
│   └── mobile/                   # React Native 移动端
├── packages/
│   ├── ui/                       # 共享组件库
│   │   ├── package.json
│   │   ├── src/
│   │   │   ├── Button/
│   │   │   └── index.ts
│   │   └── tsconfig.json
│   ├── utils/                    # 工具函数
│   ├── eslint-config/            # 共享 ESLint 配置
│   │   ├── package.json
│   │   └── index.js
│   └── tsconfig/                 # 共享 TS 配置
│       ├── base.json
│       ├── react.json
│       └── package.json
├── tooling/
│   └── github/                   # GitHub Actions 工作流
├── pnpm-workspace.yaml
├── turbo.json
├── package.json
└── tsconfig.json
```

#### 共享配置包示例

**packages/tsconfig/package.json:**

```json
{
  "name": "@company/tsconfig",
  "version": "0.0.0",
  "files": ["base.json", "react.json"]
}
```

**packages/tsconfig/react.json:**

```json
{
  "extends": "./base.json",
  "compilerOptions": {
    "jsx": "react-jsx",
    "lib": ["DOM", "DOM.Iterable", "ESNext"]
  }
}
```

**apps/web/tsconfig.json:**

```json
{
  "extends": "@company/tsconfig/react.json",
  "include": ["src"],
  "compilerOptions": {
    "outDir": "dist"
  }
}
```

---

### 五、开发工作流最佳实践

#### 1. 快速启动多个应用

**根目录 package.json:**

```json
{
  "scripts": {
    "dev": "turbo run dev --parallel",
    "dev:web": "turbo run dev --filter=@company/web",
    "dev:admin": "turbo run dev --filter=@company/admin",
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "clean": "turbo run clean && rm -rf node_modules"
  }
}
```

```bash
# 同时启动所有应用
pnpm dev

# 只启动 web 应用(会自动启动依赖包的 dev)
pnpm dev:web
```

#### 2. 版本管理(Changesets)

```bash
# 安装 changesets
pnpm add -Dw @changesets/cli
npx changeset init
```

**工作流程:**

```bash
# 1. 开发完成后创建 changeset
npx changeset
# 选择变更的包和版本类型(major/minor/patch)

# 2. 生成 .changeset/xxx.md 文件(提交到 Git)
# 3. 发版时执行
npx changeset version  # 更新版本号和 CHANGELOG
npx changeset publish  # 发布到 npm
```

#### 3. 依赖版本统一管理

**根目录 package.json 中统一定义版本:**

```json
{
  "devDependencies": {
    "typescript": "^5.0.0",
    "react": "^18.2.0",
    "eslint": "^8.40.0"
  }
}
```

**子包继承(apps/web/package.json):**

```json
{
  "dependencies": {
    "react": "workspace:*"  // 使用根目录定义的版本
  }
}
```

---

### 六、性能优化技巧

#### 1. 精准的缓存配置

```json
{
  "pipeline": {
    "build": {
      "inputs": [
        "src/**",
        "!src/**/*.test.ts",  // 排除测试文件
        "package.json",
        "tsconfig.json"
      ],
      "outputs": ["dist/**"],
      "env": ["NODE_ENV"]      // 环境变量变化也会使缓存失效
    }
  }
}
```

#### 2. 按需构建(只构建变更的包)

```bash
# 基于 Git diff 的增量构建
turbo run build --filter=[HEAD^1]

# 构建受 ui 包影响的所有包
turbo run build --filter=...@company/ui
```

#### 3. 并行任务数量控制

```bash
# 限制并发任务数(CI 环境资源有限时)
turbo run build --concurrency=3
```

---

### 七、常见问题与解决方案

#### 1. 幽灵依赖(Phantom Dependencies)

**问题:** 代码中使用了未在 `package.json` 声明的依赖(通过依赖的依赖访问)

```typescript
// 错误:lodash 未在 package.json 中声明
import _ from 'lodash';  // 实际通过 express 的依赖访问
```

**pnpm 的解决方案:** 严格的依赖隔离,上述代码会报错

**修复方法:**

```bash
pnpm add lodash  # 显式声明依赖
```

#### 2. 循环依赖

**检测循环依赖:**

```bash
npx madge --circular --extensions ts,tsx apps/web/src
```

**解决方案:**
- 提取共享逻辑到独立包
- 使用依赖注入解耦

#### 3. 构建缓存失效频繁

**排查方法:**

```bash
# 查看缓存命中情况
turbo run build --dry-run
```

**常见原因:**
- `globalDependencies` 配置不当(如 `**` 匹配了 `node_modules`)
- 构建输出包含时间戳等不稳定内容
- Git 未忽略构建产物(`.gitignore` 配置不当)

---

### 八、Monorepo 工具对比

| 特性 | Turborepo | Nx | Lerna |
|-----|-----------|-------|-------|
| **任务编排** | 简单易用,配置少 | 功能强大,配置复杂 | 基础支持 |
| **缓存机制** | 本地+远程缓存 | 本地+远程缓存 | 无 |
| **增量构建** | 基于哈希的智能检测 | 基于依赖图分析 | 手动指定 |
| **学习曲线** | 低 | 中高 | 低 |
| **适用规模** | 小到大型项目 | 大型企业项目 | 小型项目 |
| **生态** | Vercel 支持 | Angular 官方推荐 | 传统工具 |

---

### 总结

**Monorepo 核心价值:**

```
统一工具链 → 减少配置重复 → 降低维护成本
代码共享 → 避免重复造轮子 → 提升开发效率
原子化提交 → 跨项目修改一致性 → 减少集成风险
```

**技术选型建议:**
- **小型团队(< 5 人):** pnpm workspace 即可,不需要 Turborepo
- **中型项目(5-20 人):** pnpm + Turborepo(本地缓存)
- **大型项目(20+ 人):** pnpm + Turborepo + 远程缓存 + Changesets

**实施步骤:**
1. **第一阶段:** 迁移到 pnpm workspace,提取共享包
2. **第二阶段:** 引入 Turborepo,配置任务编排
3. **第三阶段:** 启用远程缓存,优化 CI/CD
4. **第四阶段:** 完善自动化工具(Changesets、代码生成器等)

**关键指标:**
- 构建时间降低 60%+(增量构建 + 缓存)
- 磁盘空间节省 70%+(pnpm 内容寻址)
- 依赖安装速度提升 2-3 倍
