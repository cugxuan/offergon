---
title: Webpack 的 Loader 和 Plugin 的区别
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: webpack-loader-vs-plugin
ref:
---

## 核心要点

- **Loader**:文件转换器,处理单个文件从输入到输出的转换(如TS→JS、SCSS→CSS)
- **Plugin**:功能扩展器,介入整个构建流程,执行更广泛的任务(如打包优化、资源管理)
- **执行时机**:Loader在模块加载时执行,Plugin在整个构建生命周期的特定钩子执行
- **使用方式**:Loader配置在module.rules,Plugin实例化后配置在plugins数组

## 详细解答

### 一、概念对比

| 维度 | Loader | Plugin |
|------|--------|--------|
| **定义** | 文件转换器 | 功能扩展器 |
| **作用范围** | 单个文件/模块 | 整个构建流程 |
| **职责** | 将文件A转换为文件B | 在构建流程中执行各种任务 |
| **输入输出** | 接收源文件,返回转换后内容 | 通过钩子访问compilation/compiler对象 |
| **执行时机** | 模块解析阶段(loading) | 整个构建生命周期的特定时刻 |

### 二、Loader 详解

#### 2.1 核心特征

**本质:**一个导出函数的Node模块
```javascript
// 一个简单的Loader示例
module.exports = function(source) {
  // source是原始文件内容(字符串/Buffer)
  const transformedCode = transform(source);
  return transformedCode; // 返回转换后的代码
};
```

**执行特点:**
1. **链式调用**:多个Loader从右到左(从下到上)串行执行
2. **单一职责**:每个Loader只做一件事
3. **同步/异步**:支持同步返回或异步callback

#### 2.2 常见Loader及用途

```javascript
module.exports = {
  module: {
    rules: [
      // 1. babel-loader: 转译ES6+代码为ES5
      {
        test: /\.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },

      // 2. css-loader + style-loader: 处理CSS
      {
        test: /\.css$/,
        use: [
          'style-loader',  // 将CSS注入到DOM
          'css-loader'     // 解析CSS文件
        ]
      },

      // 3. ts-loader: 编译TypeScript
      {
        test: /\.ts$/,
        use: 'ts-loader'
      },

      // 4. file-loader / url-loader: 处理文件资源
      {
        test: /\.(png|jpg|gif)$/,
        type: 'asset/resource' // Webpack5内置
      },

      // 5. sass-loader: 编译Sass/Scss
      {
        test: /\.scss$/,
        use: [
          'style-loader',
          'css-loader',
          'sass-loader'  // 先执行,将scss编译为css
        ]
      }
    ]
  }
}
```

#### 2.3 Loader执行流程

```
原始文件(index.scss)
    ↓
sass-loader → 编译为CSS
    ↓
css-loader → 解析@import和url()
    ↓
style-loader → 注入到<style>标签
    ↓
最终输出到Bundle
```

**关键点:**
- 执行顺序:**从右到左,从下到上**
- 数据流:**上一个Loader的输出是下一个的输入**
- 类型:**source可以是字符串(源码)或Buffer(二进制文件)**

#### 2.4 自定义Loader示例

```javascript
// my-markdown-loader.js
const marked = require('marked');

module.exports = function(source) {
  // 1. 将Markdown转为HTML
  const html = marked.parse(source);

  // 2. 包装为JS模块导出
  return `export default ${JSON.stringify(html)}`;
};

// 使用
module.exports = {
  module: {
    rules: [
      {
        test: /\.md$/,
        use: './loaders/my-markdown-loader.js'
      }
    ]
  }
}
```

**异步Loader示例:**
```javascript
module.exports = function(source) {
  const callback = this.async(); // 获取异步回调

  someAsyncOperation(source, (err, result) => {
    if (err) return callback(err);
    callback(null, result); // callback(error, result, sourceMap, meta)
  });
};
```

### 三、Plugin 详解

#### 3.1 核心特征

**本质:**一个包含`apply`方法的JavaScript对象或类
```javascript
// 一个简单的Plugin示例
class MyPlugin {
  apply(compiler) {
    // compiler是Webpack实例,包含整个构建过程的信息
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      // compilation是本次编译的上下文
      console.log('Webpack构建即将输出文件...');

      // 可以修改输出资源
      compilation.assets['my-file.txt'] = {
        source: () => 'Hello Plugin',
        size: () => 12
      };

      callback();
    });
  }
}

module.exports = MyPlugin;
```

**执行特点:**
1. **事件驱动**:基于Tapable钩子系统
2. **全流程介入**:可以访问compilation、compiler、module等对象
3. **功能丰富**:文件输出、代码优化、环境注入等

#### 3.2 常见Plugin及用途

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const webpack = require('webpack');

module.exports = {
  plugins: [
    // 1. HtmlWebpackPlugin: 生成HTML文件并自动注入bundle
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
      minify: {
        collapseWhitespace: true
      }
    }),

    // 2. MiniCssExtractPlugin: 提取CSS到单独文件
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash:8].css'
    }),

    // 3. CleanWebpackPlugin: 清理输出目录
    new CleanWebpackPlugin(),

    // 4. DefinePlugin: 定义环境变量
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production')
    }),

    // 5. HotModuleReplacementPlugin: 热更新
    new webpack.HotModuleReplacementPlugin()
  ]
}
```

#### 3.3 Plugin生命周期钩子

**Compiler钩子(全局级别):**
```javascript
compiler.hooks.entryOption     // 读取entry配置
compiler.hooks.beforeRun       // 运行前
compiler.hooks.run             // 开始编译
compiler.hooks.compile         // 创建compilation前
compiler.hooks.make            // 完成编译
compiler.hooks.emit            // 输出文件到dist前(可修改)
compiler.hooks.afterEmit       // 输出文件后
compiler.hooks.done            // 全部完成
```

**Compilation钩子(编译级别):**
```javascript
compilation.hooks.buildModule        // 构建模块前
compilation.hooks.succeedModule      // 模块构建成功
compilation.hooks.finishModules      // 所有模块构建完成
compilation.hooks.seal               // 开始封装chunk
compilation.hooks.optimizeChunks     // 优化chunk
compilation.hooks.optimizeAssets     // 优化资源
```

#### 3.4 自定义Plugin示例

**示例1:生成文件清单**
```javascript
class FileListPlugin {
  apply(compiler) {
    compiler.hooks.emit.tap('FileListPlugin', (compilation) => {
      // 获取所有输出文件名
      const fileList = Object.keys(compilation.assets)
        .map(filename => `- ${filename}`)
        .join('\n');

      // 生成filelist.md
      compilation.assets['filelist.md'] = {
        source: () => `# 文件清单\n\n${fileList}`,
        size: () => fileList.length + 10
      };
    });
  }
}
```

**示例2:移除console.log**
```javascript
class RemoveConsolePlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('RemoveConsolePlugin', (compilation) => {
      compilation.hooks.optimizeChunkAssets.tapAsync(
        'RemoveConsolePlugin',
        (chunks, callback) => {
          chunks.forEach(chunk => {
            chunk.files.forEach(file => {
              if (file.endsWith('.js')) {
                const asset = compilation.assets[file];
                const source = asset.source();
                // 移除console.log
                const newSource = source.replace(
                  /console\.log\([^)]*\);?/g,
                  ''
                );
                compilation.assets[file] = {
                  source: () => newSource,
                  size: () => newSource.length
                };
              }
            });
          });
          callback();
        }
      );
    });
  }
}
```

### 四、核心区别总结

#### 4.1 职责维度

**Loader:**
```
专注于"翻译官"角色
输入:源文件内容(字符串/Buffer)
输出:转换后的内容(必须是JavaScript代码或AST)
场景:TypeScript → JavaScript、Sass → CSS、图片 → Base64
```

**Plugin:**
```
专注于"工程师"角色
输入:整个构建上下文(compiler/compilation对象)
输出:通过钩子修改构建流程/资源
场景:生成HTML、代码分割、环境变量注入、打包优化
```

#### 4.2 配置维度

```javascript
module.exports = {
  // Loader配置:在module.rules中
  module: {
    rules: [
      {
        test: /\.css$/,        // 匹配规则
        use: ['style-loader']  // 使用的loader
      }
    ]
  },

  // Plugin配置:在plugins数组中
  plugins: [
    new HtmlWebpackPlugin()  // 实例化插件
  ]
}
```

#### 4.3 实现维度

**Loader实现:**
```javascript
// 导出函数
module.exports = function(source) {
  return transformedSource;
};

// 或导出对象(pitch loader)
module.exports = {
  pitch: function(remainingRequest) {},
  normal: function(source) {}
};
```

**Plugin实现:**
```javascript
// 必须是包含apply方法的类或对象
class MyPlugin {
  constructor(options) {
    this.options = options;
  }

  apply(compiler) {
    compiler.hooks.emit.tap('MyPlugin', (compilation) => {
      // 插件逻辑
    });
  }
}
```

#### 4.4 能力对比

| 能力 | Loader | Plugin |
|------|--------|--------|
| 文件转换 | ✅ 核心功能 | ❌ 不适合 |
| 修改输出 | ❌ 只能返回转换结果 | ✅ 可修改compilation.assets |
| 访问配置 | ⚠️ 有限访问(通过options) | ✅ 完全访问compiler |
| 异步操作 | ✅ 支持(this.async) | ✅ 支持(tapAsync/tapPromise) |
| 监听事件 | ❌ 不支持 | ✅ 核心机制 |
| 代码优化 | ❌ 不涉及 | ✅ 在optimize钩子执行 |

### 五、协同工作示例

**场景:处理Sass文件并提取到单独CSS文件**

```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: [
          // 3. 提取CSS(使用Plugin提供的Loader)
          MiniCssExtractPlugin.loader,
          // 2. 解析CSS
          'css-loader',
          // 1. 编译Sass(最先执行)
          'sass-loader'
        ]
      }
    ]
  },
  plugins: [
    // Plugin负责创建单独的CSS文件
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash:8].css'
    })
  ]
}
```

**执行流程:**
```
1. sass-loader(Loader) → 将.scss编译为.css
2. css-loader(Loader) → 解析CSS中的@import和url()
3. MiniCssExtractPlugin.loader(Loader) → 提取CSS内容(由Plugin提供)
4. MiniCssExtractPlugin(Plugin) → 在emit钩子生成单独的.css文件
```

### 六、选择建议

**使用Loader的场景:**
- 需要转换文件内容(TS、JSX、Sass等)
- 文件格式转换(图片转Base64、Markdown转HTML)
- 代码编译(Babel、TypeScript)
- 预处理器(PostCSS、Less)

**使用Plugin的场景:**
- 打包优化(压缩、Tree Shaking)
- 资源管理(复制文件、生成HTML)
- 环境变量注入
- 自定义构建流程
- 性能分析和监控

**记忆口诀:**
```
Loader管转换,一个文件一个样
Plugin管流程,全局构建它最强
```

### 七、面试追问

**Q: 为什么Loader从右到左执行?**
A: 基于函数组合(compose)的设计思想,如`compose(f, g, h)(x) = f(g(h(x)))`,右边先执行。这符合Unix管道哲学,也让数据流向更清晰。

**Q: Plugin能替代Loader吗?**
A: 理论上可以(Plugin能力更强),但不应该。Loader专注文件转换,职责单一易维护;Plugin用于文件转换会破坏架构清晰性。

**Q: 一个Plugin可以在多个钩子注册吗?**
A: 可以。一个Plugin的`apply`方法中可以在多个compiler/compilation钩子注册回调,例如同时监听`emit`和`done`。

**Q: MiniCssExtractPlugin既是Plugin又提供Loader,如何理解?**
A: 这是协同设计:Loader负责在模块解析阶段"标记"CSS内容,Plugin在emit阶段"收集"这些标记的内容生成独立文件。体现了Loader和Plugin各司其职又协同工作的设计理念。

## 总结

**本质区别:**
- **Loader**是文件级的转换器,专注"源码A → 源码B"
- **Plugin**是流程级的扩展器,专注"在构建的X时刻做Y事"

**协同关系:**
- Loader处理模块内容,Plugin控制构建流程
- 两者互补,共同构成Webpack强大的扩展体系

理解这个区别对于合理配置Webpack、排查构建问题、开发自定义扩展都至关重要。
