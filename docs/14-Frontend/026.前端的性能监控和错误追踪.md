---
title: 前端的性能监控和错误追踪
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: frontend-performance-monitoring-error-tracking
ref:
---

## 核心要点

**性能监控**:利用Performance API采集核心指标(FCP/LCP/FID/CLS)、使用PerformanceObserver监听资源加载、通过自定义打点分析业务流程
**错误追踪**:捕获JS异常(window.onerror)、Promise错误(unhandledrejection)、资源加载失败,上报至Sentry等平台进行Source Map还原和分析
**实时上报**:采用sendBeacon/fetch上报数据,结合采样率和防抖策略控制流量,确保数据准确性和系统稳定性

---

## 详细回答

前端的性能监控和错误追踪是保障用户体验和系统稳定性的关键基础设施,我会从监控指标、技术实现和实践经验三个维度来回答。

### 一、性能监控体系

#### 1. 核心性能指标

现代前端性能监控主要关注Web Vitals指标:

- **FCP (First Contentful Paint)**: 首次内容绘制时间,衡量页面首次渲染任何文本、图像的时间点
- **LCP (Largest Contentful Paint)**: 最大内容绘制时间,反映主要内容加载完成的时间(理想值<2.5s)
- **FID (First Input Delay)**: 首次输入延迟,测量用户首次交互到浏览器响应的时间(理想值<100ms)
- **CLS (Cumulative Layout Shift)**: 累计布局偏移,量化页面视觉稳定性(理想值<0.1)
- **TTFB (Time to First Byte)**: 首字节时间,反映服务器响应速度

#### 2. 技术实现方案

**基于Performance API的数据采集:**

```javascript
// 1. 使用PerformanceObserver监听性能指标
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'largest-contentful-paint') {
      const lcpValue = entry.renderTime || entry.loadTime;
      reportMetric('LCP', lcpValue);
    }
  }
});

observer.observe({ entryTypes: ['largest-contentful-paint'] });

// 2. 监听FID(通过first-input类型)
new PerformanceObserver((list) => {
  const firstInput = list.getEntries()[0];
  reportMetric('FID', firstInput.processingStart - firstInput.startTime);
}).observe({ type: 'first-input', buffered: true });

// 3. 计算CLS
let clsScore = 0;
new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (!entry.hadRecentInput) {
      clsScore += entry.value;
      reportMetric('CLS', clsScore);
    }
  }
}).observe({ type: 'layout-shift', buffered: true });

// 4. 获取资源加载性能
const resources = performance.getEntriesByType('resource');
resources.forEach(resource => {
  reportMetric('resource', {
    name: resource.name,
    duration: resource.duration,
    size: resource.transferSize
  });
});
```

**自定义性能打点:**

```javascript
// 标记关键业务流程
performance.mark('user-login-start');
// ... 登录逻辑
performance.mark('user-login-end');

// 计算耗时
performance.measure('user-login', 'user-login-start', 'user-login-end');
const loginTime = performance.getEntriesByName('user-login')[0].duration;
```

### 二、错误追踪体系

#### 1. 错误类型覆盖

前端错误主要分为以下几类:

- **JS运行时错误**: 语法错误、引用错误、类型错误等
- **Promise未捕获错误**: async/await或Promise链中的异常
- **资源加载失败**: 图片、脚本、样式表加载失败
- **接口请求异常**: API调用失败或超时
- **框架特定错误**: React/Vue组件错误边界

#### 2. 错误捕获实现

```javascript
// 1. 全局JS错误捕获
window.onerror = function(message, source, lineno, colno, error) {
  reportError({
    type: 'jsError',
    message: message,
    stack: error?.stack,
    location: `${source}:${lineno}:${colno}`,
    userAgent: navigator.userAgent,
    url: window.location.href,
    timestamp: Date.now()
  });
  return true; // 阻止默认错误提示
};

// 2. Promise错误捕获
window.addEventListener('unhandledrejection', event => {
  reportError({
    type: 'promiseError',
    reason: event.reason,
    promise: event.promise,
    stack: event.reason?.stack
  });
});

// 3. 资源加载错误捕获(需要在捕获阶段监听)
window.addEventListener('error', event => {
  if (event.target !== window) {
    reportError({
      type: 'resourceError',
      tagName: event.target.tagName,
      src: event.target.src || event.target.href,
      outerHTML: event.target.outerHTML
    });
  }
}, true); // 捕获阶段

// 4. 接口请求拦截
axios.interceptors.response.use(
  response => response,
  error => {
    reportError({
      type: 'apiError',
      url: error.config?.url,
      method: error.config?.method,
      status: error.response?.status,
      message: error.message
    });
    return Promise.reject(error);
  }
);

// 5. React错误边界
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    reportError({
      type: 'reactError',
      error: error.toString(),
      componentStack: errorInfo.componentStack
    });
  }
  render() {
    return this.props.children;
  }
}
```

### 三、数据上报与分析

#### 1. 上报策略

```javascript
// 使用sendBeacon确保页面卸载时数据不丢失
function reportMetric(name, value) {
  const data = JSON.stringify({
    name,
    value,
    page: location.pathname,
    timestamp: Date.now(),
    userId: getCurrentUserId(),
    sessionId: getSessionId()
  });

  // 优先使用sendBeacon
  if (navigator.sendBeacon) {
    navigator.sendBeacon('/api/metrics', data);
  } else {
    // 降级方案
    fetch('/api/metrics', {
      method: 'POST',
      body: data,
      keepalive: true
    });
  }
}

// 批量上报优化
class MetricReporter {
  constructor() {
    this.queue = [];
    this.timer = null;
  }

  add(metric) {
    this.queue.push(metric);

    // 防抖:500ms内批量上报
    clearTimeout(this.timer);
    this.timer = setTimeout(() => this.flush(), 500);

    // 队列满时立即上报
    if (this.queue.length >= 10) {
      this.flush();
    }
  }

  flush() {
    if (this.queue.length === 0) return;

    navigator.sendBeacon('/api/metrics', JSON.stringify(this.queue));
    this.queue = [];
  }
}
```

#### 2. 采样与降噪

```javascript
// 采样率控制(生产环境仅采样10%)
const SAMPLE_RATE = process.env.NODE_ENV === 'production' ? 0.1 : 1;

function shouldReport() {
  return Math.random() < SAMPLE_RATE;
}

// 错误去重(相同错误5分钟内只上报一次)
const errorCache = new Map();

function reportError(error) {
  const errorKey = `${error.type}_${error.message}_${error.stack?.slice(0, 100)}`;
  const lastReportTime = errorCache.get(errorKey);

  if (lastReportTime && Date.now() - lastReportTime < 5 * 60 * 1000) {
    return; // 5分钟内重复错误不上报
  }

  errorCache.set(errorKey, Date.now());

  // 实际上报逻辑
  sendErrorToServer(error);
}
```

### 四、监控平台集成

#### 1. Sentry集成示例

```javascript
import * as Sentry from '@sentry/browser';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN',
  environment: process.env.NODE_ENV,
  release: `myapp@${process.env.VERSION}`,

  // Source Map配置(用于还原压缩代码)
  integrations: [
    new Sentry.BrowserTracing({
      tracingOrigins: ['https://api.example.com']
    })
  ],

  // 性能监控采样率
  tracesSampleRate: 0.1,

  // 错误过滤
  beforeSend(event, hint) {
    // 过滤第三方脚本错误
    if (event.exception?.values?.[0]?.stacktrace?.frames?.[0]?.filename?.includes('third-party')) {
      return null;
    }

    // 添加用户上下文
    event.user = {
      id: getCurrentUserId(),
      username: getCurrentUsername()
    };

    return event;
  }
});
```

#### 2. 自建监控系统

对于大型项目,可能需要自建监控平台:

- **数据收集层**: Nginx日志 + 前端SDK上报
- **数据处理层**: Kafka + Flink实时计算
- **存储层**: ClickHouse存储时序数据
- **展示层**: Grafana可视化大盘

### 五、实战经验总结

#### 1. 性能优化案例

在之前的项目中,通过LCP监控发现首屏渲染慢(4.5s),分析Performance资源瀑布图后发现:
- 主要问题是大尺寸Hero图片阻塞渲染
- 解决方案:使用`<link rel="preload">`预加载关键图片,并采用WebP格式+CDN加速
- 优化后LCP降至1.8s,用户跳出率下降25%

#### 2. 错误治理经验

某次上线后Sentry报错激增,通过错误堆栈发现是第三方支付SDK在iOS 12系统上的兼容性问题:
- 临时方案:错误边界降级展示备用支付方式
- 长期方案:联系SDK厂商修复,同时增加设备兼容性监控

#### 3. 监控告警机制

建立分级告警体系:
- **P0级**(严重):错误率>5% 或核心接口可用性<95% → 电话+短信通知
- **P1级**(重要):LCP>4s 或JS错误率>1% → 企业微信通知
- **P2级**(关注):性能劣化趋势 → 每日报表

### 六、最佳实践建议

1. **建立性能预算**: 设定各项指标阈值(如LCP<2.5s),在CI/CD中自动化检测
2. **Source Map安全**: 生产环境Source Map仅上传到Sentry,不对外暴露源码
3. **用户体验优先**: 监控代码本身不能影响性能,使用requestIdleCallback延迟非关键上报
4. **数据隐私合规**: 上报数据脱敏处理,避免泄露用户敏感信息
5. **跨团队协作**: 性能指标纳入OKR考核,前后端共同负责

通过完善的性能监控和错误追踪体系,我们可以及时发现并解决问题,持续优化用户体验,这是前端工程化中不可或缺的一环。
