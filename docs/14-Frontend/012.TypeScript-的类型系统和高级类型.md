---
title: TypeScript 的类型系统和高级类型
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: typescript-type-system-advanced-types
ref:
---

## 核心要点

**类型系统层次**: 基础类型 → 联合/交叉类型 → 类型别名/接口 → 泛型 → 条件类型
**结构化类型(Duck Typing)**: TS 基于结构而非名义判断兼容性,只要形状匹配即可赋值
**高级类型工具**: Partial、Required、Pick、Omit、Record 等内置工具类型简化类型操作
**类型守卫与窄化**: 通过 typeof、instanceof、in、自定义类型谓词实现类型收窄

---

## 详细解答

### 一、TypeScript 类型系统基础

TypeScript 采用**结构化类型系统**(Structural Type System),也称为"鸭子类型"(Duck Typing):如果两个类型的结构相同,就认为它们是兼容的,即使它们名字不同。

#### 1. 基础类型

```typescript
// 原始类型
let isDone: boolean = false;
let count: number = 42;
let name: string = "Alice";
let u: undefined = undefined;
let n: null = null;
let sym: symbol = Symbol("key");
let big: bigint = 100n;

// 特殊类型
let notSure: any = 4;           // 任意类型(绕过类型检查)
let value: unknown = "hello";   // 未知类型(类型安全的 any)
let unusable: void = undefined; // 无返回值
let unreachable: never;         // 永不存在的值

// 数组
let list1: number[] = [1, 2, 3];
let list2: Array<number> = [1, 2, 3];

// 元组(固定长度和类型的数组)
let tuple: [string, number] = ["hello", 42];

// 枚举
enum Color {
  Red,      // 默认值 0
  Green,    // 1
  Blue = 4  // 显式赋值
}
let c: Color = Color.Green;
```

#### 2. 对象类型

```typescript
// 接口定义
interface User {
  readonly id: number;      // 只读属性
  name: string;
  age?: number;             // 可选属性
  [propName: string]: any;  // 索引签名(允许任意额外属性)
}

// 类型别名
type Point = {
  x: number;
  y: number;
};

// 函数类型
interface SearchFunc {
  (source: string, subString: string): boolean;
}

// 使用示例
const user: User = {
  id: 1,
  name: "Alice",
  email: "alice@example.com"  // 索引签名允许
};
```

#### 3. 接口 vs 类型别名

| 特性 | Interface | Type |
|------|-----------|------|
| 扩展方式 | `extends` 继承 | `&` 交叉类型 |
| 声明合并 | ✅ 支持 | ❌ 不支持 |
| 联合类型 | ❌ 不支持 | ✅ 支持 |
| 映射类型 | ❌ 不支持 | ✅ 支持 |
| 性能 | 略优(有缓存机制) | 略慢(需重新计算) |

```typescript
// 接口继承
interface Animal {
  name: string;
}
interface Dog extends Animal {
  bark(): void;
}

// 类型别名交叉
type Animal = {
  name: string;
};
type Dog = Animal & {
  bark(): void;
};

// 声明合并(只有 interface 支持)
interface Window {
  title: string;
}
interface Window {
  version: number;
}
// 最终 Window 有 title 和 version 两个属性

// 联合类型(只有 type 支持)
type Status = "pending" | "success" | "error";
```

**选择建议**:
- 定义对象形状优先用 `interface`
- 需要联合类型、映射类型用 `type`
- 库的公共 API 用 `interface`(便于用户扩展)

---

### 二、高级类型详解

#### 1. 联合类型(Union Types)

表示值可以是多种类型之一:

```typescript
// 基础联合类型
type ID = number | string;

function printId(id: ID) {
  // 类型守卫:只有共同方法可直接调用
  console.log(id.toString());  // ✅ 所有类型都有 toString

  // 需要类型收窄
  if (typeof id === "string") {
    console.log(id.toUpperCase());  // ✅ 此处 id 类型收窄为 string
  } else {
    console.log(id.toFixed(2));     // ✅ 此处 id 类型收窄为 number
  }
}

// 字面量联合类型(常用于枚举式约束)
type Direction = "north" | "east" | "south" | "west";
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

function move(direction: Direction) {
  // direction 只能是四个值之一,TS 提供自动补全
}
```

#### 2. 交叉类型(Intersection Types)

将多个类型合并为一个类型:

```typescript
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

// 交叉类型:同时拥有两个接口的所有属性
type ColorfulCircle = Colorful & Circle;

const cc: ColorfulCircle = {
  color: "red",
  radius: 10
};

// 实战示例:Mixin 模式
type WithTimestamp = {
  timestamp: Date;
};

type WithAuthor = {
  author: string;
};

type BlogPost = {
  title: string;
  content: string;
} & WithTimestamp & WithAuthor;

const post: BlogPost = {
  title: "TS 高级类型",
  content: "...",
  timestamp: new Date(),
  author: "Alice"
};
```

#### 3. 类型别名与泛型结合

```typescript
// 泛型类型别名
type Container<T> = {
  value: T;
};

const numberContainer: Container<number> = { value: 42 };
const stringContainer: Container<string> = { value: "hello" };

// 泛型约束
type Lengthwise = { length: number };

function logLength<T extends Lengthwise>(arg: T): void {
  console.log(arg.length);  // ✅ T 保证有 length 属性
}

logLength("hello");        // ✅ string 有 length
logLength([1, 2, 3]);      // ✅ array 有 length
logLength({ length: 10 }); // ✅ 自定义对象
```

#### 4. 索引类型(Index Types)

```typescript
// 索引访问类型
interface Person {
  name: string;
  age: number;
  location: string;
}

type PersonName = Person["name"];  // string
type PersonKeys = Person["name" | "age"];  // string | number

// keyof 操作符:获取所有键的联合类型
type PersonKey = keyof Person;  // "name" | "age" | "location"

// 实战:类型安全的属性访问
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person: Person = {
  name: "Alice",
  age: 30,
  location: "NYC"
};

const name = getProperty(person, "name");     // 类型推断为 string
const age = getProperty(person, "age");       // 类型推断为 number
// getProperty(person, "invalid");            // ❌ 编译错误
```

#### 5. 映射类型(Mapped Types)

基于旧类型创建新类型:

```typescript
// 基础映射
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 使用示例
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type ReadonlyTodo = Readonly<Todo>;
// 等价于:
// {
//   readonly title: string;
//   readonly description: string;
//   readonly completed: boolean;
// }

type PartialTodo = Partial<Todo>;
// 等价于:
// {
//   title?: string;
//   description?: string;
//   completed?: boolean;
// }

// 高级映射:添加修饰符
type Mutable<T> = {
  -readonly [P in keyof T]: T[P];  // 移除 readonly
};

type Required<T> = {
  [P in keyof T]-?: T[P];  // 移除可选
};
```

#### 6. 条件类型(Conditional Types)

根据条件选择类型:

```typescript
// 基础语法: T extends U ? X : Y
type IsString<T> = T extends string ? true : false;

type A = IsString<string>;  // true
type B = IsString<number>;  // false

// 实战:Extract 和 Exclude
type Extract<T, U> = T extends U ? T : never;
type Exclude<T, U> = T extends U ? never : T;

type T1 = Extract<"a" | "b" | "c", "a" | "f">;  // "a"
type T2 = Exclude<"a" | "b" | "c", "a" | "f">;  // "b" | "c"

// infer 关键字:在条件类型中推断类型
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUserInfo() {
  return { name: "Alice", age: 30 };
}

type UserInfo = ReturnType<typeof getUserInfo>;
// 推断为: { name: string; age: number; }

// 递归条件类型:深度 Readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object
    ? DeepReadonly<T[P]>
    : T[P];
};

interface NestedObject {
  a: {
    b: {
      c: number;
    };
  };
}

type DeepReadonlyNested = DeepReadonly<NestedObject>;
// 所有嵌套层级的属性都变为 readonly
```

---

### 三、内置工具类型(Utility Types)

TypeScript 提供了丰富的内置工具类型:

#### 1. 对象属性操作

```typescript
interface Todo {
  title: string;
  description: string;
  completed: boolean;
  createdAt: Date;
}

// Partial<T>: 所有属性变为可选
type PartialTodo = Partial<Todo>;
function updateTodo(todo: Todo, fieldsToUpdate: PartialTodo) {
  return { ...todo, ...fieldsToUpdate };
}

// Required<T>: 所有属性变为必选
type RequiredTodo = Required<Partial<Todo>>;

// Readonly<T>: 所有属性变为只读
type ReadonlyTodo = Readonly<Todo>;

// Pick<T, K>: 从 T 中挑选部分属性
type TodoPreview = Pick<Todo, "title" | "completed">;
// { title: string; completed: boolean; }

// Omit<T, K>: 从 T 中排除部分属性
type TodoInfo = Omit<Todo, "completed" | "createdAt">;
// { title: string; description: string; }

// Record<K, T>: 创建键为 K、值为 T 的对象类型
type PageInfo = Record<"home" | "about" | "contact", { title: string }>;
// {
//   home: { title: string };
//   about: { title: string };
//   contact: { title: string };
// }
```

#### 2. 函数类型操作

```typescript
// ReturnType<T>: 获取函数返回类型
function createUser() {
  return { id: 1, name: "Alice" };
}
type User = ReturnType<typeof createUser>;  // { id: number; name: string; }

// Parameters<T>: 获取函数参数类型元组
function updateUser(id: number, name: string, age: number) {}
type UpdateUserParams = Parameters<typeof updateUser>;  // [number, string, number]

// ConstructorParameters<T>: 获取构造函数参数类型
class Person {
  constructor(public name: string, public age: number) {}
}
type PersonParams = ConstructorParameters<typeof Person>;  // [string, number]

// InstanceType<T>: 获取构造函数的实例类型
type PersonInstance = InstanceType<typeof Person>;  // Person
```

#### 3. 字符串操作类型(TS 4.1+)

```typescript
// Uppercase<T>: 转大写
type Greeting = "hello";
type LoudGreeting = Uppercase<Greeting>;  // "HELLO"

// Lowercase<T>: 转小写
type QuietGreeting = Lowercase<LoudGreeting>;  // "hello"

// Capitalize<T>: 首字母大写
type CapitalizedGreeting = Capitalize<Greeting>;  // "Hello"

// Uncapitalize<T>: 首字母小写
type UncapitalizedGreeting = Uncapitalize<"Hello">;  // "hello"

// 实战:自动生成 setter 方法名
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

interface Person {
  name: string;
  age: number;
}

type PersonGetters = Getters<Person>;
// {
//   getName: () => string;
//   getAge: () => number;
// }
```

---

### 四、类型守卫与类型窄化

类型守卫用于在运行时缩小类型范围:

#### 1. typeof 类型守卫

```typescript
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());  // value: string
  } else {
    console.log(value.toFixed(2));     // value: number
  }
}
```

#### 2. instanceof 类型守卫

```typescript
class Dog {
  bark() { console.log("Woof!"); }
}

class Cat {
  meow() { console.log("Meow!"); }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark();  // animal: Dog
  } else {
    animal.meow();  // animal: Cat
  }
}
```

#### 3. in 操作符类型守卫

```typescript
interface Fish {
  swim(): void;
}

interface Bird {
  fly(): void;
}

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim();  // animal: Fish
  } else {
    animal.fly();   // animal: Bird
  }
}
```

#### 4. 自定义类型谓词(Type Predicates)

```typescript
// 使用 is 关键字定义类型谓词
function isFish(animal: Fish | Bird): animal is Fish {
  return (animal as Fish).swim !== undefined;
}

function handleAnimal(animal: Fish | Bird) {
  if (isFish(animal)) {
    animal.swim();  // animal: Fish
  } else {
    animal.fly();   // animal: Bird
  }
}

// 实战:过滤数组中的 null/undefined
function isDefined<T>(value: T | null | undefined): value is T {
  return value !== null && value !== undefined;
}

const mixedArray = [1, null, 3, undefined, 5];
const numbers = mixedArray.filter(isDefined);  // 类型推断为 number[]
```

#### 5. 可辨识联合(Discriminated Unions)

```typescript
// 使用共同的字面量属性作为判别器
interface SuccessResponse {
  status: "success";
  data: any;
}

interface ErrorResponse {
  status: "error";
  error: string;
}

type ApiResponse = SuccessResponse | ErrorResponse;

function handleResponse(response: ApiResponse) {
  // 通过 status 属性自动收窄类型
  if (response.status === "success") {
    console.log(response.data);   // response: SuccessResponse
  } else {
    console.log(response.error);  // response: ErrorResponse
  }
}

// 实战:Redux Action
type Action =
  | { type: "INCREMENT"; payload: number }
  | { type: "DECREMENT"; payload: number }
  | { type: "RESET" };

function reducer(state: number, action: Action): number {
  switch (action.type) {
    case "INCREMENT":
      return state + action.payload;  // action 有 payload
    case "DECREMENT":
      return state - action.payload;  // action 有 payload
    case "RESET":
      return 0;                       // action 无 payload
    default:
      // 穷尽性检查(Exhaustiveness Checking)
      const _exhaustiveCheck: never = action;
      return state;
  }
}
```

---

### 五、高级实战技巧

#### 1. 类型体操:实现 DeepPartial

```typescript
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object
    ? DeepPartial<T[P]>
    : T[P];
};

interface Company {
  name: string;
  address: {
    street: string;
    city: string;
    country: {
      name: string;
      code: string;
    };
  };
}

type PartialCompany = DeepPartial<Company>;
// 所有嵌套属性都变为可选
```

#### 2. 函数重载精确类型

```typescript
// 函数重载:根据不同参数返回不同类型
function createElement(tag: "div"): HTMLDivElement;
function createElement(tag: "span"): HTMLSpanElement;
function createElement(tag: "canvas"): HTMLCanvasElement;
function createElement(tag: string): HTMLElement {
  return document.createElement(tag);
}

const div = createElement("div");      // HTMLDivElement
const span = createElement("span");    // HTMLSpanElement
const canvas = createElement("canvas"); // HTMLCanvasElement
```

#### 3. 模板字面量类型(TS 4.1+)

```typescript
// 类型级别的字符串操作
type EventName<T extends string> = `${T}Changed`;

type NameChanged = EventName<"name">;  // "nameChanged"

// 实战:生成 CSS 属性
type CSSProperty =
  | "color"
  | "background-color"
  | "font-size";

type CSSValue<T extends CSSProperty> = T extends "font-size"
  ? `${number}px`
  : string;

const color: CSSValue<"color"> = "red";          // ✅
const fontSize: CSSValue<"font-size"> = "16px";  // ✅
// const fontSize2: CSSValue<"font-size"> = "large"; // ❌ 类型错误
```

---

### 总结

TypeScript 的类型系统特点:
- **结构化类型**: 基于形状而非名称判断兼容性
- **渐进式增强**: 可以逐步添加类型,不强制全面覆盖
- **强大的类型推断**: 很多场景下无需显式标注类型
- **图灵完备**: 类型系统本身可以进行复杂计算

掌握类型系统的收益:
- **编译时错误检测**: 在运行前发现大部分类型错误
- **更好的 IDE 支持**: 自动补全、重构、跳转等功能更准确
- **代码即文档**: 类型定义清晰表达接口契约
- **重构安全性**: 修改代码时能快速发现影响范围
