---
title: TypeScript 的泛型和类型推断
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: typescript-generics-type-inference
ref:
---

## 核心要点

**泛型本质**: 类型的参数化,实现代码复用的同时保持类型安全
**泛型约束**: 通过 extends 限制类型参数范围,确保具备特定属性或方法
**类型推断机制**: TS 根据上下文自动推导类型,减少显式类型标注
**高级推断**: 条件类型中的 infer 关键字可从类型中提取子类型

---

## 详细解答

### 一、泛型基础

#### 1. 为什么需要泛型?

在不使用泛型的情况下,我们面临两难选择:

```typescript
// 方案1:使用 any,失去类型安全
function identity(arg: any): any {
  return arg;
}

const result = identity("hello");  // result 类型是 any,无法获得字符串方法提示

// 方案2:为每种类型写重载,代码冗余
function identityString(arg: string): string {
  return arg;
}

function identityNumber(arg: number): number {
  return arg;
}
// 需要为每种类型都写一遍...
```

**泛型的解决方案**:

```typescript
// 使用泛型:既保持类型安全,又实现代码复用
function identity<T>(arg: T): T {
  return arg;
}

const str = identity("hello");   // str 类型推断为 string
const num = identity(42);         // num 类型推断为 number
const obj = identity({ x: 10 }); // obj 类型推断为 { x: number }
```

#### 2. 泛型函数

```typescript
// 泛型函数定义
function getFirst<T>(arr: T[]): T | undefined {
  return arr[0];
}

// 使用方式1:显式指定类型参数
const first1 = getFirst<number>([1, 2, 3]);  // first1: number | undefined

// 使用方式2:类型推断(推荐)
const first2 = getFirst([1, 2, 3]);          // first2: number | undefined
const first3 = getFirst(["a", "b"]);         // first3: string | undefined

// 多个类型参数
function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value];
}

const p1 = pair("age", 30);          // [string, number]
const p2 = pair(1, { name: "Alice" }); // [number, { name: string }]
```

#### 3. 泛型接口

```typescript
// 泛型接口定义
interface Box<T> {
  value: T;
  getValue: () => T;
  setValue: (value: T) => void;
}

// 使用泛型接口
const numberBox: Box<number> = {
  value: 42,
  getValue() {
    return this.value;
  },
  setValue(value) {
    this.value = value;
  }
};

// 泛型接口可以描述函数类型
interface GenericIdentityFn<T> {
  (arg: T): T;
}

const myIdentity: GenericIdentityFn<number> = (arg) => arg;
```

#### 4. 泛型类

```typescript
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;

  constructor(zeroValue: T, addFn: (x: T, y: T) => T) {
    this.zeroValue = zeroValue;
    this.add = addFn;
  }
}

// 数字版本
const numberCalculator = new GenericNumber<number>(
  0,
  (x, y) => x + y
);
console.log(numberCalculator.add(5, 10));  // 15

// 字符串版本
const stringCalculator = new GenericNumber<string>(
  "",
  (x, y) => x + y
);
console.log(stringCalculator.add("Hello ", "World"));  // "Hello World"

// 实战:通用容器类
class Container<T> {
  private value: T;

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }

  map<U>(fn: (value: T) => U): Container<U> {
    return new Container(fn(this.value));
  }
}

const numContainer = new Container(42);
const strContainer = numContainer.map(n => n.toString());  // Container<string>
console.log(strContainer.getValue());  // "42"
```

---

### 二、泛型约束

#### 1. 基础约束

使用 `extends` 关键字限制类型参数:

```typescript
// 约束:T 必须有 length 属性
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);  // ✅ 编译器知道 T 有 length 属性
  return arg;
}

logLength("hello");              // ✅ string 有 length
logLength([1, 2, 3]);            // ✅ array 有 length
logLength({ length: 10, value: 3 }); // ✅ 自定义对象
// logLength(42);                // ❌ 编译错误:number 没有 length
```

#### 2. 使用类型参数进行约束

```typescript
// K 必须是 T 的键
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30, city: "NYC" };

getProperty(person, "name");     // ✅ 返回 string
getProperty(person, "age");      // ✅ 返回 number
// getProperty(person, "invalid"); // ❌ 编译错误

// 实战:类型安全的对象更新
function updateObject<T, K extends keyof T>(
  obj: T,
  key: K,
  value: T[K]
): T {
  return { ...obj, [key]: value };
}

const user = { id: 1, name: "Bob", age: 25 };
const updated = updateObject(user, "age", 26);  // ✅
// updateObject(user, "age", "26");             // ❌ 类型错误:应该是 number
```

#### 3. 构造函数约束

```typescript
// 约束 T 必须有构造函数
function create<T>(Constructor: new () => T): T {
  return new Constructor();
}

class Person {
  name: string = "";
}

const person = create(Person);  // person: Person

// 带参数的构造函数约束
function createInstance<T>(
  Constructor: new (...args: any[]) => T,
  ...args: any[]
): T {
  return new Constructor(...args);
}

class Animal {
  constructor(public name: string) {}
}

const dog = createInstance(Animal, "Buddy");  // dog: Animal
```

#### 4. 多重约束

```typescript
// 使用交叉类型实现多重约束
interface Nameable {
  name: string;
}

interface Ageable {
  age: number;
}

function printInfo<T extends Nameable & Ageable>(obj: T): void {
  console.log(`${obj.name} is ${obj.age} years old`);
}

printInfo({ name: "Alice", age: 30 });              // ✅
printInfo({ name: "Bob", age: 25, city: "NYC" });   // ✅ 额外属性也可以
// printInfo({ name: "Charlie" });                   // ❌ 缺少 age
```

---

### 三、类型推断详解

#### 1. 基础类型推断

TypeScript 会根据赋值自动推断类型:

```typescript
// 变量初始化推断
let x = 3;         // x: number
let y = "hello";   // y: string
let z = [1, 2, 3]; // z: number[]

// 最佳通用类型(Best Common Type)推断
let arr = [1, 2, "hello"];  // arr: (string | number)[]
let mixed = [1, null];       // mixed: (number | null)[]

// 上下文类型推断(Contextual Typing)
window.onmousedown = function(event) {
  console.log(event.button);  // event 自动推断为 MouseEvent
};
```

#### 2. 函数返回值推断

```typescript
// 自动推断返回类型
function add(a: number, b: number) {
  return a + b;  // 推断返回类型为 number
}

// 复杂返回类型推断
function getUserInfo(id: number) {
  return {
    id,
    name: "Alice",
    email: "alice@example.com"
  };
}
// 推断返回类型为: { id: number; name: string; email: string; }

type UserInfo = ReturnType<typeof getUserInfo>;

// 条件推断
function process(value: string | number) {
  if (typeof value === "string") {
    return value.length;  // 推断为 number
  }
  return value * 2;       // 推断为 number
}
// 整体推断返回类型为 number
```

#### 3. 泛型推断

```typescript
// 从参数推断类型参数
function toArray<T>(value: T): T[] {
  return [value];
}

const arr1 = toArray(42);      // T 推断为 number,返回 number[]
const arr2 = toArray("hello"); // T 推断为 string,返回 string[]

// 从多个参数推断
function map<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

const numbers = [1, 2, 3];
const strings = map(numbers, n => n.toString());
// T 推断为 number,U 推断为 string,返回 string[]

// 部分推断
function merge<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const merged = merge({ name: "Alice" }, { age: 30 });
// T 推断为 { name: string },U 推断为 { age: number }
// 返回类型: { name: string } & { age: number }
```

#### 4. 上下文推断

```typescript
// 从函数参数推断
const numbers = [1, 2, 3];

// forEach 的回调函数参数类型自动推断
numbers.forEach(num => {
  console.log(num.toFixed(2));  // num 推断为 number
});

// Promise 链式调用推断
fetch("/api/user")
  .then(res => res.json())       // res 推断为 Response
  .then(data => console.log(data)); // data 推断为 any(需要手动标注)

// 正确做法:显式标注泛型
interface User {
  id: number;
  name: string;
}

fetch("/api/user")
  .then(res => res.json())
  .then((data: User) => console.log(data.name)); // data: User
```

---

### 四、高级泛型技巧

#### 1. 默认类型参数

```typescript
// 为泛型参数设置默认值
interface Container<T = string> {
  value: T;
}

const strContainer: Container = { value: "hello" };     // T 默认为 string
const numContainer: Container<number> = { value: 42 };  // 显式指定为 number

// 实战:API 响应类型
interface ApiResponse<T = any> {
  code: number;
  message: string;
  data: T;
}

const response1: ApiResponse = {
  code: 200,
  message: "success",
  data: { id: 1 }  // data 类型为 any
};

interface User {
  id: number;
  name: string;
}

const response2: ApiResponse<User> = {
  code: 200,
  message: "success",
  data: { id: 1, name: "Alice" }  // data 类型为 User
};
```

#### 2. 条件类型中的 infer

`infer` 关键字用于在条件类型中提取类型:

```typescript
// 提取函数返回类型
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUserName(): string {
  return "Alice";
}

type UserName = MyReturnType<typeof getUserName>;  // string

// 提取 Promise 的值类型
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

type A = UnwrapPromise<Promise<string>>;  // string
type B = UnwrapPromise<number>;           // number

// 提取数组元素类型
type ArrayElement<T> = T extends (infer E)[] ? E : T;

type C = ArrayElement<number[]>;     // number
type D = ArrayElement<string>;       // string

// 提取函数第一个参数类型
type FirstParameter<T> = T extends (first: infer F, ...args: any[]) => any
  ? F
  : never;

function foo(x: number, y: string): void {}

type FirstParam = FirstParameter<typeof foo>;  // number

// 递归提取:深度展开嵌套 Promise
type DeepUnwrapPromise<T> = T extends Promise<infer U>
  ? DeepUnwrapPromise<U>
  : T;

type E = DeepUnwrapPromise<Promise<Promise<Promise<string>>>>;  // string
```

#### 3. 分布式条件类型

当条件类型作用于联合类型时,会自动分布:

```typescript
// 分布式行为
type ToArray<T> = T extends any ? T[] : never;

type Result = ToArray<string | number>;
// 分布过程:
// ToArray<string> | ToArray<number>
// string[] | number[]

// 实战:过滤掉 null 和 undefined
type NonNullable<T> = T extends null | undefined ? never : T;

type A = NonNullable<string | null | undefined>;  // string
type B = NonNullable<number | null>;              // number

// 阻止分布:使用元组包裹
type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;

type Result2 = ToArrayNonDist<string | number>;  // (string | number)[]
```

#### 4. 映射类型与泛型结合

```typescript
// 将所有属性变为可选并添加 _changed 后缀
type OptionalWithSuffix<T> = {
  [K in keyof T as `${string & K}_changed`]?: T[K];
};

interface User {
  name: string;
  age: number;
}

type ChangedUser = OptionalWithSuffix<User>;
// {
//   name_changed?: string;
//   age_changed?: number;
// }

// 根据属性类型过滤
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K];
};

interface Person {
  name: string;
  age: number;
  isActive: boolean;
  salary: number;
}

type StringProps = PickByType<Person, string>;  // { name: string }
type NumberProps = PickByType<Person, number>;  // { age: number; salary: number }
```

---

### 五、实战案例

#### 1. 类型安全的事件监听器

```typescript
// 定义事件映射
interface EventMap {
  click: MouseEvent;
  keydown: KeyboardEvent;
  custom: { detail: string };
}

// 泛型事件监听器
class TypedEventEmitter<T extends Record<string, any>> {
  private listeners: {
    [K in keyof T]?: Array<(event: T[K]) => void>;
  } = {};

  on<K extends keyof T>(eventName: K, listener: (event: T[K]) => void): void {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    this.listeners[eventName]!.push(listener);
  }

  emit<K extends keyof T>(eventName: K, event: T[K]): void {
    const eventListeners = this.listeners[eventName];
    if (eventListeners) {
      eventListeners.forEach(listener => listener(event));
    }
  }
}

// 使用
const emitter = new TypedEventEmitter<EventMap>();

emitter.on("click", (e) => {
  console.log(e.clientX);  // e 类型推断为 MouseEvent
});

emitter.on("custom", (e) => {
  console.log(e.detail);   // e 类型推断为 { detail: string }
});

// emitter.on("invalid", (e) => {});  // ❌ 编译错误
```

#### 2. 类型安全的 API 客户端

```typescript
// 定义 API 端点类型
interface ApiEndpoints {
  "/users": {
    GET: { response: User[] };
    POST: { body: { name: string }; response: User };
  };
  "/users/:id": {
    GET: { params: { id: string }; response: User };
    DELETE: { params: { id: string }; response: void };
  };
}

interface User {
  id: number;
  name: string;
}

// 泛型 API 客户端
class ApiClient<T extends Record<string, any>> {
  async request<
    Path extends keyof T,
    Method extends keyof T[Path]
  >(
    path: Path,
    method: Method,
    options?: T[Path][Method] extends { body: infer B }
      ? { body: B }
      : T[Path][Method] extends { params: infer P }
      ? { params: P }
      : {}
  ): Promise<
    T[Path][Method] extends { response: infer R } ? R : never
  > {
    // 实现省略
    return {} as any;
  }
}

// 使用
const api = new ApiClient<ApiEndpoints>();

// 类型完全推断
const users = await api.request("/users", "GET");  // users: User[]

const newUser = await api.request("/users", "POST", {
  body: { name: "Alice" }
});  // newUser: User

const user = await api.request("/users/:id", "GET", {
  params: { id: "123" }
});  // user: User

// await api.request("/users", "POST", { body: { age: 30 } }); // ❌ 类型错误
```

#### 3. 类型安全的状态管理

```typescript
// 定义状态和 Action 类型
type State = {
  count: number;
  user: { name: string; age: number } | null;
};

type Actions = {
  increment: { amount: number };
  decrement: { amount: number };
  setUser: { user: State["user"] };
  reset: {};
};

// 泛型 Reducer
type Reducer<S, A extends Record<string, any>> = {
  [K in keyof A]: (state: S, payload: A[K]) => S;
};

// 实现 Reducer
const reducers: Reducer<State, Actions> = {
  increment: (state, payload) => ({
    ...state,
    count: state.count + payload.amount  // payload 类型推断正确
  }),

  decrement: (state, payload) => ({
    ...state,
    count: state.count - payload.amount
  }),

  setUser: (state, payload) => ({
    ...state,
    user: payload.user
  }),

  reset: (state, payload) => ({
    count: 0,
    user: null
  })
};

// 类型安全的 dispatch
function dispatch<K extends keyof Actions>(
  type: K,
  payload: Actions[K]
): void {
  // 实现省略
}

dispatch("increment", { amount: 5 });  // ✅
dispatch("setUser", { user: { name: "Alice", age: 30 } });  // ✅
// dispatch("increment", { amount: "5" });  // ❌ 类型错误
```

---

### 总结

**泛型的核心价值**:
- **类型安全**: 在编译时捕获错误,而不是运行时
- **代码复用**: 一份代码支持多种类型
- **类型推断**: 减少显式类型标注,提升开发体验

**类型推断的优势**:
- **减少样板代码**: 很多场景下无需手动标注类型
- **自适应**: 类型会随着代码演化自动调整
- **更好的 IDE 支持**: 自动补全更准确

**最佳实践**:
1. **优先依赖类型推断**: 只在必要时显式标注类型
2. **合理使用泛型约束**: 确保类型参数满足特定条件
3. **避免过度泛型化**: 不要为了泛型而泛型,保持代码可读性
4. **善用工具类型**: 利用内置工具类型简化复杂类型操作
