---
title: 前端的单元测试（Jest、Vitest）
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: frontend-unit-testing-jest-vitest
ref:
---

## 核心要点

- **目标**:验证单个函数/组件的正确性,快速定位问题
- **主流工具**:Jest(生态最全)、Vitest(更快、更现代)
- **测试内容**:函数逻辑、组件渲染、用户交互、边界条件
- **最佳实践**:TDD、高覆盖率、Mock 外部依赖、可读性优先

---

## 详细回答

### 一、什么是单元测试?

单元测试是对软件中**最小可测试单元**进行验证的测试,在前端通常是:
- 工具函数
- React/Vue 组件
- Hooks/Composables
- API 调用逻辑

**核心价值**:
```
快速反馈 → 提前发现 Bug → 安全重构 → 提升代码质量 → 降低维护成本
```

### 二、Jest vs Vitest 对比

| 特性 | Jest | Vitest |
|-----|------|--------|
| 性能 | 较慢(串行执行) | 极快(Vite 驱动,并行执行) |
| 配置 | 复杂(需要 Babel/TS) | 简单(复用 Vite 配置) |
| HMR | 不支持 | 支持(watch 模式快速) |
| ESM 支持 | 需要额外配置 | 原生支持 |
| 生态 | 成熟,插件丰富 | 新兴,基本兼容 Jest API |
| 社区 | 庞大 | 快速增长 |
| 适用场景 | 成熟项目,广泛支持 | 新项目,Vite 项目 |

**选择建议**:
- ✅ 新项目 + Vite → **Vitest**
- ✅ 老项目 + Webpack → **Jest**
- ✅ 追求性能 → **Vitest**
- ✅ 需要稳定生态 → **Jest**

### 三、Jest 完整实战

#### 1. 安装与配置

```bash
# 安装 Jest
npm install --save-dev jest

# React 项目额外安装
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event

# TypeScript 支持
npm install --save-dev @types/jest ts-jest
```

```javascript
// jest.config.js
module.exports = {
  // 测试环境
  testEnvironment: 'jsdom', // 浏览器环境(DOM API)

  // 文件匹配规则
  testMatch: [
    '**/__tests__/**/*.{js,jsx,ts,tsx}',
    '**/*.{spec,test}.{js,jsx,ts,tsx}',
  ],

  // 转换配置(处理 TS/JSX)
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
    '^.+\\.(js|jsx)$': 'babel-jest',
  },

  // 模块映射(处理路径别名)
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js',
  },

  // 覆盖率配置
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
  ],

  // 测试前运行(设置全局变量/Mock)
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],

  // 清除 Mock
  clearMocks: true,

  // 覆盖率阈值
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
};
```

```javascript
// jest.setup.js
import '@testing-library/jest-dom';

// Mock 全局对象
global.matchMedia = global.matchMedia || function() {
  return {
    addListener: jest.fn(),
    removeListener: jest.fn(),
  };
};

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.localStorage = localStorageMock;
```

#### 2. 基础测试示例

```typescript
// src/utils/math.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function divide(a: number, b: number): number {
  if (b === 0) throw new Error('Cannot divide by zero');
  return a / b;
}
```

```typescript
// src/utils/math.test.ts
import { add, divide } from './math';

describe('Math utils', () => {
  // 基础测试
  test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
  });

  // 多个断言
  test('divide function', () => {
    expect(divide(6, 2)).toBe(3);
    expect(divide(10, 5)).toBe(2);
  });

  // 异常测试
  test('divide by zero throws error', () => {
    expect(() => divide(10, 0)).toThrow('Cannot divide by zero');
  });

  // 分组测试
  describe('add function', () => {
    test('handles positive numbers', () => {
      expect(add(2, 3)).toBe(5);
    });

    test('handles negative numbers', () => {
      expect(add(-1, -2)).toBe(-3);
    });

    test('handles zero', () => {
      expect(add(0, 0)).toBe(0);
    });
  });
});
```

#### 3. React 组件测试

```tsx
// src/components/Button.tsx
import React from 'react';

interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

export function Button({ children, onClick, disabled, variant = 'primary' }: ButtonProps) {
  return (
    <button
      className={`btn btn--${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}
```

```tsx
// src/components/Button.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button Component', () => {
  // 渲染测试
  test('renders with children', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button')).toHaveTextContent('Click me');
  });

  // Props 测试
  test('applies variant class', () => {
    render(<Button variant="secondary">Test</Button>);
    expect(screen.getByRole('button')).toHaveClass('btn--secondary');
  });

  // 交互测试
  test('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click</Button>);

    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  // 状态测试
  test('does not call onClick when disabled', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick} disabled>Click</Button>);

    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).not.toHaveBeenCalled();
  });

  // 快照测试
  test('matches snapshot', () => {
    const { container } = render(<Button>Test</Button>);
    expect(container.firstChild).toMatchSnapshot();
  });
});
```

#### 4. 异步测试

```typescript
// src/api/user.ts
export async function fetchUser(id: number) {
  const response = await fetch(`/api/users/${id}`);
  if (!response.ok) throw new Error('User not found');
  return response.json();
}
```

```typescript
// src/api/user.test.ts
import { fetchUser } from './user';

// Mock fetch
global.fetch = jest.fn();

describe('fetchUser', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('fetches user successfully', async () => {
    const mockUser = { id: 1, name: 'John' };
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => mockUser,
    });

    const user = await fetchUser(1);
    expect(user).toEqual(mockUser);
    expect(fetch).toHaveBeenCalledWith('/api/users/1');
  });

  test('throws error when user not found', async () => {
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: false,
    });

    await expect(fetchUser(999)).rejects.toThrow('User not found');
  });

  // 使用 waitFor
  test('with waitFor', async () => {
    const { waitFor } = require('@testing-library/react');
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => ({ id: 1 }),
    });

    await waitFor(() => {
      expect(fetch).toHaveBeenCalled();
    });
  });
});
```

#### 5. Hooks 测试

```typescript
// src/hooks/useCounter.ts
import { useState, useCallback } from 'react';

export function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() => setCount((c) => c + 1), []);
  const decrement = useCallback(() => setCount((c) => c - 1), []);
  const reset = useCallback(() => setCount(initialValue), [initialValue]);

  return { count, increment, decrement, reset };
}
```

```typescript
// src/hooks/useCounter.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  test('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  test('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10));
    expect(result.current.count).toBe(10);
  });

  test('increments count', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  test('decrements count', () => {
    const { result } = renderHook(() => useCounter(5));

    act(() => {
      result.current.decrement();
    });

    expect(result.current.count).toBe(4);
  });

  test('resets to initial value', () => {
    const { result } = renderHook(() => useCounter(10));

    act(() => {
      result.current.increment();
      result.current.increment();
    });
    expect(result.current.count).toBe(12);

    act(() => {
      result.current.reset();
    });
    expect(result.current.count).toBe(10);
  });
});
```

#### 6. Mock 技巧

```typescript
// Mock 模块
jest.mock('./api/user', () => ({
  fetchUser: jest.fn(),
}));

// Mock 特定函数
import { fetchUser } from './api/user';
(fetchUser as jest.Mock).mockResolvedValue({ id: 1, name: 'John' });

// Mock 默认导出
jest.mock('./utils', () => ({
  default: jest.fn(),
  helper: jest.fn(),
}));

// 部分 Mock
jest.mock('./utils', () => ({
  ...jest.requireActual('./utils'),
  specificFunction: jest.fn(),
}));

// Mock 实现
const mockFn = jest.fn((x) => x * 2);
mockFn(5); // 返回 10

// Mock 返回值
mockFn.mockReturnValue(42);
mockFn.mockReturnValueOnce(1).mockReturnValueOnce(2);

// Mock Promise
mockFn.mockResolvedValue({ data: 'success' });
mockFn.mockRejectedValue(new Error('Failed'));

// 验证调用
expect(mockFn).toHaveBeenCalled();
expect(mockFn).toHaveBeenCalledTimes(2);
expect(mockFn).toHaveBeenCalledWith(1, 2, 3);
expect(mockFn).toHaveBeenLastCalledWith(4, 5);
```

### 四、Vitest 完整实战

#### 1. 安装与配置

```bash
# 安装 Vitest
npm install --save-dev vitest

# React 项目
npm install --save-dev @testing-library/react @testing-library/user-event jsdom

# Vue 项目
npm install --save-dev @vue/test-utils @vitejs/plugin-vue
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    // 测试环境
    environment: 'jsdom',

    // 全局 API
    globals: true,

    // Setup 文件
    setupFiles: ['./vitest.setup.ts'],

    // 覆盖率
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.{ts,tsx}'],
      exclude: ['**/*.test.{ts,tsx}', '**/*.stories.{ts,tsx}'],
    },

    // 并发执行
    threads: true,

    // UI 模式
    ui: true,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

```typescript
// vitest.setup.ts
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import matchers from '@testing-library/jest-dom/matchers';

// 扩展 expect
expect.extend(matchers);

// 每个测试后清理
afterEach(() => {
  cleanup();
});
```

#### 2. Vitest 特色功能

```typescript
// src/utils/math.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';

describe('Vitest Features', () => {
  // 并发测试(更快)
  it.concurrent('test 1', async () => {
    await new Promise((resolve) => setTimeout(resolve, 100));
    expect(1 + 1).toBe(2);
  });

  it.concurrent('test 2', async () => {
    await new Promise((resolve) => setTimeout(resolve, 100));
    expect(2 + 2).toBe(4);
  });

  // 条件测试
  it.skipIf(process.env.CI)('skips in CI', () => {
    // 本地执行,CI 跳过
  });

  it.runIf(process.platform === 'darwin')('only on macOS', () => {
    // 仅在 macOS 运行
  });

  // 测试超时
  it('with timeout', async () => {
    await new Promise((resolve) => setTimeout(resolve, 100));
  }, 1000); // 1秒超时

  // 快照
  it('matches snapshot', () => {
    const data = { name: 'John', age: 30 };
    expect(data).toMatchSnapshot();
  });

  // Inline 快照
  it('inline snapshot', () => {
    expect({ foo: 'bar' }).toMatchInlineSnapshot(`
      {
        "foo": "bar",
      }
    `);
  });
});
```

#### 3. Vi Mock (替代 Jest Mock)

```typescript
import { vi } from 'vitest';

// Mock 函数
const mockFn = vi.fn();
mockFn.mockReturnValue(42);
mockFn.mockResolvedValue({ data: 'success' });

// Mock 模块
vi.mock('./api/user', () => ({
  fetchUser: vi.fn(),
}));

// Mock 时间
vi.useFakeTimers();
vi.setSystemTime(new Date('2024-01-01'));
setTimeout(() => console.log('hello'), 1000);
vi.advanceTimersByTime(1000); // 快进
vi.useRealTimers();

// Spy
const obj = { method: () => 'original' };
const spy = vi.spyOn(obj, 'method');
spy.mockReturnValue('mocked');
```

### 五、测试最佳实践

#### 1. AAA 模式(Arrange-Act-Assert)

```typescript
test('user login', () => {
  // Arrange: 准备数据
  const username = 'testuser';
  const password = 'password123';

  // Act: 执行操作
  const result = login(username, password);

  // Assert: 验证结果
  expect(result.success).toBe(true);
  expect(result.user.username).toBe(username);
});
```

#### 2. 测试命名规范

```typescript
// ✅ 好的命名
test('shows error message when email is invalid', () => {});
test('disables submit button when form is invalid', () => {});
test('calls onSave with correct data when form is submitted', () => {});

// ❌ 不好的命名
test('test1', () => {});
test('it works', () => {});
test('test button', () => {});
```

#### 3. 避免实现细节测试

```typescript
// ❌ 测试实现细节(容易被重构破坏)
test('useState is called', () => {
  const spy = jest.spyOn(React, 'useState');
  render(<Counter />);
  expect(spy).toHaveBeenCalled();
});

// ✅ 测试行为
test('increments counter when button is clicked', () => {
  render(<Counter />);
  const button = screen.getByRole('button', { name: /increment/i });

  expect(screen.getByText('Count: 0')).toBeInTheDocument();
  fireEvent.click(button);
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

#### 4. 使用 data-testid 适度

```tsx
// ✅ 优先使用语义化查询
screen.getByRole('button', { name: /submit/i });
screen.getByLabelText('Email');
screen.getByText('Welcome');

// ⚠️ 语义化查询困难时才用 testid
<div data-testid="complex-component">...</div>
screen.getByTestId('complex-component');
```

#### 5. 测试边界条件

```typescript
describe('formatPrice', () => {
  test('handles normal prices', () => {
    expect(formatPrice(99.99)).toBe('$99.99');
  });

  // 边界条件
  test('handles zero', () => {
    expect(formatPrice(0)).toBe('$0.00');
  });

  test('handles negative numbers', () => {
    expect(formatPrice(-10)).toBe('-$10.00');
  });

  test('handles very large numbers', () => {
    expect(formatPrice(9999999.99)).toBe('$9,999,999.99');
  });

  test('handles invalid input', () => {
    expect(() => formatPrice(NaN)).toThrow();
  });
});
```

### 六、覆盖率与质量

#### 1. 运行覆盖率

```bash
# Jest
npm test -- --coverage

# Vitest
npm test -- --coverage
```

#### 2. 覆盖率报告解读

```
-------------------|---------|----------|---------|---------|-------------------
File               | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-------------------|---------|----------|---------|---------|-------------------
All files          |   85.5  |   78.2   |   90.1  |   85.5  |
 utils/            |   92.3  |   85.7   |   100   |   92.3  |
  math.ts          |   100   |   100    |   100   |   100   |
  string.ts        |   85.7  |   75     |   100   |   85.7  | 12,18
 components/       |   80.2  |   72.1   |   83.3  |   80.2  |
  Button.tsx       |   100   |   100    |   100   |   100   |
  Form.tsx         |   65.4  |   50     |   75    |   65.4  | 45-52,67
-------------------|---------|----------|---------|---------|-------------------
```

**指标说明**:
- **Statements**: 语句覆盖率
- **Branch**: 分支覆盖率(if/else/switch)
- **Functions**: 函数覆盖率
- **Lines**: 行覆盖率

#### 3. 合理的覆盖率目标

```javascript
// jest.config.js
coverageThreshold: {
  global: {
    statements: 80,    // 核心业务逻辑 80%+
    branches: 70,      // 分支逻辑 70%+
    functions: 80,     // 函数覆盖 80%+
    lines: 80,         // 行覆盖 80%+
  },
  // 特定目录更高要求
  './src/utils/': {
    statements: 90,
    branches: 85,
    functions: 90,
    lines: 90,
  },
}
```

### 七、CI/CD 集成

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test -- --coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json

      - name: Check coverage threshold
        run: |
          if [ $(jq '.total.lines.pct' coverage/coverage-summary.json) -lt 80 ]; then
            echo "Coverage below 80%"
            exit 1
          fi
```

### 八、常见问题与解决方案

#### 1. 测试运行缓慢

```bash
# Jest 使用最大 worker
jest --maxWorkers=4

# Vitest 默认并发
vitest --threads

# 只运行变更的测试
jest --onlyChanged
vitest --changed
```

#### 2. Mock 不生效

```typescript
// ❌ Mock 在 import 之后
import { fetchUser } from './api';
jest.mock('./api');

// ✅ Mock 在 import 之前
jest.mock('./api');
import { fetchUser } from './api';
```

#### 3. 异步测试超时

```typescript
// 增加超时时间
test('async test', async () => {
  await longRunningOperation();
}, 10000); // 10秒

// 或全局配置
// jest.config.js
testTimeout: 10000
```

### 九、总结

#### 单元测试的价值

✅ **快速反馈**: 几秒内验证代码正确性
✅ **重构保障**: 安全重构,防止破坏原有功能
✅ **文档作用**: 测试即文档,展示使用方式
✅ **提升质量**: 倒逼编写可测试代码(低耦合)

#### 工具选择建议

- **新项目 + Vite** → Vitest(速度快、配置简单)
- **老项目 + Webpack** → Jest(生态成熟、稳定)
- **追求性能** → Vitest(HMR、并发执行)
- **需要稳定** → Jest(久经考验)

#### 关键原则

1. **测试行为,不测实现**:避免测试实现细节
2. **保持独立**:测试间互不影响
3. **可读性优先**:清晰的命名和结构
4. **适度 Mock**:只 Mock 外部依赖
5. **覆盖率不是目标**:质量>数量

单元测试是前端工程化的基石,投入初期需要时间,但长期收益巨大。关键是养成习惯,在开发过程中持续编写和维护测试。
