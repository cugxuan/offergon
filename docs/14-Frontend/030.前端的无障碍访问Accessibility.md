---
title: 前端的无障碍访问（Accessibility）
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: frontend-accessibility
ref:
---

## 核心要点

**WCAG标准**:遵循WCAG 2.1 AA级标准,涵盖可感知性/可操作性/可理解性/健壮性四大原则
**辅助技术**:兼容屏幕阅读器/键盘导航/语音识别等辅助工具,确保残障用户正常使用
**语义化实现**:正确使用HTML语义标签+ARIA属性+焦点管理+替代文本,构建无障碍的交互体验

---

## 详细回答

前端无障碍访问(Web Accessibility)是确保所有人都能平等访问和使用Web应用的重要技术,我将从标准规范、技术实现、测试验证三个维度全面阐述。

### 一、无障碍标准与原则

#### 1. WCAG 2.1指导原则

Web内容无障碍指南(WCAG)基于四大核心原则:

**可感知性 (Perceivable)**
- 用户必须能够感知信息和用户界面组件
- 包括替代文本、字幕、颜色对比度等

**可操作性 (Operable)**
- 用户界面组件和导航必须是可操作的
- 包括键盘访问、时间限制、癫痫预防等

**可理解性 (Understandable)**
- 信息和用户界面的操作必须是可理解的
- 包括可读性、可预测性、输入帮助等

**健壮性 (Robust)**
- 内容必须足够健壮以便各种用户代理解释
- 包括兼容性、有效标记等

```javascript
// 无障碍检查器实现
class AccessibilityChecker {
  constructor() {
    this.violations = [];
    this.wcagLevels = ['A', 'AA', 'AAA'];
  }

  // 检查颜色对比度
  checkColorContrast(foreground, background, fontSize = 16) {
    const ratio = this.calculateContrastRatio(foreground, background);
    const isLargeText = fontSize >= 18 || (fontSize >= 14 && this.isBold);

    const requirements = {
      AA: isLargeText ? 3 : 4.5,
      AAA: isLargeText ? 4.5 : 7
    };

    const results = {
      ratio: ratio.toFixed(2),
      AA: ratio >= requirements.AA,
      AAA: ratio >= requirements.AAA
    };

    if (!results.AA) {
      this.addViolation('color-contrast', {
        message: `颜色对比度不足: ${results.ratio}:1 (需要至少 ${requirements.AA}:1)`,
        element: 'color-contrast-check',
        wcagLevel: 'AA'
      });
    }

    return results;
  }

  // 计算颜色对比度比例
  calculateContrastRatio(color1, color2) {
    const lum1 = this.getLuminance(color1);
    const lum2 = this.getLuminance(color2);
    const brightest = Math.max(lum1, lum2);
    const darkest = Math.min(lum1, lum2);
    return (brightest + 0.05) / (darkest + 0.05);
  }

  // 获取颜色亮度
  getLuminance(color) {
    const rgb = this.hexToRgb(color);
    const rsRGB = rgb.r / 255;
    const gsRGB = rgb.g / 255;
    const bsRGB = rgb.b / 255;

    const r = rsRGB <= 0.03928 ? rsRGB / 12.92 : Math.pow((rsRGB + 0.055) / 1.055, 2.4);
    const g = gsRGB <= 0.03928 ? gsRGB / 12.92 : Math.pow((gsRGB + 0.055) / 1.055, 2.4);
    const b = bsRGB <= 0.03928 ? bsRGB / 12.92 : Math.pow((bsRGB + 0.055) / 1.055, 2.4);

    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  // 检查图片替代文本
  checkImageAltText() {
    const images = document.querySelectorAll('img');
    images.forEach((img, index) => {
      if (!img.hasAttribute('alt')) {
        this.addViolation('missing-alt', {
          message: '图片缺少alt属性',
          element: img,
          wcagLevel: 'A'
        });
      } else if (img.alt.trim() === '' && !img.hasAttribute('role')) {
        // 装饰性图片应该有空alt或role="presentation"
        if (!this.isDecorativeImage(img)) {
          this.addViolation('empty-alt', {
            message: '非装饰性图片不应该有空的alt属性',
            element: img,
            wcagLevel: 'A'
          });
        }
      }
    });
  }

  // 检查标题层级结构
  checkHeadingStructure() {
    const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'));
    let previousLevel = 0;

    headings.forEach((heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));

      if (index === 0 && level !== 1) {
        this.addViolation('heading-structure', {
          message: '页面应该以h1标题开始',
          element: heading,
          wcagLevel: 'AA'
        });
      }

      if (level - previousLevel > 1) {
        this.addViolation('heading-structure', {
          message: `标题层级跳跃过大: 从h${previousLevel}跳到h${level}`,
          element: heading,
          wcagLevel: 'AA'
        });
      }

      previousLevel = level;
    });
  }

  addViolation(type, details) {
    this.violations.push({
      type,
      ...details,
      timestamp: Date.now()
    });
  }

  // 生成无障碍报告
  generateReport() {
    return {
      totalViolations: this.violations.length,
      byLevel: this.groupByWCAGLevel(),
      byType: this.groupByType(),
      violations: this.violations
    };
  }

  groupByWCAGLevel() {
    return this.violations.reduce((acc, violation) => {
      acc[violation.wcagLevel] = (acc[violation.wcagLevel] || 0) + 1;
      return acc;
    }, {});
  }

  groupByType() {
    return this.violations.reduce((acc, violation) => {
      acc[violation.type] = (acc[violation.type] || 0) + 1;
      return acc;
    }, {});
  }
}
```

### 二、语义化HTML与ARIA

#### 1. 正确的HTML语义结构

```html
<!-- 良好的语义化结构示例 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>无障碍电商网站 - 首页</title>
</head>
<body>
  <!-- 跳转链接(屏幕阅读器用户快速导航) -->
  <a href="#main-content" class="sr-only sr-only-focusable">跳转到主要内容</a>

  <!-- 主导航 -->
  <header role="banner">
    <nav aria-label="主导航">
      <ul>
        <li><a href="/" aria-current="page">首页</a></li>
        <li><a href="/products">产品</a></li>
        <li><a href="/about">关于我们</a></li>
        <li><a href="/contact">联系方式</a></li>
      </ul>
    </nav>
  </header>

  <!-- 主要内容区域 -->
  <main id="main-content" role="main">
    <!-- 页面标题 -->
    <h1>欢迎来到我们的电商平台</h1>

    <!-- 搜索表单 -->
    <form role="search" aria-label="产品搜索">
      <div class="form-group">
        <label for="search-input">搜索产品</label>
        <input
          id="search-input"
          type="search"
          name="q"
          aria-describedby="search-help"
          required
        >
        <div id="search-help" class="help-text">
          输入产品名称或关键词进行搜索
        </div>
      </div>
      <button type="submit">搜索</button>
    </form>

    <!-- 产品列表 -->
    <section aria-labelledby="featured-products">
      <h2 id="featured-products">热门产品</h2>

      <div class="product-grid" role="grid" aria-label="产品列表">
        <article class="product-card" role="gridcell">
          <img
            src="product1.jpg"
            alt="iPhone 15 Pro - 钛金属外壳，专业摄影系统"
            loading="lazy"
          >
          <h3>
            <a href="/products/iphone-15-pro">iPhone 15 Pro</a>
          </h3>
          <div class="price" aria-label="价格">
            <span aria-label="原价" class="original-price">¥8999</span>
            <span aria-label="现价" class="current-price">¥7999</span>
            <span aria-label="折扣" class="discount">89折</span>
          </div>
          <div class="rating" aria-label="用户评分">
            <span aria-hidden="true">★★★★☆</span>
            <span class="sr-only">4.5分，满分5分</span>
            <span class="review-count">(1,234条评价)</span>
          </div>
        </article>
      </div>
    </section>

    <!-- 分页导航 -->
    <nav aria-label="分页导航">
      <ul class="pagination">
        <li>
          <a href="?page=1" aria-label="上一页" rel="prev">‹</a>
        </li>
        <li>
          <a href="?page=1" aria-current="page">1</a>
        </li>
        <li>
          <a href="?page=2">2</a>
        </li>
        <li>
          <a href="?page=3">3</a>
        </li>
        <li>
          <a href="?page=2" aria-label="下一页" rel="next">›</a>
        </li>
      </ul>
    </nav>
  </main>

  <!-- 侧边栏 -->
  <aside role="complementary" aria-labelledby="sidebar-title">
    <h2 id="sidebar-title">相关信息</h2>
    <!-- 侧边栏内容 -->
  </aside>

  <!-- 页脚 -->
  <footer role="contentinfo">
    <nav aria-label="页脚导航">
      <ul>
        <li><a href="/privacy">隐私政策</a></li>
        <li><a href="/terms">服务条款</a></li>
        <li><a href="/help">帮助中心</a></li>
      </ul>
    </nav>
    <p>&copy; 2024 电商平台. 保留所有权利.</p>
  </footer>
</body>
</html>
```

#### 2. ARIA属性详解与应用

```javascript
// ARIA增强组件实现
class AccessibleComponents {
  // 模态框组件
  static createAccessibleModal(options) {
    const { title, content, onClose } = options;

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-labelledby', 'modal-title');
    modal.setAttribute('aria-describedby', 'modal-content');

    modal.innerHTML = `
      <div class="modal-backdrop" aria-hidden="true"></div>
      <div class="modal-content">
        <header class="modal-header">
          <h2 id="modal-title">${title}</h2>
          <button
            class="modal-close"
            aria-label="关闭对话框"
            data-dismiss="modal"
          >
            <span aria-hidden="true">&times;</span>
          </button>
        </header>
        <div id="modal-content" class="modal-body">
          ${content}
        </div>
      </div>
    `;

    // 焦点管理
    const previousActiveElement = document.activeElement;

    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.closeModal(modal, previousActiveElement, onClose);
      }
      if (e.key === 'Tab') {
        this.trapFocus(e, modal);
      }
    });

    // 关闭按钮事件
    modal.querySelector('[data-dismiss="modal"]').addEventListener('click', () => {
      this.closeModal(modal, previousActiveElement, onClose);
    });

    // 点击背景关闭
    modal.querySelector('.modal-backdrop').addEventListener('click', () => {
      this.closeModal(modal, previousActiveElement, onClose);
    });

    document.body.appendChild(modal);

    // 设置焦点到模态框
    modal.querySelector('.modal-close').focus();

    return modal;
  }

  // 焦点陷阱
  static trapFocus(e, container) {
    const focusableElements = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    if (e.shiftKey && document.activeElement === firstElement) {
      e.preventDefault();
      lastElement.focus();
    } else if (!e.shiftKey && document.activeElement === lastElement) {
      e.preventDefault();
      firstElement.focus();
    }
  }

  // 下拉菜单组件
  static createAccessibleDropdown(triggerElement, menuItems) {
    const menuId = `dropdown-${Date.now()}`;

    // 设置触发器属性
    triggerElement.setAttribute('aria-haspopup', 'true');
    triggerElement.setAttribute('aria-expanded', 'false');
    triggerElement.setAttribute('aria-controls', menuId);

    // 创建菜单
    const menu = document.createElement('ul');
    menu.id = menuId;
    menu.className = 'dropdown-menu';
    menu.setAttribute('role', 'menu');
    menu.style.display = 'none';

    menuItems.forEach((item, index) => {
      const li = document.createElement('li');
      li.setAttribute('role', 'presentation');

      const link = document.createElement('a');
      link.setAttribute('role', 'menuitem');
      link.setAttribute('tabindex', '-1');
      link.href = item.href || '#';
      link.textContent = item.text;

      if (index === 0) {
        link.setAttribute('tabindex', '0');
      }

      li.appendChild(link);
      menu.appendChild(li);
    });

    triggerElement.parentNode.appendChild(menu);

    // 键盘导航
    menu.addEventListener('keydown', (e) => {
      const menuItems = menu.querySelectorAll('[role="menuitem"]');
      const currentIndex = Array.from(menuItems).indexOf(document.activeElement);

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          const nextIndex = (currentIndex + 1) % menuItems.length;
          menuItems[nextIndex].focus();
          break;
        case 'ArrowUp':
          e.preventDefault();
          const prevIndex = currentIndex === 0 ? menuItems.length - 1 : currentIndex - 1;
          menuItems[prevIndex].focus();
          break;
        case 'Escape':
          e.preventDefault();
          this.hideDropdown(triggerElement, menu);
          break;
        case 'Enter':
        case ' ':
          e.preventDefault();
          document.activeElement.click();
          break;
      }
    });

    // 触发器事件
    triggerElement.addEventListener('click', () => {
      const isExpanded = triggerElement.getAttribute('aria-expanded') === 'true';
      if (isExpanded) {
        this.hideDropdown(triggerElement, menu);
      } else {
        this.showDropdown(triggerElement, menu);
      }
    });

    return menu;
  }

  static showDropdown(trigger, menu) {
    trigger.setAttribute('aria-expanded', 'true');
    menu.style.display = 'block';
    menu.querySelector('[role="menuitem"]').focus();
  }

  static hideDropdown(trigger, menu) {
    trigger.setAttribute('aria-expanded', 'false');
    menu.style.display = 'none';
    trigger.focus();
  }

  // 表单验证增强
  static enhanceFormAccessibility(form) {
    const inputs = form.querySelectorAll('input, select, textarea');

    inputs.forEach(input => {
      // 实时验证
      input.addEventListener('blur', () => {
        this.validateField(input);
      });

      input.addEventListener('input', () => {
        // 清除之前的错误状态
        if (input.getAttribute('aria-invalid') === 'true') {
          this.clearFieldError(input);
        }
      });
    });

    form.addEventListener('submit', (e) => {
      let hasErrors = false;

      inputs.forEach(input => {
        if (!this.validateField(input)) {
          hasErrors = true;
        }
      });

      if (hasErrors) {
        e.preventDefault();
        // 聚焦到第一个错误字段
        const firstError = form.querySelector('[aria-invalid="true"]');
        if (firstError) {
          firstError.focus();
        }
      }
    });
  }

  static validateField(input) {
    const isValid = input.checkValidity();

    if (!isValid) {
      this.showFieldError(input, input.validationMessage);
      return false;
    } else {
      this.clearFieldError(input);
      return true;
    }
  }

  static showFieldError(input, message) {
    input.setAttribute('aria-invalid', 'true');

    let errorElement = document.getElementById(`${input.id}-error`);
    if (!errorElement) {
      errorElement = document.createElement('div');
      errorElement.id = `${input.id}-error`;
      errorElement.className = 'field-error';
      errorElement.setAttribute('role', 'alert');
      input.parentNode.appendChild(errorElement);

      input.setAttribute('aria-describedby', errorElement.id);
    }

    errorElement.textContent = message;
  }

  static clearFieldError(input) {
    input.setAttribute('aria-invalid', 'false');

    const errorElement = document.getElementById(`${input.id}-error`);
    if (errorElement) {
      errorElement.textContent = '';
    }
  }
}
```

### 三、键盘导航与焦点管理

#### 1. 键盘导航实现

```javascript
// 键盘导航管理器
class KeyboardNavigationManager {
  constructor() {
    this.focusableSelectors = [
      'button',
      '[href]',
      'input:not([disabled])',
      'select:not([disabled])',
      'textarea:not([disabled])',
      '[tabindex]:not([tabindex="-1"])',
      'details',
      'summary'
    ].join(', ');

    this.setupGlobalKeyboardHandlers();
  }

  setupGlobalKeyboardHandlers() {
    document.addEventListener('keydown', (e) => {
      // Alt + 1: 跳转到主要内容
      if (e.altKey && e.key === '1') {
        e.preventDefault();
        this.focusMainContent();
      }

      // Alt + 2: 跳转到导航
      if (e.altKey && e.key === '2') {
        e.preventDefault();
        this.focusNavigation();
      }

      // Ctrl + /: 显示键盘快捷键帮助
      if (e.ctrlKey && e.key === '/') {
        e.preventDefault();
        this.showKeyboardShortcuts();
      }
    });

    // 焦点指示器增强
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        document.body.classList.add('keyboard-navigation');
      }
    });

    document.addEventListener('mousedown', () => {
      document.body.classList.remove('keyboard-navigation');
    });
  }

  focusMainContent() {
    const mainContent = document.querySelector('main, [role="main"], #main-content');
    if (mainContent) {
      mainContent.focus();
      mainContent.scrollIntoView({ behavior: 'smooth' });
    }
  }

  focusNavigation() {
    const navigation = document.querySelector('nav, [role="navigation"]');
    if (navigation) {
      const firstLink = navigation.querySelector('a, button');
      if (firstLink) {
        firstLink.focus();
      }
    }
  }

  // 获取页面所有可聚焦元素
  getFocusableElements(container = document) {
    return Array.from(container.querySelectorAll(this.focusableSelectors))
      .filter(element => {
        return this.isVisible(element) && !element.disabled;
      });
  }

  isVisible(element) {
    return !!(
      element.offsetWidth ||
      element.offsetHeight ||
      element.getClientRects().length
    );
  }

  // 创建自定义焦点顺序
  createCustomTabOrder(elements) {
    elements.forEach((element, index) => {
      element.setAttribute('tabindex', index + 1);
    });
  }

  // 区域导航(跳过大块内容)
  createSkipLinks() {
    const skipLinks = document.createElement('div');
    skipLinks.className = 'skip-links';
    skipLinks.innerHTML = `
      <a href="#main-content" class="skip-link">跳转到主要内容</a>
      <a href="#navigation" class="skip-link">跳转到导航</a>
      <a href="#search" class="skip-link">跳转到搜索</a>
    `;

    document.body.insertBefore(skipLinks, document.body.firstChild);
  }

  showKeyboardShortcuts() {
    const shortcuts = [
      { keys: 'Alt + 1', description: '跳转到主要内容' },
      { keys: 'Alt + 2', description: '跳转到导航菜单' },
      { keys: 'Tab', description: '向前移动焦点' },
      { keys: 'Shift + Tab', description: '向后移动焦点' },
      { keys: 'Enter/Space', description: '激活按钮或链接' },
      { keys: 'Escape', description: '关闭对话框或菜单' },
      { keys: '箭头键', description: '在菜单或表格中导航' }
    ];

    const modal = AccessibleComponents.createAccessibleModal({
      title: '键盘快捷键',
      content: `
        <table>
          <thead>
            <tr>
              <th>快捷键</th>
              <th>功能说明</th>
            </tr>
          </thead>
          <tbody>
            ${shortcuts.map(shortcut => `
              <tr>
                <td><kbd>${shortcut.keys}</kbd></td>
                <td>${shortcut.description}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      `,
      onClose: () => modal.remove()
    });
  }
}

// 初始化键盘导航
const keyboardNav = new KeyboardNavigationManager();
```

#### 2. 焦点管理最佳实践

```css
/* 焦点指示器样式 */
.keyboard-navigation *:focus {
  outline: 2px solid #007cba;
  outline-offset: 2px;
}

/* 跳过链接样式 */
.skip-link {
  position: absolute;
  top: -40px;
  left: 6px;
  background: #000;
  color: #fff;
  padding: 8px;
  text-decoration: none;
  z-index: 1000;
  border-radius: 4px;
}

.skip-link:focus {
  top: 6px;
}

/* 屏幕阅读器专用文本 */
.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

.sr-only-focusable:focus {
  position: static !important;
  width: auto !important;
  height: auto !important;
  padding: inherit !important;
  margin: inherit !important;
  overflow: visible !important;
  clip: auto !important;
  white-space: inherit !important;
}

/* 高对比度模式支持 */
@media (prefers-contrast: high) {
  .button {
    border: 2px solid;
  }

  .card {
    border: 1px solid;
  }
}

/* 减少动画偏好 */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

### 四、屏幕阅读器优化

#### 1. 屏幕阅读器测试与优化

```javascript
// 屏幕阅读器兼容性增强
class ScreenReaderOptimizer {
  constructor() {
    this.announcements = [];
    this.setupLiveRegions();
    this.enhanceInteractiveElements();
  }

  // 设置实时通知区域
  setupLiveRegions() {
    // 创建全局通知区域
    const alertRegion = document.createElement('div');
    alertRegion.id = 'aria-live-alert';
    alertRegion.setAttribute('aria-live', 'assertive');
    alertRegion.setAttribute('aria-atomic', 'true');
    alertRegion.className = 'sr-only';
    document.body.appendChild(alertRegion);

    const politeRegion = document.createElement('div');
    politeRegion.id = 'aria-live-polite';
    politeRegion.setAttribute('aria-live', 'polite');
    politeRegion.setAttribute('aria-atomic', 'true');
    politeRegion.className = 'sr-only';
    document.body.appendChild(politeRegion);
  }

  // 向屏幕阅读器发布消息
  announce(message, priority = 'polite') {
    const regionId = priority === 'assertive' ? 'aria-live-alert' : 'aria-live-polite';
    const region = document.getElementById(regionId);

    if (region) {
      // 清空然后设置新内容(确保被读出)
      region.textContent = '';
      setTimeout(() => {
        region.textContent = message;
      }, 100);

      // 记录通知历史
      this.announcements.push({
        message,
        priority,
        timestamp: Date.now()
      });
    }
  }

  // 增强表单元素
  enhanceFormElements() {
    const forms = document.querySelectorAll('form');

    forms.forEach(form => {
      // 表单提交状态通知
      form.addEventListener('submit', () => {
        this.announce('表单正在提交，请稍候...', 'assertive');
      });

      // 字段组织和标记
      const fieldsets = form.querySelectorAll('fieldset');
      fieldsets.forEach(fieldset => {
        if (!fieldset.querySelector('legend')) {
          console.warn('Fieldset缺少legend元素:', fieldset);
        }
      });

      // 必填字段增强
      const requiredFields = form.querySelectorAll('[required]');
      requiredFields.forEach(field => {
        const label = form.querySelector(`label[for="${field.id}"]`);
        if (label && !label.querySelector('.required-indicator')) {
          const indicator = document.createElement('span');
          indicator.className = 'required-indicator';
          indicator.setAttribute('aria-label', '必填');
          indicator.textContent = ' *';
          label.appendChild(indicator);
        }
      });
    });
  }

  // 增强数据表格
  enhanceDataTables() {
    const tables = document.querySelectorAll('table[data-enhance="accessibility"]');

    tables.forEach(table => {
      // 添加表格说明
      if (!table.querySelector('caption')) {
        const caption = document.createElement('caption');
        caption.textContent = this.generateTableCaption(table);
        table.insertBefore(caption, table.firstChild);
      }

      // 为表头添加scope属性
      const headerCells = table.querySelectorAll('th');
      headerCells.forEach(th => {
        if (!th.hasAttribute('scope')) {
          // 自动判断是行表头还是列表头
          const row = th.parentElement;
          const rowIndex = Array.from(table.rows).indexOf(row);
          const cellIndex = Array.from(row.cells).indexOf(th);

          if (rowIndex === 0) {
            th.setAttribute('scope', 'col');
          } else if (cellIndex === 0) {
            th.setAttribute('scope', 'row');
          }
        }
      });

      // 复杂表格的headers属性
      if (this.isComplexTable(table)) {
        this.addHeadersAttribute(table);
      }
    });
  }

  generateTableCaption(table) {
    const rowCount = table.rows.length;
    const colCount = table.rows[0]?.cells.length || 0;
    return `数据表格，包含${rowCount}行${colCount}列`;
  }

  isComplexTable(table) {
    // 检查是否有合并单元格或多层表头
    const cells = table.querySelectorAll('td, th');
    return Array.from(cells).some(cell =>
      cell.hasAttribute('colspan') ||
      cell.hasAttribute('rowspan')
    );
  }

  // 增强导航元素
  enhanceNavigation() {
    const navElements = document.querySelectorAll('nav');

    navElements.forEach(nav => {
      // 添加导航标签
      if (!nav.hasAttribute('aria-label') && !nav.hasAttribute('aria-labelledby')) {
        const heading = nav.querySelector('h1, h2, h3, h4, h5, h6');
        if (heading) {
          nav.setAttribute('aria-labelledby', heading.id || this.generateId());
        } else {
          nav.setAttribute('aria-label', '导航菜单');
        }
      }

      // 当前页面指示
      const currentLink = nav.querySelector('[aria-current]');
      if (!currentLink) {
        const currentPageLink = nav.querySelector(`[href="${window.location.pathname}"]`);
        if (currentPageLink) {
          currentPageLink.setAttribute('aria-current', 'page');
        }
      }
    });
  }

  // 页面加载完成通知
  announcePageLoad() {
    const pageTitle = document.title;
    const landmark = document.querySelector('main h1')?.textContent;

    let message = `页面已加载: ${pageTitle}`;
    if (landmark) {
      message += `，主要内容: ${landmark}`;
    }

    // 延迟通知，等待页面完全加载
    setTimeout(() => {
      this.announce(message, 'polite');
    }, 1000);
  }

  generateId() {
    return `sr-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 初始化屏幕阅读器优化
const screenReaderOptimizer = new ScreenReaderOptimizer();

// 页面加载完成后启动
document.addEventListener('DOMContentLoaded', () => {
  screenReaderOptimizer.enhanceFormElements();
  screenReaderOptimizer.enhanceDataTables();
  screenReaderOptimizer.enhanceNavigation();
  screenReaderOptimizer.announcePageLoad();
});
```

### 五、无障碍测试与验证

#### 1. 自动化测试集成

```javascript
// 无障碍自动化测试
class AccessibilityTester {
  constructor() {
    this.testResults = [];
    this.wcagTests = {
      level_A: [],
      level_AA: [],
      level_AAA: []
    };
  }

  // 执行完整的无障碍测试套件
  async runFullAudit() {
    console.log('开始无障碍测试...');

    await this.testColorContrast();
    await this.testKeyboardNavigation();
    await this.testScreenReaderCompatibility();
    await this.testSemanticStructure();
    await this.testFormAccessibility();

    return this.generateTestReport();
  }

  // 颜色对比度测试
  async testColorContrast() {
    const textElements = document.querySelectorAll('p, span, div, h1, h2, h3, h4, h5, h6, a, button');

    for (const element of textElements) {
      const styles = getComputedStyle(element);
      const textColor = styles.color;
      const backgroundColor = this.getEffectiveBackgroundColor(element);

      if (textColor && backgroundColor) {
        const contrast = this.calculateContrastRatio(textColor, backgroundColor);
        const fontSize = parseFloat(styles.fontSize);
        const fontWeight = styles.fontWeight;

        const requirements = this.getContrastRequirements(fontSize, fontWeight);

        this.addTestResult('color-contrast', {
          element: this.getElementSelector(element),
          textColor,
          backgroundColor,
          contrast: contrast.toFixed(2),
          requirements,
          passed: contrast >= requirements.AA,
          wcagLevel: 'AA'
        });
      }
    }
  }

  // 键盘导航测试
  async testKeyboardNavigation() {
    const focusableElements = document.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    let tabIndex = 0;
    for (const element of focusableElements) {
      // 检查是否可以通过Tab键访问
      if (this.isVisible(element) && !element.disabled) {
        const hasVisibleFocus = this.hasVisibleFocusIndicator(element);

        this.addTestResult('keyboard-navigation', {
          element: this.getElementSelector(element),
          tabIndex: tabIndex++,
          hasVisibleFocus,
          passed: hasVisibleFocus,
          wcagLevel: 'AA'
        });
      }
    }

    // 测试焦点陷阱(模态框等)
    const modals = document.querySelectorAll('[role="dialog"], .modal');
    modals.forEach(modal => {
      if (this.isVisible(modal)) {
        const hasFocusTrap = this.testFocusTrap(modal);
        this.addTestResult('focus-trap', {
          element: this.getElementSelector(modal),
          hasFocusTrap,
          passed: hasFocusTrap,
          wcagLevel: 'AA'
        });
      }
    });
  }

  // 语义结构测试
  async testSemanticStructure() {
    // 测试标题层级
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    let previousLevel = 0;
    let hasH1 = false;

    headings.forEach((heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));

      if (level === 1) hasH1 = true;

      if (index === 0 && level !== 1) {
        this.addTestResult('heading-structure', {
          issue: 'first-heading-not-h1',
          element: this.getElementSelector(heading),
          passed: false,
          wcagLevel: 'AA'
        });
      }

      if (level - previousLevel > 1) {
        this.addTestResult('heading-structure', {
          issue: 'heading-level-skip',
          element: this.getElementSelector(heading),
          previousLevel,
          currentLevel: level,
          passed: false,
          wcagLevel: 'AA'
        });
      }

      previousLevel = level;
    });

    if (!hasH1 && headings.length > 0) {
      this.addTestResult('heading-structure', {
        issue: 'no-h1-found',
        passed: false,
        wcagLevel: 'AA'
      });
    }

    // 测试地标元素
    this.testLandmarks();

    // 测试图片替代文本
    this.testImageAltText();
  }

  testLandmarks() {
    const landmarks = {
      banner: document.querySelector('header, [role="banner"]'),
      navigation: document.querySelector('nav, [role="navigation"]'),
      main: document.querySelector('main, [role="main"]'),
      contentinfo: document.querySelector('footer, [role="contentinfo"]')
    };

    Object.entries(landmarks).forEach(([type, element]) => {
      this.addTestResult('landmarks', {
        landmarkType: type,
        present: !!element,
        element: element ? this.getElementSelector(element) : null,
        passed: !!element,
        wcagLevel: 'AA'
      });
    });
  }

  testImageAltText() {
    const images = document.querySelectorAll('img');

    images.forEach(img => {
      const hasAlt = img.hasAttribute('alt');
      const altText = img.getAttribute('alt');
      const isDecorative = img.hasAttribute('role') && img.getAttribute('role') === 'presentation';

      let passed = true;
      let issue = null;

      if (!hasAlt && !isDecorative) {
        passed = false;
        issue = 'missing-alt-attribute';
      } else if (hasAlt && altText.trim() === '' && !isDecorative) {
        passed = false;
        issue = 'empty-alt-for-content-image';
      }

      this.addTestResult('image-alt-text', {
        element: this.getElementSelector(img),
        hasAlt,
        altText,
        isDecorative,
        issue,
        passed,
        wcagLevel: 'A'
      });
    });
  }

  // 表单无障碍测试
  async testFormAccessibility() {
    const forms = document.querySelectorAll('form');

    forms.forEach(form => {
      const inputs = form.querySelectorAll('input, select, textarea');

      inputs.forEach(input => {
        const hasLabel = this.hasAssociatedLabel(input);
        const hasRequiredIndication = input.hasAttribute('required') &&
          this.hasRequiredIndication(input);

        this.addTestResult('form-accessibility', {
          element: this.getElementSelector(input),
          inputType: input.type || input.tagName.toLowerCase(),
          hasLabel,
          isRequired: input.hasAttribute('required'),
          hasRequiredIndication,
          passed: hasLabel && (!input.hasAttribute('required') || hasRequiredIndication),
          wcagLevel: 'A'
        });
      });
    });
  }

  // 辅助方法
  hasAssociatedLabel(input) {
    const label = document.querySelector(`label[for="${input.id}"]`);
    const ariaLabel = input.hasAttribute('aria-label');
    const ariaLabelledby = input.hasAttribute('aria-labelledby');

    return !!(label || ariaLabel || ariaLabelledby);
  }

  hasRequiredIndication(input) {
    const label = document.querySelector(`label[for="${input.id}"]`);
    if (label) {
      return label.textContent.includes('*') ||
             label.textContent.includes('必填') ||
             label.querySelector('.required-indicator');
    }
    return false;
  }

  getElementSelector(element) {
    if (element.id) return `#${element.id}`;
    if (element.className) return `${element.tagName.toLowerCase()}.${element.className.split(' ')[0]}`;
    return element.tagName.toLowerCase();
  }

  addTestResult(category, result) {
    this.testResults.push({
      category,
      ...result,
      timestamp: Date.now()
    });
  }

  generateTestReport() {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(test => test.passed).length;
    const failedTests = totalTests - passedTests;

    const report = {
      summary: {
        total: totalTests,
        passed: passedTests,
        failed: failedTests,
        passRate: ((passedTests / totalTests) * 100).toFixed(2) + '%'
      },
      byCategory: this.groupTestsByCategory(),
      byWCAGLevel: this.groupTestsByWCAGLevel(),
      failures: this.testResults.filter(test => !test.passed),
      details: this.testResults
    };

    console.log('无障碍测试报告:', report);
    return report;
  }

  groupTestsByCategory() {
    return this.testResults.reduce((acc, test) => {
      if (!acc[test.category]) {
        acc[test.category] = { total: 0, passed: 0, failed: 0 };
      }
      acc[test.category].total++;
      if (test.passed) {
        acc[test.category].passed++;
      } else {
        acc[test.category].failed++;
      }
      return acc;
    }, {});
  }

  groupTestsByWCAGLevel() {
    return this.testResults.reduce((acc, test) => {
      const level = test.wcagLevel || 'Unknown';
      if (!acc[level]) {
        acc[level] = { total: 0, passed: 0, failed: 0 };
      }
      acc[level].total++;
      if (test.passed) {
        acc[level].passed++;
      } else {
        acc[level].failed++;
      }
      return acc;
    }, {});
  }
}

// 使用示例
const accessibilityTester = new AccessibilityTester();

// 在开发环境中运行测试
if (process.env.NODE_ENV === 'development') {
  document.addEventListener('DOMContentLoaded', async () => {
    await accessibilityTester.runFullAudit();
  });
}
```

### 六、实践经验与工具推荐

#### 1. 无障碍开发实践案例

在之前负责的政府网站项目中,我们必须达到WCAG 2.1 AA级标准:

**技术实施:**
- 全站键盘导航支持,Tab键顺序逻辑清晰
- 颜色对比度全部达到4.5:1以上
- 所有交互元素支持屏幕阅读器
- 表单提供详细的错误提示和帮助信息

**测试验证:**
- 使用NVDA、JAWS等屏幕阅读器测试
- 键盘导航全流程测试
- 颜色盲用户测试(使用滤镜模拟)
- 认知障碍用户易用性测试

**成果:**
- 通过第三方无障碍认证(AAA级)
- 用户反馈满意度从60%提升到95%
- 政府无障碍评估获得优秀等级

#### 2. 无障碍工具生态

**开发工具:**
- axe-core: 自动化无障碍测试引擎
- Pa11y: 命令行无障碍测试工具
- Lighthouse: Google的综合性能和无障碍审计
- WAVE: 在线无障碍评估工具

**浏览器扩展:**
- axe DevTools: 浏览器中的无障碍检测
- Accessibility Insights: 微软的无障碍检测工具
- Colour Contrast Analyser: 颜色对比度检测

**屏幕阅读器:**
- NVDA(Windows): 免费开源屏幕阅读器
- JAWS(Windows): 专业屏幕阅读器
- VoiceOver(macOS): 苹果内置屏幕阅读器
- TalkBack(Android): 安卓无障碍服务

通过系统性的无障碍优化,我们能够确保Web应用对所有用户都是可访问的,这不仅是技术要求,更是社会责任。无障碍设计让我们的产品更具包容性,服务更广泛的用户群体。
