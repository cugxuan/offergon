---
title: Webpack 的代码分割策略(SplitChunksPlugin)
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: webpack-code-splitting-splitchunksplugin
ref:
---

## 核心要点

- **代码分割目的**:将大bundle拆分为多个小文件,实现按需加载、并行加载、提升缓存命中率
- **三种实现方式**:Entry配置、动态import()、SplitChunksPlugin自动分割
- **SplitChunksPlugin核心**:基于chunks/minSize/cacheGroups等规则自动提取公共代码
- **最佳实践**:分离vendor、提取公共模块、配置合理阈值、利用缓存组实现精细化控制

## 详细解答

### 一、代码分割的价值

#### 1.1 为什么需要代码分割?

**问题场景:**
```javascript
// 所有代码打包成一个大文件
// bundle.js: 3MB (包含首屏代码、路由代码、第三方库等)
```

**存在的问题:**
1. **首屏加载慢**:用户需下载3MB才能看到首页
2. **缓存失效**:修改一行代码,整个3MB需要重新下载
3. **资源浪费**:很多功能用户可能永远不会访问
4. **并行加载受限**:浏览器无法并行加载多个资源

**代码分割后:**
```javascript
// 拆分成多个文件
vendor.js: 500KB    (第三方库,很少变化,缓存命中率高)
common.js: 200KB    (公共组件,偶尔变化)
home.js: 100KB      (首页代码,首屏加载)
about.js: 80KB      (关于页,按需加载)
user.js: 120KB      (用户中心,按需加载)
```

**收益:**
- ✅ 首屏只需加载800KB (vendor + common + home)
- ✅ 修改about.js不影响其他文件缓存
- ✅ 用户不访问的页面不会下载
- ✅ 多个文件可并行加载,提升速度

#### 1.2 核心收益

| 收益 | 说明 | 实际效果 |
|------|------|----------|
| **首屏优化** | 只加载必要代码 | 首屏时间减少30%-50% |
| **缓存优化** | 拆分不同变化频率的代码 | 缓存命中率提升60%+ |
| **按需加载** | 用到才加载 | 总下载量减少20%-40% |
| **并行加载** | 多文件同时下载 | 加载速度提升20%+ |

### 二、代码分割的三种方式

#### 2.1 方式一:Entry配置(手动分割)

**适用场景**:明确知道哪些模块需要分开打包

```javascript
module.exports = {
  entry: {
    // 主应用代码
    app: './src/main.js',
    // 第三方库单独打包
    vendor: ['vue', 'vue-router', 'axios', 'lodash']
  },
  output: {
    filename: '[name].[contenthash:8].js',
    path: path.resolve(__dirname, 'dist')
  }
}

// 输出:
// app.abc123.js
// vendor.def456.js
```

**优点:**
- 简单直接,容易理解
- 完全控制分割逻辑

**缺点:**
- 手动维护,容易遗漏
- 无法自动提取公共代码
- 多入口可能重复打包相同模块

#### 2.2 方式二:动态import()(路由懒加载)

**适用场景**:SPA路由懒加载、大型组件按需加载

**基础用法:**
```javascript
// 普通导入:打包到主bundle
import Home from './views/Home.vue';

// 动态导入:单独生成chunk
const About = () => import('./views/About.vue');

// 使用魔法注释命名chunk
const User = () => import(
  /* webpackChunkName: "user" */
  /* webpackPrefetch: true */
  './views/User.vue'
);
```

**路由懒加载示例(Vue Router):**
```javascript
const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import(/* webpackChunkName: "home" */ '@/views/Home.vue')
  },
  {
    path: '/about',
    name: 'About',
    component: () => import(/* webpackChunkName: "about" */ '@/views/About.vue')
  },
  {
    path: '/user',
    name: 'User',
    component: () => import(/* webpackChunkName: "user" */ '@/views/User.vue')
  }
];

// 生成的文件:
// home.abc123.js
// about.def456.js
// user.ghi789.js
```

**魔法注释说明:**
```javascript
import(
  /* webpackChunkName: "my-chunk" */      // 指定chunk名称
  /* webpackPrefetch: true */             // 空闲时预加载
  /* webpackPreload: true */              // 并行加载(优先级高)
  /* webpackMode: "lazy" */               // 加载模式:lazy/eager/weak/lazy-once
  './module.js'
)
```

**按需加载大型库:**
```javascript
// 需要图表时才加载echarts
async function renderChart(data) {
  const echarts = await import(/* webpackChunkName: "echarts" */ 'echarts');
  const chart = echarts.init(document.getElementById('chart'));
  chart.setOption(data);
}

// 只在某些页面需要moment.js
async function formatDate(date) {
  const moment = await import(/* webpackChunkName: "moment" */ 'moment');
  return moment(date).format('YYYY-MM-DD');
}
```

#### 2.3 方式三:SplitChunksPlugin(自动分割)

**适用场景**:自动提取公共代码、第三方库分离、缓存优化

**核心特点:**
- Webpack内置,无需安装
- 基于规则自动分析依赖
- 智能提取公共模块
- 配置灵活,功能强大

### 三、SplitChunksPlugin详解

#### 3.1 默认配置

```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'async',              // 处理哪些chunk:async(异步)/initial(同步)/all(所有)
      minSize: 20000,               // 最小体积(字节),小于此值不分割
      minRemainingSize: 0,          // 分割后剩余的最小体积
      minChunks: 1,                 // 最少被引用次数
      maxAsyncRequests: 30,         // 异步加载时最大并行请求数
      maxInitialRequests: 30,       // 入口点最大并行请求数
      enforceSizeThreshold: 50000,  // 强制分割的体积阈值
      cacheGroups: {                // 缓存组:自定义分割规则
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          reuseExistingChunk: true
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
}
```

#### 3.2 核心配置项详解

**1. chunks - 控制分割范围**

```javascript
splitChunks: {
  chunks: 'all',  // 推荐配置
  // chunks: 'async',    // 只处理异步chunk(默认)
  // chunks: 'initial',  // 只处理入口chunk
  // chunks: (chunk) => chunk.name !== 'excluded'  // 自定义函数
}
```

**对比示例:**
```javascript
// a.js
import { add } from './utils';
const subtract = () => import('./subtract');

// 配置chunks: 'async'
// 结果:subtract单独打包,utils.js留在a.js中

// 配置chunks: 'all'
// 结果:subtract和utils都可能被提取(取决于其他条件)
```

**2. minSize / maxSize - 控制体积**

```javascript
splitChunks: {
  minSize: 20000,    // 至少20KB才分割
  maxSize: 244000,   // 超过244KB尝试继续分割(非强制)
  minRemainingSize: 0  // 分割后剩余chunk的最小体积
}
```

**实际效果:**
```javascript
// 假设utils.js有50KB,被2个文件引用
// minSize: 20000 → ✅ 会提取(50KB > 20KB)
// minSize: 60000 → ❌ 不提取(50KB < 60KB)

// 假设vendor.js有300KB
// maxSize: 244000 → Webpack会尝试拆分(但可能拆不动)
```

**3. minChunks - 最少引用次数**

```javascript
splitChunks: {
  minChunks: 2  // 至少被2个chunk引用才提取
}
```

**示例:**
```javascript
// utils.js被home.js和about.js引用
// minChunks: 2 → ✅ 会提取为common chunk

// header.js只被home.js引用
// minChunks: 2 → ❌ 不提取,留在home.js中
```

**4. cacheGroups - 缓存组(核心)**

**作用:**定义不同类型模块的分割规则,可以覆盖默认配置。

**基础示例:**
```javascript
splitChunks: {
  cacheGroups: {
    // 提取node_modules中的代码
    vendor: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',
      chunks: 'all',
      priority: 10  // 优先级高
    },
    // 提取公共代码
    common: {
      minChunks: 2,
      name: 'common',
      chunks: 'all',
      priority: 5,
      reuseExistingChunk: true  // 复用已存在的chunk
    }
  }
}
```

**缓存组配置项:**
```javascript
cacheGroups: {
  myGroup: {
    test: /匹配规则/,              // 正则/函数,匹配模块路径
    name: 'chunk名称',            // 输出的chunk名称
    chunks: 'all',                // 处理范围
    priority: 10,                 // 优先级(数字越大越优先)
    minChunks: 2,                 // 覆盖外层配置
    minSize: 0,                   // 覆盖外层配置
    maxSize: 0,                   // 覆盖外层配置
    reuseExistingChunk: true,     // 复用已存在chunk
    enforce: true,                // 忽略minSize/maxSize/minChunks
    filename: '[name].bundle.js'  // 自定义输出文件名
  }
}
```

#### 3.3 实战配置示例

**示例1:基础优化(推荐配置)**

```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',  // 处理所有chunk
      cacheGroups: {
        // 第三方库
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        // 公共代码
        common: {
          minChunks: 2,
          name: 'common',
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
}

// 输出:
// vendors.js     (所有node_modules代码)
// common.js      (被多次引用的公共代码)
// home.js        (首页独有代码)
// about.js       (关于页独有代码)
```

**示例2:分离大型库**

```javascript
splitChunks: {
  chunks: 'all',
  cacheGroups: {
    // Vue全家桶
    vue: {
      test: /[\\/]node_modules[\\/](vue|vue-router|vuex)[\\/]/,
      name: 'vue',
      priority: 20
    },
    // Element UI
    elementUI: {
      test: /[\\/]node_modules[\\/]element-plus[\\/]/,
      name: 'element-ui',
      priority: 20
    },
    // 其他第三方库
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',
      priority: 10
    },
    // 公共代码
    common: {
      minChunks: 2,
      name: 'common',
      priority: 5
    }
  }
}

// 输出:
// vue.js          (Vue框架相关)
// element-ui.js   (UI库)
// vendors.js      (其他第三方库)
// common.js       (公共业务代码)
// home.js / about.js / ...
```

**示例3:按路由分组**

```javascript
splitChunks: {
  chunks: 'all',
  cacheGroups: {
    // 首页相关
    homeGroup: {
      test: /[\\/]src[\\/]views[\\/]home[\\/]/,
      name: 'home-group',
      priority: 10
    },
    // 用户中心相关
    userGroup: {
      test: /[\\/]src[\\/]views[\\/]user[\\/]/,
      name: 'user-group',
      priority: 10
    },
    // 通用vendor
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',
      priority: 5
    }
  }
}
```

**示例4:按文件大小分割**

```javascript
splitChunks: {
  chunks: 'all',
  minSize: 20000,      // 20KB
  maxSize: 200000,     // 200KB
  cacheGroups: {
    // 大型库单独分割
    largeLibs: {
      test: /[\\/]node_modules[\\/](echarts|moment|lodash)[\\/]/,
      name: (module) => {
        // 根据包名生成chunk名
        const packageName = module.context.match(
          /[\\/]node_modules[\\/](.*?)([\\/]|$)/
        )[1];
        return `npm.${packageName.replace('@', '')}`;
      },
      priority: 20
    },
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',
      priority: 10
    }
  }
}

// 输出:
// npm.echarts.js
// npm.moment.js
// npm.lodash.js
// vendors.js (其他小库)
```

**示例5:动态命名**

```javascript
splitChunks: {
  chunks: 'all',
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      name(module, chunks, cacheGroupKey) {
        // 根据引用该模块的chunk生成名称
        const allChunksNames = chunks.map(c => c.name).join('~');
        return `${cacheGroupKey}-${allChunksNames}`;
      },
      priority: 10
    }
  }
}

// 示例输出:
// vendors-home~about.js  (home和about共用的vendor)
// vendors-user.js        (user独有的vendor)
```

### 四、完整实战方案

#### 4.1 中小型SPA项目

```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 框架代码(变化少,单独缓存)
        framework: {
          test: /[\\/]node_modules[\\/](vue|vue-router|vuex|axios)[\\/]/,
          name: 'framework',
          priority: 20,
          reuseExistingChunk: true
        },
        // UI库(体积大,单独加载)
        ui: {
          test: /[\\/]node_modules[\\/]element-plus[\\/]/,
          name: 'ui',
          priority: 20
        },
        // 其他第三方库
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
          minChunks: 1
        },
        // 公共业务代码
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    },
    // 提取runtime代码
    runtimeChunk: {
      name: 'runtime'
    }
  }
}

// 输出结构:
// runtime.js       (webpack运行时,约1-2KB)
// framework.js     (Vue全家桶,约200KB)
// ui.js            (Element Plus,约500KB)
// vendors.js       (其他库,约100KB)
// common.js        (公共组件,约50KB)
// home.js          (首页,约30KB)
// about.js         (按需加载)
// user.js          (按需加载)
```

#### 4.2 大型多页应用

```javascript
module.exports = {
  entry: {
    app: './src/app.js',
    admin: './src/admin.js',
    mobile: './src/mobile.js'
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
      maxInitialRequests: 10,    // 增加初始请求数限制
      maxAsyncRequests: 10,
      cacheGroups: {
        // 核心库(所有页面共用)
        core: {
          test: /[\\/]node_modules[\\/](vue|vue-router|axios)[\\/]/,
          name: 'core',
          priority: 30,
          minChunks: 2
        },
        // 桌面端UI库
        desktopUI: {
          test: /[\\/]node_modules[\\/]element-plus[\\/]/,
          name: 'desktop-ui',
          priority: 20,
          chunks: (chunk) => {
            return chunk.name === 'app' || chunk.name === 'admin';
          }
        },
        // 移动端UI库
        mobileUI: {
          test: /[\\/]node_modules[\\/]vant[\\/]/,
          name: 'mobile-ui',
          priority: 20,
          chunks: (chunk) => chunk.name === 'mobile'
        },
        // 其他vendor
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        // 多页面公共代码
        common: {
          minChunks: 3,  // 至少3个页面引用
          name: 'common',
          priority: 5
        }
      }
    },
    runtimeChunk: {
      name: (entrypoint) => `runtime-${entrypoint.name}`
    }
  }
}

// 输出:
// runtime-app.js / runtime-admin.js / runtime-mobile.js
// core.js           (Vue核心)
// desktop-ui.js     (桌面端UI)
// mobile-ui.js      (移动端UI)
// vendors.js        (其他库)
// common.js         (3个页面共用的代码)
// app.js / admin.js / mobile.js
```

### 五、高级技巧

#### 5.1 预加载和预获取

```javascript
// prefetch:空闲时加载(低优先级)
const About = () => import(
  /* webpackPrefetch: true */
  './views/About.vue'
);

// preload:并行加载(高优先级)
const User = () => import(
  /* webpackPreload: true */
  './views/User.vue'
);

// 生成的HTML:
// <link rel="prefetch" href="about.js">
// <link rel="preload" href="user.js" as="script">
```

**使用建议:**
- **prefetch**:用于很可能会访问的页面(如导航栏的下一个页面)
- **preload**:用于当前页面必需但稍后加载的资源(如字体、关键组件)

#### 5.2 分析bundle组成

```bash
# 安装分析工具
npm install webpack-bundle-analyzer -D

# webpack.config.js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',      // 生成静态HTML
      openAnalyzer: false,
      reportFilename: 'bundle-report.html'
    })
  ]
}

# 运行构建后查看报告
npm run build
open dist/bundle-report.html
```

#### 5.3 按需加载第三方库

```javascript
// 错误:全量引入lodash(70KB)
import _ from 'lodash';
_.debounce(fn, 300);

// 正确1:按需引入具体函数
import debounce from 'lodash/debounce';
debounce(fn, 300);

// 正确2:使用babel-plugin-lodash自动转换
// .babelrc
{
  "plugins": [
    ["lodash", { "id": ["lodash"] }]
  ]
}

// 代码依然写全量导入
import { debounce } from 'lodash';
// 编译后自动转换为 import debounce from 'lodash/debounce';
```

#### 5.4 动态决定是否分割

```javascript
splitChunks: {
  chunks: (chunk) => {
    // 排除某些入口
    return chunk.name !== 'polyfills';
  },
  cacheGroups: {
    vendors: {
      test: (module) => {
        // 只分割大于100KB的包
        return (
          module.resource &&
          module.resource.includes('node_modules') &&
          module.size() > 100000
        );
      },
      name: 'large-vendors',
      priority: 10
    }
  }
}
```

### 六、常见问题与解决方案

#### 6.1 为什么配置了splitChunks但没生效?

**原因排查:**
1. **chunks配置错误**
   ```javascript
   // 错误:只处理异步chunk,但代码是同步导入
   splitChunks: { chunks: 'async' }
   import './common.js';  // 同步导入

   // 解决:改为all
   splitChunks: { chunks: 'all' }
   ```

2. **体积未达到minSize**
   ```javascript
   // 公共模块只有5KB
   splitChunks: { minSize: 20000 }  // 20KB

   // 解决:降低阈值
   splitChunks: { minSize: 0 }
   ```

3. **优先级不够**
   ```javascript
   // vendor的priority比default低
   cacheGroups: {
     vendor: { priority: 5 },
     default: { priority: 10 }  // default优先级更高
   }

   // 解决:提高vendor优先级
   cacheGroups: {
     vendor: { priority: 20 },
     default: { priority: 5 }
   }
   ```

#### 6.2 chunk过多导致请求过多?

**解决方案:**
```javascript
splitChunks: {
  maxInitialRequests: 5,   // 限制入口最多5个请求
  maxAsyncRequests: 5,     // 限制异步最多5个请求
  minSize: 30000,          // 提高最小体积
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',     // 合并为一个vendor
      priority: 10
    }
  }
}
```

#### 6.3 如何避免重复打包?

```javascript
splitChunks: {
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      priority: 10,
      reuseExistingChunk: true  // 关键:复用已存在的chunk
    }
  }
}
```

### 七、性能对比

**优化前:**
```
bundle.js: 2.5MB
首屏加载时间: 8s
缓存命中率: 20%
```

**优化后:**
```
runtime.js: 2KB
framework.js: 200KB   (缓存命中率95%)
ui.js: 500KB          (缓存命中率90%)
vendors.js: 100KB     (缓存命中率80%)
common.js: 50KB       (缓存命中率60%)
home.js: 30KB         (缓存命中率30%)

首屏加载时间: 3s (减少62.5%)
平均缓存命中率: 75% (提升3.75倍)
```

### 八、面试追问

**Q: chunks的async、initial、all有什么区别?**
A:
- `async`:只处理异步导入的模块(import()),适合路由懒加载
- `initial`:只处理同步导入的模块(import xxx),适合入口文件分割
- `all`:处理所有模块(推荐),可以最大化提取公共代码

**Q: priority优先级是如何工作的?**
A: 当一个模块同时匹配多个cacheGroups时,优先级高的规则生效。例如vue同时匹配`framework`(priority: 20)和`vendors`(priority: 10),会被分配到`framework`组。

**Q: reuseExistingChunk的作用是什么?**
A: 当模块已经被分割到某个chunk时,不再重复打包,而是复用已存在的chunk。避免同一个模块出现在多个bundle中。

**Q: 为什么要提取runtimeChunk?**
A: runtime代码包含模块映射关系,业务代码变化时runtime也会变化,导致vendor的hash也变。提取runtime后,vendor的hash保持稳定,提升缓存命中率。

**Q: maxInitialRequests和maxAsyncRequests如何选择?**
A:
- `maxInitialRequests`:控制首屏并行请求数,建议5-10,太多影响性能
- `maxAsyncRequests`:控制按需加载时的并行请求,可以设置大一些(10-30)
- HTTP/2环境下可以适当增大,因为支持多路复用

## 总结

**代码分割的黄金法则:**
1. **分离框架代码**:React/Vue等框架单独打包,缓存命中率最高
2. **分离大型库**:echarts、moment等大库独立chunk,按需加载
3. **提取公共代码**:被多个页面引用的代码提取为common
4. **路由懒加载**:非首屏路由使用import()动态加载
5. **合理设置阈值**:minSize不宜过小(避免过多请求),不宜过大(影响分割效果)

**核心配置模板:**
```javascript
splitChunks: {
  chunks: 'all',
  cacheGroups: {
    framework: { /* 框架代码 */ },
    vendors: { /* 第三方库 */ },
    common: { /* 公共代码 */ }
  }
},
runtimeChunk: 'single'
```

掌握代码分割是前端性能优化的核心技能之一,对提升用户体验和降低服务器成本都有显著效果。
