---
title: Webpack 的 Tree Shaking 原理和配置
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: webpack-tree-shaking-principle-configuration
ref:
---

## 核心要点

- **Tree Shaking定义**:移除JavaScript中未使用(dead code)的代码,减小bundle体积
- **实现基础**:依赖ES6 Module的静态结构(import/export),在编译时确定依赖关系
- **工作原理**:标记(Mark)未使用导出 → 摇树(Shake)移除dead code → 压缩(Minify)删除标记代码
- **生效条件**:production模式、ES6 Module、sideEffects配置、合理的导出方式

## 详细解答

### 一、Tree Shaking 是什么?

#### 1.1 概念理解

**形象比喻:**
```
一棵苹果树(代码库)
├── 红苹果(被使用的函数) ✅
├── 青苹果(被使用的函数) ✅
├── 枯叶(未使用的函数) ❌
└── 枯枝(未使用的模块) ❌

摇一摇树(Tree Shaking)
→ 枯叶和枯枝掉落(被移除)
→ 只留下新鲜的苹果(被使用的代码)
```

**实际示例:**
```javascript
// utils.js - 工具库
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {  // 未使用
  return a - b;
}

export function multiply(a, b) {  // 未使用
  return a * b;
}

// main.js - 只使用add函数
import { add } from './utils.js';
console.log(add(1, 2));

// 打包后(Tree Shaking生效)
// 只包含add函数,subtract和multiply被移除
function add(a, b) {
  return a + b;
}
console.log(add(1, 2));
```

#### 1.2 为什么需要 Tree Shaking?

**问题场景:**
```javascript
// 引入整个lodash库(70KB)
import _ from 'lodash';
_.debounce(fn, 300);  // 只用了一个函数

// 实际需要的只有debounce(~2KB)
// 但打包了整个lodash → 浪费68KB
```

**收益:**
```javascript
// 使用Tree Shaking
import { debounce } from 'lodash-es';  // ES6 Module版本

// 打包结果:只包含debounce及其依赖(~2KB)
// 减少体积: 68KB → 节省96%的空间
```

**实际数据对比:**

| 场景 | 未优化 | Tree Shaking后 | 减少 |
|------|--------|----------------|------|
| lodash全量 | 70KB | 2KB | 97% |
| moment.js | 230KB | 60KB | 74% |
| antd全量 | 1.2MB | 200KB | 83% |
| 业务代码 | 500KB | 350KB | 30% |

### 二、Tree Shaking 的工作原理

#### 2.1 核心依赖:ES6 Module

**为什么必须是ES6 Module?**

**ES6 Module(静态结构):**
```javascript
// ✅ 静态导入:编译时确定
import { add } from './utils';  // 编译时就知道只用add

// ✅ 静态导出
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// Webpack在编译时分析:
// "main.js只导入了add,subtract未被使用" → 标记为dead code
```

**CommonJS(动态结构):**
```javascript
// ❌ 动态导入:运行时才确定
const utils = require('./utils');
const add = utils[Math.random() > 0.5 ? 'add' : 'subtract'];

// Webpack编译时无法确定会用哪个函数
// 只能保留所有代码 → 无法Tree Shaking
```

**对比表:**

| 特性 | ES6 Module | CommonJS |
|------|-----------|----------|
| 加载时机 | 编译时(静态) | 运行时(动态) |
| 导入方式 | `import { add }` | `require().add` |
| 导出方式 | `export function` | `module.exports =` |
| Tree Shaking | ✅ 支持 | ❌ 不支持 |
| 示例库 | lodash-es, vue, react | lodash, moment |

#### 2.2 三阶段工作流程

**阶段1:标记(Mark) - 标记未使用代码**

```javascript
// utils.js
export function used() { /* 被使用 */ }
export function unused() { /* 未使用 */ }

// main.js
import { used } from './utils';
used();

// Webpack分析后添加标记注释:
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "used": () => (/* binding */ used)
/* harmony export */ });
/* unused harmony export unused */  // ← 标记为未使用

function used() { /* ... */ }
function unused() { /* ... */ }  // ← 这段代码被标记
```

**阶段2:摇树(Shake) - 移除dead code**

```javascript
// Webpack的optimization.usedExports开启后
// 会在生成的代码中移除unused标记的导出

// 生成的bundle(简化版):
__webpack_require__.d(__webpack_exports__, {
  "used": () => (/* binding */ used)
  // unused没有被导出
});

function used() { /* ... */ }
function unused() { /* ... */ }  // ← 依然存在,但未导出
```

**阶段3:压缩(Minify) - 彻底删除**

```javascript
// TerserPlugin(压缩工具)分析:
// "unused函数没有被任何地方引用" → 删除

// 最终bundle:
function used() { /* ... */ }
// unused函数被完全删除
```

#### 2.3 流程图

```
源代码
  ↓
Webpack解析(Parse)
  ↓
分析依赖图(Dependency Graph)
  ↓
标记未使用导出(Mark unused exports)
  → optimization.usedExports: true
  ↓
生成bundle(带标记注释)
  ↓
Terser压缩(Minify)
  → 删除未引用代码
  ↓
最终bundle(只含使用的代码)
```

### 三、Webpack 配置 Tree Shaking

#### 3.1 基础配置(开启Tree Shaking)

```javascript
// webpack.config.js
module.exports = {
  mode: 'production',  // 关键1:自动启用优化

  optimization: {
    usedExports: true,  // 关键2:标记未使用导出
    minimize: true,     // 关键3:启用压缩
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            unused: true,        // 删除未使用函数
            dead_code: true      // 删除不可达代码
          }
        }
      })
    ]
  }
}
```

**mode: 'production' 自动开启的优化:**
```javascript
// 等价于以下配置:
{
  optimization: {
    usedExports: true,
    minimize: true,
    concatenateModules: true,  // Scope Hoisting
    sideEffects: true          // 使用package.json的sideEffects字段
  }
}
```

#### 3.2 sideEffects 配置(关键优化)

**什么是副作用(Side Effect)?**
```javascript
// 有副作用的代码(不能删除)
import './polyfill.js';      // 修改全局对象
import './global.css';       // 修改DOM样式
console.log('I am here');    // 控制台输出
window.myGlobal = 123;       // 修改window对象

// 无副作用的代码(可以安全删除)
export function add(a, b) {
  return a + b;  // 纯函数,无副作用
}
```

**package.json配置:**

**方式1:标记整个包无副作用**
```json
{
  "name": "my-library",
  "sideEffects": false  // 所有文件都无副作用
}
```

**方式2:指定有副作用的文件**
```json
{
  "name": "my-library",
  "sideEffects": [
    "*.css",                    // 所有CSS文件
    "*.scss",
    "./src/polyfill.js",        // 特定JS文件
    "./src/global-setup.js"
  ]
}
```

**实际效果对比:**

```javascript
// utils.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// main.js
import './utils';  // 导入但未使用任何导出

// sideEffects: false
// 结果:utils.js完全被移除(整个文件被认为无副作用)

// sideEffects: true (或未配置)
// 结果:utils.js保留(可能有副作用,不能删除)
```

**常见库的sideEffects配置:**

```json
// lodash-es/package.json
{
  "sideEffects": false  // 所有函数都是纯函数
}

// antd/package.json
{
  "sideEffects": [
    "dist/*",
    "es/**/style/*",
    "lib/**/style/*",
    "*.less"
  ]
}

// vue/package.json
{
  "sideEffects": false
}
```

#### 3.3 导出方式的影响

**✅ 推荐:命名导出(Named Exports)**
```javascript
// utils.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }
export function multiply(a, b) { return a * b; }

// main.js
import { add } from './utils';  // ✅ 只导入add
// Tree Shaking:subtract和multiply被移除
```

**❌ 不推荐:默认导出对象**
```javascript
// utils.js
export default {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b
}

// main.js
import utils from './utils';
utils.add(1, 2);

// ❌ Tree Shaking失效:整个对象被保留
// 原因:Webpack无法确定对象的哪些属性会被使用
```

**✅ 优化:拆分为独立文件**
```javascript
// add.js
export function add(a, b) { return a + b; }

// subtract.js
export function subtract(a, b) { return a - b; }

// index.js
export { add } from './add';
export { subtract } from './subtract';

// main.js
import { add } from './utils';  // ✅ 只打包add.js
```

#### 3.4 第三方库的 Tree Shaking

**方式1:使用ES6 Module版本**
```javascript
// ❌ CommonJS版本(不支持Tree Shaking)
import _ from 'lodash';
_.debounce(fn, 300);  // 打包整个lodash(70KB)

// ✅ ES6 Module版本
import { debounce } from 'lodash-es';
debounce(fn, 300);  // 只打包debounce(~2KB)
```

**方式2:按需引入**
```javascript
// ❌ 全量引入
import { Button, Modal, Table } from 'antd';

// ✅ 使用babel-plugin-import自动按需引入
// .babelrc
{
  "plugins": [
    ["import", {
      "libraryName": "antd",
      "libraryDirectory": "es",
      "style": "css"
    }]
  ]
}

// 代码写全量导入
import { Button, Modal } from 'antd';
// 编译后自动转换为:
import Button from 'antd/es/button';
import 'antd/es/button/style/css';
import Modal from 'antd/es/modal';
import 'antd/es/modal/style/css';
```

**方式3:直接引入具体路径**
```javascript
// ✅ 直接引入子模块
import Button from 'antd/es/button';
import 'antd/es/button/style/css';
```

### 四、实战配置示例

#### 4.1 基础项目配置

```javascript
// webpack.config.js
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  mode: 'production',

  optimization: {
    usedExports: true,
    sideEffects: true,
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            unused: true,
            dead_code: true,
            pure_funcs: ['console.log']  // 移除console.log
          },
          mangle: true  // 变量名混淆
        }
      })
    ]
  },

  // 配置resolve,优先使用ES6 Module
  resolve: {
    mainFields: ['module', 'main'],  // 优先读取package.json的module字段
    extensions: ['.mjs', '.js', '.json']
  }
}

// package.json
{
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/polyfill.js"
  ]
}
```

#### 4.2 Vue/React项目配置

**Vue3项目:**
```javascript
// webpack.config.js
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: true
  },
  resolve: {
    alias: {
      // 使用ES Module版本的Vue
      'vue': 'vue/dist/vue.esm-bundler.js'
    }
  }
}

// 使用方式
import { ref, computed } from 'vue';  // ✅ 只打包用到的API
```

**React项目:**
```javascript
// webpack.config.js
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: true
  }
}

// React 17+自动支持Tree Shaking
import { useState, useEffect } from 'react';  // ✅ 自动优化
```

#### 4.3 库开发者配置

```javascript
// package.json(发布给别人使用的库)
{
  "name": "my-awesome-lib",
  "version": "1.0.0",
  "main": "dist/index.js",           // CommonJS入口
  "module": "dist/index.esm.js",     // ES Module入口(关键!)
  "sideEffects": false,               // 声明无副作用
  "exports": {
    ".": {
      "import": "./dist/index.esm.js",
      "require": "./dist/index.js"
    },
    "./utils": {
      "import": "./dist/utils.esm.js",
      "require": "./dist/utils.js"
    }
  }
}

// rollup.config.js(库打包配置)
export default {
  input: 'src/index.js',
  output: [
    {
      file: 'dist/index.js',
      format: 'cjs'  // CommonJS
    },
    {
      file: 'dist/index.esm.js',
      format: 'esm'  // ES Module(支持Tree Shaking)
    }
  ],
  external: ['react', 'vue']  // 外部依赖不打包
}
```

### 五、常见问题与解决方案

#### 5.1 为什么配置了Tree Shaking但没生效?

**原因1:使用了CommonJS模块**
```javascript
// ❌ 错误
const { add } = require('./utils');  // CommonJS

// ✅ 正确
import { add } from './utils';  // ES6 Module
```

**原因2:Babel配置错误**
```json
// .babelrc
{
  "presets": [
    ["@babel/preset-env", {
      "modules": false  // ⚠️ 关键:不转换ES6 Module
    }]
  ]
}

// ❌ 错误配置:modules默认值会转为CommonJS
{
  "presets": ["@babel/preset-env"]  // 等同于 "modules": "auto"
}
```

**原因3:副作用未正确标记**
```javascript
// utils.js
console.log('utils loaded');  // ← 副作用代码
export function add(a, b) { return a + b; }

// main.js
import './utils';  // 导入但未使用导出

// package.json未配置sideEffects
// 结果:utils.js被保留(可能有副作用)

// 解决方案:
{
  "sideEffects": false  // 或移除console.log
}
```

**原因4:开发模式下**
```javascript
// ❌ development模式下Tree Shaking不完全生效
mode: 'development'

// ✅ 必须是production模式
mode: 'production'
```

#### 5.2 CSS的Tree Shaking

**问题:CSS无法像JS一样自动Tree Shaking**

**解决方案:使用PurgeCSS**
```javascript
// webpack.config.js
const PurgeCSSPlugin = require('purgecss-webpack-plugin');
const glob = require('glob');

module.exports = {
  plugins: [
    new PurgeCSSPlugin({
      paths: glob.sync(`${path.join(__dirname, 'src')}/**/*`, { nodir: true }),
      safelist: ['body', 'html']  // 保留的类名
    })
  ]
}

// 效果:
// 原始CSS: 500KB (包含整个Bootstrap)
// 处理后: 50KB (只保留用到的样式)
```

**Tailwind CSS的Tree Shaking:**
```javascript
// tailwind.config.js
module.exports = {
  content: [
    './src/**/*.{js,jsx,ts,tsx,vue,html}'  // 扫描这些文件
  ],
  // Tailwind会自动移除未使用的样式类
}
```

#### 5.3 动态导入的Tree Shaking

```javascript
// ❌ 动态属性访问:无法Tree Shaking
const moduleName = 'utils';
import(`./${moduleName}`).then(mod => {
  mod.add(1, 2);  // Webpack不知道会用哪个函数
});

// ✅ 静态路径+命名导入
import('./utils').then(({ add }) => {
  add(1, 2);  // ✅ subtract和multiply可以被移除
});
```

### 六、验证Tree Shaking效果

#### 6.1 查看打包分析

```bash
# 安装分析工具
npm install webpack-bundle-analyzer -D

# webpack.config.js
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}

# 运行构建
npm run build
# 自动打开可视化报告,查看各模块体积
```

#### 6.2 对比构建产物

```bash
# 关闭Tree Shaking
npx webpack --mode production --optimization-used-exports false

# 开启Tree Shaking
npx webpack --mode production

# 对比bundle体积
ls -lh dist/*.js
```

#### 6.3 查看生成代码

```javascript
// 设置生成易读代码
module.exports = {
  mode: 'production',
  optimization: {
    minimize: false  // 暂时禁用压缩,查看标记
  }
}

// 打包后查看dist/main.js
// 搜索 "unused harmony export" 查看未使用的导出
```

### 七、最佳实践

#### 7.1 代码编写规范

```javascript
// ✅ 推荐:命名导出+纯函数
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// ❌ 避免:默认导出对象
export default {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b
}

// ❌ 避免:导出时执行副作用
export const config = (() => {
  console.log('init');  // 副作用
  return { value: 123 };
})();

// ✅ 推荐:延迟执行
export function getConfig() {
  return { value: 123 };
}
```

#### 7.2 第三方库选择

```javascript
// 优先选择支持Tree Shaking的库:
✅ lodash-es (ES6 Module版本)
✅ date-fns (代替moment,天然支持Tree Shaking)
✅ Vue 3 (完全支持Tree Shaking)
✅ React 17+ (自动优化)

// 避免:
❌ lodash (CommonJS)
❌ moment (整体导入230KB)
❌ jQuery (单体库)
```

#### 7.3 Monorepo项目

```javascript
// lerna.json / pnpm-workspace.yaml
{
  "packages": ["packages/*"]
}

// packages/utils/package.json
{
  "name": "@my-org/utils",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",  // 关键
  "sideEffects": false
}

// 使用方导入
import { add } from '@my-org/utils';  // ✅ 自动Tree Shaking
```

### 八、性能对比

**实际项目优化数据:**

| 优化项 | 优化前 | 优化后 | 减少 |
|--------|--------|--------|------|
| lodash改为lodash-es | 70KB | 2KB | 97% |
| moment改为date-fns | 230KB | 15KB | 93% |
| antd按需引入 | 1.2MB | 180KB | 85% |
| 移除未使用组件 | 500KB | 320KB | 36% |
| CSS Tree Shaking | 300KB | 45KB | 85% |
| **总体优化** | **2.3MB** | **562KB** | **76%** |

### 九、面试追问

**Q: Tree Shaking和Dead Code Elimination的区别?**
A: Tree Shaking是DCE的一种,特指基于ES6 Module的静态分析移除未使用代码。DCE是更广义的概念,包括移除不可达代码、无用变量等。

**Q: 为什么CommonJS不支持Tree Shaking?**
A: CommonJS的require()是动态的,可以在运行时条件导入(`if (x) require('a') else require('b')`),Webpack编译时无法确定会加载哪个模块。ES6 Module的import必须在顶层且静态,编译时就能分析依赖。

**Q: sideEffects: false 有什么风险?**
A: 如果代码中有副作用(如修改全局变量、导入CSS)但标记为无副作用,这些代码会被错误移除。例如`import './polyfill.js'`如果被Tree Shaking掉,会导致功能异常。

**Q: usedExports和sideEffects的区别?**
A:
- `usedExports`:分析哪些导出被使用,标记未使用的导出
- `sideEffects`:标记模块是否有副作用,无副作用的模块整个文件都可以删除
- 两者配合才能达到最佳效果

**Q: 如何验证库是否支持Tree Shaking?**
A: 检查package.json的`module`字段(指向ES Module入口)和`sideEffects`配置。可以实际构建测试,只导入一个函数,查看bundle是否只包含该函数。

## 总结

**Tree Shaking的黄金法则:**

1. **使用ES6 Module**:import/export代替require/module.exports
2. **配置Babel正确**:`modules: false`保留ES6 Module
3. **标记副作用**:package.json配置`sideEffects`
4. **选对库**:优先使用lodash-es、date-fns等支持Tree Shaking的库
5. **命名导出**:避免`export default`导出对象
6. **生产模式**:只有production模式才完全生效

**核心配置:**
```javascript
{
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: true,
    minimize: true
  }
}
```

**package.json:**
```json
{
  "sideEffects": false,
  "module": "dist/index.esm.js"
}
```

掌握Tree Shaking是现代前端优化的必备技能,对减小bundle体积、提升加载速度有显著效果,通常可减少30%-80%的代码体积!
