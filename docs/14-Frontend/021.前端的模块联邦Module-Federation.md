---
title: 前端的模块联邦（Module Federation）
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: module-federation-frontend
ref:
---

## 核心要点

- **概念**:Webpack 5 的革命性功能,实现运行时动态加载和共享模块
- **解决问题**:跨应用代码共享、微前端架构、减少重复打包
- **核心能力**:独立部署、独立开发、共享依赖、动态加载
- **适用场景**:大型项目拆分、多团队协作、组件/工具共享

---

## 详细回答

### 一、什么是模块联邦?

模块联邦(Module Federation)是 Webpack 5 引入的一项革命性功能,它允许多个独立构建的应用在**运行时**共享代码和依赖,而不需要在构建时将所有代码打包到一起。

**核心思想**:将一个应用的部分模块暴露出来,供其他应用在运行时动态加载使用。

### 二、核心概念

#### 1. Host(宿主应用)
消费其他应用模块的应用。
```javascript
// webpack.config.js (Host)
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    app1: 'app1@http://localhost:3001/remoteEntry.js',
    app2: 'app2@http://localhost:3002/remoteEntry.js',
  },
  shared: ['react', 'react-dom']
})
```

#### 2. Remote(远程应用)
暴露模块供其他应用使用的应用。
```javascript
// webpack.config.js (Remote)
new ModuleFederationPlugin({
  name: 'app1',
  filename: 'remoteEntry.js',
  exposes: {
    './Button': './src/components/Button',
    './utils': './src/utils',
  },
  shared: ['react', 'react-dom']
})
```

#### 3. Shared(共享依赖)
多个应用共享的依赖,避免重复加载。

### 三、工作原理

```
┌─────────────┐                    ┌─────────────┐
│   Host App  │                    │  Remote App │
│             │                    │             │
│  ┌────────┐ │  1. 加载 Remote   │  ┌────────┐ │
│  │ Button │◄├────Entry.js────────┤  │ Button │ │
│  └────────┘ │                    │  └────────┘ │
│             │  2. 动态导入组件   │             │
│  ┌────────┐ │◄───────────────────┤  ┌────────┐ │
│  │ React  │ │  3. 共享依赖       │  │ React  │ │
│  └────────┘ │                    │  └────────┘ │
└─────────────┘                    └─────────────┘
```

**核心流程**:
1. Host 应用启动时加载 Remote 的 `remoteEntry.js`(清单文件)
2. 通过清单文件了解 Remote 暴露了哪些模块
3. 按需动态加载所需模块
4. 自动协调共享依赖版本,避免重复加载

### 四、实际使用示例

#### Remote 应用(暴露模块)

```javascript
// remote-app/webpack.config.js
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  output: {
    publicPath: 'http://localhost:3001/',
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'remoteApp',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/components/Button',
        './Header': './src/components/Header',
      },
      shared: {
        react: { singleton: true, requiredVersion: '^18.0.0' },
        'react-dom': { singleton: true, requiredVersion: '^18.0.0' },
      },
    }),
  ],
};
```

```jsx
// remote-app/src/components/Button.jsx
export default function Button({ children, onClick }) {
  return <button onClick={onClick}>{children}</button>;
}
```

#### Host 应用(消费模块)

```javascript
// host-app/webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'hostApp',
      remotes: {
        remoteApp: 'remoteApp@http://localhost:3001/remoteEntry.js',
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

```jsx
// host-app/src/App.jsx
import React, { lazy, Suspense } from 'react';

// 动态导入 Remote 组件
const RemoteButton = lazy(() => import('remoteApp/Button'));

function App() {
  return (
    <div>
      <h1>Host Application</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <RemoteButton onClick={() => alert('点击!')}>
          来自 Remote 的按钮
        </RemoteButton>
      </Suspense>
    </div>
  );
}
```

### 五、核心配置详解

#### 1. shared 配置策略

```javascript
shared: {
  // 基础配置
  'react': {
    singleton: true,        // 确保只加载一个版本
    eager: false,           // 是否立即加载(非异步)
    requiredVersion: '^18', // 版本要求
    strictVersion: false,   // 是否严格版本匹配
  },

  // 简写方式
  'lodash': '^4.17.0',

  // 共享多个包
  ...['react', 'react-dom'].reduce((acc, lib) => {
    acc[lib] = { singleton: true };
    return acc;
  }, {})
}
```

#### 2. exposes 配置技巧

```javascript
exposes: {
  // 暴露单个组件
  './Button': './src/components/Button',

  // 暴露目录
  './components': './src/components/index',

  // 暴露工具函数
  './utils': './src/utils',

  // 暴露 Store
  './store': './src/store',
}
```

### 六、优势与挑战

#### 优势

1. **真正的独立部署**
   - 每个应用独立构建、部署、更新
   - 无需重新构建整个项目

2. **减少重复打包**
   - 共享依赖只加载一次
   - 减少总体包体积

3. **技术栈灵活**
   - 不同应用可使用不同版本的框架
   - 渐进式升级变得可能

4. **开发体验好**
   - 每个团队独立开发
   - 本地开发支持热更新

#### 挑战

1. **版本管理复杂**
   - 需要协调共享依赖版本
   - 可能出现版本冲突

2. **类型支持弱**
   - TypeScript 类型需要额外配置
   - 需要手动维护类型定义

3. **调试困难**
   - 跨应用调试复杂
   - 错误堆栈可能不清晰

4. **网络依赖**
   - 依赖网络加载远程模块
   - 需要处理加载失败情况

### 七、最佳实践

#### 1. 错误处理

```jsx
import React, { lazy, Suspense } from 'react';

const RemoteButton = lazy(() =>
  import('remoteApp/Button').catch(() => {
    // 降级方案
    return import('./FallbackButton');
  })
);

function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<Skeleton />}>
        <RemoteButton />
      </Suspense>
    </ErrorBoundary>
  );
}
```

#### 2. TypeScript 支持

```typescript
// host-app/src/types/remoteApp.d.ts
declare module 'remoteApp/Button' {
  const Button: React.FC<{
    children: React.ReactNode;
    onClick: () => void;
  }>;
  export default Button;
}
```

#### 3. 环境变量管理

```javascript
// 根据环境动态配置 Remote 地址
const remotes = {
  development: 'remoteApp@http://localhost:3001/remoteEntry.js',
  production: 'remoteApp@https://cdn.example.com/remoteEntry.js',
};

new ModuleFederationPlugin({
  remotes: {
    remoteApp: remotes[process.env.NODE_ENV],
  },
});
```

#### 4. 共享状态管理

```javascript
// 通过 exposes 共享 Store
// remote-app
exposes: {
  './store': './src/store',
}

// host-app
import remoteStore from 'remoteApp/store';
// 合并到主应用 Store
```

### 八、与微前端方案对比

| 特性 | Module Federation | qiankun | Micro-App |
|-----|------------------|---------|-----------|
| 实现原理 | Webpack 插件 | JS 沙箱 | Web Component |
| 粒度 | 模块级别 | 应用级别 | 应用级别 |
| 样式隔离 | 需要自行处理 | 支持 | 天然隔离 |
| JS 隔离 | 共享作用域 | Proxy 沙箱 | 天然隔离 |
| 构建工具依赖 | 需要 Webpack 5 | 无限制 | 无限制 |
| 性能 | 优秀 | 良好 | 优秀 |

### 九、适用场景

✅ **适合使用**:
- 多个 Webpack 项目需要共享代码
- 大型项目拆分为多个独立应用
- 组件库/工具库跨项目共享
- 需要独立部署和快速迭代

❌ **不适合使用**:
- 小型项目(增加复杂度)
- 不使用 Webpack(需要 Webpack 5+)
- 需要强样式隔离(需要额外处理)
- 对首屏性能要求极高(增加网络请求)

### 十、总结

模块联邦是 Webpack 5 带来的重大创新,它从构建工具层面解决了微前端的核心问题——**运行时代码共享**。相比传统的 iframe 或 JS 沙箱方案,它更轻量、性能更好,且开发体验更友好。

但它也不是银弹,需要团队有一定的工程化能力,能够处理版本管理、错误处理等复杂场景。在合适的场景下,模块联邦能够显著提升大型项目的开发效率和部署灵活性。
