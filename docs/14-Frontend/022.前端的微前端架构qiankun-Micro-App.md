---
title: 前端的微前端架构（qiankun、Micro App）
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: micro-frontend-architecture-qiankun-micro-app
ref:
---

## 核心要点

- **概念**:将大型前端应用拆分为多个独立子应用,各自开发、部署、运行
- **核心价值**:技术栈无关、独立部署、增量升级、团队自治
- **主流方案**:qiankun(阿里)、Micro-App(京东)、single-spa、无界
- **核心技术**:应用加载、JS 沙箱、样式隔离、应用通信

---

## 详细回答

### 一、什么是微前端?

微前端是一种类似于微服务的架构,它将前端应用拆分为多个**独立的、可独立部署的子应用**,通过一个主应用(基座)进行统一管理和协调。

**核心思想**:
```
传统单体应用:  [────────── 一个大应用 ──────────]

微前端架构:   [主应用]
                ├── [子应用A - React]
                ├── [子应用B - Vue]
                └── [子应用C - Angular]
```

### 二、为什么需要微前端?

#### 1. 解决的核心问题

| 问题 | 传统方案 | 微前端方案 |
|-----|---------|-----------|
| 技术栈升级 | 全量改造,风险大 | 逐步迁移,增量升级 |
| 团队协作 | 代码冲突频繁 | 独立开发,互不干扰 |
| 部署上线 | 牵一发动全身 | 独立部署,互不影响 |
| 代码规模 | 项目越来越大 | 拆分为多个小应用 |

#### 2. 适用场景

✅ **适合使用**:
- 多团队协作的大型项目
- 需要技术栈渐进式升级
- 历史项目需要重构但无法推倒重来
- 不同业务模块由不同团队负责

❌ **不适合使用**:
- 小型项目(增加复杂度)
- 团队规模小(管理成本高)
- 子应用间交互频繁(通信成本高)
- 对首屏性能要求极高

### 三、qiankun 架构详解

#### 1. 核心架构

```
┌─────────────────────────────────────────┐
│           主应用 (Base App)              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │ 路由管理 │  │ 应用注册 │  │ 生命周期 │ │
│  └─────────┘  └─────────┘  └─────────┘ │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │ JS 沙箱 │  │ 样式隔离 │  │ 应用通信 │ │
│  └─────────┘  └─────────┘  └─────────┘ │
└─────────────────────────────────────────┘
         │           │           │
    ┌────┴────┐ ┌────┴────┐ ┌────┴────┐
    │ 子应用A │ │ 子应用B │ │ 子应用C │
    │ (React) │ │  (Vue)  │ │(Angular)│
    └─────────┘ └─────────┘ └─────────┘
```

#### 2. 主应用实现

```javascript
// main-app/src/main.js
import { registerMicroApps, start } from 'qiankun';

// 注册子应用
registerMicroApps([
  {
    name: 'reactApp',                    // 应用名称
    entry: '//localhost:3001',           // 应用地址
    container: '#subapp-container',      // 挂载容器
    activeRule: '/react',                // 激活路径
    props: {                             // 传递给子应用的数据
      data: { user: 'admin' },
      onGlobalStateChange,
      setGlobalState,
    },
  },
  {
    name: 'vueApp',
    entry: '//localhost:3002',
    container: '#subapp-container',
    activeRule: '/vue',
  },
]);

// 启动 qiankun
start({
  sandbox: { strictStyleIsolation: true }, // 严格样式隔离
  prefetch: true,                          // 预加载子应用
  singular: false,                         // 允许多个子应用同时挂载
});
```

```jsx
// main-app/src/App.jsx
import { Link } from 'react-router-dom';

function App() {
  return (
    <div>
      <nav>
        <Link to="/react">React 子应用</Link>
        <Link to="/vue">Vue 子应用</Link>
      </nav>
      {/* 子应用挂载容器 */}
      <div id="subapp-container"></div>
    </div>
  );
}
```

#### 3. 子应用实现 (React)

```javascript
// react-app/src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

// 独立运行时的渲染函数
function render(props = {}) {
  const { container } = props;
  ReactDOM.render(
    <App />,
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}

// 非 qiankun 环境下直接渲染
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

// qiankun 生命周期钩子
export async function bootstrap() {
  console.log('react app bootstraped');
}

export async function mount(props) {
  console.log('react app mount', props);
  render(props);
}

export async function unmount(props) {
  const { container } = props;
  ReactDOM.unmountComponentAtNode(
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}
```

```javascript
// react-app/config-overrides.js (配置跨域和 UMD 打包)
const { name } = require('./package.json');

module.exports = {
  webpack: (config) => {
    config.output.library = `${name}-[name]`;
    config.output.libraryTarget = 'umd';
    config.output.globalObject = 'window';
    return config;
  },
  devServer: (configFunction) => {
    return function (proxy, allowedHost) {
      const config = configFunction(proxy, allowedHost);
      config.headers = {
        'Access-Control-Allow-Origin': '*',
      };
      return config;
    };
  },
};
```

#### 4. 子应用实现 (Vue)

```javascript
// vue-app/src/main.js
import Vue from 'vue';
import App from './App.vue';
import router from './router';

let instance = null;

function render(props = {}) {
  const { container } = props;
  instance = new Vue({
    router,
    render: (h) => h(App),
  }).$mount(container ? container.querySelector('#app') : '#app');
}

// 独立运行
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

// 生命周期钩子
export async function bootstrap() {
  console.log('vue app bootstraped');
}

export async function mount(props) {
  render(props);
}

export async function unmount() {
  instance.$destroy();
  instance.$el.innerHTML = '';
  instance = null;
}
```

```javascript
// vue-app/vue.config.js
const { name } = require('./package.json');

module.exports = {
  devServer: {
    port: 3002,
    headers: {
      'Access-Control-Allow-Origin': '*',
    },
  },
  configureWebpack: {
    output: {
      library: `${name}-[name]`,
      libraryTarget: 'umd',
      globalObject: 'window',
    },
  },
};
```

### 四、核心技术实现

#### 1. JS 沙箱隔离

qiankun 提供三种沙箱模式:

**SnapshotSandbox (快照沙箱)**
```javascript
class SnapshotSandbox {
  constructor() {
    this.windowSnapshot = {};
    this.modifyPropsMap = {};
  }

  active() {
    // 保存当前 window 快照
    this.windowSnapshot = {};
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop];
    }

    // 恢复上次修改
    Object.keys(this.modifyPropsMap).forEach((prop) => {
      window[prop] = this.modifyPropsMap[prop];
    });
  }

  inactive() {
    // 记录本次修改
    for (const prop in window) {
      if (window[prop] !== this.windowSnapshot[prop]) {
        this.modifyPropsMap[prop] = window[prop];
        window[prop] = this.windowSnapshot[prop];
      }
    }
  }
}
```

**ProxySandbox (代理沙箱) - 推荐**
```javascript
class ProxySandbox {
  constructor() {
    this.fakeWindow = {};
    this.proxy = new Proxy(this.fakeWindow, {
      get: (target, prop) => {
        // 优先从 fakeWindow 取值
        return prop in target ? target[prop] : window[prop];
      },
      set: (target, prop, value) => {
        // 修改记录到 fakeWindow
        target[prop] = value;
        return true;
      },
    });
  }

  active() {
    this.active = true;
  }

  inactive() {
    this.active = false;
  }
}
```

#### 2. 样式隔离方案

**方案一:严格样式隔离 (Shadow DOM)**
```javascript
start({
  sandbox: {
    strictStyleIsolation: true, // 开启 Shadow DOM
  },
});
```

**方案二:作用域隔离 (增加前缀)**
```javascript
start({
  sandbox: {
    experimentalStyleIsolation: true, // 动态添加前缀
  },
});

// 生成的 CSS
.app1__container { /* ... */ }
.app1__button { /* ... */ }
```

**方案三:手动命名空间**
```css
/* 子应用统一前缀 */
.react-app {
  .container { /* ... */ }
  .button { /* ... */ }
}
```

#### 3. 应用间通信

**方式一:qiankun 官方通信 (推荐)**
```javascript
// 主应用
import { initGlobalState } from 'qiankun';

const actions = initGlobalState({ user: 'admin', token: 'xxx' });

// 监听变化
actions.onGlobalStateChange((state, prev) => {
  console.log('状态变化:', state, prev);
});

// 修改状态
actions.setGlobalState({ user: 'new user' });

// 子应用
export async function mount(props) {
  // 监听变化
  props.onGlobalStateChange((state, prev) => {
    console.log('子应用收到:', state);
  });

  // 修改状态
  props.setGlobalState({ token: 'new token' });
}
```

**方式二:自定义事件总线**
```javascript
// event-bus.js
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach((cb) => cb(data));
    }
  }
}

window.__MICRO_APP_EVENT_BUS__ = new EventBus();
```

### 五、Micro-App 架构详解

#### 1. 核心特点

Micro-App 基于 **Web Component** 实现,使用更简单:

```javascript
// 主应用 - 无需安装 SDK
import microApp from '@micro-zoe/micro-app';

microApp.start();
```

```html
<!-- 使用自定义元素加载子应用 -->
<micro-app
  name="reactApp"
  url="http://localhost:3001/"
  baseroute="/react"
></micro-app>
```

#### 2. 优势对比

| 特性 | qiankun | Micro-App |
|-----|---------|-----------|
| 实现方式 | JS 劫持 | Web Component |
| 接入成本 | 中 | 低 |
| 样式隔离 | 配置开启 | 天然隔离 |
| JS 隔离 | Proxy 沙箱 | iframe 沙箱 |
| 子应用改造 | 需要导出生命周期 | 几乎无需改造 |
| 性能 | 好 | 好 |

#### 3. 实际使用

```javascript
// main-app/src/main.js
import microApp from '@micro-zoe/micro-app';

microApp.start({
  'disable-memory-router': true,  // 关闭虚拟路由
  'disable-patch-request': true,  // 关闭请求拦截
});
```

```jsx
// main-app/src/App.jsx
import { useState } from 'react';

function App() {
  const [data, setData] = useState({ user: 'admin' });

  return (
    <div>
      <micro-app
        name="reactApp"
        url="http://localhost:3001/"
        data={data}                        // 传递数据
        onDataChange={(e) => {             // 接收子应用数据
          console.log('来自子应用:', e.detail.data);
        }}
      ></micro-app>
    </div>
  );
}
```

```javascript
// react-app/src/App.jsx - 子应用几乎无需改造
import { useEffect } from 'react';

function App() {
  useEffect(() => {
    // 接收主应用数据
    window.microApp.addDataListener((data) => {
      console.log('来自主应用:', data);
    });

    // 发送数据给主应用
    window.microApp.dispatch({ msg: 'hello from child' });
  }, []);

  return <div>React 子应用</div>;
}
```

### 六、最佳实践

#### 1. 路由管理

```javascript
// 主应用路由配置
const routes = [
  { path: '/', component: Home },
  { path: '/react/*', component: () => <div id="react-app-container" /> },
  { path: '/vue/*', component: () => <div id="vue-app-container" /> },
];

// 子应用使用相对路径
// react-app
const router = createBrowserRouter([
  { path: '/', element: <Home /> },
  { path: '/about', element: <About /> },  // 实际路径: /react/about
]);
```

#### 2. 环境变量管理

```javascript
// 子应用判断运行环境
const isQiankun = window.__POWERED_BY_QIANKUN__;
const isMicroApp = window.__MICRO_APP_ENVIRONMENT__;

const publicPath = isQiankun || isMicroApp
  ? '/child-app/'
  : '/';
```

#### 3. 性能优化

```javascript
// 预加载子应用
import { prefetchApps } from 'qiankun';

prefetchApps([
  { name: 'reactApp', entry: '//localhost:3001' },
  { name: 'vueApp', entry: '//localhost:3002' },
]);

// 子应用懒加载
const routes = [
  {
    path: '/react',
    component: lazy(() => import('./ReactAppWrapper')),
  },
];
```

#### 4. 错误处理

```javascript
registerMicroApps(
  [...apps],
  {
    beforeLoad: (app) => console.log('before load', app.name),
    beforeMount: (app) => console.log('before mount', app.name),
    afterMount: (app) => console.log('after mount', app.name),
    beforeUnmount: (app) => console.log('before unmount', app.name),
    afterUnmount: (app) => console.log('after unmount', app.name),
  }
);

// 子应用加载失败处理
start({
  fetch: (url, ...args) => {
    return window.fetch(url, ...args).catch((err) => {
      console.error('子应用加载失败:', err);
      // 降级方案
      return { ok: false };
    });
  },
});
```

### 七、常见问题及解决方案

#### 1. 静态资源 404

**原因**:子应用使用相对路径,加载资源时基于主应用域名

**解决方案**:
```javascript
// 子应用设置 publicPath
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
```

#### 2. 全局变量污染

**原因**:子应用直接操作 window 对象

**解决方案**:
- 使用 qiankun 的沙箱隔离
- 避免直接操作 window,使用闭包或模块化

#### 3. 样式冲突

**解决方案**:
- 开启严格样式隔离
- 使用 CSS Modules 或 CSS-in-JS
- 统一命名空间前缀

#### 4. 跨域问题

**解决方案**:
```javascript
// 子应用 devServer 配置
devServer: {
  headers: {
    'Access-Control-Allow-Origin': '*',
  },
}
```

### 八、技术选型建议

| 场景 | 推荐方案 | 理由 |
|-----|---------|------|
| 新项目 | Micro-App | 接入简单,维护成本低 |
| 已有 qiankun | 继续使用 qiankun | 生态成熟,社区活跃 |
| 需要模块级共享 | Module Federation | 更细粒度的代码共享 |
| 强隔离需求 | Micro-App | Web Component 天然隔离 |
| 复杂通信场景 | qiankun | 通信机制更灵活 |

### 九、总结

微前端不是银弹,它解决了大型项目的工程化问题,但也带来了额外的复杂度:

**适合微前端的团队**:
- 多团队协作,业务边界清晰
- 有一定的前端工程化能力
- 需要技术栈多样性或渐进式升级

**核心价值**:
- ✅ 技术栈无关,渐进式升级
- ✅ 独立开发、部署、运行
- ✅ 团队自治,提升协作效率
- ⚠️ 增加系统复杂度和维护成本

选择微前端架构前,务必评估团队规模、项目复杂度和长期维护成本,确保收益大于成本。
