---
title: TypeScript 的装饰器和元数据
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: typescript-decorators-metadata
ref:
---

## 核心要点

**装饰器本质**: 特殊的函数,用于修改类、方法、属性、参数的行为(Stage 3 提案,TS 实验性支持)
**五种装饰器**: 类装饰器、方法装饰器、访问器装饰器、属性装饰器、参数装饰器
**元数据(Metadata)**: 通过 reflect-metadata 库实现运行时类型反射,支持 IoC 容器等高级场景
**执行顺序**: 参数 → 方法/访问器/属性 → 类,同类型装饰器从下到上执行

---

## 详细解答

### 一、装饰器基础

#### 1. 启用装饰器支持

装饰器目前是 Stage 3 提案,需要在 `tsconfig.json` 中启用:

```json
{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true,      // 启用装饰器
    "emitDecoratorMetadata": true        // 启用元数据(可选)
  }
}
```

**注意**: TypeScript 5.0+ 默认使用新版装饰器语法(Stage 3),与旧版(experimentalDecorators)不兼容。本答案主要讲解旧版语法,因其在生产环境应用更广泛。

#### 2. 装饰器的本质

装饰器是一个函数,接收目标对象及相关参数,返回修改后的描述符或新的构造函数:

```typescript
// 简化版装饰器执行过程
function decorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  // target: 类的原型对象(实例方法)或构造函数(静态方法)
  // propertyKey: 方法名
  // descriptor: 属性描述符

  const originalMethod = descriptor.value;

  descriptor.value = function(...args: any[]) {
    console.log('方法调用前');
    const result = originalMethod.apply(this, args);
    console.log('方法调用后');
    return result;
  };

  return descriptor;
}
```

---

### 二、五种装饰器详解

#### 1. 类装饰器(Class Decorator)

作用于类的构造函数,可以修改或替换类定义:

```typescript
// 类装饰器函数签名
type ClassDecorator = <TFunction extends Function>(
  target: TFunction  // 类的构造函数
) => TFunction | void;

// 简单类装饰器
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
}

// 工厂函数:返回装饰器
function component(config: { selector: string }) {
  return function(constructor: Function) {
    console.log(`组件选择器: ${config.selector}`);
    // 可以修改或扩展类
  };
}

@component({ selector: 'app-root' })
class AppComponent {}

// 替换构造函数
function reportableClassDecorator<T extends { new(...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    reportingURL = "http://example.com";

    constructor(...args: any[]) {
      super(...args);
      console.log('实例创建');
    }
  };
}

@reportableClassDecorator
class BugReport {
  type = "report";
  title: string;

  constructor(title: string) {
    this.title = title;
  }
}

const bug = new BugReport("Bug in login");
console.log(bug.reportingURL);  // "http://example.com"
```

**实战案例:自动注册类**

```typescript
// 全局类注册表
const classRegistry = new Map<string, any>();

function register(name: string) {
  return function<T extends { new(...args: any[]): {} }>(constructor: T) {
    classRegistry.set(name, constructor);
    return constructor;
  };
}

@register('UserService')
class UserService {
  getUsers() {
    return ['Alice', 'Bob'];
  }
}

// 通过名称获取类
const ServiceClass = classRegistry.get('UserService');
const service = new ServiceClass();
console.log(service.getUsers());  // ['Alice', 'Bob']
```

#### 2. 方法装饰器(Method Decorator)

作用于类的方法:

```typescript
// 方法装饰器函数签名
type MethodDecorator = <T>(
  target: Object,                      // 原型对象(实例方法)或构造函数(静态方法)
  propertyKey: string | symbol,        // 方法名
  descriptor: TypedPropertyDescriptor<T>  // 属性描述符
) => TypedPropertyDescriptor<T> | void;

// 日志装饰器
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function(...args: any[]) {
    console.log(`调用 ${propertyKey} 方法,参数:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`${propertyKey} 返回:`, result);
    return result;
  };

  return descriptor;
}

class Calculator {
  @log
  add(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3);
// 输出:
// 调用 add 方法,参数: [2, 3]
// add 返回: 5

// 性能监控装饰器
function measure(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = async function(...args: any[]) {
    const start = performance.now();
    const result = await originalMethod.apply(this, args);
    const end = performance.now();
    console.log(`${propertyKey} 执行耗时: ${(end - start).toFixed(2)}ms`);
    return result;
  };

  return descriptor;
}

class DataService {
  @measure
  async fetchData() {
    await new Promise(resolve => setTimeout(resolve, 1000));
    return { data: [1, 2, 3] };
  }
}

// 防抖装饰器
function debounce(delay: number) {
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    let timeoutId: NodeJS.Timeout;

    descriptor.value = function(...args: any[]) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        originalMethod.apply(this, args);
      }, delay);
    };

    return descriptor;
  };
}

class SearchBox {
  @debounce(500)
  onInput(value: string) {
    console.log('搜索:', value);
  }
}
```

**实战案例:权限验证**

```typescript
// 权限枚举
enum Permission {
  READ = 'READ',
  WRITE = 'WRITE',
  DELETE = 'DELETE'
}

// 模拟当前用户权限
let currentUserPermissions: Permission[] = [Permission.READ, Permission.WRITE];

function requirePermission(permission: Permission) {
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function(...args: any[]) {
      if (!currentUserPermissions.includes(permission)) {
        throw new Error(`权限不足: 需要 ${permission} 权限`);
      }
      return originalMethod.apply(this, args);
    };

    return descriptor;
  };
}

class UserManager {
  @requirePermission(Permission.READ)
  getUser(id: number) {
    return { id, name: 'Alice' };
  }

  @requirePermission(Permission.DELETE)
  deleteUser(id: number) {
    console.log(`删除用户 ${id}`);
  }
}

const manager = new UserManager();
manager.getUser(1);      // ✅ 成功
// manager.deleteUser(1);  // ❌ 抛出错误: 权限不足
```

#### 3. 访问器装饰器(Accessor Decorator)

作用于 getter/setter:

```typescript
function configurable(value: boolean) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    descriptor.configurable = value;
  };
}

class Point {
  private _x: number = 0;
  private _y: number = 0;

  @configurable(false)
  get x() {
    return this._x;
  }

  set x(value: number) {
    this._x = value;
  }
}

// 验证装饰器
function validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalSetter = descriptor.set;

  descriptor.set = function(value: any) {
    if (typeof value !== 'number' || value < 0) {
      throw new Error(`${propertyKey} 必须是非负数`);
    }
    originalSetter?.call(this, value);
  };
}

class Product {
  private _price: number = 0;

  @validate
  set price(value: number) {
    this._price = value;
  }

  get price() {
    return this._price;
  }
}

const product = new Product();
product.price = 100;   // ✅
// product.price = -10;  // ❌ 抛出错误
```

#### 4. 属性装饰器(Property Decorator)

作用于类的属性(注意:没有 descriptor 参数):

```typescript
// 属性装饰器函数签名
type PropertyDecorator = (
  target: Object,              // 原型对象或构造函数
  propertyKey: string | symbol // 属性名
) => void;

// 属性装饰器不能修改属性值,只能记录元数据
function format(formatString: string) {
  return function(target: any, propertyKey: string) {
    // 通常配合 reflect-metadata 使用
    Reflect.defineMetadata('format', formatString, target, propertyKey);
  };
}

// 默认值装饰器
function defaultValue(value: any) {
  return function(target: any, propertyKey: string) {
    let val = value;

    const getter = function() {
      return val;
    };

    const setter = function(newVal: any) {
      val = newVal;
    };

    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  };
}

class User {
  @defaultValue('未命名')
  name: string;

  @defaultValue(0)
  age: number;
}

const user = new User();
console.log(user.name);  // "未命名"
console.log(user.age);   // 0
```

**实战案例:序列化标记**

```typescript
const serializableKeys = new WeakMap<any, string[]>();

function serializable(target: any, propertyKey: string) {
  const constructor = target.constructor;
  const keys = serializableKeys.get(constructor) || [];
  keys.push(propertyKey);
  serializableKeys.set(constructor, keys);
}

class Person {
  @serializable
  name: string;

  @serializable
  age: number;

  // 不序列化
  private password: string;

  constructor(name: string, age: number, password: string) {
    this.name = name;
    this.age = age;
    this.password = password;
  }

  toJSON() {
    const keys = serializableKeys.get(this.constructor) || [];
    const result: any = {};
    keys.forEach(key => {
      result[key] = (this as any)[key];
    });
    return result;
  }
}

const person = new Person('Alice', 30, 'secret123');
console.log(JSON.stringify(person));  // {"name":"Alice","age":30}
```

#### 5. 参数装饰器(Parameter Decorator)

作用于方法的参数:

```typescript
// 参数装饰器函数签名
type ParameterDecorator = (
  target: Object,              // 原型对象或构造函数
  propertyKey: string | symbol,// 方法名
  parameterIndex: number       // 参数索引
) => void;

// 必填参数装饰器
const requiredMetadataKey = Symbol('required');

function required(target: any, propertyKey: string, parameterIndex: number) {
  const existingRequiredParams: number[] = Reflect.getOwnMetadata(
    requiredMetadataKey,
    target,
    propertyKey
  ) || [];

  existingRequiredParams.push(parameterIndex);

  Reflect.defineMetadata(
    requiredMetadataKey,
    existingRequiredParams,
    target,
    propertyKey
  );
}

// 配合方法装饰器验证
function validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function(...args: any[]) {
    const requiredParams: number[] = Reflect.getOwnMetadata(
      requiredMetadataKey,
      target,
      propertyKey
    ) || [];

    for (const index of requiredParams) {
      if (args[index] === undefined || args[index] === null) {
        throw new Error(`参数 ${index} 是必填的`);
      }
    }

    return originalMethod.apply(this, args);
  };

  return descriptor;
}

class UserService {
  @validate
  createUser(
    @required name: string,
    @required email: string,
    age?: number
  ) {
    console.log('创建用户:', { name, email, age });
  }
}

const service = new UserService();
service.createUser('Alice', 'alice@example.com', 30);  // ✅
// service.createUser('Bob', null);  // ❌ 抛出错误: 参数 1 是必填的
```

---

### 三、装饰器执行顺序

多个装饰器的执行顺序有固定规则:

```typescript
function first() {
  console.log('first(): 装饰器工厂被求值');
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log('first(): 装饰器被调用');
  };
}

function second() {
  console.log('second(): 装饰器工厂被求值');
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log('second(): 装饰器被调用');
  };
}

class ExampleClass {
  @first()
  @second()
  method() {}
}

// 输出顺序:
// first(): 装饰器工厂被求值
// second(): 装饰器工厂被求值
// second(): 装饰器被调用
// first(): 装饰器被调用
```

**完整执行顺序规则**:

1. **参数装饰器** → **方法/访问器/属性装饰器** → **类装饰器**
2. 同类型装饰器:**从下到上**执行(与书写顺序相反)
3. 不同方法的装饰器:**从上到下**执行(按声明顺序)

```typescript
function logClass(name: string) {
  return function(constructor: Function) {
    console.log(`类装饰器: ${name}`);
  };
}

function logMethod(name: string) {
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log(`方法装饰器: ${name}, 方法: ${propertyKey}`);
  };
}

function logParam(name: string) {
  return function(target: any, propertyKey: string, paramIndex: number) {
    console.log(`参数装饰器: ${name}, 方法: ${propertyKey}, 索引: ${paramIndex}`);
  };
}

@logClass('MyClass')
class MyClass {
  @logMethod('method1-decorator1')
  @logMethod('method1-decorator2')
  method1(@logParam('param1') p1: string) {}

  @logMethod('method2')
  method2() {}
}

// 输出顺序:
// 参数装饰器: param1, 方法: method1, 索引: 0
// 方法装饰器: method1-decorator2, 方法: method1
// 方法装饰器: method1-decorator1, 方法: method1
// 方法装饰器: method2, 方法: method2
// 类装饰器: MyClass
```

---

### 四、元数据(Metadata)

元数据需要安装 `reflect-metadata` 库:

```bash
npm install reflect-metadata
```

#### 1. 基础元数据操作

```typescript
import 'reflect-metadata';

// 定义元数据
const formatMetadataKey = Symbol('format');

function format(formatString: string) {
  return Reflect.metadata(formatMetadataKey, formatString);
}

// 获取元数据
function getFormat(target: any, propertyKey: string): string {
  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
}

class User {
  @format('YYYY-MM-DD')
  birthDate: Date;
}

const user = new User();
console.log(getFormat(user, 'birthDate'));  // 'YYYY-MM-DD'
```

#### 2. 设计时类型元数据

启用 `emitDecoratorMetadata` 后,TypeScript 会自动添加三种元数据:

```typescript
import 'reflect-metadata';

class Point {
  x: number;
  y: number;
}

class User {
  name: string;

  @Reflect.metadata('role', 'admin')
  method(point: Point): string {
    return '';
  }
}

// 获取设计时类型信息
const paramTypes = Reflect.getMetadata('design:paramtypes', User.prototype, 'method');
console.log(paramTypes);  // [Point]

const returnType = Reflect.getMetadata('design:returntype', User.prototype, 'method');
console.log(returnType);  // String

const type = Reflect.getMetadata('design:type', User.prototype, 'method');
console.log(type);  // Function
```

**三种设计时元数据**:
- `design:type`: 属性的类型
- `design:paramtypes`: 方法参数类型数组
- `design:returntype`: 方法返回类型

#### 3. 实战案例:依赖注入(DI)

```typescript
import 'reflect-metadata';

// 可注入装饰器
const INJECTABLE_METADATA_KEY = Symbol('INJECTABLE_KEY');

function injectable() {
  return function(target: any) {
    Reflect.defineMetadata(INJECTABLE_METADATA_KEY, true, target);
    return target;
  };
}

// 注入装饰器
const INJECT_METADATA_KEY = Symbol('INJECT_KEY');

function inject() {
  return function(target: any, propertyKey: string, parameterIndex: number) {
    const existingInjectedParameters: number[] = Reflect.getOwnMetadata(
      INJECT_METADATA_KEY,
      target,
      propertyKey
    ) || [];

    existingInjectedParameters.push(parameterIndex);

    Reflect.defineMetadata(
      INJECT_METADATA_KEY,
      existingInjectedParameters,
      target,
      propertyKey
    );
  };
}

// IoC 容器
class Container {
  private services = new Map<any, any>();

  register<T>(token: any, instance: T) {
    this.services.set(token, instance);
  }

  resolve<T>(target: any): T {
    // 获取构造函数参数类型
    const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];

    // 获取需要注入的参数索引
    const injectedParams: number[] = Reflect.getOwnMetadata(
      INJECT_METADATA_KEY,
      target,
      'constructor'
    ) || [];

    // 解析依赖
    const dependencies = paramTypes.map((paramType: any, index: number) => {
      if (injectedParams.includes(index)) {
        return this.services.get(paramType);
      }
      return undefined;
    });

    return new target(...dependencies);
  }
}

// 使用示例
@injectable()
class Logger {
  log(message: string) {
    console.log(`[LOG] ${message}`);
  }
}

@injectable()
class Database {
  constructor(@inject() private logger: Logger) {}

  query(sql: string) {
    this.logger.log(`执行查询: ${sql}`);
    return [];
  }
}

@injectable()
class UserService {
  constructor(
    @inject() private db: Database,
    @inject() private logger: Logger
  ) {}

  getUsers() {
    this.logger.log('获取用户列表');
    return this.db.query('SELECT * FROM users');
  }
}

// 创建容器并注册服务
const container = new Container();
container.register(Logger, new Logger());
container.register(Database, container.resolve(Database));

// 解析服务
const userService = container.resolve<UserService>(UserService);
userService.getUsers();
// 输出:
// [LOG] 获取用户列表
// [LOG] 执行查询: SELECT * FROM users
```

#### 4. 实战案例:ORM 模型定义

```typescript
import 'reflect-metadata';

// 元数据键
const TABLE_NAME_KEY = Symbol('TABLE_NAME');
const COLUMNS_KEY = Symbol('COLUMNS');

// 表装饰器
function table(name: string) {
  return function(constructor: Function) {
    Reflect.defineMetadata(TABLE_NAME_KEY, name, constructor);
  };
}

// 列装饰器
interface ColumnOptions {
  type: 'string' | 'number' | 'boolean';
  primary?: boolean;
  nullable?: boolean;
}

function column(options: ColumnOptions) {
  return function(target: any, propertyKey: string) {
    const columns = Reflect.getMetadata(COLUMNS_KEY, target.constructor) || {};
    columns[propertyKey] = options;
    Reflect.defineMetadata(COLUMNS_KEY, columns, target.constructor);
  };
}

// 使用装饰器定义模型
@table('users')
class User {
  @column({ type: 'number', primary: true })
  id: number;

  @column({ type: 'string' })
  name: string;

  @column({ type: 'string', nullable: true })
  email?: string;

  constructor(id: number, name: string, email?: string) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
}

// 获取表信息
function getTableInfo(target: any) {
  const tableName = Reflect.getMetadata(TABLE_NAME_KEY, target);
  const columns = Reflect.getMetadata(COLUMNS_KEY, target);
  return { tableName, columns };
}

const userInfo = getTableInfo(User);
console.log(userInfo);
// {
//   tableName: 'users',
//   columns: {
//     id: { type: 'number', primary: true },
//     name: { type: 'string' },
//     email: { type: 'string', nullable: true }
//   }
// }

// 生成 SQL
function generateCreateTableSQL(target: any): string {
  const { tableName, columns } = getTableInfo(target);

  const columnDefs = Object.entries(columns).map(([name, opts]: [string, any]) => {
    let def = `${name} `;

    switch (opts.type) {
      case 'number':
        def += 'INT';
        break;
      case 'string':
        def += 'VARCHAR(255)';
        break;
      case 'boolean':
        def += 'BOOLEAN';
        break;
    }

    if (opts.primary) {
      def += ' PRIMARY KEY';
    }

    if (!opts.nullable) {
      def += ' NOT NULL';
    }

    return def;
  });

  return `CREATE TABLE ${tableName} (\n  ${columnDefs.join(',\n  ')}\n);`;
}

console.log(generateCreateTableSQL(User));
// CREATE TABLE users (
//   id INT PRIMARY KEY NOT NULL,
//   name VARCHAR(255) NOT NULL,
//   email VARCHAR(255)
// );
```

---

### 五、装饰器的实际应用

#### 1. Angular 风格的组件系统

```typescript
interface ComponentConfig {
  selector: string;
  template: string;
}

function Component(config: ComponentConfig) {
  return function<T extends { new(...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
      selector = config.selector;
      template = config.template;

      render() {
        console.log(`渲染组件 <${this.selector}>`);
        console.log(`模板: ${this.template}`);
      }
    };
  };
}

@Component({
  selector: 'app-user',
  template: '<div>{{user.name}}</div>'
})
class UserComponent {
  user = { name: 'Alice' };
}

const component = new UserComponent();
(component as any).render();
```

#### 2. Express 风格的路由装饰器

```typescript
const routeMetadataKey = Symbol('routes');

interface RouteDefinition {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  path: string;
  methodName: string;
}

function Controller(basePath: string) {
  return function(constructor: Function) {
    Reflect.defineMetadata('basePath', basePath, constructor);
  };
}

function Get(path: string) {
  return function(target: any, propertyKey: string) {
    registerRoute(target, 'GET', path, propertyKey);
  };
}

function Post(path: string) {
  return function(target: any, propertyKey: string) {
    registerRoute(target, 'POST', path, propertyKey);
  };
}

function registerRoute(
  target: any,
  method: 'GET' | 'POST' | 'PUT' | 'DELETE',
  path: string,
  methodName: string
) {
  const routes: RouteDefinition[] = Reflect.getMetadata(
    routeMetadataKey,
    target.constructor
  ) || [];

  routes.push({ method, path, methodName });

  Reflect.defineMetadata(routeMetadataKey, routes, target.constructor);
}

@Controller('/api/users')
class UserController {
  @Get('/')
  getUsers() {
    return [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
  }

  @Get('/:id')
  getUserById(id: string) {
    return { id, name: 'Alice' };
  }

  @Post('/')
  createUser(body: any) {
    return { id: 3, ...body };
  }
}

// 注册路由到 Express
function registerController(app: any, controller: any) {
  const instance = new controller();
  const basePath = Reflect.getMetadata('basePath', controller);
  const routes: RouteDefinition[] = Reflect.getMetadata(routeMetadataKey, controller) || [];

  routes.forEach(route => {
    const fullPath = basePath + route.path;
    const handler = (instance as any)[route.methodName].bind(instance);

    console.log(`注册路由: ${route.method} ${fullPath}`);
    // app[route.method.toLowerCase()](fullPath, handler);
  });
}

// registerController(app, UserController);
registerController({}, UserController);
// 输出:
// 注册路由: GET /api/users/
// 注册路由: GET /api/users/:id
// 注册路由: POST /api/users/
```

---

### 总结

**装饰器的优势**:
- **声明式编程**: 将横切关注点(日志、权限、验证)与业务逻辑分离
- **代码复用**: 一次定义,多处使用
- **可组合性**: 多个装饰器可以叠加使用
- **元编程能力**: 运行时修改类和方法行为

**使用建议**:
1. **适度使用**: 过度使用会降低代码可读性
2. **明确职责**: 每个装饰器只做一件事
3. **注意性能**: 装饰器在类定义时执行,避免耗时操作
4. **善用元数据**: 配合 reflect-metadata 实现高级功能

**常见应用场景**:
- **框架开发**: Angular、NestJS 等框架大量使用装饰器
- **依赖注入**: IoC 容器实现
- **ORM/数据验证**: TypeORM、class-validator
- **路由定义**: Express 风格的声明式路由
- **AOP**: 日志、性能监控、权限验证等横切关注点
