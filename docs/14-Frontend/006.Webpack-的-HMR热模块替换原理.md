---
title: Webpack 的 HMR（热模块替换）原理
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: webpack-hmr-principle
ref:
---

## 要点提炼

**HMR核心机制**：通过WebSocket建立持久连接,在文件变化时只更新改动模块而不刷新整个页面,保留应用运行状态。

**关键技术**：Webpack-dev-server + HotModuleReplacementPlugin + WS通信 + Runtime热更新逻辑 + module.hot API。

**完整流程**：文件监听 → 增量编译 → Hash对比 → 推送更新清单 → 客户端下载Chunk → 执行热替换回调 → 更新DOM。

---

## 详细回答

### 一、HMR的基本概念

HMR(Hot Module Replacement)热模块替换是Webpack提供的一种开发体验优化技术,它允许在应用运行时替换、添加或删除模块,而无需完全刷新页面。这样可以保留应用的运行状态,显著提升开发效率。

**核心价值**:
- 保留应用状态(如表单输入、React组件state等)
- 只更新变化的内容,速度快
- 精准定位到修改的模块
- 提供更流畅的开发体验

### 二、HMR的完整工作流程

#### 1. 建立WebSocket连接

当我们启动`webpack-dev-server`时,它会做两件事:
```javascript
// 服务端: webpack-dev-server启动
const server = new WebpackDevServer(compiler, {
  hot: true, // 开启HMR
  // ...
});

// 客户端: webpack会自动注入WDS Client代码
// 建立与服务器的WebSocket连接
const socket = new WebSocket('ws://localhost:8080');
```

这个WebSocket连接是HMR的通信管道,所有的更新通知都通过它传递。

#### 2. 文件监听与增量编译

Webpack通过文件系统的watch机制监听源码变化:

```javascript
compiler.watch({
  aggregateTimeout: 300, // 防抖,300ms内的多次修改合并处理
  poll: undefined
}, (err, stats) => {
  // 文件变化后触发重新编译
});
```

**关键点**: Webpack不会重新编译整个项目,而是:
- 找出修改的模块及其依赖链
- 只编译受影响的模块
- 生成新的module代码和manifest清单

每次编译会生成一个新的Hash值,用于标识这次构建:
```
[webpack-dev-server] App updated. Recompiling...
Hash: a1b2c3d4e5f6
```

#### 3. 服务端推送更新通知

编译完成后,webpack-dev-server通过WebSocket向客户端推送消息:

```javascript
// 消息1: hash事件 - 告知新的编译hash
{
  type: 'hash',
  data: 'a1b2c3d4e5f6'
}

// 消息2: ok事件 - 编译成功,可以开始更新
{
  type: 'ok'
}
```

#### 4. 客户端处理更新

客户端的HMR Runtime收到消息后,会执行以下步骤:

**步骤1: 下载更新清单**
```javascript
// 请求: /hot-update.json
// 返回: 本次更新的模块列表
{
  "h": "a1b2c3d4e5f6",  // 新hash
  "c": {
    "main": true  // main chunk需要更新
  }
}
```

**步骤2: 下载更新的模块代码**
```javascript
// 请求: /main.a1b2c3d4e5f6.hot-update.js
// 返回: JSONP格式的模块代码
webpackHotUpdate("main", {
  "./src/App.js": function(module, exports, __webpack_require__) {
    // 新的模块代码
  }
});
```

**步骤3: 执行热更新**
```javascript
// HMR Runtime的核心逻辑
function hotApply() {
  // 1. 删除旧模块缓存
  delete __webpack_require__.c[moduleId];

  // 2. 添加新模块到modules对象
  __webpack_modules__[moduleId] = newModule;

  // 3. 执行module.hot.accept的回调
  if (module.hot._acceptedDependencies[moduleId]) {
    module.hot._acceptedDependencies[moduleId]();
  }
}
```

### 三、开发者如何使用HMR API

#### 1. 基础配置

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    hot: true, // 开启HMR
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin() // Webpack5中可省略
  ]
};
```

#### 2. 在代码中处理热更新

**示例1: 普通JavaScript模块**
```javascript
// utils.js
export function add(a, b) {
  return a + b;
}

// main.js
import { add } from './utils.js';

console.log(add(1, 2));

// 处理热更新
if (module.hot) {
  module.hot.accept('./utils.js', function() {
    // utils.js更新后的回调
    console.log('utils.js已更新');
    // 重新执行依赖utils的逻辑
  });
}
```

**示例2: React组件(React Hot Loader已内置)**
```javascript
// App.jsx
import React from 'react';

function App() {
  return <h1>Hello HMR</h1>;
}

export default App;

// React Fast Refresh会自动处理组件热更新
// 无需手动编写module.hot.accept
```

#### 3. CSS的热更新

```javascript
// style-loader已经内置了HMR支持
import './styles.css';

// 当styles.css改变时,style-loader会:
// 1. 移除旧的<style>标签
// 2. 插入新的<style>标签
// 完全不需要手动处理
```

### 四、HMR失败的降级处理

并非所有模块都能热更新,HMR有一套降级机制:

```javascript
// HMR Runtime的决策树
if (模块自身有module.hot.accept) {
  执行热更新回调
} else if (父模块有module.hot.accept(子模块)) {
  向上传递,在父模块处理
} else if (一直传递到入口文件都没有处理) {
  降级为刷新整个页面 // Live Reload
}
```

**常见的无法热更新的场景**:
- 修改webpack配置文件(需要重启dev server)
- 修改入口文件(无父模块可传递)
- 修改HTML模板
- 某些环境变量的变化

### 五、核心技术要点总结

#### 1. 通信架构
```
文件系统(watch) → Webpack编译器 → Dev Server
                                        ↓ (WebSocket)
                                   浏览器 HMR Runtime
```

#### 2. 关键文件
- `hot-update.json`: 更新清单(哪些chunk需要更新)
- `[chunkhash].hot-update.js`: 具体的模块代码
- HMR Runtime: 注入到bundle中的客户端代码

#### 3. 性能优化点
- **增量编译**: 只编译变化的模块
- **内存文件系统**: dev server把文件存在内存中(memfs),不写磁盘
- **并行处理**: 支持多个模块并发更新
- **防抖机制**: 短时间内的多次修改合并为一次编译

### 六、实际面试中的加分回答

**面试官可能的追问**:

**Q1: HMR和Live Reload的区别?**
```
Live Reload: 文件改变 → 刷新整个页面 → 状态丢失
HMR: 文件改变 → 只替换改变的模块 → 保留状态

HMR失败时会降级为Live Reload
```

**Q2: HMR的性能瓶颈在哪里?**
```
1. WebSocket通信延迟(通常很小,可忽略)
2. 模块依赖链过长,传播慢
3. 更新回调函数执行耗时(如大型React组件树的reconcile)

优化: 拆分模块、使用React.memo减少重渲染
```

**Q3: 生产环境能用HMR吗?**
```
不能也不应该:
- HMR Runtime会增加bundle体积
- WebSocket连接需要dev server
- 热更新逻辑是为开发设计的

生产环境应该使用静态资源+版本号+CDN缓存
```

### 七、示例代码:手动实现一个简易HMR

```javascript
// 简化版HMR Runtime核心逻辑
class HMRRuntime {
  constructor() {
    this.moduleCache = {};
    this.acceptCallbacks = {};
  }

  // 模拟module.hot.accept
  accept(moduleId, callback) {
    this.acceptCallbacks[moduleId] = callback;
  }

  // 模拟热更新流程
  applyUpdate(moduleId, newModuleCode) {
    // 1. 清除旧模块缓存
    delete this.moduleCache[moduleId];

    // 2. 执行新模块代码
    const newModule = this.executeModule(newModuleCode);
    this.moduleCache[moduleId] = newModule;

    // 3. 触发accept回调
    if (this.acceptCallbacks[moduleId]) {
      this.acceptCallbacks[moduleId](newModule);
    }
  }

  executeModule(code) {
    // 在沙箱中执行模块代码
    const module = { exports: {} };
    const func = new Function('module', 'exports', code);
    func(module, module.exports);
    return module.exports;
  }
}

// 使用示例
const hmr = new HMRRuntime();

// 注册热更新处理
hmr.accept('./math.js', (newMath) => {
  console.log('math模块已更新', newMath);
});

// 模拟接收到服务器推送的更新
hmr.applyUpdate('./math.js', `
  module.exports.add = (a, b) => a + b + 1; // 逻辑改变
`);
```

### 八、总结

Webpack的HMR是一个精密的工程设计,它涉及:
- **服务端**: 文件监听、增量编译、WebSocket推送
- **客户端**: WS接收、下载更新、模块替换、回调执行
- **开发者**: module.hot API、accept处理、框架集成

理解HMR不仅能优化开发体验,更能加深对模块化、编译原理、长连接通信等技术的认识,这些知识在前端工程化体系中都是相通的。
