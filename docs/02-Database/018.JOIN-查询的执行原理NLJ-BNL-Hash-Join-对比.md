---
title: JOIN 查询的执行原理，NLJ、BNL、Hash Join 对比
tags:
  - 数据库
status: robot
class: 数据库
slug: join-query-execution-nlj-bnl-hash-join-comparison
ref:
---

## 核心要点

MySQL JOIN 查询有三种算法：NLJ（嵌套循环）适合小表驱动大表且被驱动表有索引，BNL（块嵌套循环）用于无索引场景通过 join buffer 减少 IO，Hash Join（MySQL 8.0.18+）对等值连接性能最优。

## 详细回答

### 1. 三种 JOIN 算法对比

**算法特性总览：**

| 算法 | 全称 | 适用场景 | 时间复杂度 | 是否需要索引 | MySQL 版本 |
|------|------|---------|-----------|-------------|-----------|
| NLJ | Nested-Loop Join | 被驱动表有索引 | O(M * log N) | 是 | 所有版本 |
| BNL | Block Nested-Loop Join | 被驱动表无索引 | O(M * N / buffer_size) | 否 | 5.6+ |
| Hash Join | Hash Join | 等值连接 | O(M + N) | 否 | 8.0.18+ |

**基础测试数据：**
```sql
-- 用户表（小表，1000 行）
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  dept_id INT,
  INDEX idx_dept(dept_id)
);

-- 订单表（大表，100 万行）
CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT,
  amount DECIMAL(10,2),
  created_at DATETIME,
  INDEX idx_user(user_id)
);

-- 部门表（小表，10 行）
CREATE TABLE departments (
  id INT PRIMARY KEY,
  dept_name VARCHAR(50)
);
```

### 2. NLJ（Nested-Loop Join）原理

**执行流程：**
```sql
-- 示例查询：
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5;

-- NLJ 执行伪代码：
for each row in users where dept_id = 5 {  -- 外层循环（驱动表）
    // 假设匹配 50 行
    for each matched row {
        // 使用 idx_user 索引在 orders 表中查找
        rows = orders.find_by_index(user_id = row.id);  -- O(log N)
        output(row, rows);
    }
}

-- 时间复杂度：
-- 驱动表扫描：50 行
-- 被驱动表索引查找：50 * log(1000000) ≈ 50 * 20 = 1000 次
```

**EXPLAIN 分析：**
```sql
EXPLAIN SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5\G

*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: u
         type: ref
possible_keys: idx_dept
          key: idx_dept
      key_len: 5
         rows: 50              ← 驱动表估算行数
        Extra: Using index condition

*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: o
         type: ref
possible_keys: idx_user
          key: idx_user        ← 使用索引查找
      key_len: 5
         rows: 20              ← 每个用户平均订单数
        Extra: NULL

-- 总扫描行数：50 + (50 * 20) = 1050 行
```

**性能特点：**
- **优点**：被驱动表有索引时效率高，适合 OLTP 查询
- **缺点**：被驱动表无索引时退化为笛卡尔积（O(M*N)）
- **优化关键**：小表驱动大表，被驱动表关联列有索引

### 3. BNL（Block Nested-Loop Join）原理

**执行流程（无索引场景）：**
```sql
-- 假设 orders 表的 user_id 列没有索引
ALTER TABLE orders DROP INDEX idx_user;

SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5;

-- BNL 执行伪代码：
join_buffer = allocate(join_buffer_size);  -- 默认 256KB

for each row in users where dept_id = 5 {
    join_buffer.add(row);  -- 缓存驱动表数据

    if (join_buffer.full() || last_row) {
        // 全表扫描被驱动表
        for each row in orders {
            for each cached_row in join_buffer {
                if (row.user_id == cached_row.id) {
                    output(cached_row, row);
                }
            }
        }
        join_buffer.clear();
    }
}

-- 时间复杂度分析：
-- 驱动表：50 行
-- join_buffer 可缓存：256KB / 100B ≈ 2500 行（一次性缓存完）
-- 被驱动表全表扫描：1000000 行
-- 总扫描：50 + 1000000 = 1000050 行
```

**EXPLAIN 分析：**
```sql
EXPLAIN SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5\G

*************************** 2. row ***************************
        table: o
         type: ALL               ← 全表扫描
          key: NULL              ← 无索引可用
         rows: 1000000
        Extra: Using join buffer (Block Nested Loop)  ← 使用 BNL

-- 警告信息：
SHOW WARNINGS;
-- 提示：Using join buffer，性能较差
```

**优化方法：**
```sql
-- 方法 1：增大 join_buffer_size
SET SESSION join_buffer_size = 8388608;  -- 8MB

-- 方法 2：添加索引（推荐）
ALTER TABLE orders ADD INDEX idx_user(user_id);
-- BNL 自动切换为 NLJ

-- 方法 3：调整 JOIN 顺序
-- 错误（大表驱动小表）：
SELECT * FROM orders o JOIN users u ON o.user_id = u.id;
-- 扫描：1000000 + (1000000 * 1) = 2000000 行

-- 正确（小表驱动大表）：
SELECT * FROM users u JOIN orders o ON u.id = o.user_id;
-- 扫描：1000 + (1000 * 1000) = 1001000 行
```

### 4. Hash Join（MySQL 8.0.18+）原理

**执行流程：**
```sql
-- MySQL 8.0.18+ 自动使用 Hash Join（等值连接且无索引）
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id;

-- Hash Join 执行伪代码：
-- 阶段 1：构建哈希表（Build Phase）
hash_table = {};
for each row in users {  -- 驱动表
    hash_table[row.id] = row;  -- O(M)
}

-- 阶段 2：探测哈希表（Probe Phase）
for each row in orders {  -- 被驱动表
    if (hash_table[row.user_id]) {  -- O(1) 查找
        output(hash_table[row.user_id], row);
    }
}

-- 时间复杂度：O(M + N)
-- 空间复杂度：O(M)
```

**EXPLAIN 分析：**
```sql
-- MySQL 8.0.18+
EXPLAIN FORMAT=TREE
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id\G

*************************** 1. row ***************************
EXPLAIN: -> Inner hash join (o.user_id = u.id)
    -> Table scan on o
    -> Hash
        -> Table scan on u

-- 执行计划关键信息：
-- 1. "Inner hash join"：使用哈希连接
-- 2. "Hash"：构建哈希表（users 表）
-- 3. "Table scan"：全表扫描（但只扫描一次）
```

**性能对比测试：**
```sql
-- 测试场景：users(1000 行) JOIN orders(100 万行)
-- 假设 orders.user_id 无索引

-- BNL（MySQL 5.7）：
-- 扫描行数：1000 + 1000000 = 1001000
-- 耗时：约 8 秒

-- Hash Join（MySQL 8.0.18+）：
-- 扫描行数：1000 + 1000000 = 1001000（相同）
-- 但内存比较（哈希表）比磁盘 IO 快得多
-- 耗时：约 1.5 秒

-- 性能提升：约 5 倍
```

**Hash Join 限制：**
```sql
-- 1. 仅支持等值连接
SELECT * FROM t1 JOIN t2 ON t1.id = t2.id;  -- ✓ 支持
SELECT * FROM t1 JOIN t2 ON t1.id > t2.id;  -- ✗ 不支持，使用 BNL

-- 2. 不支持 LEFT/RIGHT JOIN（MySQL 8.0.20+ 支持）
SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id;  -- 8.0.18 不支持
-- MySQL 8.0.20+ 支持外连接的 Hash Join

-- 3. 内存不足时会降级
-- 哈希表大小超过 join_buffer_size 时，可能退化为磁盘临时表
```

### 5. 实战案例

**案例 1：三表 JOIN 优化**
```sql
-- 需求：查询部门下所有用户的订单
-- 表大小：departments(10), users(1000), orders(100万)

-- 错误写法（大表驱动）：
SELECT d.dept_name, u.name, o.amount
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN departments d ON u.dept_id = d.id
WHERE d.id = 5;

-- EXPLAIN 分析：
-- 1. orders 全表扫描（1000000 行）
-- 2. users 索引查找（1000000 次）
-- 3. departments 索引查找（1000000 次）
-- 总扫描：≈ 200 万行

-- 正确写法（小表驱动）：
SELECT d.dept_name, u.name, o.amount
FROM departments d
JOIN users u ON d.id = u.dept_id
JOIN orders o ON u.id = o.user_id
WHERE d.id = 5;

-- EXPLAIN 分析：
-- 1. departments 主键查找（1 行）
-- 2. users 索引查找（50 行）
-- 3. orders 索引查找（50 * 20 = 1000 行）
-- 总扫描：1051 行
-- 性能提升：1900 倍！
```

**案例 2：子查询转 JOIN**
```sql
-- 错误写法（子查询）：
SELECT u.name,
       (SELECT COUNT(*) FROM orders WHERE user_id = u.id) AS order_count
FROM users u
WHERE u.dept_id = 5;

-- 执行分析：
-- users 表扫描 50 行
-- 每行执行一次子查询（50 * 全表扫描）
-- 总扫描：50 + (50 * 1000000) = 5000万行

-- 正确写法（JOIN + GROUP BY）：
SELECT u.name, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.dept_id = 5
GROUP BY u.id;

-- 执行分析：
-- users 表扫描 50 行
-- orders 索引查找 1000 行
-- 总扫描：1050 行
```

**案例 3：强制使用 Hash Join（MySQL 8.0.18+）**
```sql
-- 场景：临时分析，不想建索引
-- 使用 optimizer_switch 控制

-- 禁用 BNL，强制 Hash Join
SET optimizer_switch='block_nested_loop=off';

SELECT /*+ NO_BNL(o) */ u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id;

-- 或使用 Hint 强制 Hash Join
SELECT /*+ HASH_JOIN(u, o) */ u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id;

-- 验证执行计划
EXPLAIN FORMAT=TREE SELECT ...;
-- 应显示 "Inner hash join"
```

### 6. 性能调优最佳实践

**优化决策树：**
```
JOIN 查询优化
│
├─ 是否等值连接？
│  ├─ 是 → 被驱动表有索引？
│  │      ├─ 有 → 使用 NLJ（最优）
│  │      └─ 无 → MySQL 8.0.18+？
│  │             ├─ 是 → 使用 Hash Join
│  │             └─ 否 → 使用 BNL（建议加索引）
│  │
│  └─ 否（范围连接）→ 只能使用 BNL
│         → 考虑业务逻辑优化
```

**优化检查清单：**
```sql
-- 1. 查看执行计划
EXPLAIN FORMAT=TREE
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id\G

-- 2. 检查关键指标
EXPLAIN SELECT ...;
-- 关注：
-- - type: 应为 ref 或 eq_ref，避免 ALL
-- - key: 关联列应有索引
-- - rows: 扫描行数应尽量少
-- - Extra: 避免 "Using join buffer (Block Nested Loop)"

-- 3. 统计实际执行情况（MySQL 8.0+）
SET SESSION optimizer_trace='enabled=on';
SELECT ...;
SELECT * FROM information_schema.optimizer_trace\G
-- 查看 "join_optimization" 部分

-- 4. 监控 join buffer 使用情况
SHOW STATUS LIKE 'Select_scan';           -- BNL 次数
SHOW STATUS LIKE 'Select_full_join';      -- 全连接次数（警告）
```

**索引设计原则：**
```sql
-- 1. 关联列必须有索引
ALTER TABLE orders ADD INDEX idx_user(user_id);

-- 2. WHERE 条件列需要索引
ALTER TABLE users ADD INDEX idx_dept(dept_id);

-- 3. 组合索引优化（覆盖索引）
-- 避免回表
ALTER TABLE orders ADD INDEX idx_user_amount(user_id, amount);

SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id;
-- orders 表使用 idx_user_amount（覆盖索引），不需要回表
```

### 7. Go + GoFrame 代码示例

**错误示例（N+1 查询）：**
```go
// 查询用户及其订单
users, err := dao.Users.Ctx(ctx).Where("dept_id", 5).All()
for _, user := range users {
    // 每个用户执行一次查询（N+1 问题）
    orders, _ := dao.Orders.Ctx(ctx).Where("user_id", user.Id).All()
    // 总查询：1 + N 次
}
```

**正确示例（JOIN 查询）：**
```go
type UserOrder struct {
    UserName    string `json:"user_name"`
    OrderAmount float64 `json:"order_amount"`
}

var results []UserOrder
err := dao.Users.Ctx(ctx).
    Fields("u.name as user_name, o.amount as order_amount").
    LeftJoin("orders o", "u.id = o.user_id").
    Where("u.dept_id", 5).
    Scan(&results)
// 只执行一次 JOIN 查询

// 生成的 SQL：
// SELECT u.name as user_name, o.amount as order_amount
// FROM users u
// LEFT JOIN orders o ON u.id = o.user_id
// WHERE u.dept_id = 5
```

**强制使用索引（避免错误执行计划）：**
```go
// 使用 FORCE INDEX
err := dao.Orders.Ctx(ctx).
    Fields("o.*, u.name").
    LeftJoin("users u FORCE INDEX(idx_dept)", "o.user_id = u.id").
    Where("u.dept_id", 5).
    Scan(&results)

// 生成 SQL：
// SELECT o.*, u.name
// FROM orders o
// LEFT JOIN users u FORCE INDEX(idx_dept) ON o.user_id = u.id
// WHERE u.dept_id = 5
```

### 8. 总结

**算法选择推荐：**

| 场景 | 推荐算法 | 原因 |
|------|---------|------|
| 小表 JOIN 大表（有索引） | NLJ | O(M * log N)，最优 |
| 小表 JOIN 大表（无索引） | Hash Join | O(M + N)，比 BNL 快 |
| 大表 JOIN 大表 | 避免 | 考虑业务拆分或异步处理 |
| 范围连接（>, <） | BNL + 索引优化 | Hash Join 不支持 |

**生产环境经验：**
1. **优先保证 NLJ**：关联列加索引
2. **升级到 MySQL 8.0.18+**：自动使用 Hash Join
3. **监控慢查询日志**：关注 `Using join buffer` 警告
4. **大表 JOIN 优化**：分批处理 + 缓存中间结果
