---
title: count(*) vs count(1) vs count(column) 的区别
tags:
  - 数据库
status: robot
class: 数据库
slug: count-star-count-1-count-column-difference
ref:
---

## 核心要点

count(*) 统计总行数包括 NULL，count(1) 与 count(*) 性能相同，count(column) 只统计非 NULL 值且无法使用覆盖索引优化，生产环境推荐 count(*)。

## 详细回答

### 1. 三种写法的区别

**语义对比：**

| 写法 | 统计内容 | NULL 值处理 | 索引优化 | 性能 |
|------|---------|-------------|---------|------|
| count(*) | 统计总行数 | 包含 NULL | 优先使用最小索引 | 最快 |
| count(1) | 统计总行数 | 包含 NULL | 优先使用最小索引 | 与 count(*) 相同 |
| count(column) | 统计列非 NULL 值 | 排除 NULL | 必须访问列数据 | 最慢 |

**示例数据：**
```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(100),
  age INT,
  INDEX idx_age(age)
);

INSERT INTO users VALUES
(1, 'Alice', 'alice@example.com', 25),
(2, 'Bob', NULL, 30),
(3, 'Charlie', 'charlie@example.com', NULL),
(4, NULL, 'dave@example.com', 28);

-- 结果对比：
SELECT
  COUNT(*) AS count_star,        -- 4（所有行）
  COUNT(1) AS count_1,            -- 4（所有行）
  COUNT(email) AS count_email,    -- 3（email 非 NULL 的行）
  COUNT(age) AS count_age,        -- 3（age 非 NULL 的行）
  COUNT(name) AS count_name       -- 3（name 非 NULL 的行）
FROM users;
```

### 2. 底层执行原理

**InnoDB 引擎的处理：**

```sql
-- count(*) 和 count(1) 的执行计划
EXPLAIN SELECT COUNT(*) FROM users;

-- 输出：
-- id: 1
-- select_type: SIMPLE
-- table: users
-- type: index
-- possible_keys: NULL
-- key: idx_age        ← 选择最小的索引
-- key_len: 5
-- rows: 4
-- Extra: Using index  ← 覆盖索引扫描

-- count(column) 的执行计划
EXPLAIN SELECT COUNT(email) FROM users;

-- 输出：
-- key: PRIMARY         ← 必须访问主键（聚簇索引）
-- Extra: Using where   ← 需要判断 NULL 值
```

**内部实现差异：**

```
count(*) / count(1) 执行流程：
1. 选择最小的辅助索引（如 idx_age）
2. 全索引扫描，累加行数
3. 不需要读取任何列数据
4. 时间复杂度：O(n)，但 n 是索引大小

count(column) 执行流程：
1. 如果 column 有索引：扫描该索引
   - 判断每行的 column 值是否为 NULL
   - 非 NULL 则计数器 +1
2. 如果 column 无索引：全表扫描主键
   - 读取每行的 column 列
   - 判断是否为 NULL
3. 时间复杂度：O(n)，且需要额外的 NULL 判断
```

**MyISAM 引擎的特殊优化：**
```sql
-- MyISAM 存储了行数，count(*) 是 O(1) 操作
CREATE TABLE test_myisam (
  id INT,
  name VARCHAR(50)
) ENGINE=MyISAM;

INSERT INTO test_myisam VALUES (1, 'A'), (2, 'B'), (3, 'C');

-- 即使表有 1 亿行，这个查询也是瞬间完成
SELECT COUNT(*) FROM test_myisam;  -- 读取元数据，不扫描数据

-- 但有 WHERE 条件时，仍需要扫描
SELECT COUNT(*) FROM test_myisam WHERE name = 'A';  -- O(n)
```

### 3. 性能测试对比

**测试用例（1000 万行数据）：**
```sql
-- 创建测试表
CREATE TABLE test_count (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50),
  age INT,
  email VARCHAR(100),
  INDEX idx_age(age),
  INDEX idx_email(email)
) ENGINE=InnoDB;

-- 插入 1000 万行数据
-- 其中 10% 的 email 为 NULL

-- 性能对比：
SELECT COUNT(*) FROM test_count;        -- 1.2 秒（使用 idx_age）
SELECT COUNT(1) FROM test_count;        -- 1.2 秒（使用 idx_age）
SELECT COUNT(id) FROM test_count;       -- 1.2 秒（id 非 NULL，使用 idx_age）
SELECT COUNT(email) FROM test_count;    -- 2.8 秒（需读取 email 列）
SELECT COUNT(name) FROM test_count;     -- 4.5 秒（全表扫描主键）
```

**EXPLAIN 分析：**
```sql
-- count(*) 优化器选择
EXPLAIN SELECT COUNT(*) FROM test_count\G

*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: test_count
         type: index
possible_keys: NULL
          key: idx_age              ← 自动选择最小索引
      key_len: 5                    ← INT 类型 + NULL 标志
         rows: 10000000
        Extra: Using index          ← 覆盖索引，不回表

-- count(name) 无优化
EXPLAIN SELECT COUNT(name) FROM test_count\G

          key: NULL                 ← 全表扫描
        Extra: Using where          ← 需要判断 NULL
```

### 4. 常见误区

**误区 1：count(1) 比 count(*) 快**
```sql
-- 错误认知：
-- "count(1) 不需要取值，比 count(*) 快"

-- 实际情况：
-- MySQL 优化器对两者的处理完全相同
EXPLAIN SELECT COUNT(*) FROM users;
EXPLAIN SELECT COUNT(1) FROM users;
-- 执行计划完全一致

-- 性能测试（1 亿行数据）：
SELECT COUNT(*) FROM big_table;   -- 10.5 秒
SELECT COUNT(1) FROM big_table;   -- 10.5 秒
-- 完全相同
```

**误区 2：count(主键) 最快**
```sql
-- 错误认知：
-- "主键有索引，count(id) 应该最快"

-- 实际情况：
-- InnoDB 主键索引（聚簇索引）包含全部列数据，占用空间大
-- 辅助索引只包含索引列 + 主键值，占用空间小

SELECT COUNT(id) FROM users;    -- 扫描主键索引，10 秒
SELECT COUNT(*) FROM users;     -- 扫描 idx_age（辅助索引），3 秒

-- 验证索引大小：
SELECT
  index_name,
  stat_value * @@innodb_page_size / 1024 / 1024 AS size_mb
FROM mysql.innodb_index_stats
WHERE table_name = 'users' AND stat_name = 'size';

-- 输出：
-- PRIMARY: 500 MB（主键索引）
-- idx_age: 150 MB（辅助索引）
```

**误区 3：在有 WHERE 条件时三者性能相同**
```sql
-- 场景：统计成年用户数
-- count(*) vs count(column)

SELECT COUNT(*) FROM users WHERE age >= 18;     -- 优化器可用索引
SELECT COUNT(email) FROM users WHERE age >= 18; -- 需额外判断 NULL

-- EXPLAIN 对比：
-- count(*)：Using where; Using index（只用索引）
-- count(email)：Using where（需回表读 email）
```

### 5. 实战案例

**案例 1：分页总数统计**
```sql
-- 错误做法：
SELECT COUNT(*) FROM orders WHERE user_id = 123;
-- 如果 orders 表有 1 亿行，即使有索引也很慢

-- 优化方案 A：估算总数（适用于分页）
EXPLAIN SELECT * FROM orders WHERE user_id = 123;
-- 从 rows 估算值获取大概数量（误差 ±10%）

-- 优化方案 B：缓存计数
-- 使用 Redis 缓存：
-- key: order_count:user:123
-- value: 158
-- 每次新增/删除订单时更新缓存

-- 优化方案 C：分段计数（超大表）
SELECT COUNT(*) FROM orders
WHERE user_id = 123 AND created_at >= '2024-01-01';
-- 只统计近期数据，历史数据缓存
```

**案例 2：统计非空值比例**
```sql
-- 需求：统计用户邮箱填写率
SELECT
  COUNT(*) AS total_users,                  -- 总用户数
  COUNT(email) AS users_with_email,         -- 有邮箱的用户数
  ROUND(COUNT(email) / COUNT(*) * 100, 2) AS email_fill_rate
FROM users;

-- 输出：
-- total_users: 10000
-- users_with_email: 8500
-- email_fill_rate: 85.00
```

**案例 3：多条件计数优化**
```sql
-- 错误做法（多次查询）：
SELECT COUNT(*) FROM orders WHERE status = 'paid';      -- 3 秒
SELECT COUNT(*) FROM orders WHERE status = 'pending';   -- 3 秒
SELECT COUNT(*) FROM orders WHERE status = 'canceled';  -- 3 秒
-- 总耗时：9 秒

-- 正确做法（单次查询）：
SELECT
  COUNT(*) AS total,
  COUNT(IF(status = 'paid', 1, NULL)) AS paid_count,
  COUNT(IF(status = 'pending', 1, NULL)) AS pending_count,
  COUNT(IF(status = 'canceled', 1, NULL)) AS canceled_count
FROM orders;
-- 总耗时：3 秒

-- 或使用 SUM：
SELECT
  SUM(status = 'paid') AS paid_count,
  SUM(status = 'pending') AS pending_count,
  SUM(status = 'canceled') AS canceled_count
FROM orders;
```

### 6. 推荐使用规则

**生产环境选择策略：**

```sql
-- 1. 统计总行数 → 使用 count(*)
SELECT COUNT(*) FROM users;

-- 2. 统计非 NULL 值 → 使用 count(column)
SELECT COUNT(email) FROM users;  -- 明确表示"统计有邮箱的用户"

-- 3. 条件统计 → 使用 count(*) + WHERE
SELECT COUNT(*) FROM users WHERE age >= 18;

-- 4. 多条件统计 → 使用 SUM(条件表达式)
SELECT
  SUM(age >= 18) AS adult_count,
  SUM(age < 18) AS minor_count
FROM users;

-- 5. 超大表统计 → 使用近似值或缓存
-- 方案 A：EXPLAIN 估算
-- 方案 B：Redis 计数器
-- 方案 C：定时任务预计算
```

**代码示例（Go + GoFrame）：**
```go
// 错误示例：
var count int
err := dao.Users.Ctx(ctx).Count(&count)  // 默认使用 count(*)

// 统计非空邮箱：
var emailCount int
err := dao.Users.Ctx(ctx).
    Fields("email").
    Where("email IS NOT NULL").
    Count(&emailCount)

// 优化：直接使用聚合函数
type CountResult struct {
    Total      int `json:"total"`
    EmailCount int `json:"email_count"`
}
var result CountResult
err := dao.Users.Ctx(ctx).
    Fields("COUNT(*) as total, COUNT(email) as email_count").
    Scan(&result)
```

### 7. 总结

**性能排序（InnoDB）：**
```
count(*) ≈ count(1) > count(主键) > count(索引列) > count(非索引列)
```

**最佳实践：**
1. 默认使用 `count(*)`，语义清晰且性能最优
2. 统计非 NULL 值时才用 `count(column)`
3. 避免在大表上使用 count，考虑缓存或估算
4. 定期使用 `ANALYZE TABLE` 更新统计信息
