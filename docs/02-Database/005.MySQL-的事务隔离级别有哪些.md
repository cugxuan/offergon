---
title: MySQL 的事务隔离级别有哪些？MVCC 如何实现可重复读？
tags:
  - 数据库
  - 事务
status: robot
class: 数据库
slug: mysql-transaction-isolation-levels-mvcc-repeatable-read
ref:
---

## 核心要点

**四种隔离级别：读未提交 < 读已提交 < 可重复读（MySQL默认）< 串行化；MVCC 通过版本链和 ReadView 实现可重复读**

## 详细回答

### 一、四种事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 实现方式 |
|---------|------|-----------|------|---------|
| **READ UNCOMMITTED**<br>读未提交 | ✅ | ✅ | ✅ | 无锁 |
| **READ COMMITTED**<br>读已提交 | ❌ | ✅ | ✅ | MVCC（每次查询生成新 ReadView） |
| **REPEATABLE READ**<br>可重复读（默认） | ❌ | ❌ | ⚠️ | MVCC（事务开始生成 ReadView）+ Next-Key Lock |
| **SERIALIZABLE**<br>串行化 | ❌ | ❌ | ❌ | 锁（读加共享锁，写加排他锁） |

### 二、三种并发问题

**1. 脏读（Dirty Read）**
- 读取到其他事务未提交的数据
- 示例：事务 A 修改但未提交，事务 B 读取到修改后的值，A 回滚后 B 读取的数据无效

**2. 不可重复读（Non-Repeatable Read）**
- 同一事务内多次读取同一数据，结果不一致（其他事务 UPDATE 导致）
- 示例：事务 A 读取 age=20，事务 B 修改为 age=30 并提交，A 再次读取变成 30

**3. 幻读（Phantom Read）**
- 同一事务内多次范围查询，结果集行数不一致（其他事务 INSERT/DELETE 导致）
- 示例：事务 A 查询 age>20 有 5 条，事务 B 插入 1 条并提交，A 再次查询变成 6 条

### 三、MVCC 实现可重复读

**MVCC（Multi-Version Concurrency Control）多版本并发控制**

#### 核心组件

**1. 隐藏字段**
每行记录包含：
- `DB_TRX_ID`：最后修改该行的事务 ID
- `DB_ROLL_PTR`：回滚指针，指向 undo log 中的历史版本
- `DB_ROW_ID`：隐藏主键（无主键时使用）

**2. Undo Log 版本链**
每次修改生成历史版本，通过 `DB_ROLL_PTR` 形成链表：
```
当前版本(age=30, trx_id=102)
  ↓ DB_ROLL_PTR
历史版本(age=20, trx_id=101)
  ↓ DB_ROLL_PTR
更早版本(age=10, trx_id=100)
```

**3. ReadView（读视图）**
事务查询时生成的一致性快照，包含：
- `m_ids`：当前活跃事务 ID 列表
- `min_trx_id`：最小活跃事务 ID
- `max_trx_id`：下一个将被分配的事务 ID
- `creator_trx_id`：创建该 ReadView 的事务 ID

#### 可见性判断规则

对于版本链中的每个版本，按以下规则判断是否可见：

```
if (DB_TRX_ID == creator_trx_id):
    可见（自己修改的数据）
elif (DB_TRX_ID < min_trx_id):
    可见（已提交的历史事务）
elif (DB_TRX_ID >= max_trx_id):
    不可见（未来事务）
elif (DB_TRX_ID in m_ids):
    不可见（活跃事务未提交）
else:
    可见（已提交事务）
```

找到第一个可见版本后返回。

### 四、不同隔离级别的 ReadView 生成时机

| 隔离级别 | ReadView 生成时机 | 效果 |
|---------|------------------|------|
| **READ COMMITTED** | 每次 SELECT 生成新 ReadView | 能读到其他事务已提交的修改（不可重复读） |
| **REPEATABLE READ** | 事务开始时生成唯一 ReadView | 整个事务期间读取数据一致（可重复读） |

**示例**：

```sql
-- 事务 A（REPEATABLE READ）
START TRANSACTION; -- 此时生成 ReadView
SELECT age FROM user WHERE id=1; -- age=20
-- 此时事务 B 修改 age=30 并提交
SELECT age FROM user WHERE id=1; -- 仍然是 age=20（使用事务开始的 ReadView）
COMMIT;
```

### 五、幻读的解决

**MVCC 无法完全解决幻读**（针对 INSERT/DELETE）

InnoDB 使用 **Next-Key Lock（记录锁 + 间隙锁）** 解决：

```sql
-- 事务 A
SELECT * FROM user WHERE age BETWEEN 20 AND 30 FOR UPDATE;
-- 锁定范围 [20, 30] 及间隙，阻止其他事务插入 age 在此范围的数据

-- 事务 B（阻塞）
INSERT INTO user(age) VALUES(25); -- 被阻塞
```

**快照读 vs 当前读**：
- 快照读（普通 SELECT）：使用 MVCC，可能出现幻读
- 当前读（SELECT ... FOR UPDATE/LOCK IN SHARE MODE、UPDATE、DELETE）：使用 Next-Key Lock，避免幻读

### 六、设置隔离级别

```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;

-- 设置全局隔离级别
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- 设置会话隔离级别
SET SESSION transaction_isolation = 'REPEATABLE-READ';
```

### 七、面试加分项

**为什么 MySQL 默认是 REPEATABLE READ，而 Oracle/PostgreSQL 默认是 READ COMMITTED？**

**历史原因**：
- MySQL 5.0 之前使用基于语句的 binlog 复制（Statement-Based Replication）
- READ COMMITTED 下可能导致主从数据不一致
- REPEATABLE READ 配合 binlog 能保证主从一致性

**现代实践**：
- MySQL 5.1+ 默认使用基于行的 binlog（Row-Based Replication），READ COMMITTED 也能保证主从一致
- 互联网公司通常改为 READ COMMITTED（如阿里、美团），减少锁竞争，提升并发性能
