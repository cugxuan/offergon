---
title: MySQL 的分区表（Partition）使用场景和限制
tags:
  - 数据库
status: robot
class: 数据库
slug: mysql-partition-use-cases-and-limitations
ref:
---

## 核心要点

MySQL 分区表在逻辑上是一张表，物理上分为多个分区存储，支持按 RANGE、LIST、HASH、KEY 分区；适用于超大表的数据归档、时间序列查询优化，但有限制：分区键必须包含在主键/唯一索引中、全局索引不友好、不支持外键、最大分区数 8192。

## 详细回答

### 一、分区表概念

MySQL 分区表是一种**逻辑上的表**，在存储层面被拆分为多个独立的物理分区，每个分区对应独立的 `.ibd` 文件。查询时，MySQL 根据分区键自动定位到具体分区（分区裁剪），减少扫描数据量。

**分区表 vs 分库分表：**

| 对比维度 | 分区表 | 分库分表 |
|---------|--------|---------|
| **透明性** | 对应用完全透明，无需修改 SQL | 需要应用层路由逻辑 |
| **扩展性** | 单机资源限制，最多 8192 个分区 | 可跨多台机器，几乎无限扩展 |
| **维护成本** | 简单，DDL 操作方便 | 复杂，需要管理多个数据库实例 |
| **适用场景** | 千万级到亿级数据的单表优化 | 亿级以上数据，需要水平扩展 |

### 二、分区类型与使用场景

#### 1. RANGE 分区（按范围分区）

根据分区键的连续范围划分数据，最常用于**时间序列数据**。

**示例：订单表按月份分区**
```sql
CREATE TABLE orders (
    id BIGINT NOT NULL AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    order_no VARCHAR(32) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    create_time DATETIME NOT NULL,
    PRIMARY KEY (id, create_time)  -- 注意：分区键必须在主键中
) ENGINE=InnoDB
PARTITION BY RANGE (YEAR(create_time)*100 + MONTH(create_time)) (
    PARTITION p202401 VALUES LESS THAN (202402),
    PARTITION p202402 VALUES LESS THAN (202403),
    PARTITION p202403 VALUES LESS THAN (202404),
    PARTITION p202404 VALUES LESS THAN (202405),
    PARTITION p202405 VALUES LESS THAN (202406),
    PARTITION p202406 VALUES LESS THAN (202407),
    PARTITION p202407 VALUES LESS THAN (202408),
    PARTITION p202408 VALUES LESS THAN (202409),
    PARTITION p202409 VALUES LESS THAN (202410),
    PARTITION p202410 VALUES LESS THAN (202411),
    PARTITION p202411 VALUES LESS THAN (202412),
    PARTITION p202412 VALUES LESS THAN (202501),
    PARTITION p_future VALUES LESS THAN MAXVALUE  -- 兜底分区
);
```

**分区裁剪示例：**
```sql
-- 查询 2024 年 10 月的订单（只扫描 p202410 分区）
EXPLAIN PARTITIONS
SELECT * FROM orders
WHERE create_time >= '2024-10-01' AND create_time < '2024-11-01';

-- 结果显示：
-- partitions: p202410  （只扫描一个分区，而不是整张表）
```

**数据归档示例：**
```sql
-- 删除 2024 年 1 月的历史数据（毫秒级完成，不锁表）
ALTER TABLE orders DROP PARTITION p202401;

-- 归档数据到历史表
CREATE TABLE orders_archive LIKE orders;
ALTER TABLE orders EXCHANGE PARTITION p202402 WITH TABLE orders_archive;
```

**优点：**
- 查询效率高：按时间范围查询时，只扫描相关分区
- 数据归档快：删除整个分区是元数据操作，不需要扫描数据
- 维护简单：可以定期添加新分区、删除旧分区

**使用场景：**
- 日志表、订单表、账单表等时间序列数据
- 需要定期归档历史数据的业务

#### 2. LIST 分区（按列表分区）

根据分区键的离散值列表划分数据，适用于**地域、类别**等枚举类型。

**示例：用户表按地区分区**
```sql
CREATE TABLE users (
    id BIGINT NOT NULL AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    region_code INT NOT NULL,  -- 1:华北 2:华东 3:华南 4:西南
    create_time DATETIME NOT NULL,
    PRIMARY KEY (id, region_code)
) ENGINE=InnoDB
PARTITION BY LIST (region_code) (
    PARTITION p_north VALUES IN (1),      -- 北京、天津、河北
    PARTITION p_east VALUES IN (2),       -- 上海、江苏、浙江
    PARTITION p_south VALUES IN (3),      -- 广东、福建
    PARTITION p_west VALUES IN (4),       -- 四川、重庆
    PARTITION p_other VALUES IN (0)       -- 其他地区
);
```

**查询示例：**
```sql
-- 查询华东地区用户（只扫描 p_east 分区）
SELECT * FROM users WHERE region_code = 2;
```

**使用场景：**
- 多租户系统（按租户 ID 分区）
- 电商系统（按店铺类型分区：自营、第三方）

#### 3. HASH 分区（按哈希分区）

根据分区键的哈希值分配数据，保证数据**分布均匀**。

**示例：用户表按 ID 哈希分区（8 个分区）**
```sql
CREATE TABLE users (
    id BIGINT NOT NULL AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    create_time DATETIME NOT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB
PARTITION BY HASH(id)
PARTITIONS 8;  -- 自动创建 p0, p1, ..., p7
```

**分区分布：**
```sql
-- 用户 ID 1001 → 分区索引 = 1001 % 8 = 1 → 存储在 p1
-- 用户 ID 1002 → 分区索引 = 1002 % 8 = 2 → 存储在 p2
```

**优点：**
- 数据分布均匀，避免热点
- 自动管理分区，无需手动定义范围

**缺点：**
- 不支持分区裁剪（除非查询条件是分区键的等值查询）
- 扩容困难：增加分区数会导致数据重新分布

**使用场景：**
- 用户表、设备表等 ID 递增的表
- 数据分布均匀性要求高的场景

#### 4. KEY 分区（按 MySQL 内部哈希分区）

与 HASH 分区类似，但使用 MySQL 内部哈希函数，支持非整型字段。

```sql
CREATE TABLE sessions (
    session_id VARCHAR(128) NOT NULL,
    user_id BIGINT NOT NULL,
    data TEXT,
    expire_time DATETIME,
    PRIMARY KEY (session_id)
) ENGINE=InnoDB
PARTITION BY KEY(session_id)
PARTITIONS 16;
```

### 三、分区表的限制

#### 1. 分区键必须包含在主键/唯一索引中

**错误示例：**
```sql
-- 错误：主键不包含分区键 create_time
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 主键只有 id
    user_id BIGINT,
    create_time DATETIME
) PARTITION BY RANGE (YEAR(create_time));

-- 报错：ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function
```

**正确示例：**
```sql
-- 方案 1：主键包含分区键
CREATE TABLE orders (
    id BIGINT NOT NULL AUTO_INCREMENT,
    user_id BIGINT,
    create_time DATETIME,
    PRIMARY KEY (id, create_time)  -- 联合主键
) PARTITION BY RANGE (YEAR(create_time));

-- 方案 2：使用唯一索引替代主键
CREATE TABLE orders (
    id BIGINT NOT NULL AUTO_INCREMENT,
    user_id BIGINT,
    create_time DATETIME,
    UNIQUE KEY (id, create_time)  -- 唯一索引包含分区键
) PARTITION BY RANGE (YEAR(create_time));
```

#### 2. 最大分区数限制

MySQL 5.7 及以上版本，单表最多支持 **8192 个分区**。

```sql
-- 查看分区数
SELECT TABLE_NAME, COUNT(*) AS partition_count
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'your_database'
GROUP BY TABLE_NAME;
```

#### 3. 不支持外键

```sql
-- 错误：分区表不能使用外键
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY,
    order_id BIGINT,
    FOREIGN KEY (order_id) REFERENCES orders(id)  -- 报错
) PARTITION BY HASH(id);
```

#### 4. 全表扫描可能性能下降

如果查询条件不包含分区键，MySQL 需要扫描所有分区（全表扫描）。

```sql
-- 不包含分区键 create_time，扫描所有分区
SELECT * FROM orders WHERE user_id = 12345;

-- 包含分区键，只扫描一个分区
SELECT * FROM orders WHERE create_time = '2024-10-08' AND user_id = 12345;
```

#### 5. 分区键不能为 NULL

```sql
-- 错误：分区键列必须定义为 NOT NULL
CREATE TABLE test (
    id INT,
    create_time DATETIME  -- 允许 NULL
) PARTITION BY RANGE (YEAR(create_time));

-- 报错：ERROR 1659 (HY000): Field in list of fields for partition function not found in table
```

### 四、实战案例

**案例：日志表的分区优化**

某监控系统日志表每天产生 5000 万条记录，1 年累计 180 亿条数据，查询和归档遇到瓶颈。

**原表结构（无分区）：**
```sql
CREATE TABLE system_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    service_name VARCHAR(50),
    log_level VARCHAR(10),
    message TEXT,
    create_time DATETIME
) ENGINE=InnoDB;

-- 问题：
-- 1. 表大小 3TB，单表查询缓慢
-- 2. 删除历史数据需要数小时，锁表严重
```

**优化方案（RANGE 分区 + 按天分区）：**
```sql
CREATE TABLE system_logs (
    id BIGINT NOT NULL AUTO_INCREMENT,
    service_name VARCHAR(50),
    log_level VARCHAR(10),
    message TEXT,
    create_time DATETIME NOT NULL,
    PRIMARY KEY (id, create_time),
    INDEX idx_service_time (service_name, create_time)
) ENGINE=InnoDB
PARTITION BY RANGE (TO_DAYS(create_time)) (
    PARTITION p20241001 VALUES LESS THAN (TO_DAYS('2024-10-02')),
    PARTITION p20241002 VALUES LESS THAN (TO_DAYS('2024-10-03')),
    -- ... 省略其他日期分区
    PARTITION p20241007 VALUES LESS THAN (TO_DAYS('2024-10-08')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**自动化分区管理（定时任务）：**
```sql
-- 每天凌晨 1 点创建新分区
DELIMITER $$
CREATE EVENT create_daily_partition
ON SCHEDULE EVERY 1 DAY
STARTS '2024-10-08 01:00:00'
DO
BEGIN
    SET @tomorrow = DATE_ADD(CURDATE(), INTERVAL 1 DAY);
    SET @partition_name = CONCAT('p', DATE_FORMAT(@tomorrow, '%Y%m%d'));
    SET @partition_value = TO_DAYS(@tomorrow);

    SET @sql = CONCAT(
        'ALTER TABLE system_logs REORGANIZE PARTITION p_future INTO (',
        'PARTITION ', @partition_name, ' VALUES LESS THAN (', @partition_value, '),',
        'PARTITION p_future VALUES LESS THAN MAXVALUE)'
    );

    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$
DELIMITER ;

-- 每周日删除 90 天前的分区（数据归档）
DELIMITER $$
CREATE EVENT drop_old_partitions
ON SCHEDULE EVERY 1 WEEK
STARTS '2024-10-13 02:00:00'
DO
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE part_name VARCHAR(64);
    DECLARE cur CURSOR FOR
        SELECT PARTITION_NAME
        FROM INFORMATION_SCHEMA.PARTITIONS
        WHERE TABLE_SCHEMA = 'your_database'
          AND TABLE_NAME = 'system_logs'
          AND PARTITION_NAME != 'p_future'
          AND PARTITION_DESCRIPTION < TO_DAYS(DATE_SUB(CURDATE(), INTERVAL 90 DAY));
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO part_name;
        IF done THEN
            LEAVE read_loop;
        END IF;

        SET @sql = CONCAT('ALTER TABLE system_logs DROP PARTITION ', part_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    CLOSE cur;
END$$
DELIMITER ;
```

**优化效果：**

| 指标 | 优化前 | 优化后 |
|------|-------|-------|
| 查询最近 7 天日志 | 扫描 180 亿行，耗时 45 秒 | 扫描 3.5 亿行（7 个分区），耗时 2 秒 |
| 删除 90 天前数据 | 全表扫描删除，耗时 8 小时 | DROP PARTITION，耗时 < 1 秒 |
| 磁盘空间回收 | DELETE 后需手动 OPTIMIZE TABLE | 删除分区立即释放空间 |

### 五、分区管理操作

```sql
-- 1. 查看表的分区信息
SELECT PARTITION_NAME, PARTITION_EXPRESSION, PARTITION_DESCRIPTION, TABLE_ROWS
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'your_database' AND TABLE_NAME = 'orders';

-- 2. 添加新分区（RANGE 分区）
ALTER TABLE orders ADD PARTITION (
    PARTITION p202501 VALUES LESS THAN (202502)
);

-- 3. 删除分区（删除数据）
ALTER TABLE orders DROP PARTITION p202401;

-- 4. 交换分区（快速归档）
CREATE TABLE orders_archive_202401 LIKE orders;
ALTER TABLE orders_archive_202401 REMOVE PARTITIONING;  -- 归档表不分区
ALTER TABLE orders EXCHANGE PARTITION p202401 WITH TABLE orders_archive_202401;

-- 5. 重组分区（拆分或合并分区）
ALTER TABLE orders REORGANIZE PARTITION p_future INTO (
    PARTITION p202502 VALUES LESS THAN (202503),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 6. 查看分区裁剪情况（EXPLAIN）
EXPLAIN PARTITIONS
SELECT * FROM orders WHERE create_time BETWEEN '2024-10-01' AND '2024-10-31';
```

### 六、何时使用分区表

**适合使用分区表：**
1. 单表数据量超过 1000 万行，且持续增长
2. 查询主要按时间范围或特定字段过滤
3. 需要定期归档或清理历史数据
4. 单机数据库可满足容量需求（不需要分布式）

**不适合使用分区表：**
1. 查询条件不包含分区键（导致全表扫描）
2. 需要频繁的跨分区关联查询
3. 数据量超过单机承载能力（应使用分库分表）
4. 需要外键约束

**推荐实践：**
- 时间序列数据优先使用 RANGE 分区 + 自动化分区管理
- 查询时尽量在 WHERE 条件中包含分区键
- 定期监控分区大小，避免单个分区过大
- 分区数量控制在 100-500 之间（过多分区影响性能）

分区表是介于单表和分库分表之间的折中方案，能以较低成本解决大部分单表性能问题，是 DBA 必备的优化手段。
