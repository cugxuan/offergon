---
title: MySQL 的聚簇索引和非聚簇索引有什么区别？InnoDB 和 MyISAM 的索引结构有何不同？
tags:
  - 数据库
  - 索引
status: robot
class: 数据库
slug: clustered-nonclustered-index-difference-innodb-myisam
ref:
---

## 核心要点

**聚簇索引：数据和索引存储在一起，叶子节点存储完整行数据；非聚簇索引：索引和数据分离，叶子节点存储主键值**

## 详细回答

### 一、聚簇索引（Clustered Index）

**定义**：索引的叶子节点直接存储完整的行数据，数据的物理存储顺序与索引顺序一致。

**特点**：
1. **一张表只能有一个聚簇索引**（因为数据只能按一种顺序存储）
2. **InnoDB 的主键就是聚簇索引**
3. 如果没有主键，InnoDB 会选择第一个唯一非空索引作为聚簇索引
4. 如果都没有，InnoDB 会自动生成隐藏的 6 字节 row_id 作为聚簇索引

**优势**：
- 按主键查询速度极快（一次 I/O 直接获取完整数据）
- 范围查询效率高（数据物理连续存储）
- 覆盖索引查询不需要回表

**劣势**：
- 插入/更新可能导致页分裂，影响性能
- 二级索引需要回表（存储的是主键值）

### 二、非聚簇索引（Non-Clustered Index / Secondary Index）

**定义**：索引与数据分离，索引的叶子节点存储的是主键值（InnoDB）或数据指针（MyISAM）。

**特点**：
1. **一张表可以有多个非聚簇索引**
2. InnoDB 的二级索引都是非聚簇索引
3. 查询时需要两步：先通过二级索引找到主键值，再通过主键查询聚簇索引（回表）

**优势**：
- 可以创建多个，灵活支持不同查询场景
- 索引体积小，维护成本低

**劣势**：
- 回表操作增加 I/O 次数
- 范围查询可能触发大量随机 I/O

### 三、InnoDB vs MyISAM 索引结构对比

| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| **主键索引** | 聚簇索引（叶子节点存数据） | 非聚簇索引（叶子节点存数据地址） |
| **二级索引** | 非聚簇索引（存主键值） | 非聚簇索引（存数据地址） |
| **回表** | 二级索引需要回表 | 所有索引都直接访问数据地址，无需回表 |
| **数据存储** | .ibd 文件（索引和数据一起） | .MYD 数据文件 + .MYI 索引文件 |
| **主键要求** | 必须有主键（没有会自动生成） | 可以没有主键 |

### 四、实际案例对比

**场景**：表 `user(id, name, age)`，主键 id，普通索引 age

```sql
-- InnoDB 执行流程
SELECT * FROM user WHERE age = 20;
```

**InnoDB**：
1. 在 age 二级索引树中找到 age=20 的记录，获取主键 id=100
2. 回表：用 id=100 到聚簇索引树中查询完整数据

**MyISAM**：
1. 在 age 索引树中找到 age=20 的记录，获取数据文件地址
2. 直接根据地址读取 .MYD 文件中的数据

### 五、覆盖索引优化（避免回表）

```sql
-- 创建联合索引
CREATE INDEX idx_name_age ON user(name, age);

-- 下面的查询无需回表（覆盖索引）
SELECT name, age FROM user WHERE name = 'Alice';
```

因为查询字段都在索引中，无需访问聚簇索引。

### 六、面试加分项

**为什么 InnoDB 推荐使用自增主键？**

1. **避免页分裂**：自增主键顺序插入，不会导致 B+ 树节点频繁分裂
2. **减小索引体积**：二级索引存储主键值，自增 INT 比 UUID 节省空间
3. **提升插入性能**：顺序写入比随机写入快

**UUID 作为主键的问题**：
- 无序插入导致频繁页分裂和碎片化
- 占用空间大（36 字节 vs 4 字节）
- 二级索引体积膨胀
