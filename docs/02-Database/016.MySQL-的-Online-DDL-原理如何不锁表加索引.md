---
title: MySQL 的 Online DDL 原理，如何不锁表加索引？
tags:
  - 数据库
  - 索引
status: robot
class: 数据库
slug: mysql-online-ddl-add-index-without-locking
ref:
---

## 核心要点

Online DDL 通过三阶段实现不锁表加索引：准备阶段加短暂元数据锁，执行阶段只读表数据并记录增量 DML 到 row log，提交阶段回放 row log 并切换表定义，整体支持并发 DML。

## 详细回答

### 1. Online DDL 的三个阶段

**阶段划分：**

| 阶段 | 操作内容 | 锁定情况 | 耗时 |
|------|---------|---------|------|
| Prepare（准备） | 创建临时 frm 文件，获取元数据锁 | MDL 写锁（极短） | 毫秒级 |
| Execute（执行） | 读取原表数据构建新索引，记录增量变更到 row log | 允许并发 DML | 分钟到小时级 |
| Commit（提交） | 回放 row log，替换 frm 文件，释放资源 | MDL 写锁（极短） | 秒级 |

**核心原理：**
```sql
-- 示例：给大表添加索引
ALTER TABLE users
ADD INDEX idx_email(email),
ALGORITHM=INPLACE, LOCK=NONE;

-- 参数说明：
-- ALGORITHM=INPLACE：数据在原表上修改，不拷贝全表
-- LOCK=NONE：允许并发 DML 操作
```

### 2. 关键机制

**Row Log（行日志）：**
```sql
-- 执行阶段，并发的 DML 操作被记录：
INSERT INTO users VALUES (...);  -- 记录到 row log
UPDATE users SET email=...;       -- 记录到 row log
DELETE FROM users WHERE ...;      -- 记录到 row log

-- row log 特点：
-- 1. 存储在 InnoDB 临时表空间
-- 2. 大小受 innodb_online_alter_log_max_size 限制（默认 128MB）
-- 3. 超出大小会导致 DDL 失败
```

**示例流程：**
```
时间线              原表操作                    DDL 操作
------------------------------------------------------------
T1                                          开始 ALTER TABLE
T2    INSERT id=100                         读取 id=1~99
T3    UPDATE id=50                          读取 id=100~199
                                            ↓ 将 T2,T3 操作记录到 row log
T4    DELETE id=75                          读取 id=200~299
T5                                          执行完毕，回放 row log
                                            应用 id=100 插入、id=50 更新、id=75 删除
T6                                          切换表定义，完成
```

### 3. ALGORITHM 和 LOCK 参数对比

| ALGORITHM | 说明 | 拷贝数据 | 支持并发 DML | 适用场景 |
|-----------|------|---------|--------------|---------|
| COPY | 创建临时表，全表拷贝 | 是 | 否（表锁） | MySQL 5.5 默认方式 |
| INPLACE | 原表上修改，使用 row log | 否 | 是（部分 DDL） | 添加索引、修改列类型 |
| INSTANT | 仅修改元数据 | 否 | 是 | MySQL 8.0 添加列（末尾） |

| LOCK | 说明 | 并发读 | 并发写 | 风险 |
|------|------|--------|--------|------|
| NONE | 不加锁 | 允许 | 允许 | row log 可能溢出 |
| SHARED | 共享锁 | 允许 | 阻塞 | 低风险 |
| EXCLUSIVE | 排他锁 | 阻塞 | 阻塞 | 业务中断 |
| DEFAULT | 自动选择最小锁 | - | - | 推荐 |

### 4. 实战案例

**案例 1：大表加索引（生产环境）**
```sql
-- 1 亿行数据的订单表
-- 错误做法：
ALTER TABLE orders ADD INDEX idx_user_id(user_id);
-- 可能锁表数小时，业务不可用

-- 正确做法：
-- 方案 A：使用 Online DDL 参数
ALTER TABLE orders
ADD INDEX idx_user_id(user_id),
ALGORITHM=INPLACE, LOCK=NONE;

-- 方案 B：pt-online-schema-change（推荐）
pt-online-schema-change \
  --alter "ADD INDEX idx_user_id(user_id)" \
  --execute \
  --chunk-size=5000 \
  --max-load="Threads_running=100" \
  D=mydb,t=orders

-- 方案 C：MySQL 8.0 降低优先级
SET SESSION alter_algorithm='INSTANT,INPLACE,COPY';
ALTER TABLE orders ADD INDEX idx_user_id(user_id);
```

**案例 2：监控 DDL 进度**
```sql
-- 查看 Online DDL 执行状态
SELECT
  EVENT_NAME,
  WORK_COMPLETED,
  WORK_ESTIMATED,
  ROUND(WORK_COMPLETED/WORK_ESTIMATED*100, 2) AS progress_pct
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE 'stage/innodb/alter%';

-- 输出示例：
-- EVENT_NAME: stage/innodb/alter table (read PK and internal sort)
-- WORK_COMPLETED: 45000000
-- WORK_ESTIMATED: 100000000
-- progress_pct: 45.00
```

**案例 3：row log 溢出处理**
```sql
-- 调大 row log 缓冲区（DDL 前）
SET GLOBAL innodb_online_alter_log_max_size = 1073741824; -- 1GB

-- 如果仍然失败，降级为只读锁
ALTER TABLE users
ADD INDEX idx_email(email),
ALGORITHM=INPLACE, LOCK=SHARED;  -- 允许读，阻塞写
```

### 5. 不支持 Online 的 DDL 操作

**必须 COPY 的操作：**
```sql
-- 1. 修改列类型（大多数情况）
ALTER TABLE users MODIFY COLUMN name VARCHAR(50);  -- 从 VARCHAR(100) 缩小

-- 2. 修改字符集
ALTER TABLE users CONVERT TO CHARACTER SET utf8mb4;

-- 3. 删除主键
ALTER TABLE users DROP PRIMARY KEY;

-- 4. 添加全文索引（InnoDB）
ALTER TABLE articles ADD FULLTEXT INDEX ft_content(content);

-- 这些操作会：
-- - 创建临时表
-- - 逐行拷贝数据
-- - 加表锁（阻塞写入）
```

### 6. 最佳实践

**生产环境 DDL 检查清单：**
```sql
-- 1. 确认 DDL 是否支持 Online
SELECT * FROM information_schema.innodb_sys_tables
WHERE name = 'mydb/users';

-- 2. 预估执行时间（按索引大小）
SELECT
  table_name,
  ROUND((data_length + index_length)/1024/1024, 2) AS size_mb,
  ROUND((data_length + index_length)/1024/1024/10, 2) AS estimated_minutes
FROM information_schema.tables
WHERE table_name = 'users';

-- 3. 业务低峰期执行
-- 4. 设置超时保护
SET SESSION lock_wait_timeout = 5;  -- 等待 MDL 锁最多 5 秒

-- 5. 使用 pt-osc 工具（更安全）
-- - 自动分块处理
-- - 监控负载
-- - 暂停/恢复功能
-- - 失败自动回滚
```

**对比传统方式：**
```sql
-- 传统 DDL（MySQL 5.5 之前）
ALTER TABLE users ADD INDEX idx_email(email);
-- 问题：
-- - 全表拷贝到临时表
-- - 加表级写锁
-- - 1 亿行数据可能锁表数小时
-- - 业务完全不可用

-- Online DDL（MySQL 5.6+）
ALTER TABLE users ADD INDEX idx_email(email) ALGORITHM=INPLACE;
-- 优势：
-- - 原地修改，仅拷贝索引数据
-- - 允许并发 DML
-- - 1 亿行数据约 30 分钟，业务可用
```
