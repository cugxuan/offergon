---
title: MySQL 8.0 的新特性（窗口函数、CTE、隐藏索引等）
tags:
  - 数据库
  - 索引
status: robot
class: 数据库
slug: mysql-8-new-features-window-functions-cte-hidden-indexes
ref:
---

## 核心要点

MySQL 8.0 引入窗口函数实现排名分组聚合、CTE 递归查询、隐藏索引测试影响、降序索引优化 ORDER BY DESC、角色管理简化权限、原子 DDL 保证一致性等核心特性。

## 详细回答

### 1. 窗口函数（Window Functions）

**核心概念：**
窗口函数在查询结果集上定义一个窗口（行的集合），对窗口内的数据进行计算，但不改变结果集的行数。

**常用窗口函数分类：**

| 类型 | 函数 | 功能 |
|------|------|------|
| 排名函数 | ROW_NUMBER() | 连续排名（1,2,3,4） |
| | RANK() | 跳跃排名（1,2,2,4） |
| | DENSE_RANK() | 密集排名（1,2,2,3） |
| | NTILE(n) | 分组排名（分成 n 组） |
| 聚合函数 | SUM() OVER() | 累计求和 |
| | AVG() OVER() | 移动平均 |
| | COUNT() OVER() | 累计计数 |
| 取值函数 | LAG(col, n) | 取前 n 行的值 |
| | LEAD(col, n) | 取后 n 行的值 |
| | FIRST_VALUE() | 窗口内第一个值 |
| | LAST_VALUE() | 窗口内最后一个值 |

**实战案例 1：部门薪资排名**
```sql
-- 需求：每个部门员工按薪资排名
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  dept_id INT,
  salary DECIMAL(10,2)
);

-- 传统方法（MySQL 5.7）：
SELECT e1.*, COUNT(e2.id) AS rank
FROM employees e1
LEFT JOIN employees e2 ON e1.dept_id = e2.dept_id AND e1.salary < e2.salary
GROUP BY e1.id
ORDER BY e1.dept_id, rank;
-- 问题：自连接，性能差，代码复杂

-- MySQL 8.0 窗口函数：
SELECT
  name,
  dept_id,
  salary,
  ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS row_num,
  RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS rank_num,
  DENSE_RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS dense_rank_num
FROM employees;

-- 输出示例：
-- name   dept_id  salary   row_num  rank_num  dense_rank_num
-- Alice  1        10000    1        1         1
-- Bob    1        9000     2        2         2
-- Carol  1        9000     3        2         2  ← 并列第2，RANK跳到4
-- Dave   1        8000     4        4         3  ← DENSE_RANK是3
-- Eve    2        12000    1        1         1
```

**实战案例 2：累计销售额**
```sql
-- 需求：计算每月累计销售额
SELECT
  month,
  amount,
  SUM(amount) OVER (ORDER BY month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,
  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg_3
FROM monthly_sales;

-- 输出示例：
-- month    amount   cumulative_sum   moving_avg_3
-- 2024-01  10000    10000            10000.00  ← 第1个月，只有自己
-- 2024-02  15000    25000            12500.00  ← 前2月平均
-- 2024-03  12000    37000            12333.33  ← 前3月平均
-- 2024-04  18000    55000            15000.00  ← 最近3月平均
```

**实战案例 3：同比环比计算**
```sql
-- 需求：计算销售额的环比增长率
SELECT
  month,
  amount,
  LAG(amount, 1) OVER (ORDER BY month) AS last_month,
  ROUND((amount - LAG(amount, 1) OVER (ORDER BY month)) / LAG(amount, 1) OVER (ORDER BY month) * 100, 2) AS growth_rate,
  LAG(amount, 12) OVER (ORDER BY month) AS last_year_same_month
FROM monthly_sales;

-- 输出示例：
-- month    amount   last_month   growth_rate   last_year_same_month
-- 2024-01  10000    NULL         NULL          NULL
-- 2024-02  15000    10000        50.00         NULL
-- 2024-03  12000    15000        -20.00        NULL
```

**窗口函数语法：**
```sql
function_name([expression]) OVER (
  [PARTITION BY partition_expression]  -- 分组
  [ORDER BY sort_expression]           -- 排序
  [frame_clause]                       -- 窗口范围
)

-- frame_clause 选项：
-- ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- 从头到当前行
-- ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING          -- 前1行到后1行
-- RANGE BETWEEN INTERVAL 1 DAY PRECEDING AND CURRENT ROW  -- 时间范围
```

### 2. CTE（公用表表达式）

**基础 CTE（非递归）：**
```sql
-- 传统子查询：
SELECT *
FROM employees
WHERE dept_id IN (
  SELECT id FROM departments WHERE budget > 100000
)
AND salary > (
  SELECT AVG(salary) FROM employees
);

-- CTE 写法（更清晰）：
WITH
  high_budget_depts AS (
    SELECT id FROM departments WHERE budget > 100000
  ),
  avg_salary AS (
    SELECT AVG(salary) AS avg_val FROM employees
  )
SELECT e.*
FROM employees e
JOIN high_budget_depts d ON e.dept_id = d.id
CROSS JOIN avg_salary a
WHERE e.salary > a.avg_val;
```

**递归 CTE（核心特性）：**
```sql
-- 案例 1：生成连续数字（1-100）
WITH RECURSIVE numbers AS (
  SELECT 1 AS n          -- 初始查询（anchor member）
  UNION ALL
  SELECT n + 1           -- 递归查询（recursive member）
  FROM numbers
  WHERE n < 100          -- 终止条件
)
SELECT * FROM numbers;

-- 案例 2：组织架构树形查询
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  manager_id INT,
  FOREIGN KEY (manager_id) REFERENCES employees(id)
);

-- 查询某员工的所有下属（递归）
WITH RECURSIVE subordinates AS (
  -- Anchor：起始员工
  SELECT id, name, manager_id, 1 AS level
  FROM employees
  WHERE id = 1  -- CEO

  UNION ALL

  -- Recursive：递归查找下属
  SELECT e.id, e.name, e.manager_id, s.level + 1
  FROM employees e
  JOIN subordinates s ON e.manager_id = s.id
  WHERE s.level < 10  -- 防止无限递归
)
SELECT
  CONCAT(REPEAT('  ', level - 1), name) AS hierarchy,
  level
FROM subordinates
ORDER BY level, id;

-- 输出示例：
-- hierarchy        level
-- CEO              1
--   VP Sales       2
--     Manager A    3
--       Staff 1    4
--       Staff 2    4
--   VP Tech        2
--     Manager B    3
```

**CTE 性能优化：**
```sql
-- 多次引用 CTE（MySQL 8.0.16+ 自动物化）
WITH sales_summary AS (
  SELECT dept_id, SUM(amount) AS total
  FROM orders
  GROUP BY dept_id
)
SELECT
  d.name,
  s1.total AS current_total,
  s2.total AS compare_total
FROM departments d
JOIN sales_summary s1 ON d.id = s1.dept_id
LEFT JOIN sales_summary s2 ON d.parent_id = s2.dept_id;

-- MySQL 自动将 sales_summary 物化为临时表
-- 避免重复执行 GROUP BY
```

### 3. 隐藏索引（Invisible Indexes）

**功能：**
测试删除索引的影响，不实际删除索引。

**使用场景：**
```sql
-- 创建隐藏索引
CREATE TABLE users (
  id INT PRIMARY KEY,
  email VARCHAR(100),
  name VARCHAR(50),
  INDEX idx_email(email) INVISIBLE  -- 创建时隐藏
);

-- 或修改现有索引
ALTER TABLE users ALTER INDEX idx_email INVISIBLE;

-- 验证索引状态
SELECT
  TABLE_NAME,
  INDEX_NAME,
  IS_VISIBLE
FROM information_schema.statistics
WHERE table_schema = 'mydb' AND table_name = 'users';

-- 输出：
-- TABLE_NAME  INDEX_NAME   IS_VISIBLE
-- users       PRIMARY      YES
-- users       idx_email    NO          ← 隐藏索引
```

**实战案例：安全删除索引**
```sql
-- 步骤 1：隐藏索引（不删除）
ALTER TABLE orders ALTER INDEX idx_user_id INVISIBLE;

-- 步骤 2：观察业务指标（1-2 周）
-- - 慢查询日志：是否有新的慢查询
-- - QPS/TPS：是否下降
-- - CPU 使用率：是否上升

SELECT
  sql_text,
  exec_count,
  avg_timer_wait / 1000000000 AS avg_seconds
FROM performance_schema.events_statements_summary_by_digest
WHERE sql_text LIKE '%orders%'
ORDER BY avg_timer_wait DESC
LIMIT 10;

-- 步骤 3A：如果性能无影响，删除索引
DROP INDEX idx_user_id ON orders;

-- 步骤 3B：如果性能下降，恢复索引
ALTER TABLE orders ALTER INDEX idx_user_id VISIBLE;
```

**强制使用隐藏索引（测试用）：**
```sql
-- 全局开启隐藏索引
SET SESSION optimizer_switch='use_invisible_indexes=on';

-- 查询会使用隐藏索引
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 恢复默认
SET SESSION optimizer_switch='use_invisible_indexes=off';
```

### 4. 降序索引（Descending Indexes）

**MySQL 5.7 vs 8.0 差异：**
```sql
-- MySQL 5.7：DESC 被忽略
CREATE INDEX idx_created ON orders(created_at DESC);
-- 实际创建的是升序索引，ORDER BY DESC 需要额外排序

-- MySQL 8.0：真正的降序索引
CREATE INDEX idx_created_desc ON orders(created_at DESC);
-- 物理上按降序存储
```

**性能提升案例：**
```sql
-- 场景：查询最新订单（常见需求）
SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;

-- MySQL 5.7 执行计划：
-- key: idx_created_asc
-- Extra: Using index; Using filesort  ← 需要额外排序

-- MySQL 8.0 执行计划（使用降序索引）：
-- key: idx_created_desc
-- Extra: Using index  ← 直接从索引读取，无需排序

-- 性能提升：大表上可提升 50%+
```

**组合索引优化：**
```sql
-- 场景：分页查询，先按时间降序，再按 ID 升序
CREATE INDEX idx_time_id ON orders(created_at DESC, id ASC);

SELECT * FROM orders
ORDER BY created_at DESC, id ASC
LIMIT 100;

-- 完美利用索引，无需 filesort
```

### 5. 角色管理（Roles）

**传统权限管理问题：**
```sql
-- MySQL 5.7：为每个用户单独授权
GRANT SELECT, INSERT ON mydb.* TO 'user1'@'%';
GRANT SELECT, INSERT ON mydb.* TO 'user2'@'%';
GRANT SELECT, INSERT ON mydb.* TO 'user3'@'%';
-- 重复劳动，难以维护
```

**MySQL 8.0 角色方案：**
```sql
-- 1. 创建角色
CREATE ROLE 'app_read', 'app_write', 'app_admin';

-- 2. 给角色授权
GRANT SELECT ON mydb.* TO 'app_read';
GRANT SELECT, INSERT, UPDATE, DELETE ON mydb.* TO 'app_write';
GRANT ALL PRIVILEGES ON mydb.* TO 'app_admin';

-- 3. 用户绑定角色
CREATE USER 'user1'@'%' IDENTIFIED BY 'password';
GRANT 'app_read' TO 'user1'@'%';

CREATE USER 'user2'@'%' IDENTIFIED BY 'password';
GRANT 'app_write' TO 'user2'@'%';

-- 4. 激活角色（用户登录后执行）
SET ROLE 'app_read';

-- 或设置默认角色（自动激活）
ALTER USER 'user1'@'%' DEFAULT ROLE 'app_read';
```

**动态权限调整：**
```sql
-- 撤销角色权限（所有用户立即生效）
REVOKE INSERT ON mydb.* FROM 'app_write';

-- 查看用户角色
SHOW GRANTS FOR 'user1'@'%';
-- 输出：
-- GRANT USAGE ON *.* TO `user1`@`%`
-- GRANT `app_read`@`%` TO `user1`@`%`

-- 查看角色权限
SHOW GRANTS FOR 'app_read';
```

### 6. 原子 DDL（Atomic DDL）

**MySQL 5.7 问题：**
```sql
-- 删除表可能部分失败
DROP TABLE t1, t2, t3;
-- 如果 t2 不存在：
-- - t1 被删除
-- - t2 报错
-- - t3 未删除
-- 数据字典和文件系统不一致
```

**MySQL 8.0 原子性保证：**
```sql
-- 全部成功或全部失败
DROP TABLE t1, t2, t3;
-- 如果 t2 不存在：
-- - 事务回滚
-- - t1, t3 都不删除
-- - 保证一致性

-- 支持的原子 DDL：
-- - DROP TABLE/DATABASE
-- - RENAME TABLE
-- - ALTER TABLE（部分操作）
-- - CREATE TABLE ... SELECT
```

### 7. 其他重要特性

**7.1 默认字符集 utf8mb4**
```sql
-- MySQL 5.7 默认：latin1
-- MySQL 8.0 默认：utf8mb4（支持 emoji）

CREATE DATABASE mydb;  -- 自动使用 utf8mb4
CREATE TABLE users (
  name VARCHAR(50)  -- 可存储 emoji 😀
);
```

**7.2 JSON 增强**
```sql
-- JSON 表函数（展开 JSON 数组）
SELECT jt.*
FROM users,
JSON_TABLE(
  tags,
  '$[*]' COLUMNS(
    tag VARCHAR(50) PATH '$'
  )
) AS jt;

-- JSON 聚合函数
SELECT
  dept_id,
  JSON_ARRAYAGG(name) AS employees
FROM employees
GROUP BY dept_id;
-- 输出：{"dept_id": 1, "employees": ["Alice", "Bob", "Carol"]}
```

**7.3 CHECK 约束**
```sql
-- MySQL 5.7：语法支持但不生效
-- MySQL 8.0：真正生效

CREATE TABLE employees (
  id INT PRIMARY KEY,
  age INT CHECK (age >= 18 AND age <= 65),  -- 年龄限制
  salary DECIMAL(10,2) CHECK (salary > 0)   -- 薪资必须为正
);

INSERT INTO employees VALUES (1, 16, 5000);
-- ERROR 3819: Check constraint 'employees_chk_1' is violated.
```

**7.4 即时添加列（INSTANT ADD COLUMN）**
```sql
-- MySQL 5.7：添加列需要重建表（耗时数小时）
ALTER TABLE big_table ADD COLUMN new_col INT;

-- MySQL 8.0：瞬间完成（仅修改元数据）
ALTER TABLE big_table ADD COLUMN new_col INT, ALGORITHM=INSTANT;
-- 1 亿行数据，1 秒完成

-- 限制：只能添加到表末尾
ALTER TABLE t ADD COLUMN c1 INT AFTER id;  -- 不支持 INSTANT
```

### 8. Go + GoFrame 代码示例

**窗口函数查询：**
```go
// 查询部门薪资排名前 3 的员工
type RankResult struct {
    Name   string  `json:"name"`
    Dept   int     `json:"dept_id"`
    Salary float64 `json:"salary"`
    Rank   int     `json:"rank"`
}

var results []RankResult
sql := `
SELECT name, dept_id, salary, rank_num
FROM (
    SELECT
        name,
        dept_id,
        salary,
        RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS rank_num
    FROM employees
) t
WHERE rank_num <= 3
`
err := g.DB().GetScan(&results, sql)
```

**CTE 递归查询：**
```go
// 查询组织架构树
type OrgNode struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Level    int    `json:"level"`
}

sql := `
WITH RECURSIVE org_tree AS (
    SELECT id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.id, e.name, e.manager_id, o.level + 1
    FROM employees e
    JOIN org_tree o ON e.manager_id = o.id
)
SELECT * FROM org_tree ORDER BY level, id
`
var nodes []OrgNode
err := g.DB().GetScan(&nodes, sql)
```

### 9. 升级到 MySQL 8.0 注意事项

**兼容性检查：**
```sql
-- 1. 运行 MySQL 升级检查工具
mysqlcheck -u root -p --check-upgrade --all-databases

-- 2. 检查废弃特性
-- - query_cache 已移除
-- - \N 作为 NULL 的写法不再支持
-- - PROCEDURE ANALYSE() 已移除

-- 3. 保留字冲突
-- 新增保留字：RANK, SYSTEM, WINDOW 等
-- 需要用反引号转义：SELECT `rank` FROM t;
```

**性能优化建议：**
```sql
-- 1. 更新统计信息
ANALYZE TABLE orders;

-- 2. 重建索引（利用降序索引）
ALTER TABLE orders DROP INDEX idx_created;
ALTER TABLE orders ADD INDEX idx_created(created_at DESC);

-- 3. 启用直方图（提高统计准确性）
ANALYZE TABLE orders UPDATE HISTOGRAM ON created_at, user_id;
```

### 10. 总结

**核心特性对比：**

| 特性 | MySQL 5.7 | MySQL 8.0 | 性能提升 |
|------|-----------|-----------|---------|
| 窗口函数 | 需自连接 | 原生支持 | 10x+ |
| CTE 递归 | 临时表模拟 | 原生支持 | 易用性大幅提升 |
| 降序索引 | 假降序 | 真降序 | 50%+ |
| 隐藏索引 | 不支持 | 支持 | 运维安全性提升 |
| 默认字符集 | latin1 | utf8mb4 | 支持 emoji |

**推荐升级路线：**
1. 开发/测试环境先升级，验证兼容性
2. 利用窗口函数重构复杂查询
3. 使用 CTE 提升代码可读性
4. 降序索引优化常见 ORDER BY DESC 场景
5. 隐藏索引测试后再删除，降低风险
