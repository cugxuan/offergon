---
title: MySQL 的读写分离架构，如何解决主从延迟？
tags:
  - 数据库
status: robot
class: 数据库
slug: mysql-read-write-separation-master-slave-delay
ref:
---

## 核心要点

读写分离通过主库处理写操作、从库处理读操作来分散压力，但主从复制的异步特性会导致延迟；解决方案包括：强制读主库（写后立即读）、延迟双读（先读从库，数据不一致再读主库）、半同步复制、并行复制优化、业务层缓存标记等策略。

## 详细回答

### 一、读写分离架构设计

读写分离是 MySQL 高并发场景的常见架构，核心思想是将读写流量分离到不同的数据库实例。

**架构图：**
```
                    应用层
                      │
                      ▼
             ┌─────────────────┐
             │  数据库中间件    │  (ProxySQL/Atlas/ShardingSphere)
             └────────┬─────────┘
                      │
         ┌────────────┼────────────┐
         │            │            │
         ▼            ▼            ▼
    ┌────────┐   ┌────────┐   ┌────────┐
    │  主库  │   │  从库1 │   │  从库2 │
    │(写入)  ├──>│ (读取) │   │ (读取) │
    └────────┘   └────────┘   └────────┘
      写操作       读操作       读操作
```

**Go 代码实现示例（使用 GORM）：**
```go
package database

import (
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/plugin/dbresolver"
)

// 初始化读写分离数据库
func InitDB() (*gorm.DB, error) {
    // 主库连接
    masterDSN := "root:password@tcp(master-db:3306)/offergon?charset=utf8mb4&parseTime=True"
    db, err := gorm.Open(mysql.Open(masterDSN), &gorm.Config{})
    if err != nil {
        return nil, err
    }

    // 配置读写分离
    db.Use(dbresolver.Register(dbresolver.Config{
        // 从库列表（支持多个从库负载均衡）
        Replicas: []gorm.Dialector{
            mysql.Open("root:password@tcp(slave1-db:3306)/offergon?charset=utf8mb4&parseTime=True"),
            mysql.Open("root:password@tcp(slave2-db:3306)/offergon?charset=utf8mb4&parseTime=True"),
        },
        // 负载均衡策略：随机选择从库
        Policy: dbresolver.RandomPolicy{},
    }))

    return db, nil
}

// 使用示例
func GetUserByID(db *gorm.DB, userID int64) (*User, error) {
    var user User
    // 默认读从库
    result := db.Where("id = ?", userID).First(&user)
    return &user, result.Error
}

func CreateUser(db *gorm.DB, user *User) error {
    // 写操作自动路由到主库
    return db.Create(user).Error
}
```

### 二、主从延迟产生的原因

主从延迟是指从库的数据落后于主库的时间差，主要原因包括：

| 原因 | 说明 | 影响 |
|------|------|------|
| **异步复制机制** | 主库提交事务后立即返回，不等待从库确认 | 从库 IO 线程拉取延迟 |
| **从库单线程回放** | MySQL 5.6 之前，从库 SQL 线程串行执行 | 主库并发写，从库串行执行导致积压 |
| **大事务** | 主库执行大批量更新（如更新 100 万行） | 从库需要相同时间执行，阻塞其他事务 |
| **从库负载高** | 从库承载大量查询，CPU/IO 资源不足 | SQL 线程执行变慢 |
| **网络抖动** | 主从之间网络延迟或丢包 | binlog 传输变慢 |

**检测主从延迟：**
```sql
-- 在从库执行
SHOW SLAVE STATUS\G

-- 关键指标
Seconds_Behind_Master: 5  -- 延迟 5 秒
Slave_IO_Running: Yes     -- IO 线程正常
Slave_SQL_Running: Yes    -- SQL 线程正常
```

### 三、解决主从延迟的策略

#### 策略 1：强制读主库（写后立即读）

适用于对数据一致性要求极高的场景，写操作后立即读取时，强制从主库读取。

```go
package service

import (
    "gorm.io/gorm"
    "gorm.io/plugin/dbresolver"
)

// 用户注册后立即查询（强制读主库）
func RegisterAndGetUser(db *gorm.DB, username string) (*User, error) {
    // 1. 创建用户（写主库）
    user := &User{Username: username}
    if err := db.Create(user).Error; err != nil {
        return nil, err
    }

    // 2. 立即查询刚创建的用户（强制读主库）
    var newUser User
    err := db.Clauses(dbresolver.Write).  // 强制使用主库连接
        Where("id = ?", user.ID).
        First(&newUser).Error

    return &newUser, err
}
```

**优缺点：**
- 优点：保证强一致性，避免读取到旧数据
- 缺点：增加主库压力，部分丧失读写分离的价值

#### 策略 2：延迟双读（缓存 + 重试）

先读从库，如果发现数据异常或不存在，再读主库进行兜底。

```go
func GetUserWithFallback(db *gorm.DB, userID int64) (*User, error) {
    var user User

    // 1. 先读从库（默认行为）
    result := db.Where("id = ?", userID).First(&user)
    if result.Error == nil && user.ID > 0 {
        return &user, nil
    }

    // 2. 从库未找到或异常，读主库兜底
    err := db.Clauses(dbresolver.Write).
        Where("id = ?", userID).
        First(&user).Error

    return &user, err
}
```

#### 策略 3：业务层标记 + 缓存

写操作后在 Redis 设置短期标记（如 3 秒），期间该用户的读请求路由到主库。

```go
package service

import (
    "context"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    "gorm.io/gorm"
    "gorm.io/plugin/dbresolver"
)

type UserService struct {
    db    *gorm.DB
    redis *redis.Client
}

// 更新用户信息
func (s *UserService) UpdateUser(ctx context.Context, userID int64, data map[string]interface{}) error {
    // 1. 更新数据库（写主库）
    if err := s.db.Model(&User{}).Where("id = ?", userID).Updates(data).Error; err != nil {
        return err
    }

    // 2. 在 Redis 设置标记：该用户 3 秒内读主库
    key := fmt.Sprintf("user:read_master:%d", userID)
    s.redis.Set(ctx, key, "1", 3*time.Second)

    return nil
}

// 查询用户信息
func (s *UserService) GetUser(ctx context.Context, userID int64) (*User, error) {
    var user User

    // 1. 检查 Redis 标记
    key := fmt.Sprintf("user:read_master:%d", userID)
    exists, _ := s.redis.Exists(ctx, key).Result()

    // 2. 如果标记存在，读主库
    if exists > 0 {
        err := s.db.Clauses(dbresolver.Write).
            Where("id = ?", userID).
            First(&user).Error
        return &user, err
    }

    // 3. 否则读从库
    err := s.db.Where("id = ?", userID).First(&user).Error
    return &user, err
}
```

#### 策略 4：半同步复制（MySQL 配置）

MySQL 5.5+ 支持半同步复制，主库提交事务前，至少等待一个从库确认接收到 binlog。

```sql
-- 主库安装半同步插件
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';

-- 从库安装半同步插件
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';

-- 主库启用半同步
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_master_timeout = 1000;  -- 超时 1 秒降级为异步

-- 从库启用半同步
SET GLOBAL rpl_semi_sync_slave_enabled = 1;

-- 查看半同步状态
SHOW STATUS LIKE 'Rpl_semi_sync%';
```

**半同步复制流程：**
```
客户端                主库                    从库
  │                   │                       │
  ├─1. 写入请求──────>│                       │
  │                   ├─2. 写 binlog          │
  │                   ├─3. 发送 binlog────────>│
  │                   │                       ├─4. 接收并写入 relay log
  │                   │<─5. 返回 ACK──────────┤
  │                   ├─6. 提交事务           │
  │<─7. 返回成功──────┤                       │
```

优缺点：
- 优点：减少延迟，提高数据一致性
- 缺点：增加主库事务提交延迟（约 1-10ms），网络问题时可能降级为异步

#### 策略 5：并行复制优化

MySQL 5.7+ 支持基于 LOGICAL_CLOCK 的并行复制，从库可以并行执行多个事务。

```sql
-- 主库配置（启用组提交）
SET GLOBAL binlog_group_commit_sync_delay = 1000;  -- 延迟 1ms 收集更多事务
SET GLOBAL binlog_group_commit_sync_no_delay_count = 10;

-- 从库配置（并行复制）
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';
SET GLOBAL slave_parallel_workers = 4;  -- 4 个 SQL 线程并行执行
SET GLOBAL slave_preserve_commit_order = ON;  -- 保持提交顺序

-- 重启复制应用配置
STOP SLAVE SQL_THREAD;
START SLAVE SQL_THREAD;
```

### 四、实战案例

**案例：电商订单系统的读写分离优化**

某电商系统在促销活动期间，用户下单后立即跳转订单详情页，发现 20% 的用户看到"订单不存在"错误（主从延迟 2-5 秒导致）。

**问题分析：**
```
用户下单 → 写入主库（订单 ID: 10001）
           ↓
         返回订单 ID
           ↓
用户查询订单 → 读从库（延迟 3 秒，查不到订单 10001）
           ↓
         提示"订单不存在"
```

**解决方案（组合策略）：**

```go
package service

type OrderService struct {
    db    *gorm.DB
    redis *redis.Client
}

// 创建订单
func (s *OrderService) CreateOrder(ctx context.Context, order *Order) error {
    // 1. 写入主库
    if err := s.db.Create(order).Error; err != nil {
        return err
    }

    // 2. 将订单详情缓存到 Redis（5 分钟）
    orderKey := fmt.Sprintf("order:%d", order.ID)
    orderJSON, _ := json.Marshal(order)
    s.redis.Set(ctx, orderKey, orderJSON, 5*time.Minute)

    // 3. 设置"强制读主库"标记（5 秒）
    masterKey := fmt.Sprintf("order:read_master:%d", order.ID)
    s.redis.Set(ctx, masterKey, "1", 5*time.Second)

    return nil
}

// 查询订单
func (s *OrderService) GetOrder(ctx context.Context, orderID int64) (*Order, error) {
    // 1. 先查 Redis 缓存
    orderKey := fmt.Sprintf("order:%d", orderID)
    orderJSON, err := s.redis.Get(ctx, orderKey).Result()
    if err == nil {
        var order Order
        json.Unmarshal([]byte(orderJSON), &order)
        return &order, nil
    }

    // 2. 检查是否需要读主库
    masterKey := fmt.Sprintf("order:read_master:%d", orderID)
    exists, _ := s.redis.Exists(ctx, masterKey).Result()

    var order Order
    if exists > 0 {
        // 读主库
        err = s.db.Clauses(dbresolver.Write).
            Where("id = ?", orderID).
            First(&order).Error
    } else {
        // 读从库
        err = s.db.Where("id = ?", orderID).First(&order).Error
    }

    if err == nil {
        // 回填缓存
        orderJSON, _ := json.Marshal(order)
        s.redis.Set(ctx, orderKey, orderJSON, 5*time.Minute)
    }

    return &order, err
}
```

**效果：**
- 99% 的查询命中 Redis，完全避开主从延迟
- 1% 未命中的查询，通过标记强制读主库，保证数据一致性
- "订单不存在"错误率从 20% 降至 0.01%

### 五、监控与告警

```go
// 监控主从延迟
func MonitorReplicationDelay(db *gorm.DB) (int, error) {
    var result struct {
        SecondsBehindMaster sql.NullInt64
    }

    err := db.Raw("SHOW SLAVE STATUS").Scan(&result).Error
    if err != nil {
        return -1, err
    }

    if !result.SecondsBehindMaster.Valid {
        return -1, errors.New("replication not running")
    }

    delay := int(result.SecondsBehindMaster.Int64)

    // 告警：延迟超过 5 秒
    if delay > 5 {
        // 发送告警通知
        log.Warnf("Replication delay: %d seconds", delay)
    }

    return delay, nil
}
```

**总结：** 读写分离架构需要根据业务场景选择合适的延迟处理策略，通常采用"缓存 + 标记 + 半同步复制"的组合方案，既能保证数据一致性，又能充分利用读写分离的性能优势。
