---
title: 什么是幻读？Next-Key Lock 如何解决幻读问题？
tags:
  - 数据库
status: robot
class: 数据库
slug: next-key-lock-solve-phantom-read
ref:
---

## 核心要点

**幻读：同一事务中多次范围查询结果集行数不一致；Next-Key Lock = 记录锁 + 间隙锁，锁定范围和间隙防止插入**

## 详细回答

### 一、什么是幻读

**定义**：在同一个事务中，先后执行两次相同的范围查询（如 `WHERE age > 20`），第二次查询读取到了第一次查询没有的记录（其他事务插入的新数据）。

**经典示例**：

```sql
-- 事务 A
START TRANSACTION;
SELECT * FROM user WHERE age > 20;  -- 返回 5 条记录

-- 此时事务 B 插入新数据
INSERT INTO user(age) VALUES(25);
COMMIT;

-- 事务 A 再次查询
SELECT * FROM user WHERE age > 20;  -- 返回 6 条记录（出现幻读）
```

**幻读 vs 不可重复读**：
- **不可重复读**：同一记录的值变了（UPDATE）
- **幻读**：记录数量变了（INSERT/DELETE）

### 二、MVCC 为什么无法完全解决幻读

**MVCC 机制**：
- 通过 Undo Log 版本链和 ReadView 实现一致性读
- 对于已存在的记录，可以通过版本链找到事务开始时的快照

**MVCC 的局限**：
- 新插入的记录没有历史版本链
- 如果其他事务插入了新记录，MVCC 无法识别这是"不该看到的数据"

**结论**：普通 SELECT（快照读）在 REPEATABLE READ 下仍可能出现幻读。

### 三、Next-Key Lock 解决幻读

**Next-Key Lock = Record Lock（记录锁）+ Gap Lock（间隙锁）**

#### 1. Record Lock（记录锁）
锁定索引记录本身，防止其他事务修改或删除。

#### 2. Gap Lock（间隙锁）
锁定索引记录之间的间隙，防止其他事务在间隙中插入新记录。

**示例**：索引值为 [10, 20, 30]

```
间隙: (-∞, 10) | (10, 20) | (20, 30) | (30, +∞)
```

#### 3. Next-Key Lock（临键锁）
锁定记录 + 左侧间隙，左开右闭区间。

**示例**：
```sql
-- 事务 A（使用当前读）
SELECT * FROM user WHERE age > 20 FOR UPDATE;
-- 锁定范围：(20, 30], (30, +∞)
-- 阻止在 (20, +∞) 插入数据

-- 事务 B（被阻塞）
INSERT INTO user(age) VALUES(25);  -- 阻塞
```

### 四、快照读 vs 当前读

| 读取方式 | SQL 示例 | 使用机制 | 是否有幻读 |
|---------|---------|---------|-----------|
| **快照读** | `SELECT *` | MVCC | ⚠️ 可能有 |
| **当前读** | `SELECT ... FOR UPDATE`<br>`SELECT ... LOCK IN SHARE MODE`<br>`UPDATE`<br>`DELETE` | Next-Key Lock | ❌ 无 |

**关键区别**：
- 快照读：读取历史版本，不加锁，高并发
- 当前读：读取最新版本，加锁，防止幻读

### 五、Next-Key Lock 加锁规则

**基本原则**：
1. 加锁的基本单位是 Next-Key Lock（左开右闭）
2. 查询过程中访问到的对象才会加锁
3. 等值查询，命中记录时退化为 Record Lock
4. 等值查询，未命中时退化为 Gap Lock
5. 唯一索引等值查询，命中唯一记录时只锁记录

**示例 1：范围查询**
```sql
-- 索引值: 5, 10, 15, 20
SELECT * FROM user WHERE id >= 10 FOR UPDATE;
-- 加锁范围: (5, 10], (10, 15], (15, 20], (20, +∞)
```

**示例 2：等值查询（命中）**
```sql
-- 主键等值查询
SELECT * FROM user WHERE id = 10 FOR UPDATE;
-- 加锁范围: id=10 这一行（Record Lock）
```

**示例 3：等值查询（未命中）**
```sql
-- 索引值: 5, 10, 15
SELECT * FROM user WHERE id = 12 FOR UPDATE;
-- 加锁范围: (10, 15)（Gap Lock，防止插入 id=12）
```

### 六、实际案例分析

**场景**：秒杀库存扣减

```sql
-- 不安全的做法（有幻读风险）
SELECT stock FROM product WHERE id = 100;  -- 快照读，读到 stock=10
-- 其他事务可能插入/修改库存
UPDATE product SET stock = stock - 1 WHERE id = 100;

-- 安全的做法（使用当前读）
SELECT stock FROM product WHERE id = 100 FOR UPDATE;  -- 当前读 + 锁定
UPDATE product SET stock = stock - 1 WHERE id = 100;
```

### 七、间隙锁的代价

**优势**：
- 彻底解决幻读
- 保证数据一致性

**代价**：
- 降低并发性能（锁定间隙阻止插入）
- 可能导致死锁

**生产优化**：
- 大部分互联网公司改为 READ COMMITTED 隔离级别
- 业务层容忍幻读，换取更高并发
- 关键场景使用当前读（FOR UPDATE）

### 八、面试加分项

**为什么 SERIALIZABLE 没有幻读？**

SERIALIZABLE 隔离级别下，普通 SELECT 也会自动加共享锁（等同于 LOCK IN SHARE MODE），因此所有读取都是当前读，通过 Next-Key Lock 防止幻读。

**代价**：并发性能极差，生产环境几乎不用。
