---
title: MySQL 的锁机制：表锁、行锁、意向锁、间隙锁详解
tags:
  - 数据库
status: robot
class: 数据库
slug: mysql-lock-mechanisms-table-row-intention-gap-locks
ref:
---

## 核心要点

**表锁粒度大并发低，行锁粒度小并发高；意向锁协调表锁与行锁；间隙锁防止幻读；InnoDB 默认行锁**

## 详细回答

### 一、锁的分类体系

```
按粒度分:
├── 全局锁 (FLUSH TABLES WITH READ LOCK)
├── 表级锁
│   ├── 表锁 (LOCK TABLES)
│   ├── 元数据锁 (MDL)
│   └── 意向锁 (Intention Lock)
└── 行级锁
    ├── 记录锁 (Record Lock)
    ├── 间隙锁 (Gap Lock)
    └── Next-Key Lock (Record + Gap)

按类型分:
├── 共享锁 (S Lock, Shared Lock) - 读锁
└── 排他锁 (X Lock, Exclusive Lock) - 写锁
```

### 二、表锁 (Table Lock)

**特点**：
- 锁定整张表，开销小，加锁快
- 不会出现死锁
- 锁粒度大，并发度低
- MyISAM 默认使用表锁

**语法**：
```sql
-- 加读锁（共享锁）
LOCK TABLES user READ;
-- 其他会话可以读，但无法写

-- 加写锁（排他锁）
LOCK TABLES user WRITE;
-- 其他会话无法读写

-- 释放锁
UNLOCK TABLES;
```

**适用场景**：
- MyISAM 引擎
- 批量更新整表数据
- 数据备份

### 三、行锁 (Row Lock)

**特点**：
- 锁定单行记录，开销大，加锁慢
- 可能出现死锁
- 锁粒度小，并发度高
- InnoDB 默认使用行锁

**类型**：

#### 1. 记录锁 (Record Lock)
锁定索引记录，防止其他事务修改或删除。

```sql
-- 排他记录锁
UPDATE user SET age = 30 WHERE id = 1;
SELECT * FROM user WHERE id = 1 FOR UPDATE;

-- 共享记录锁
SELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE;
```

#### 2. 间隙锁 (Gap Lock)
锁定索引记录之间的间隙，防止插入。

```sql
-- 锁定 (10, 20) 间隙
SELECT * FROM user WHERE id > 10 AND id < 20 FOR UPDATE;
```

#### 3. Next-Key Lock (临键锁)
Record Lock + Gap Lock，锁定记录及左侧间隙（左开右闭区间）。

```sql
-- 锁定 (10, 20]
SELECT * FROM user WHERE id <= 20 FOR UPDATE;
```

**行锁必须通过索引**：
```sql
-- ✅ 有索引，使用行锁
UPDATE user SET age = 30 WHERE id = 1;

-- ❌ 无索引，升级为表锁
UPDATE user SET age = 30 WHERE name = 'Alice';  -- name 无索引
```

### 四、意向锁 (Intention Lock)

**目的**：协调表锁与行锁的关系，提高加表锁的效率。

**问题场景**：
1. 事务 A 对某行加了行锁
2. 事务 B 想加表锁，需要检查是否有行锁冲突
3. 如果逐行检查，效率极低

**解决方案**：意向锁
- 事务加行锁前，先在表级别加意向锁
- 加表锁时只需检查意向锁，无需逐行检查

**类型**：
- **意向共享锁 (IS)**：事务准备在某行加共享锁
- **意向排他锁 (IX)**：事务准备在某行加排他锁

**兼容性矩阵**：

|  | IS | IX | S | X |
|--|----|----|---|---|
| **IS** | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ |
| **S**  | ✅ | ❌ | ✅ | ❌ |
| **X**  | ❌ | ❌ | ❌ | ❌ |

**示例**：
```sql
-- 事务 A：自动加 IX + 行级 X 锁
UPDATE user SET age = 30 WHERE id = 1;

-- 事务 B：检查到 IX，直接阻塞（无需逐行检查）
LOCK TABLES user WRITE;
```

### 五、元数据锁 (MDL, Metadata Lock)

**目的**：保护表结构的一致性，防止 DDL 和 DML 并发冲突。

**加锁规则**：
- 执行 DML（SELECT/INSERT/UPDATE/DELETE）：自动加 MDL 读锁
- 执行 DDL（ALTER TABLE/DROP TABLE）：自动加 MDL 写锁

**示例**：
```sql
-- 事务 A：持有 MDL 读锁
START TRANSACTION;
SELECT * FROM user;

-- 事务 B：尝试加 MDL 写锁（阻塞）
ALTER TABLE user ADD COLUMN email VARCHAR(100);
```

**生产问题**：
- 长事务持有 MDL 读锁，导致 DDL 阻塞
- DDL 阻塞导致后续所有查询堆积

**排查命令**：
```sql
-- 查看 MDL 锁
SELECT * FROM performance_schema.metadata_locks;

-- 查看长事务
SELECT * FROM information_schema.INNODB_TRX WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 60;
```

### 六、锁的兼容性

**行级锁兼容性**：

|  | S 锁 | X 锁 |
|--|------|------|
| **S 锁** | ✅ 兼容 | ❌ 冲突 |
| **X 锁** | ❌ 冲突 | ❌ 冲突 |

**规则**：
- 多个事务可以同时持有同一行的共享锁（S）
- 排他锁（X）与任何锁都冲突

### 七、查看锁信息

```sql
-- 查看当前锁等待
SELECT * FROM performance_schema.data_locks;

-- 查看锁等待关系
SELECT * FROM performance_schema.data_lock_waits;

-- 查看事务信息
SELECT * FROM information_schema.INNODB_TRX;

-- 查看最近死锁日志
SHOW ENGINE INNODB STATUS;
```

### 八、实际优化建议

**1. 尽量使用行锁**
- 使用 InnoDB 引擎
- 查询必须走索引
- 缩小事务范围

**2. 避免长事务**
```sql
-- ❌ 不推荐
START TRANSACTION;
SELECT * FROM user;  -- 长时间不提交

-- ✅ 推荐
START TRANSACTION;
SELECT * FROM user;
COMMIT;  -- 尽快提交
```

**3. 索引优化避免锁升级**
```sql
-- 为常用查询字段添加索引
CREATE INDEX idx_name ON user(name);

-- 避免锁升级为表锁
UPDATE user SET age = 30 WHERE name = 'Alice';  -- 现在走索引，使用行锁
```

**4. 减少间隙锁范围**
```sql
-- ❌ 锁定大范围
SELECT * FROM user WHERE age > 10 FOR UPDATE;

-- ✅ 精确锁定
SELECT * FROM user WHERE id IN (1, 2, 3) FOR UPDATE;
```

### 九、面试加分项

**为什么 InnoDB 行锁是基于索引实现的？**

InnoDB 的行锁实际是锁定的索引记录：
1. 通过索引定位记录，锁定索引项
2. 如果没有索引，需要全表扫描，所有扫描过的记录都会加锁（近似表锁）
3. 这也是为什么无索引的 UPDATE 会退化为表锁

**死锁预防**：
- 固定加锁顺序（按主键 ID 升序）
- 缩短事务时间
- 降低隔离级别（READ COMMITTED 无间隙锁）
