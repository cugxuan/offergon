---
title: 死锁是如何产生的？MySQL 如何检测和处理死锁？
tags:
  - 数据库
  - 死锁
status: robot
class: 数据库
slug: mysql-deadlock-detection-handling
ref:
---

## 核心要点

**死锁：两个或多个事务互相等待对方释放锁；MySQL 自动检测并回滚代价小的事务；预防：固定加锁顺序、降低隔离级别**

## 详细回答

### 一、死锁的定义

**死锁（Deadlock）**：两个或多个事务在执行过程中，因争夺资源而造成的互相等待的现象，若无外力干涉，它们都将无法推进下去。

**经典示例**：

```sql
-- 事务 A
START TRANSACTION;
UPDATE user SET age = 20 WHERE id = 1;  -- 锁定 id=1
-- 等待锁定 id=2
UPDATE user SET age = 20 WHERE id = 2;  -- 阻塞

-- 事务 B
START TRANSACTION;
UPDATE user SET age = 30 WHERE id = 2;  -- 锁定 id=2
-- 等待锁定 id=1
UPDATE user SET age = 30 WHERE id = 1;  -- 阻塞 → 死锁！
```

**死锁四个必要条件**：
1. **互斥**：资源不能被多个事务共享
2. **持有并等待**：事务持有锁的同时等待其他锁
3. **不可剥夺**：锁不能被强制释放
4. **循环等待**：事务形成环形等待链

### 二、死锁产生的典型场景

#### 场景 1：不同顺序加锁

```sql
-- 事务 A：先锁 1 再锁 2
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;

-- 事务 B：先锁 2 再锁 1
UPDATE account SET balance = balance - 100 WHERE id = 2;
UPDATE account SET balance = balance + 100 WHERE id = 1;
```

#### 场景 2：间隙锁冲突

```sql
-- 表数据：id = 1, 5, 10

-- 事务 A
SELECT * FROM user WHERE id = 3 FOR UPDATE;  -- 锁定间隙 (1, 5)

-- 事务 B
SELECT * FROM user WHERE id = 4 FOR UPDATE;  -- 锁定间隙 (1, 5)

-- 事务 A
INSERT INTO user (id) VALUES (3);  -- 尝试插入，等待事务 B

-- 事务 B
INSERT INTO user (id) VALUES (4);  -- 尝试插入，等待事务 A → 死锁！
```

#### 场景 3：索引失效导致锁升级

```sql
-- name 字段无索引

-- 事务 A
UPDATE user SET age = 20 WHERE name = 'Alice';  -- 全表扫描，锁定所有行

-- 事务 B
UPDATE user SET age = 30 WHERE name = 'Bob';    -- 也需要锁定所有行 → 死锁风险
```

### 三、MySQL 的死锁检测与处理

#### 1. 自动死锁检测

InnoDB 有死锁检测机制（`innodb_deadlock_detect=ON`，默认开启）：
- 事务等待锁时，检测是否形成等待环
- 检测到死锁后，选择 **undo 量最小（代价最小）** 的事务回滚
- 被回滚的事务返回错误：`ERROR 1213 (40001): Deadlock found`

#### 2. 超时机制

如果关闭死锁检测，使用超时机制：
```sql
-- 设置锁等待超时时间（默认 50 秒）
SET innodb_lock_wait_timeout = 10;
```

超时后返回：`ERROR 1205 (HY000): Lock wait timeout exceeded`

### 四、查看死锁日志

```sql
-- 查看最近一次死锁信息
SHOW ENGINE INNODB STATUS;
```

**关键部分**：
```
------------------------
LATEST DETECTED DEADLOCK
------------------------
2024-10-08 10:30:15
*** (1) TRANSACTION:
TRANSACTION 12345, ACTIVE 10 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 10, OS thread handle 123, query id 456 localhost root updating
UPDATE user SET age = 20 WHERE id = 2

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 0 page no 3 n bits 72 index PRIMARY of table `test`.`user` trx id 12345 lock_mode X locks rec but not gap waiting

*** (2) TRANSACTION:
TRANSACTION 12346, ACTIVE 5 sec starting index read
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 11, OS thread handle 124, query id 457 localhost root updating
UPDATE user SET age = 30 WHERE id = 1

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 0 page no 3 n bits 72 index PRIMARY of table `test`.`user` trx id 12346 lock_mode X locks rec but not gap

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 0 page no 3 n bits 72 index PRIMARY of table `test`.`user` trx id 12346 lock_mode X locks rec but not gap waiting

*** WE ROLL BACK TRANSACTION (1)
```

**解读**：
- 事务 1 等待 id=2 的锁
- 事务 2 持有 id=2 的锁，等待 id=1 的锁
- 形成循环等待，回滚事务 1

### 五、死锁预防策略

#### 1. 固定加锁顺序

```sql
-- ❌ 不同顺序（易死锁）
-- 事务 A: 先锁 1 再锁 2
-- 事务 B: 先锁 2 再锁 1

-- ✅ 统一顺序（避免死锁）
-- 所有事务都按 ID 升序加锁
UPDATE user SET age = age + 1 WHERE id IN (1, 2) ORDER BY id;
```

#### 2. 降低事务隔离级别

```sql
-- REPEATABLE READ（有间隙锁，易死锁）
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- READ COMMITTED（无间隙锁，减少死锁）
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 3. 添加索引避免锁升级

```sql
-- 为常用查询字段添加索引
CREATE INDEX idx_name ON user(name);

-- 避免全表扫描导致的表锁
UPDATE user SET age = 20 WHERE name = 'Alice';  -- 现在走索引，只锁相关行
```

#### 4. 缩短事务时间

```sql
-- ❌ 长事务（增加死锁概率）
START TRANSACTION;
SELECT * FROM user WHERE id = 1 FOR UPDATE;
-- 执行复杂业务逻辑（耗时操作）
UPDATE user SET age = 20 WHERE id = 1;
COMMIT;

-- ✅ 短事务（减少锁持有时间）
-- 先完成业务逻辑
START TRANSACTION;
SELECT * FROM user WHERE id = 1 FOR UPDATE;
UPDATE user SET age = 20 WHERE id = 1;
COMMIT;
```

#### 5. 使用乐观锁

```sql
-- 悲观锁（容易死锁）
SELECT * FROM user WHERE id = 1 FOR UPDATE;
UPDATE user SET age = 20 WHERE id = 1;

-- 乐观锁（通过版本号）
SELECT age, version FROM user WHERE id = 1;
UPDATE user SET age = 20, version = version + 1
WHERE id = 1 AND version = #{oldVersion};
-- 更新失败则重试
```

### 六、应用层处理死锁

```go
// Go 示例：重试机制
func updateWithRetry(db *sql.DB, id int, maxRetries int) error {
    for i := 0; i < maxRetries; i++ {
        err := updateUser(db, id)
        if err == nil {
            return nil
        }

        // 检测是否为死锁错误
        if isDead lockError(err) {
            time.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))
            continue  // 重试
        }
        return err
    }
    return errors.New("max retries exceeded")
}

func isDeadlockError(err error) bool {
    return strings.Contains(err.Error(), "Deadlock found")
}
```

### 七、监控与告警

```sql
-- 查看死锁次数
SHOW STATUS LIKE 'Innodb_deadlocks';

-- 查看锁等待次数
SHOW STATUS LIKE 'Innodb_row_lock_waits';

-- 查看平均锁等待时间（毫秒）
SHOW STATUS LIKE 'Innodb_row_lock_time_avg';
```

**告警指标**：
- 死锁次数 > 10/分钟
- 锁等待时间 > 1000ms

### 八、面试加分项

**为什么 MyISAM 不会出现死锁？**

MyISAM 使用表级锁：
1. 加锁前会一次性获取所有需要的锁
2. 不存在"持有锁的同时等待其他锁"的情况
3. 不满足死锁四个必要条件中的"持有并等待"

**代价**：并发性能极差，无法支持高并发写入。

**死锁检测的性能开销**：
- 高并发下，死锁检测本身成为性能瓶颈
- 可以考虑关闭死锁检测（`innodb_deadlock_detect=OFF`），依赖超时机制
- 适用于能容忍超时等待的场景
