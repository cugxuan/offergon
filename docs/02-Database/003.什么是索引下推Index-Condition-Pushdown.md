---
title: 什么是索引下推（Index Condition Pushdown）？它如何优化查询？
tags:
  - 数据库
  - 索引
status: robot
class: 数据库
slug: index-condition-pushdown-query-optimization
ref:
---

## 核心要点

**索引下推（ICP）：在索引遍历时直接过滤不符合条件的记录，减少回表次数，降低磁盘 I/O**

## 详细回答

### 一、索引下推（Index Condition Pushdown, ICP）是什么

**定义**：MySQL 5.6 引入的优化技术，将部分 WHERE 条件下推到存储引擎层在索引遍历时进行过滤，而不是在 Server 层过滤。

**核心目标**：减少回表次数，降低磁盘 I/O 和 CPU 开销。

### 二、没有 ICP 的查询流程（传统方式）

**场景**：联合索引 `idx_name_age(name, age)`

```sql
SELECT * FROM user WHERE name LIKE 'Zhang%' AND age = 30;
```

**传统流程（MySQL 5.5 及之前）**：
1. 存储引擎根据索引 `name LIKE 'Zhang%'` 定位到所有满足条件的记录
2. 对每条记录执行回表，获取完整行数据
3. Server 层检查 `age = 30` 条件，过滤不符合的数据
4. 返回最终结果

**问题**：即使 age 不等于 30，也会执行回表操作，造成无效 I/O。

### 三、有 ICP 的查询流程（优化后）

**ICP 流程（MySQL 5.6+）**：
1. 存储引擎根据索引 `name LIKE 'Zhang%'` 定位到第一条记录
2. **在索引中直接检查 `age = 30` 条件**（索引下推）
3. 只有同时满足两个条件的记录才执行回表
4. Server 层接收已过滤的数据，返回结果

**优势**：大幅减少回表次数，尤其在过滤效果好的场景下。

### 四、适用条件与限制

**适用场景**：
1. 使用了联合索引
2. WHERE 条件包含索引列，但不完全符合最左前缀（如上例中 age 不在最左）
3. InnoDB 和 MyISAM 引擎

**不适用场景**：
1. 主键索引（聚簇索引本身无需回表）
2. 覆盖索引（查询字段全在索引中，无需回表）
3. 触发函数、存储过程等复杂条件

### 五、如何判断是否使用了 ICP

**使用 EXPLAIN 查看**：

```sql
EXPLAIN SELECT * FROM user WHERE name LIKE 'Zhang%' AND age = 30;
```

**关键字段**：
- `type`: range（范围扫描）
- `Extra`: **Using index condition**（表示使用了索引下推）

**对比示例**：
```
-- 使用 ICP
Extra: Using index condition

-- 未使用 ICP
Extra: Using where
```

### 六、实际性能对比

**测试场景**：100 万用户数据，100 个姓 Zhang 的用户，只有 5 个年龄为 30

**没有 ICP**：
- 回表次数：100 次（所有姓 Zhang 的用户）
- 磁盘 I/O：100 次随机读

**有 ICP**：
- 回表次数：5 次（姓 Zhang 且年龄 30）
- 磁盘 I/O：5 次随机读

**性能提升**：I/O 减少 95%

### 七、开启/关闭 ICP

```sql
-- 查看 ICP 状态（默认开启）
SHOW VARIABLES LIKE 'optimizer_switch';

-- 关闭 ICP（测试用）
SET optimizer_switch='index_condition_pushdown=off';

-- 开启 ICP
SET optimizer_switch='index_condition_pushdown=on';
```

### 八、面试加分项

**ICP 与覆盖索引的区别**：
- **覆盖索引**：查询字段完全包含在索引中，完全不需要回表
- **索引下推**：仍需回表，但减少了回表次数

**ICP 与 MRR 的配合**：
- MRR（Multi-Range Read）优化随机回表为顺序读
- ICP 减少回表次数 + MRR 优化回表顺序 = 双重优化
