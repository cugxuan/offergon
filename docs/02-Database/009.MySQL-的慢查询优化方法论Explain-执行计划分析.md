---
title: MySQL 的慢查询优化方法论（Explain 执行计划分析）
tags:
  - 数据库
status: robot
class: 数据库
slug: mysql-slow-query-optimization-explain-analysis
ref:
---

## 核心要点

**慢查询优化：开启慢查询日志定位问题 → EXPLAIN 分析执行计划 → 优化索引/SQL 结构 → 验证效果**

## 详细回答

### 一、慢查询定位

#### 1. 开启慢查询日志

```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 2;  -- 查询超过 2 秒记录日志
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
```

#### 2. 分析慢查询日志

```bash
# 使用 mysqldumpslow 分析
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log
# -s t: 按查询时间排序
# -t 10: 显示前 10 条

# 使用 pt-query-digest（Percona 工具）
pt-query-digest /var/log/mysql/slow.log
```

### 二、EXPLAIN 执行计划分析

**语法**：
```sql
EXPLAIN SELECT * FROM user WHERE age > 20;
```

**输出字段详解**：

| 字段 | 说明 | 重点关注 |
|------|------|---------|
| **id** | 查询序列号 | 子查询和 UNION 的执行顺序 |
| **select_type** | 查询类型 | SIMPLE/PRIMARY/SUBQUERY/DERIVED |
| **table** | 访问的表名 | - |
| **type** | 访问类型 | ⭐**性能关键** |
| **possible_keys** | 可能使用的索引 | - |
| **key** | 实际使用的索引 | NULL 表示未使用索引 |
| **key_len** | 索引使用的字节数 | 判断联合索引使用了几列 |
| **ref** | 索引匹配的列或常量 | const/字段名 |
| **rows** | 估算扫描的行数 | ⭐越少越好 |
| **filtered** | 过滤后的行百分比 | MySQL 5.7+ |
| **Extra** | 额外信息 | ⭐优化提示 |

### 三、type 字段（访问类型）- 性能从优到劣

| type | 说明 | 示例 |
|------|------|------|
| **system** | 表只有一行（系统表） | 极少见 |
| **const** | 主键或唯一索引等值查询 | `WHERE id = 1` |
| **eq_ref** | JOIN 时使用主键或唯一索引 | `user.id = order.user_id` |
| **ref** | 非唯一索引等值查询 | `WHERE name = 'Alice'` |
| **range** | 索引范围查询 | `WHERE age > 20` |
| **index** | 全索引扫描 | `SELECT id FROM user` |
| **ALL** | 全表扫描 | ❌ 需要优化 |

**优化目标**：至少达到 **range**，最好是 **ref** 或 **const**。

### 四、Extra 字段 - 关键提示

| Extra 值 | 含义 | 优化建议 |
|---------|------|---------|
| **Using index** | ✅ 覆盖索引，无需回表 | 最优 |
| **Using index condition** | ✅ 索引下推（ICP） | 良好 |
| **Using where** | ⚠️ Server 层过滤 | 考虑优化索引 |
| **Using filesort** | ❌ 文件排序（内存/磁盘） | 添加索引优化 ORDER BY |
| **Using temporary** | ❌ 使用临时表 | 添加索引优化 GROUP BY |
| **Using join buffer** | ⚠️ JOIN 缓冲 | 添加索引优化 JOIN |
| **Impossible WHERE** | WHERE 条件永远为 FALSE | 检查SQL逻辑 |

### 五、慢查询优化方法论

#### 1. 索引优化

**场景 1：缺少索引**
```sql
-- ❌ 全表扫描
EXPLAIN SELECT * FROM user WHERE age = 20;
-- type: ALL, Extra: Using where

-- ✅ 添加索引
CREATE INDEX idx_age ON user(age);
-- type: ref
```

**场景 2：索引失效**
```sql
-- ❌ 函数导致索引失效
SELECT * FROM user WHERE YEAR(created_at) = 2024;

-- ✅ 改写 SQL
SELECT * FROM user WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31';
```

**场景 3：联合索引顺序**
```sql
-- 索引: INDEX(a, b, c)

-- ❌ 跳过最左列
SELECT * FROM table WHERE b = 2 AND c = 3;

-- ✅ 包含最左列
SELECT * FROM table WHERE a = 1 AND b = 2 AND c = 3;
```

#### 2. SQL 改写

**避免 SELECT ***
```sql
-- ❌ 查询所有字段
SELECT * FROM user WHERE id = 1;

-- ✅ 只查询需要的字段（覆盖索引）
SELECT id, name, age FROM user WHERE id = 1;
```

**优化子查询**
```sql
-- ❌ 子查询
SELECT * FROM user WHERE id IN (SELECT user_id FROM order WHERE status = 1);

-- ✅ 改写为 JOIN
SELECT u.* FROM user u
JOIN order o ON u.id = o.user_id
WHERE o.status = 1;
```

**优化 OR 条件**
```sql
-- ❌ OR 可能不走索引
SELECT * FROM user WHERE name = 'Alice' OR age = 20;

-- ✅ 改写为 UNION ALL
SELECT * FROM user WHERE name = 'Alice'
UNION ALL
SELECT * FROM user WHERE age = 20 AND name != 'Alice';
```

#### 3. 分页优化

**深度分页问题**
```sql
-- ❌ 偏移量大导致慢查询
SELECT * FROM user ORDER BY id LIMIT 1000000, 10;
-- 需要扫描 1000010 行

-- ✅ 使用子查询优化
SELECT * FROM user
WHERE id >= (SELECT id FROM user ORDER BY id LIMIT 1000000, 1)
ORDER BY id LIMIT 10;

-- ✅ 使用延迟关联
SELECT u.* FROM user u
JOIN (SELECT id FROM user ORDER BY id LIMIT 1000000, 10) t
ON u.id = t.id;
```

#### 4. JOIN 优化

```sql
-- ❌ 未使用索引
SELECT * FROM user u
JOIN order o ON u.name = o.user_name;  -- name 字段无索引

-- ✅ 添加索引
CREATE INDEX idx_name ON user(name);
CREATE INDEX idx_user_name ON order(user_name);
```

**小表驱动大表**
```sql
-- user 表 10 万行，order 表 100 万行

-- ✅ 小表在前
SELECT * FROM user u
JOIN order o ON u.id = o.user_id
WHERE u.age > 20;
```

### 六、实战案例分析

**案例：订单查询慢**

```sql
-- 原 SQL（耗时 5 秒）
SELECT * FROM order
WHERE user_id = 123 AND status = 'paid' AND created_at > '2024-01-01'
ORDER BY created_at DESC
LIMIT 10;
```

**EXPLAIN 分析**：
- type: ALL（全表扫描）
- rows: 1000000
- Extra: Using where; Using filesort

**优化步骤**：

1. **添加联合索引**
```sql
CREATE INDEX idx_user_status_time ON order(user_id, status, created_at);
```

2. **再次 EXPLAIN**：
- type: ref
- key: idx_user_status_time
- rows: 50
- Extra: Using index condition

3. **性能提升**：5 秒 → 10ms

### 七、优化工具

**1. EXPLAIN ANALYZE（MySQL 8.0+）**
```sql
EXPLAIN ANALYZE SELECT * FROM user WHERE age > 20;
-- 显示实际执行时间和行数
```

**2. SHOW PROFILE**
```sql
SET profiling = 1;
SELECT * FROM user WHERE age > 20;
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;
```

**3. Performance Schema**
```sql
-- 查看最慢的语句
SELECT * FROM sys.statement_analysis ORDER BY total_latency DESC LIMIT 10;
```

### 八、面试加分项

**为什么 EXPLAIN 的 rows 是估算值？**

MySQL 使用 **索引统计信息** 估算：
1. 通过采样统计索引的基数（Cardinality）
2. 根据 WHERE 条件计算选择性
3. 估算需要扫描的行数

**优化器可能选错索引**：
```sql
-- 强制使用指定索引
SELECT * FROM user FORCE INDEX(idx_age) WHERE age > 20;

-- 忽略某个索引
SELECT * FROM user IGNORE INDEX(idx_name) WHERE age > 20;
```

**成本估算**：
```sql
-- 查看查询成本
EXPLAIN FORMAT=JSON SELECT * FROM user WHERE age > 20;
-- 查看 cost_info 字段
```
