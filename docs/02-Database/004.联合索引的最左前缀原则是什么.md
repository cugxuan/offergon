---
title: 联合索引的最左前缀原则是什么？如何利用索引优化 SQL？
tags:
  - 数据库
  - 索引
status: robot
class: 数据库
slug: leftmost-prefix-composite-index-sql-optimization
ref:
---

## 核心要点

**最左前缀原则：联合索引查询必须从最左列开始连续匹配，中间不能跳过，否则索引失效**

## 详细回答

### 一、什么是最左前缀原则

**定义**：联合索引 `INDEX(a, b, c)` 的 B+ 树按 a → b → c 的顺序排列，查询时必须从 a 开始连续使用索引列，才能有效利用索引。

**核心规则**：
- 必须包含最左列 a
- 可以是 (a)、(a,b) 或 (a,b,c)
- 不能跳过中间列（如 (a,c) 中 c 无法使用索引）

### 二、联合索引的存储结构

**联合索引 `idx_abc(a, b, c)` 的排序规则**：
1. 先按 a 排序
2. a 相同时按 b 排序
3. b 相同时按 c 排序

**示例数据**：
```
(a=1, b=2, c=3)
(a=1, b=3, c=1)
(a=2, b=1, c=2)
(a=2, b=2, c=1)
```

由于只有 a 是全局有序的，b 和 c 仅在 a 相同的局部有序，因此必须从 a 开始查询。

### 三、索引使用情况分析

**假设索引**：`INDEX idx_abc(a, b, c)`

| SQL WHERE 条件 | 索引使用情况 | 说明 |
|---------------|-------------|------|
| `a = 1` | ✅ 使用 a | 符合最左前缀 |
| `a = 1 AND b = 2` | ✅ 使用 a, b | 连续匹配 |
| `a = 1 AND b = 2 AND c = 3` | ✅ 使用 a, b, c | 完全匹配 |
| `a = 1 AND c = 3` | ⚠️ 仅使用 a | 跳过 b，c 无法使用索引 |
| `b = 2` | ❌ 不使用索引 | 缺少最左列 a |
| `b = 2 AND c = 3` | ❌ 不使用索引 | 缺少最左列 a |
| `a = 1 AND b > 2 AND c = 3` | ⚠️ 使用 a, b | b 是范围查询,c 无法使用索引 |
| `a LIKE 'abc%' AND b = 2` | ✅ 使用 a, b | 前缀匹配符合规则 |
| `a LIKE '%abc'` | ❌ 不使用索引 | 非前缀匹配无法走索引 |

### 四、范围查询的特殊情况

**规则**：范围查询（>、<、BETWEEN、LIKE）会中断后续列的索引使用

```sql
-- 索引: INDEX(a, b, c)

-- ✅ 使用 a, b 索引，c 无法使用
WHERE a = 1 AND b > 10 AND c = 5

-- ✅ 使用 a 索引，b 和 c 无法使用
WHERE a > 1 AND b = 2 AND c = 3
```

**原因**：范围查询后数据不再有序，无法继续使用索引。

### 五、优化技巧

#### 1. 调整查询顺序（无需关心）

MySQL 优化器会自动调整 WHERE 条件顺序：

```sql
-- 下面两个查询等价
WHERE b = 2 AND a = 1 AND c = 3
WHERE a = 1 AND b = 2 AND c = 3
```

#### 2. 合理设计索引顺序

**原则**：区分度高的列放最左边，等值查询列优先于范围查询列

```sql
-- 不推荐：性别区分度低
INDEX(gender, age, city)

-- 推荐：城市区分度高
INDEX(city, age, gender)
```

#### 3. 覆盖索引优化

```sql
-- 索引: INDEX(a, b, c)

-- ✅ 覆盖索引，无需回表
SELECT a, b, c FROM table WHERE a = 1;

-- ❌ 需要回表获取 d
SELECT a, b, c, d FROM table WHERE a = 1;
```

### 六、实战案例

**场景**：用户表 `user(city, age, name)`

```sql
-- 创建联合索引
CREATE INDEX idx_city_age ON user(city, age);

-- ✅ 高效查询（使用完整索引）
SELECT * FROM user WHERE city = 'Beijing' AND age = 25;

-- ⚠️ 部分使用索引（仅使用 city）
SELECT * FROM user WHERE city = 'Beijing' AND age > 20;

-- ❌ 索引失效（缺少最左列 city）
SELECT * FROM user WHERE age = 25;
```

**优化建议**：如果经常单独查询 age，可以额外创建单列索引 `INDEX(age)`。

### 七、EXPLAIN 验证

```sql
EXPLAIN SELECT * FROM user WHERE city = 'Beijing' AND age = 25;
```

**关键字段**：
- `key`: idx_city_age（使用的索引）
- `key_len`: 可以判断使用了几列索引（city=varchar(50)=152字节, age=int=4字节）
  - key_len=152：仅使用 city
  - key_len=156：使用 city + age

### 八、面试加分项

**为什么不推荐创建过多索引？**

1. **写入性能下降**：每次 INSERT/UPDATE/DELETE 都需要维护索引 B+ 树
2. **存储空间占用**：每个索引都是独立的 B+ 树
3. **优化器选择困难**：索引过多可能导致选择错误的执行计划

**最佳实践**：
- 单表索引数量控制在 5 个以内
- 优先使用联合索引覆盖多个查询场景
- 定期清理无用索引（通过慢查询日志分析）
