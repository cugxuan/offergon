---
title: MySQL 的主从复制原理，binlog 的三种格式对比
tags:
  - 数据库
status: robot
class: 数据库
slug: mysql-master-slave-replication-binlog-format-comparison
ref:
---

## 核心要点

MySQL 主从复制基于 binlog 异步传输，主库记录变更日志，从库 IO 线程拉取写入 relay log，SQL 线程回放执行；binlog 三种格式：Statement（记录 SQL 语句，体积小但可能不一致）、Row（记录每行数据变更，一致性高但体积大）、Mixed（自动混合前两者）。

## 详细回答

### 一、MySQL 主从复制原理

MySQL 主从复制是一种异步数据同步机制，核心流程包括三个步骤：

**1. 主库记录 binlog**
```sql
-- 主库配置启用 binlog
[mysqld]
server-id=1
log-bin=/var/lib/mysql/mysql-bin
binlog_format=ROW
```

主库在执行每个事务时，会将数据变更记录到 binary log（二进制日志）中，事务提交时同步刷盘。

**2. 从库 IO 线程拉取 binlog**
```bash
# 从库配置
[mysqld]
server-id=2
relay-log=/var/lib/mysql/relay-bin
read_only=1
```

从库的 IO 线程连接主库，发送读取 binlog 的请求，主库通过 dump 线程推送 binlog 事件，从库将接收到的日志写入 relay log（中继日志）。

**3. 从库 SQL 线程回放**

从库的 SQL 线程读取 relay log，解析并执行其中的事件，将数据变更应用到从库数据库中，实现数据同步。

**复制流程图：**
```
主库                                     从库
┌─────────────┐                    ┌─────────────┐
│   Client    │                    │ IO Thread   │
└──────┬──────┘                    └──────┬──────┘
       │                                   │
       │ 1. 写入操作                       │
       ▼                                   │
┌─────────────┐                           │
│   InnoDB    │                           │
└──────┬──────┘                           │
       │                                   │
       │ 2. 记录 binlog                    │
       ▼                                   │
┌─────────────┐    3. 拉取 binlog         │
│   binlog    ├──────────────────────────►│
└─────────────┘                           │
                                          │ 4. 写入 relay log
                                          ▼
                                   ┌─────────────┐
                                   │ relay log   │
                                   └──────┬──────┘
                                          │ 5. 读取并执行
                                          ▼
                                   ┌─────────────┐
                                   │ SQL Thread  │
                                   └──────┬──────┘
                                          │
                                          ▼
                                   ┌─────────────┐
                                   │   InnoDB    │
                                   └─────────────┘
```

### 二、binlog 三种格式对比

| 格式 | 记录内容 | 优点 | 缺点 | 适用场景 |
|------|---------|------|------|----------|
| **Statement** | SQL 语句原文 | binlog 体积小，网络传输快，历史默认格式 | 遇到 UUID()、NOW() 等非确定性函数会导致主从数据不一致 | 简单的 OLTP 场景，无非确定性函数 |
| **Row** | 每一行数据的变更 | 数据一致性高，不受函数影响，可精确恢复数据 | binlog 体积大（批量更新时显著），网络开销大 | 生产环境推荐，特别是有触发器、存储过程的场景 |
| **Mixed** | 自动选择 Statement 或 Row | 兼顾体积和一致性，大部分用 Statement，特殊场景用 Row | 规则复杂，可能难以预测具体格式 | 折中方案，但不如直接用 Row 可控 |

**Statement 格式示例：**
```sql
-- 主库执行
UPDATE users SET login_time = NOW() WHERE id = 100;

-- binlog 记录（伪代码）
BEGIN;
UPDATE users SET login_time = NOW() WHERE id = 100;
COMMIT;

-- 问题：从库执行时 NOW() 返回从库当前时间，导致数据不一致
```

**Row 格式示例：**
```bash
# 使用 mysqlbinlog 查看 Row 格式
$ mysqlbinlog --base64-output=DECODE-ROWS -v mysql-bin.000001

### UPDATE `test`.`users`
### WHERE
###   @1=100 /* id */
###   @2='2025-10-01 10:00:00' /* login_time */
### SET
###   @1=100 /* id */
###   @2='2025-10-08 14:30:00' /* login_time */
```

Row 格式记录了变更前后的完整数据行，保证从库回放结果与主库完全一致。

### 三、实战案例

**案例：生产环境 binlog 格式选择**

某电商系统初期使用 Statement 格式，在订单同步时发现主从数据不一致问题：

```sql
-- 主库生成订单号使用 UUID()
INSERT INTO orders (order_no, user_id, amount)
VALUES (UUID(), 1001, 299.00);

-- Statement 格式下，从库执行时会生成不同的 UUID
-- 导致主库订单号：550e8400-e29b-41d4-a716-446655440000
-- 从库订单号：6ba7b810-9dad-11d1-80b4-00c04fd430c8
```

**解决方案：**
```sql
-- 1. 切换为 Row 格式（需重启或动态修改）
SET GLOBAL binlog_format = 'ROW';

-- 2. 验证从库同步状态
SHOW SLAVE STATUS\G
*************************** 1. row ***************************
               Slave_IO_Running: Yes
              Slave_SQL_Running: Yes
          Exec_Master_Log_Pos: 154
               Relay_Log_Space: 521
         Seconds_Behind_Master: 0
```

**Row 格式的性能优化：**
```sql
-- 批量更新 10 万行数据
UPDATE users SET status = 1 WHERE create_time < '2024-01-01';

-- Statement 格式：binlog 只记录一条 SQL，约 100 字节
-- Row 格式：记录 10 万行变更，约 10MB（假设每行 100 字节）

-- 优化：启用 binlog_row_image = MINIMAL，只记录变更的列
SET GLOBAL binlog_row_image = 'MINIMAL';
```

**配置建议：**
```ini
[mysqld]
# 生产环境推荐配置
binlog_format = ROW
binlog_row_image = MINIMAL  # 只记录变更列，减少体积
sync_binlog = 1             # 每次事务提交同步刷盘，保证持久性
expire_logs_days = 7        # binlog 保留 7 天
max_binlog_size = 1G        # 单个 binlog 文件最大 1GB
```

### 四、主从复制监控要点

```sql
-- 检查主从延迟
SHOW SLAVE STATUS\G
-- 关键指标：
-- Seconds_Behind_Master: 延迟秒数，0 表示无延迟
-- Slave_IO_Running/Slave_SQL_Running: 必须都是 Yes

-- 查看主库 binlog 位置
SHOW MASTER STATUS;

-- 查看从库已同步的位置
SHOW SLAVE STATUS\G | grep 'Exec_Master_Log_Pos'
```

通过 binlog 实现的主从复制是 MySQL 高可用架构的基础，Row 格式虽然体积较大，但在数据一致性和可恢复性上具有明显优势，是生产环境的首选方案。
