---
title: React 的性能优化策略（代码分割、懒加载、虚拟列表）
tags:
  - 前端React
status: robot
class: 前端React
slug: react-performance-optimization-strategies
ref:
---

## 核心要点

**React 性能优化的核心是"避免不必要的渲染和计算"，通过代码分割减少初始加载体积，懒加载按需加载资源，虚拟列表只渲染可见区域，从而实现极致的用户体验。**

关键技术：
- 📦 **代码分割**：`React.lazy` + Dynamic Import + Route-based Splitting
- ⏳ **懒加载**：图片懒加载、组件懒加载、预加载策略
- 🚀 **虚拟列表**：react-window / react-virtualized，只渲染可见项
- ⚡ **其他优化**：memo、useMemo、useCallback、Web Worker

---

## 详细解答

### 一、代码分割（Code Splitting）

#### 1. 为什么需要代码分割

**问题**：单页应用打包成一个巨大的 bundle.js

```javascript
// 未优化前
// bundle.js (2.5MB)
├── react, react-dom (150KB)
├── 主页组件 (50KB)
├── 管理后台 (800KB)     ❌ 普通用户永远不会访问
├── 数据分析页面 (500KB)  ❌ 大部分用户不使用
├── 第三方库 (1MB)
└── ...

// 结果：
// - 首次加载时间：5-10秒
// - 用户流失率：+40%
```

**解决方案**：按需加载

```javascript
// 优化后
// main.js (200KB) - 立即加载
// home.chunk.js (50KB) - 访问首页时加载
// admin.chunk.js (800KB) - 访问管理后台时加载
// analytics.chunk.js (500KB) - 打开数据分析时加载

// 结果：
// - 首次加载时间：1-2秒 ✅
// - 首屏加载提升：5x
```

#### 2. React.lazy + Suspense

**2.1 基本用法**

```javascript
import { lazy, Suspense } from 'react'

// ❌ 传统导入（打包到主 bundle）
// import Dashboard from './Dashboard'

// ✅ 懒加载（独立 chunk）
const Dashboard = lazy(() => import('./Dashboard'))
const Analytics = lazy(() => import('./Analytics'))
const Settings = lazy(() => import('./Settings'))

function App() {
  return (
    <div>
      <Suspense fallback={<Loading />}>
        <Dashboard />
      </Suspense>
    </div>
  )
}

// Loading 组件
function Loading() {
  return (
    <div className="loading-skeleton">
      <div className="skeleton-header" />
      <div className="skeleton-content" />
    </div>
  )
}
```

**2.2 错误处理**

```javascript
import { lazy, Suspense, Component } from 'react'

// Error Boundary
class ErrorBoundary extends Component {
  state = { hasError: false, error: null }

  static getDerivedStateFromError(error) {
    return { hasError: true, error }
  }

  componentDidCatch(error, errorInfo) {
    console.error('Lazy load failed:', error, errorInfo)
    // 发送到错误监控服务
    Sentry.captureException(error)
  }

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>组件加载失败</h2>
          <button onClick={() => window.location.reload()}>
            刷新页面
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

// 使用
function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<Loading />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  )
}
```

**2.3 带重试机制的懒加载**

```javascript
// lazyWithRetry.js
function lazyWithRetry(componentImport, retries = 3) {
  return lazy(() => {
    return new Promise((resolve, reject) => {
      const attemptImport = (retriesLeft) => {
        componentImport()
          .then(resolve)
          .catch((error) => {
            if (retriesLeft === 0) {
              reject(error)
            } else {
              console.log(`Retrying import... (${retriesLeft} attempts left)`)
              setTimeout(() => attemptImport(retriesLeft - 1), 1000)
            }
          })
      }

      attemptImport(retries)
    })
  })
}

// 使用
const Dashboard = lazyWithRetry(() => import('./Dashboard'))
```

#### 3. 路由级代码分割（最佳实践）

```javascript
import { lazy, Suspense } from 'react'
import { BrowserRouter, Routes, Route } from 'react-router-dom'

// 路由组件懒加载
const Home = lazy(() => import('./pages/Home'))
const Products = lazy(() => import('./pages/Products'))
const ProductDetail = lazy(() => import('./pages/ProductDetail'))
const Admin = lazy(() => import('./pages/Admin'))

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoading />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/products" element={<Products />} />
          <Route path="/products/:id" element={<ProductDetail />} />
          <Route path="/admin" element={<Admin />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  )
}

// 页面级 Loading
function PageLoading() {
  return (
    <div className="page-loading">
      <div className="spinner" />
      <p>加载中...</p>
    </div>
  )
}
```

#### 4. 组件级代码分割

```javascript
// 重型组件懒加载
const HeavyChart = lazy(() => import('./HeavyChart'))
const RichTextEditor = lazy(() => import('./RichTextEditor'))
const VideoPlayer = lazy(() => import('./VideoPlayer'))

function Dashboard() {
  const [showChart, setShowChart] = useState(false)

  return (
    <div>
      <h1>Dashboard</h1>
      <button onClick={() => setShowChart(true)}>显示图表</button>

      {showChart && (
        <Suspense fallback={<Skeleton />}>
          <HeavyChart data={data} />
        </Suspense>
      )}
    </div>
  )
}
```

#### 5. 动态导入（Advanced）

```javascript
// 根据条件动态加载不同组件
function ThemeProvider({ theme, children }) {
  const [ThemeComponent, setThemeComponent] = useState(null)

  useEffect(() => {
    const loadTheme = async () => {
      if (theme === 'dark') {
        const module = await import('./themes/DarkTheme')
        setThemeComponent(() => module.default)
      } else {
        const module = await import('./themes/LightTheme')
        setThemeComponent(() => module.default)
      }
    }

    loadTheme()
  }, [theme])

  if (!ThemeComponent) return <Loading />

  return <ThemeComponent>{children}</ThemeComponent>
}

// 动态加载语言包
async function loadLocale(locale) {
  const messages = await import(`./locales/${locale}.json`)
  return messages.default
}

// 动态加载工具库
async function loadAnalytics() {
  if (process.env.NODE_ENV === 'production') {
    const analytics = await import('analytics')
    analytics.init()
  }
}
```

---

### 二、懒加载（Lazy Loading）

#### 1. 图片懒加载

**1.1 原生 Intersection Observer**

```javascript
function LazyImage({ src, alt, placeholder }) {
  const [imageSrc, setImageSrc] = useState(placeholder)
  const [isLoaded, setIsLoaded] = useState(false)
  const imgRef = useRef(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setImageSrc(src)
            observer.unobserve(entry.target)
          }
        })
      },
      {
        rootMargin: '50px' // 提前 50px 加载
      }
    )

    if (imgRef.current) {
      observer.observe(imgRef.current)
    }

    return () => {
      if (imgRef.current) {
        observer.unobserve(imgRef.current)
      }
    }
  }, [src])

  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      onLoad={() => setIsLoaded(true)}
      className={isLoaded ? 'loaded' : 'loading'}
    />
  )
}

// 使用
<LazyImage
  src="/images/high-res.jpg"
  placeholder="/images/placeholder.jpg"
  alt="Product"
/>
```

**1.2 现代浏览器原生支持**

```javascript
// HTML loading 属性（最简单！）
<img src="/image.jpg" loading="lazy" alt="Product" />

// React 中
function ProductImage({ src, alt }) {
  return (
    <img
      src={src}
      alt={alt}
      loading="lazy" // 浏览器原生懒加载
      decoding="async" // 异步解码
    />
  )
}
```

**1.3 渐进式图片加载（LQIP - Low Quality Image Placeholder）**

```javascript
function ProgressiveImage({ lowQualitySrc, highQualitySrc, alt }) {
  const [src, setSrc] = useState(lowQualitySrc)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const img = new Image()
    img.src = highQualitySrc

    img.onload = () => {
      setSrc(highQualitySrc)
      setIsLoading(false)
    }
  }, [highQualitySrc])

  return (
    <div className={`progressive-image ${isLoading ? 'loading' : 'loaded'}`}>
      <img src={src} alt={alt} />
    </div>
  )
}

// CSS
// .progressive-image.loading img {
//   filter: blur(10px);
// }
// .progressive-image.loaded img {
//   filter: none;
//   transition: filter 0.3s ease;
// }
```

#### 2. 组件预加载

**2.1 鼠标悬停预加载**

```javascript
function PreloadableLink({ to, children }) {
  const [isPreloaded, setIsPreloaded] = useState(false)

  const preload = () => {
    if (!isPreloaded) {
      // 预加载路由组件
      import(`./pages${to}`)
      setIsPreloaded(true)
    }
  }

  return (
    <Link
      to={to}
      onMouseEnter={preload}  // 鼠标悬停时预加载
      onFocus={preload}        // 键盘聚焦时预加载
    >
      {children}
    </Link>
  )
}
```

**2.2 可见时预加载**

```javascript
function PreloadWhenVisible({ children, preloadFunc }) {
  const ref = useRef(null)
  const [hasPreloaded, setHasPreloaded] = useState(false)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && !hasPreloaded) {
          preloadFunc()
          setHasPreloaded(true)
          observer.disconnect()
        }
      },
      { rootMargin: '100px' }
    )

    if (ref.current) {
      observer.observe(ref.current)
    }

    return () => observer.disconnect()
  }, [preloadFunc, hasPreloaded])

  return <div ref={ref}>{children}</div>
}

// 使用
<PreloadWhenVisible preloadFunc={() => import('./HeavyComponent')}>
  <button>点击查看详情</button>
</PreloadWhenVisible>
```

**2.3 空闲时预加载**

```javascript
// 使用 requestIdleCallback
function preloadOnIdle(importFunc) {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      importFunc()
    })
  } else {
    // 降级方案
    setTimeout(importFunc, 1)
  }
}

// 使用
function App() {
  useEffect(() => {
    // 首屏渲染完成后，空闲时预加载其他路由
    preloadOnIdle(() => import('./pages/Dashboard'))
    preloadOnIdle(() => import('./pages/Settings'))
  }, [])

  return <div>...</div>
}
```

---

### 三、虚拟列表（Virtual List / Windowing）

#### 1. 为什么需要虚拟列表

```javascript
// ❌ 直接渲染 10000 项
function BadList({ items }) {
  return (
    <div>
      {items.map(item => (
        <div key={item.id} className="list-item">
          {item.name}
        </div>
      ))}
    </div>
  )
}
// 问题：
// - 10000 个 DOM 节点（内存占用 ~100MB）
// - 首次渲染耗时 2-5 秒
// - 滚动卡顿（需要 layout 10000 个元素）

// ✅ 虚拟列表：只渲染可见的 20 项
// - 20 个 DOM 节点（内存占用 ~2MB）
// - 首次渲染耗时 <100ms
// - 滚动流畅（60fps）
```

#### 2. 手写简单虚拟列表

```javascript
function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0)

  // 可见区域的起止索引
  const startIndex = Math.floor(scrollTop / itemHeight)
  const endIndex = Math.ceil((scrollTop + containerHeight) / itemHeight)

  // 可见项
  const visibleItems = items.slice(startIndex, endIndex + 1)

  // 总高度
  const totalHeight = items.length * itemHeight

  // 偏移量
  const offsetY = startIndex * itemHeight

  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{ height: itemHeight }}
              className="list-item"
            >
              {item.name}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

// 使用
const items = Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  name: `Item ${i}`
}))

<VirtualList
  items={items}
  itemHeight={50}
  containerHeight={600}
/>
```

#### 3. react-window（推荐）

**3.1 固定高度列表**

```javascript
import { FixedSizeList } from 'react-window'

function MyList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style} className="list-item">
      {items[index].name}
    </div>
  )

  return (
    <FixedSizeList
      height={600}        // 容器高度
      itemCount={items.length}
      itemSize={50}       // 每项高度
      width="100%"
    >
      {Row}
    </FixedSizeList>
  )
}
```

**3.2 动态高度列表**

```javascript
import { VariableSizeList } from 'react-window'

function DynamicList({ items }) {
  const listRef = useRef(null)
  const rowHeights = useRef({})

  // 设置行高
  const setRowHeight = (index, size) => {
    listRef.current.resetAfterIndex(0)
    rowHeights.current = { ...rowHeights.current, [index]: size }
  }

  // 获取行高
  const getRowHeight = (index) => {
    return rowHeights.current[index] || 80 // 默认高度
  }

  const Row = ({ index, style }) => {
    const rowRef = useRef(null)

    useEffect(() => {
      if (rowRef.current) {
        setRowHeight(index, rowRef.current.clientHeight)
      }
    }, [index])

    return (
      <div style={style}>
        <div ref={rowRef} className="dynamic-row">
          <h3>{items[index].title}</h3>
          <p>{items[index].content}</p>
        </div>
      </div>
    )
  }

  return (
    <VariableSizeList
      ref={listRef}
      height={600}
      itemCount={items.length}
      itemSize={getRowHeight}
      width="100%"
    >
      {Row}
    </VariableSizeList>
  )
}
```

**3.3 虚拟网格**

```javascript
import { FixedSizeGrid } from 'react-window'

function ImageGrid({ images }) {
  const Cell = ({ columnIndex, rowIndex, style }) => {
    const index = rowIndex * 5 + columnIndex // 5 列
    const image = images[index]

    if (!image) return null

    return (
      <div style={style} className="grid-cell">
        <img src={image.url} alt={image.title} loading="lazy" />
      </div>
    )
  }

  return (
    <FixedSizeGrid
      columnCount={5}
      columnWidth={200}
      height={600}
      rowCount={Math.ceil(images.length / 5)}
      rowHeight={200}
      width={1000}
    >
      {Cell}
    </FixedSizeGrid>
  )
}
```

**3.4 无限滚动 + 虚拟列表**

```javascript
import { FixedSizeList } from 'react-window'
import InfiniteLoader from 'react-window-infinite-loader'

function InfiniteVirtualList() {
  const [items, setItems] = useState([])
  const [hasNextPage, setHasNextPage] = useState(true)

  // 加载更多
  const loadMoreItems = async (startIndex, stopIndex) => {
    const newItems = await fetchItems(startIndex, stopIndex)
    setItems(prev => [...prev, ...newItems])

    if (newItems.length === 0) {
      setHasNextPage(false)
    }
  }

  // 检查是否已加载
  const isItemLoaded = (index) => !hasNextPage || index < items.length

  const Row = ({ index, style }) => {
    const item = items[index]

    if (!item) {
      return <div style={style}>加载中...</div>
    }

    return (
      <div style={style}>
        {item.name}
      </div>
    )
  }

  return (
    <InfiniteLoader
      isItemLoaded={isItemLoaded}
      itemCount={hasNextPage ? items.length + 1 : items.length}
      loadMoreItems={loadMoreItems}
    >
      {({ onItemsRendered, ref }) => (
        <FixedSizeList
          height={600}
          itemCount={hasNextPage ? items.length + 1 : items.length}
          itemSize={50}
          onItemsRendered={onItemsRendered}
          ref={ref}
          width="100%"
        >
          {Row}
        </FixedSizeList>
      )}
    </InfiniteLoader>
  )
}
```

---

### 四、其他性能优化技巧

#### 1. React.memo 避免重渲染

```javascript
// ❌ 父组件更新时，子组件总是重渲染
function BadChild({ name }) {
  console.log('Rendering Child')
  return <div>{name}</div>
}

// ✅ 使用 memo，props 不变时跳过渲染
const GoodChild = memo(function Child({ name }) {
  console.log('Rendering Child')
  return <div>{name}</div>
})

// 自定义比较函数
const OptimizedChild = memo(
  function Child({ user }) {
    return <div>{user.name}</div>
  },
  (prevProps, nextProps) => {
    // 返回 true 表示跳过更新
    return prevProps.user.id === nextProps.user.id
  }
)
```

#### 2. useMemo 缓存计算结果

```javascript
function ExpensiveComponent({ items, filterText }) {
  // ❌ 每次渲染都重新计算
  // const filtered = items.filter(item => item.name.includes(filterText))

  // ✅ 只在依赖项变化时重新计算
  const filtered = useMemo(() => {
    console.log('Filtering...')
    return items.filter(item => item.name.includes(filterText))
  }, [items, filterText])

  return <ul>{filtered.map(item => <li key={item.id}>{item.name}</li>)}</ul>
}
```

#### 3. useCallback 缓存函数引用

```javascript
function Parent() {
  const [count, setCount] = useState(0)

  // ❌ 每次渲染都创建新函数，导致 Child 重渲染
  // const handleClick = () => console.log('Clicked')

  // ✅ 使用 useCallback 缓存函数
  const handleClick = useCallback(() => {
    console.log('Clicked')
  }, [])

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </div>
  )
}

const Child = memo(({ onClick }) => {
  console.log('Rendering Child')
  return <button onClick={onClick}>Click me</button>
})
```

#### 4. Web Worker 处理重型计算

```javascript
// worker.js
self.addEventListener('message', (e) => {
  const { data, type } = e.data

  if (type === 'SORT') {
    const sorted = data.sort((a, b) => b - a) // 耗时排序
    self.postMessage({ type: 'SORT_COMPLETE', data: sorted })
  }
})

// Component.jsx
function HeavyComputation({ numbers }) {
  const [sorted, setSorted] = useState([])

  useEffect(() => {
    const worker = new Worker(new URL('./worker.js', import.meta.url))

    worker.postMessage({ type: 'SORT', data: numbers })

    worker.onmessage = (e) => {
      if (e.data.type === 'SORT_COMPLETE') {
        setSorted(e.data.data)
      }
    }

    return () => worker.terminate()
  }, [numbers])

  return <ul>{sorted.map(n => <li key={n}>{n}</li>)}</ul>
}
```

#### 5. 时间切片（Time Slicing）

```javascript
// 使用 React 18 的 startTransition
import { useState, startTransition } from 'react'

function SearchPage() {
  const [input, setInput] = useState('')
  const [results, setResults] = useState([])

  const handleChange = (e) => {
    // 立即更新输入框（高优先级）
    setInput(e.target.value)

    // 延迟更新搜索结果（低优先级）
    startTransition(() => {
      const filtered = hugeData.filter(item =>
        item.name.includes(e.target.value)
      )
      setResults(filtered)
    })
  }

  return (
    <div>
      <input value={input} onChange={handleChange} />
      <ul>
        {results.map(item => <li key={item.id}>{item.name}</li>)}
      </ul>
    </div>
  )
}
```

---

### 五、性能监控与分析

#### 1. React DevTools Profiler

```javascript
import { Profiler } from 'react'

function onRenderCallback(
  id,        // 组件 ID
  phase,     // "mount" 或 "update"
  actualDuration, // 本次渲染耗时
  baseDuration,   // 预估渲染耗时
  startTime,
  commitTime
) {
  console.log(`${id} ${phase} took ${actualDuration}ms`)
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Dashboard />
    </Profiler>
  )
}
```

#### 2. Lighthouse 性能审计

```bash
# Chrome DevTools → Lighthouse → Generate Report
# 关键指标：
# - FCP (First Contentful Paint) < 1.8s
# - LCP (Largest Contentful Paint) < 2.5s
# - TTI (Time to Interactive) < 3.8s
# - TBT (Total Blocking Time) < 200ms
# - CLS (Cumulative Layout Shift) < 0.1
```

---

## 总结

### 优化策略对比

| 技术 | 适用场景 | 性能提升 | 实现复杂度 |
|------|---------|---------|-----------|
| **代码分割** | 大型应用、多路由 | ⭐⭐⭐⭐⭐ | 简单 |
| **懒加载** | 图片密集、重型组件 | ⭐⭐⭐⭐ | 简单 |
| **虚拟列表** | 长列表（>1000项） | ⭐⭐⭐⭐⭐ | 中等 |
| **memo/useMemo** | 频繁重渲染的组件 | ⭐⭐⭐ | 简单 |
| **Web Worker** | CPU 密集型计算 | ⭐⭐⭐⭐ | 中等 |

### 最佳实践检查清单

✅ **初始加载优化**
- [ ] 路由级代码分割
- [ ] 第三方库按需引入（tree-shaking）
- [ ] 压缩打包体积（Gzip/Brotli）

✅ **运行时优化**
- [ ] 长列表使用虚拟滚动
- [ ] 图片懒加载 + WebP 格式
- [ ] 组件懒加载 + 预加载

✅ **渲染优化**
- [ ] React.memo 避免不必要的重渲染
- [ ] useMemo/useCallback 缓存计算和函数
- [ ] 使用 key 优化列表渲染

✅ **监控与调试**
- [ ] React DevTools Profiler 分析性能瓶颈
- [ ] Lighthouse 定期审计
- [ ] 真实用户监控（RUM）

掌握这些性能优化技术，可以让 React 应用在任何设备上都保持流畅，显著提升用户体验和业务转化率。
