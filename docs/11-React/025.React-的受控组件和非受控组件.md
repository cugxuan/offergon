---
title: React 的受控组件和非受控组件
tags:
  - 前端React
status: robot
class: 前端React
slug: controlled-vs-uncontrolled-components-react
ref:
---

## 核心要点

**受控 vs 非受控的本质区分**：受控组件的值由 React state 完全控制（单一数据源），每次输入都触发 state 更新和重新渲染；非受控组件的值由 DOM 自身管理，通过 ref 访问。受控组件提供完全控制和验证能力，适合复杂表单；非受控组件性能更好，代码更简洁，适合简单场景。两者可混合使用，关键是理解数据流和控制权的差异。

---

## 详细回答

### 一、受控组件（Controlled Components）

#### 1. 定义和原理

**受控组件**：表单元素的值由 React state 控制，每次用户输入都会触发事件处理函数更新 state，state 的变化驱动组件重新渲染，形成**单向数据流**。

**核心特征**：
- React state 是"唯一数据源"（Single Source of Truth）
- 表单元素的 `value` 属性由 state 控制
- 用户输入通过 `onChange` 事件更新 state

**数据流**：

```
用户输入 → onChange 事件 → 更新 state → 重新渲染 → 显示新值
         ↑                                           ↓
         └──────────────────────────────────────────┘
                    单向数据流（循环）
```

#### 2. 基础示例

```tsx
function ControlledInput() {
  const [value, setValue] = useState('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  };

  return (
    <div>
      <input
        type="text"
        value={value}          // ← state 控制值
        onChange={handleChange} // ← 用户输入更新 state
      />
      <p>当前值：{value}</p>
    </div>
  );
}
```

**完整的表单示例**：

```tsx
interface FormData {
  username: string;
  email: string;
  age: number;
  gender: 'male' | 'female' | '';
  agree: boolean;
  comments: string;
}

function ControlledForm() {
  const [formData, setFormData] = useState<FormData>({
    username: '',
    email: '',
    age: 0,
    gender: '',
    agree: false,
    comments: '',
  });

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;

    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox'
        ? (e.target as HTMLInputElement).checked
        : type === 'number'
        ? Number(value)
        : value,
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('提交数据:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 文本输入 */}
      <input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="用户名"
      />

      {/* 邮箱输入 */}
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="邮箱"
      />

      {/* 数字输入 */}
      <input
        type="number"
        name="age"
        value={formData.age}
        onChange={handleChange}
        placeholder="年龄"
      />

      {/* 下拉选择 */}
      <select name="gender" value={formData.gender} onChange={handleChange}>
        <option value="">请选择性别</option>
        <option value="male">男</option>
        <option value="female">女</option>
      </select>

      {/* 复选框 */}
      <label>
        <input
          type="checkbox"
          name="agree"
          checked={formData.agree}
          onChange={handleChange}
        />
        同意条款
      </label>

      {/* 多行文本 */}
      <textarea
        name="comments"
        value={formData.comments}
        onChange={handleChange}
        placeholder="备注"
      />

      <button type="submit">提交</button>
    </form>
  );
}
```

#### 3. 受控组件的优势

**① 实时验证**

```tsx
function ValidatedInput() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setEmail(value);

    // 实时验证
    if (value && !value.includes('@')) {
      setError('请输入有效的邮箱地址');
    } else {
      setError('');
    }
  };

  return (
    <div>
      <input type="email" value={email} onChange={handleChange} />
      {error && <span style={{ color: 'red' }}>{error}</span>}
    </div>
  );
}
```

**② 条件禁用/启用**

```tsx
function ConditionalForm() {
  const [hasAccount, setHasAccount] = useState(false);
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  return (
    <form>
      <label>
        <input
          type="checkbox"
          checked={hasAccount}
          onChange={(e) => setHasAccount(e.target.checked)}
        />
        我已有账号
      </label>

      <input
        type="text"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        disabled={!hasAccount} // 根据状态禁用
      />

      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        disabled={!hasAccount}
      />
    </form>
  );
}
```

**③ 格式化输入**

```tsx
function FormattedInput() {
  const [phone, setPhone] = useState('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let value = e.target.value.replace(/\D/g, ''); // 只保留数字

    // 格式化为 XXX-XXXX-XXXX
    if (value.length > 3 && value.length <= 7) {
      value = `${value.slice(0, 3)}-${value.slice(3)}`;
    } else if (value.length > 7) {
      value = `${value.slice(0, 3)}-${value.slice(3, 7)}-${value.slice(7, 11)}`;
    }

    setPhone(value);
  };

  return (
    <input
      type="text"
      value={phone}
      onChange={handleChange}
      placeholder="手机号码"
      maxLength={13} // XXX-XXXX-XXXX
    />
  );
}
```

**④ 强制转换输入**

```tsx
function UppercaseInput() {
  const [value, setValue] = useState('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value.toUpperCase()); // 强制大写
  };

  return <input type="text" value={value} onChange={handleChange} />;
}
```

**⑤ 阻止特定输入**

```tsx
function NoNumbersInput() {
  const [value, setValue] = useState('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value.replace(/\d/g, ''); // 移除所有数字
    setValue(newValue);
  };

  return <input type="text" value={value} onChange={handleChange} />;
}
```

---

### 二、非受控组件（Uncontrolled Components）

#### 1. 定义和原理

**非受控组件**：表单元素的值由 **DOM 自身管理**，React 通过 `ref` 访问 DOM 节点来获取值，而不是通过 state 控制。

**核心特征**：
- DOM 是数据源
- 使用 `ref` 访问表单值
- 不需要 `onChange` 事件处理函数
- 使用 `defaultValue` 设置初始值

#### 2. 基础示例

```tsx
function UncontrolledInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('输入值:', inputRef.current?.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={inputRef}
        defaultValue="初始值" // 使用 defaultValue，不是 value
      />
      <button type="submit">提交</button>
    </form>
  );
}
```

**完整表单示例**：

```tsx
function UncontrolledForm() {
  const usernameRef = useRef<HTMLInputElement>(null);
  const emailRef = useRef<HTMLInputElement>(null);
  const ageRef = useRef<HTMLInputElement>(null);
  const genderRef = useRef<HTMLSelectElement>(null);
  const agreeRef = useRef<HTMLInputElement>(null);
  const commentsRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    const formData = {
      username: usernameRef.current?.value,
      email: emailRef.current?.value,
      age: Number(ageRef.current?.value),
      gender: genderRef.current?.value,
      agree: agreeRef.current?.checked,
      comments: commentsRef.current?.value,
    };

    console.log('提交数据:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={usernameRef}
        defaultValue=""
        placeholder="用户名"
      />

      <input
        type="email"
        ref={emailRef}
        defaultValue=""
        placeholder="邮箱"
      />

      <input
        type="number"
        ref={ageRef}
        defaultValue="0"
        placeholder="年龄"
      />

      <select ref={genderRef} defaultValue="">
        <option value="">请选择性别</option>
        <option value="male">男</option>
        <option value="female">女</option>
      </select>

      <label>
        <input type="checkbox" ref={agreeRef} />
        同意条款
      </label>

      <textarea
        ref={commentsRef}
        defaultValue=""
        placeholder="备注"
      />

      <button type="submit">提交</button>
    </form>
  );
}
```

#### 3. 非受控组件的优势

**① 更简洁的代码**

```tsx
// 受控组件（需要大量代码）
function ControlledExample() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');

  return (
    <form>
      <input value={name} onChange={e => setName(e.target.value)} />
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <input value={phone} onChange={e => setPhone(e.target.value)} />
    </form>
  );
}

// 非受控组件（更简洁）
function UncontrolledExample() {
  const nameRef = useRef<HTMLInputElement>(null);
  const emailRef = useRef<HTMLInputElement>(null);
  const phoneRef = useRef<HTMLInputElement>(null);

  return (
    <form>
      <input ref={nameRef} defaultValue="" />
      <input ref={emailRef} defaultValue="" />
      <input ref={phoneRef} defaultValue="" />
    </form>
  );
}
```

**② 更好的性能**（减少渲染）

```tsx
function PerformanceComparison() {
  const [controlledValue, setControlledValue] = useState('');
  const uncontrolledRef = useRef<HTMLInputElement>(null);

  console.log('组件渲染'); // 受控组件每次输入都会触发

  return (
    <div>
      {/* 每次输入都重新渲染整个组件 */}
      <input
        value={controlledValue}
        onChange={e => setControlledValue(e.target.value)}
      />

      {/* 不触发重新渲染 */}
      <input ref={uncontrolledRef} defaultValue="" />
    </div>
  );
}
```

**③ 与第三方库集成**

```tsx
import { useRef, useEffect } from 'react';

function DatePickerExample() {
  const dateInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (dateInputRef.current) {
      // 假设使用 flatpickr 日期选择器
      const picker = flatpickr(dateInputRef.current, {
        dateFormat: 'Y-m-d',
        onChange: (selectedDates) => {
          console.log('选择日期:', selectedDates);
        },
      });

      return () => picker.destroy();
    }
  }, []);

  return <input ref={dateInputRef} type="text" placeholder="选择日期" />;
}
```

**④ 文件上传**

```tsx
function FileUpload() {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    const files = fileInputRef.current?.files;
    if (files && files.length > 0) {
      const formData = new FormData();
      formData.append('file', files[0]);

      // 上传文件
      fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="file" ref={fileInputRef} />
      <button type="submit">上传</button>
    </form>
  );
}

// ⚠️ 注意：文件输入必须是非受控组件
// <input type="file"> 的 value 属性是只读的，无法通过 state 控制
```

---

### 三、受控 vs 非受控对比

| 维度 | 受控组件 | 非受控组件 |
|------|---------|----------|
| **数据源** | React state | DOM |
| **访问值** | 通过 state | 通过 ref |
| **初始值** | `value={state}` | `defaultValue="..."` |
| **更新值** | `onChange` 事件 | 无需事件处理 |
| **渲染频率** | 每次输入都重新渲染 | 不触发渲染 |
| **验证时机** | 实时验证（每次输入） | 提交时验证 |
| **代码复杂度** | 较高（需要 state + handler） | 较低（只需 ref） |
| **性能** | 较低（频繁渲染） | 较高（按需访问） |
| **控制能力** | 完全控制（格式化、验证、限制） | 有限控制 |
| **适用场景** | 复杂表单、实时验证、动态表单 | 简单表单、文件上传、第三方库 |

### 四、混合使用（Hybrid Approach）

在实际项目中，经常混合使用受控和非受控组件。

#### 示例：混合表单

```tsx
function HybridForm() {
  // 受控：需要实时验证的字段
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');

  // 非受控：简单字段
  const nameRef = useRef<HTMLInputElement>(null);
  const phoneRef = useRef<HTMLInputElement>(null);
  const addressRef = useRef<HTMLTextAreaElement>(null);

  const validateEmail = (value: string) => {
    if (!value.includes('@')) {
      setEmailError('邮箱格式不正确');
    } else {
      setEmailError('');
    }
  };

  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setEmail(value);
    validateEmail(value);
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    const formData = {
      name: nameRef.current?.value,
      email: email,
      phone: phoneRef.current?.value,
      address: addressRef.current?.value,
    };

    console.log('提交:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 非受控：简单文本输入 */}
      <input ref={nameRef} type="text" placeholder="姓名" />

      {/* 受控：需要实时验证 */}
      <div>
        <input
          type="email"
          value={email}
          onChange={handleEmailChange}
          placeholder="邮箱"
        />
        {emailError && <span style={{ color: 'red' }}>{emailError}</span>}
      </div>

      {/* 非受控：简单输入 */}
      <input ref={phoneRef} type="tel" placeholder="电话" />
      <textarea ref={addressRef} placeholder="地址" />

      <button type="submit">提交</button>
    </form>
  );
}
```

---

### 五、从非受控转为受控（常见陷阱）

#### 问题场景

```tsx
function BuggyComponent({ initialValue }: { initialValue?: string }) {
  const [value, setValue] = useState(initialValue);

  return (
    <input
      value={value} // ❌ 问题：value 可能是 undefined
      onChange={(e) => setValue(e.target.value)}
    />
  );
}

// React 警告：
// "A component is changing an uncontrolled input to be controlled"
```

**原因**：
- 初始 `value={undefined}` → 非受控组件
- 用户输入后 `value="abc"` → 受控组件
- React 不允许组件在受控/非受控之间切换

**✅ 解决方案 1：始终提供有效值**

```tsx
function FixedComponent({ initialValue }: { initialValue?: string }) {
  const [value, setValue] = useState(initialValue || ''); // 确保不是 undefined

  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

**✅ 解决方案 2：使用非受控组件**

```tsx
function FixedComponent({ initialValue }: { initialValue?: string }) {
  const inputRef = useRef<HTMLInputElement>(null);

  return <input ref={inputRef} defaultValue={initialValue} />;
}
```

---

### 六、高级技巧

#### 1. 自定义受控组件

```tsx
interface CustomInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

function CustomInput({ value, onChange, placeholder }: CustomInputProps) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // 可以在这里添加自定义逻辑
    const newValue = e.target.value;
    onChange(newValue);
  };

  return (
    <div className="custom-input">
      <input
        type="text"
        value={value}
        onChange={handleChange}
        placeholder={placeholder}
      />
      <span className="char-count">{value.length}/100</span>
    </div>
  );
}

// 使用
function App() {
  const [text, setText] = useState('');

  return <CustomInput value={text} onChange={setText} />;
}
```

#### 2. 使用 FormData API（非受控组件）

```tsx
function ModernForm() {
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    // 直接从表单获取所有数据
    const formData = new FormData(e.currentTarget);

    const data = {
      username: formData.get('username'),
      email: formData.get('email'),
      age: formData.get('age'),
    };

    console.log('提交:', data);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="username" type="text" defaultValue="" />
      <input name="email" type="email" defaultValue="" />
      <input name="age" type="number" defaultValue="0" />
      <button type="submit">提交</button>
    </form>
  );
}
```

#### 3. 使用表单库（React Hook Form）

```tsx
import { useForm } from 'react-hook-form';

function RHFExample() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = (data: any) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* 非受控（内部使用 ref） */}
      <input {...register('username', { required: true })} />
      {errors.username && <span>用户名必填</span>}

      <input {...register('email', { pattern: /^\S+@\S+$/i })} />
      {errors.email && <span>邮箱格式不正确</span>}

      <button type="submit">提交</button>
    </form>
  );
}
```

#### 4. 受控组件性能优化

```tsx
import { memo } from 'react';

// 昂贵的输入组件
const ExpensiveInput = memo(function ExpensiveInput({
  value,
  onChange,
}: {
  value: string;
  onChange: (value: string) => void;
}) {
  console.log('ExpensiveInput 渲染');

  return (
    <input
      value={value}
      onChange={(e) => onChange(e.target.value)}
    />
  );
});

function OptimizedForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  // 使用 useCallback 避免不必要的重新渲染
  const handleNameChange = useCallback((value: string) => {
    setName(value);
  }, []);

  const handleEmailChange = useCallback((value: string) => {
    setEmail(value);
  }, []);

  return (
    <div>
      <ExpensiveInput value={name} onChange={handleNameChange} />
      <ExpensiveInput value={email} onChange={handleEmailChange} />
    </div>
  );
}
```

---

### 七、选择建议

#### 使用受控组件的场景

1. **实时验证**：密码强度、邮箱格式等
2. **格式化输入**：电话号码、信用卡号等
3. **条件禁用**：根据其他字段的值禁用/启用
4. **字符限制**：最大长度、禁止某些字符
5. **动态表单**：字段根据条件显示/隐藏
6. **多步表单**：需要在步骤间保持状态
7. **即时搜索**：搜索框实时过滤结果

#### 使用非受控组件的场景

1. **简单表单**：只在提交时需要值
2. **文件上传**：`<input type="file">` 必须非受控
3. **第三方库集成**：日期选择器、富文本编辑器等
4. **性能敏感**：大量输入字段的表单
5. **遗留代码集成**：与非 React 代码集成
6. **原型开发**：快速原型，后期可重构

---

### 八、常见错误和修复

#### 错误 1：value 和 defaultValue 同时使用

```tsx
// ❌ 错误
<input
  value={value}
  defaultValue="初始值"
  onChange={handleChange}
/>

// ✅ 受控组件
<input value={value} onChange={handleChange} />

// ✅ 非受控组件
<input ref={inputRef} defaultValue="初始值" />
```

#### 错误 2：受控组件没有 onChange

```tsx
// ❌ 错误（只读输入）
<input value={value} />

// ✅ 添加 onChange
<input value={value} onChange={handleChange} />

// ✅ 或使用 readOnly
<input value={value} readOnly />
```

#### 错误 3：直接修改 ref 的值

```tsx
// ❌ 错误
function BadExample() {
  const inputRef = useRef<HTMLInputElement>(null);

  const clearInput = () => {
    if (inputRef.current) {
      inputRef.current.value = ''; // 可行，但不是 React 方式
    }
  };

  return <input ref={inputRef} />;
}

// ✅ 正确（使用受控组件）
function GoodExample() {
  const [value, setValue] = useState('');

  const clearInput = () => {
    setValue('');
  };

  return <input value={value} onChange={e => setValue(e.target.value)} />;
}
```

---

## 总结

**受控组件和非受控组件是 React 表单处理的两种核心模式**：

1. **受控组件**：React state 控制，提供完全控制和验证能力，适合复杂表单
2. **非受控组件**：DOM 控制，代码简洁、性能更好，适合简单场景
3. **混合使用**：实际项目中常根据字段特性选择合适的模式
4. **关键区别**：数据源（state vs DOM）、访问方式（state vs ref）、渲染频率
5. **选择依据**：根据验证需求、性能要求、代码复杂度等因素综合考虑

理解这两种模式的本质差异和适用场景，能帮助我们在 React 中更高效地处理表单，编写出性能优秀、用户体验良好的应用。
