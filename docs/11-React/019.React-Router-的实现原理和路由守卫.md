---
title: React Router 的实现原理和路由守卫
tags:
  - 前端React
status: robot
class: 前端React
slug: react-router-implementation-route-guards
ref:
---

## 核心要点

**React Router 通过 History API 和 Context 机制实现声明式路由，路由守卫则通过组件拦截、Loader/Action（v6.4+）和自定义 Hook 来实现权限控制和导航拦截。**

关键技术：
- 🧭 **路由匹配**：基于 `path-to-regexp` 的动态路由匹配
- 📍 **History 管理**：Browser/Hash/Memory History 三种模式
- 🎯 **嵌套路由**：通过 `<Outlet>` 实现布局复用
- 🛡️ **路由守卫**：Loader、Protected Route、导航拦截

---

## 详细解答

### 一、React Router 的核心原理

#### 1. History 管理

React Router 基于 `history` 库实现路由状态管理，支持三种模式：

**1.1 Browser History（生产环境推荐）**

```javascript
// 使用 HTML5 History API
import { createBrowserRouter } from 'react-router-dom'

// URL 示例：https://example.com/products/123
const router = createBrowserRouter([
  { path: '/products/:id', element: <Product /> }
])

// 底层实现
const history = {
  push: (path) => window.history.pushState(null, '', path),
  replace: (path) => window.history.replaceState(null, '', path),
  go: (n) => window.history.go(n),
  listen: (callback) => {
    window.addEventListener('popstate', callback)
    return () => window.removeEventListener('popstate', callback)
  }
}
```

**关键 API**：
- `pushState(state, title, url)` - 添加历史记录
- `replaceState(state, title, url)` - 替换当前记录
- `popstate` 事件 - 监听前进/后退

**1.2 Hash History（兼容老浏览器）**

```javascript
import { createHashRouter } from 'react-router-dom'

// URL 示例：https://example.com/#/products/123
const router = createHashRouter([
  { path: '/products/:id', element: <Product /> }
])

// 底层实现
const hashHistory = {
  push: (path) => { window.location.hash = path },
  replace: (path) => {
    const url = window.location.href.replace(/#.*$/, '') + '#' + path
    window.location.replace(url)
  },
  listen: (callback) => {
    window.addEventListener('hashchange', callback)
  }
}
```

**1.3 Memory History（测试/SSR）**

```javascript
import { createMemoryRouter } from 'react-router-dom'

// 不依赖浏览器 API，历史记录存储在内存中
const router = createMemoryRouter([...], {
  initialEntries: ['/products/123']
})
```

#### 2. 路由匹配算法

**2.1 路径匹配原理**

```javascript
// React Router 使用 path-to-regexp 进行路径匹配
import { pathToRegexp } from 'path-to-regexp'

// 静态路由
const pattern1 = '/products'
pathToRegexp(pattern1).test('/products') // true

// 动态参数
const pattern2 = '/products/:id'
const regex2 = pathToRegexp(pattern2) // /^\/products\/([^\/]+?)\/?$/
regex2.test('/products/123') // true

// 提取参数
const keys = []
const regex3 = pathToRegexp('/products/:category/:id', keys)
const match = regex3.exec('/products/books/123')
// match = ['/products/books/123', 'books', '123']
// keys = [{ name: 'category', ... }, { name: 'id', ... }]

// 可选参数
pathToRegexp('/products/:id?') // 匹配 /products 和 /products/123

// 通配符
pathToRegexp('/docs/*') // 匹配 /docs/a, /docs/a/b, /docs/a/b/c
```

**2.2 路由优先级**

```javascript
// React Router v6 的匹配规则
const routes = [
  { path: '/products', element: <List /> },           // 优先级 3
  { path: '/products/:id', element: <Detail /> },     // 优先级 2
  { path: '/products/*', element: <NotFound /> }      // 优先级 1
]

// 匹配算法（简化版）
function matchRoutes(routes, pathname) {
  const matches = []

  for (const route of routes) {
    const regex = pathToRegexp(route.path)
    const match = regex.exec(pathname)

    if (match) {
      matches.push({
        route,
        params: extractParams(match, route.path),
        score: calculateScore(route.path) // 静态路径 > 动态参数 > 通配符
      })
    }
  }

  // 按得分排序，返回最佳匹配
  return matches.sort((a, b) => b.score - a.score)[0]
}

// 评分规则
function calculateScore(path) {
  let score = 0
  const segments = path.split('/')

  for (const segment of segments) {
    if (segment === '') continue
    if (segment.startsWith(':')) score += 1  // 动态参数
    else if (segment === '*') score += 0.5   // 通配符
    else score += 3                           // 静态段
  }

  return score
}

// 示例
calculateScore('/products')         // 3
calculateScore('/products/:id')     // 4 (3 + 1)
calculateScore('/products/*')       // 3.5 (3 + 0.5)
```

#### 3. Context 驱动的组件通信

React Router v6 使用 Context 实现路由状态共享：

```javascript
// React Router 内部简化实现
import { createContext, useContext, useState } from 'react'

// 路由上下文
const RouterContext = createContext(null)
const LocationContext = createContext(null)

// Router 组件
function BrowserRouter({ children }) {
  const [location, setLocation] = useState({
    pathname: window.location.pathname,
    search: window.location.search,
    hash: window.location.hash
  })

  useEffect(() => {
    const handlePopState = () => {
      setLocation({
        pathname: window.location.pathname,
        search: window.location.search,
        hash: window.location.hash
      })
    }

    window.addEventListener('popstate', handlePopState)
    return () => window.removeEventListener('popstate', handlePopState)
  }, [])

  const navigate = (to) => {
    window.history.pushState(null, '', to)
    setLocation({
      pathname: to.split('?')[0],
      search: to.includes('?') ? '?' + to.split('?')[1] : '',
      hash: ''
    })
  }

  return (
    <RouterContext.Provider value={{ navigate }}>
      <LocationContext.Provider value={location}>
        {children}
      </LocationContext.Provider>
    </RouterContext.Provider>
  )
}

// useNavigate Hook
function useNavigate() {
  const context = useContext(RouterContext)
  if (!context) throw new Error('useNavigate must be used within Router')
  return context.navigate
}

// useLocation Hook
function useLocation() {
  const context = useContext(LocationContext)
  if (!context) throw new Error('useLocation must be used within Router')
  return context
}

// Link 组件
function Link({ to, children }) {
  const navigate = useNavigate()

  const handleClick = (e) => {
    e.preventDefault()
    navigate(to)
  }

  return <a href={to} onClick={handleClick}>{children}</a>
}
```

#### 4. 嵌套路由与 `<Outlet>`

```javascript
// 路由配置
const routes = [
  {
    path: '/',
    element: <Layout />,
    children: [
      { path: 'dashboard', element: <Dashboard /> },
      { path: 'products', element: <Products /> }
    ]
  }
]

// Layout 组件
function Layout() {
  return (
    <div>
      <nav>
        <Link to="/dashboard">Dashboard</Link>
        <Link to="/products">Products</Link>
      </nav>
      <main>
        <Outlet /> {/* 子路由渲染位置 */}
      </main>
    </div>
  )
}

// Outlet 实现原理（简化版）
function Outlet() {
  const { matches } = useContext(RouteContext)

  // matches = [
  //   { route: Layout, params: {} },
  //   { route: Dashboard, params: {} }
  // ]

  // 渲染下一层匹配的路由
  const nextMatch = matches[matches.length - 1]
  return nextMatch ? <RouteRenderer match={nextMatch} /> : null
}
```

---

### 二、路由守卫实现

#### 1. 基于组件的路由守卫（最常用）

**1.1 Protected Route 模式**

```javascript
// ========== 基础版本 ==========
function ProtectedRoute({ children }) {
  const { user } = useAuth() // 自定义认证 Hook
  const location = useLocation()

  if (!user) {
    // 未登录，重定向到登录页，并保存原始路径
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  return children
}

// 使用
const routes = [
  {
    path: '/dashboard',
    element: (
      <ProtectedRoute>
        <Dashboard />
      </ProtectedRoute>
    )
  }
]

// ========== 基于角色的权限控制 ==========
function RoleBasedRoute({ children, allowedRoles }) {
  const { user } = useAuth()

  if (!user) {
    return <Navigate to="/login" replace />
  }

  if (!allowedRoles.includes(user.role)) {
    return <Navigate to="/403" replace /> // 无权限
  }

  return children
}

// 使用
<RoleBasedRoute allowedRoles={['admin', 'editor']}>
  <AdminPanel />
</RoleBasedRoute>

// ========== 多条件守卫 ==========
function GuardedRoute({ children, guards = [] }) {
  const location = useLocation()

  for (const guard of guards) {
    const result = guard()

    if (result === false) {
      return <Navigate to="/login" state={{ from: location }} replace />
    }

    if (typeof result === 'string') {
      return <Navigate to={result} replace />
    }
  }

  return children
}

// 使用
const isAuthenticated = () => {
  const token = localStorage.getItem('token')
  return token ? true : '/login'
}

const hasPermission = () => {
  const user = JSON.parse(localStorage.getItem('user'))
  return user?.role === 'admin' ? true : '/403'
}

<GuardedRoute guards={[isAuthenticated, hasPermission]}>
  <SecretPage />
</GuardedRoute>
```

**1.2 登录后返回原页面**

```javascript
// Login 组件
function Login() {
  const navigate = useNavigate()
  const location = useLocation()

  // 从 location.state 获取原始路径
  const from = location.state?.from?.pathname || '/dashboard'

  const handleLogin = async (credentials) => {
    await authService.login(credentials)
    navigate(from, { replace: true }) // 登录成功后跳转回原页面
  }

  return (
    <form onSubmit={handleLogin}>
      {/* 登录表单 */}
    </form>
  )
}
```

#### 2. React Router v6.4+ Loader 守卫

**2.1 Loader 数据预加载 + 权限校验**

```javascript
import { redirect } from 'react-router-dom'

// 路由配置
const routes = [
  {
    path: '/dashboard',
    element: <Dashboard />,
    loader: dashboardLoader // 数据加载器
  }
]

// Loader 函数（在渲染前执行）
async function dashboardLoader({ request, params }) {
  // 1. 权限校验
  const user = await getCurrentUser()
  if (!user) {
    // 重定向到登录页
    return redirect('/login')
  }

  // 2. 数据预加载
  const data = await fetch('/api/dashboard').then(r => r.json())

  // 3. 返回数据
  return { user, data }
}

// 组件中使用
import { useLoaderData } from 'react-router-dom'

function Dashboard() {
  const { user, data } = useLoaderData() // 获取 loader 返回的数据

  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <Stats data={data} />
    </div>
  )
}
```

**2.2 多层嵌套 Loader**

```javascript
const routes = [
  {
    path: '/',
    element: <Root />,
    loader: rootLoader, // 父级 loader
    children: [
      {
        path: 'users/:userId',
        element: <User />,
        loader: userLoader // 子级 loader（并行加载）
      }
    ]
  }
]

// 父级 Loader
async function rootLoader() {
  const currentUser = await getCurrentUser()
  if (!currentUser) return redirect('/login')
  return { currentUser }
}

// 子级 Loader
async function userLoader({ params }) {
  const user = await fetch(`/api/users/${params.userId}`).then(r => r.json())
  return { user }
}

// 组件中访问
function User() {
  const { user } = useLoaderData()          // 当前路由的数据
  const { currentUser } = useMatches()[0]   // 父路由的数据

  return <div>{user.name}</div>
}
```

**2.3 Loader 错误处理**

```javascript
async function protectedLoader() {
  const response = await fetch('/api/data')

  if (response.status === 401) {
    throw new Response('Unauthorized', { status: 401 })
  }

  if (!response.ok) {
    throw new Response('Not Found', { status: 404 })
  }

  return response.json()
}

// 路由配置
const routes = [
  {
    path: '/protected',
    element: <Protected />,
    loader: protectedLoader,
    errorElement: <ErrorBoundary /> // 错误处理组件
  }
]

// ErrorBoundary 组件
import { useRouteError } from 'react-router-dom'

function ErrorBoundary() {
  const error = useRouteError()

  if (error.status === 401) {
    return <Navigate to="/login" />
  }

  if (error.status === 404) {
    return <h1>Page Not Found</h1>
  }

  return <h1>Something went wrong!</h1>
}
```

#### 3. 导航拦截（Navigation Blocker）

**3.1 阻止未保存的更改丢失**

```javascript
import { useBlocker } from 'react-router-dom'

function FormPage() {
  const [formData, setFormData] = useState({})
  const [isDirty, setIsDirty] = useState(false)

  // 表单未保存时阻止导航
  const blocker = useBlocker(
    ({ currentLocation, nextLocation }) =>
      isDirty && currentLocation.pathname !== nextLocation.pathname
  )

  return (
    <div>
      <form onChange={() => setIsDirty(true)}>
        {/* 表单字段 */}
      </form>

      {blocker.state === 'blocked' && (
        <Modal>
          <p>你有未保存的更改，确定要离开吗？</p>
          <button onClick={() => blocker.proceed()}>离开</button>
          <button onClick={() => blocker.reset()}>取消</button>
        </Modal>
      )}
    </div>
  )
}
```

**3.2 自定义 usePrompt Hook**

```javascript
// hooks/usePrompt.js
import { useEffect } from 'react'
import { useBeforeUnload, useBlocker } from 'react-router-dom'

export function usePrompt(message, when = true) {
  // 阻止浏览器刷新/关闭
  useBeforeUnload(
    (event) => {
      if (when) {
        event.preventDefault()
        event.returnValue = message
      }
    },
    { capture: true }
  )

  // 阻止路由跳转
  const blocker = useBlocker(when)

  useEffect(() => {
    if (blocker.state === 'blocked' && !window.confirm(message)) {
      blocker.reset()
    } else if (blocker.state === 'blocked') {
      blocker.proceed()
    }
  }, [blocker, message])
}

// 使用
function EditPage() {
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

  usePrompt('你有未保存的更改，确定要离开吗？', hasUnsavedChanges)

  return <form>{/* ... */}</form>
}
```

#### 4. 全局导航守卫

**4.1 监听所有路由变化**

```javascript
import { useEffect } from 'react'
import { useLocation, useNavigate } from 'react-router-dom'

function App() {
  const location = useLocation()
  const navigate = useNavigate()

  useEffect(() => {
    // 路由变化时执行的逻辑
    console.log('Route changed to:', location.pathname)

    // 权限校验
    const token = localStorage.getItem('token')
    const protectedRoutes = ['/dashboard', '/profile', '/settings']

    if (protectedRoutes.some(route => location.pathname.startsWith(route))) {
      if (!token) {
        navigate('/login', { replace: true })
      }
    }

    // 页面访问统计
    analytics.track('page_view', {
      path: location.pathname,
      search: location.search
    })
  }, [location, navigate])

  return <RouterProvider router={router} />
}
```

**4.2 路由中间件模式**

```javascript
// routeMiddleware.js
export const middlewares = {
  auth: (context) => {
    const token = localStorage.getItem('token')
    if (!token) {
      return { redirect: '/login' }
    }
  },

  admin: (context) => {
    const user = JSON.parse(localStorage.getItem('user') || '{}')
    if (user.role !== 'admin') {
      return { redirect: '/403' }
    }
  },

  logging: (context) => {
    console.log(`Navigating to ${context.pathname}`)
  }
}

// 应用中间件
function applyMiddlewares(middlewares, context) {
  for (const middleware of middlewares) {
    const result = middleware(context)
    if (result?.redirect) {
      return result.redirect
    }
  }
  return null
}

// 路由配置
const routes = [
  {
    path: '/admin',
    element: <Admin />,
    meta: { middlewares: [middlewares.auth, middlewares.admin, middlewares.logging] }
  }
]

// 路由守卫组件
function RouteGuard({ children, meta }) {
  const location = useLocation()
  const navigate = useNavigate()

  useEffect(() => {
    if (meta?.middlewares) {
      const redirect = applyMiddlewares(meta.middlewares, location)
      if (redirect) {
        navigate(redirect, { replace: true })
      }
    }
  }, [location, meta, navigate])

  return children
}
```

---

### 三、高级路由模式

#### 1. 懒加载路由

```javascript
import { lazy, Suspense } from 'react'

const Dashboard = lazy(() => import('./pages/Dashboard'))
const Products = lazy(() => import('./pages/Products'))

const routes = [
  {
    path: '/dashboard',
    element: (
      <Suspense fallback={<Loading />}>
        <Dashboard />
      </Suspense>
    )
  }
]

// 更优雅的封装
function LazyRoute({ importFunc }) {
  const Component = lazy(importFunc)

  return (
    <Suspense fallback={<Loading />}>
      <Component />
    </Suspense>
  )
}

// 使用
{
  path: '/products',
  element: <LazyRoute importFunc={() => import('./pages/Products')} />
}
```

#### 2. 动态路由（权限路由）

```javascript
// 根据用户角色生成路由
function generateRoutes(userRole) {
  const baseRoutes = [
    { path: '/', element: <Home /> },
    { path: '/about', element: <About /> }
  ]

  const roleRoutes = {
    admin: [
      { path: '/admin', element: <Admin /> },
      { path: '/users', element: <Users /> }
    ],
    editor: [
      { path: '/editor', element: <Editor /> }
    ],
    viewer: []
  }

  return [...baseRoutes, ...(roleRoutes[userRole] || [])]
}

// App 组件
function App() {
  const { user } = useAuth()
  const [routes, setRoutes] = useState([])

  useEffect(() => {
    if (user) {
      const dynamicRoutes = generateRoutes(user.role)
      setRoutes(dynamicRoutes)
    }
  }, [user])

  const router = createBrowserRouter(routes)

  return <RouterProvider router={router} />
}
```

#### 3. 面包屑导航

```javascript
import { useMatches } from 'react-router-dom'

// 路由配置（添加 handle 元数据）
const routes = [
  {
    path: '/',
    element: <Root />,
    handle: { crumb: () => 'Home' },
    children: [
      {
        path: 'products',
        element: <Products />,
        handle: { crumb: () => 'Products' },
        children: [
          {
            path: ':id',
            element: <ProductDetail />,
            loader: productLoader,
            handle: {
              crumb: (data) => data.product.name
            }
          }
        ]
      }
    ]
  }
]

// Breadcrumbs 组件
function Breadcrumbs() {
  const matches = useMatches()

  const crumbs = matches
    .filter(match => match.handle?.crumb)
    .map(match => ({
      label: match.handle.crumb(match.data),
      path: match.pathname
    }))

  return (
    <nav>
      {crumbs.map((crumb, index) => (
        <span key={index}>
          {index > 0 && ' / '}
          <Link to={crumb.path}>{crumb.label}</Link>
        </span>
      ))}
    </nav>
  )
}
```

---

### 四、性能优化

#### 1. 路由预加载

```javascript
// 鼠标悬停时预加载
function PreloadLink({ to, children }) {
  const preload = () => {
    // 预加载组件
    import(`./pages${to}`)
  }

  return (
    <Link to={to} onMouseEnter={preload}>
      {children}
    </Link>
  )
}

// 提前预加载关键路由
function App() {
  useEffect(() => {
    // 预加载常用页面
    const preloadRoutes = ['/dashboard', '/products']

    preloadRoutes.forEach(route => {
      import(`./pages${route}`)
    })
  }, [])

  return <RouterProvider router={router} />
}
```

#### 2. 路由级代码分割

```javascript
// vite.config.js / webpack.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['react', 'react-dom', 'react-router-dom'],
          'admin': ['./src/pages/Admin', './src/pages/Users'],
          'public': ['./src/pages/Home', './src/pages/About']
        }
      }
    }
  }
}
```

---

## 总结

### 核心原理
1. **History 管理**：基于 `pushState`/`replaceState` + `popstate` 事件
2. **路由匹配**：使用 `path-to-regexp` 进行路径匹配和参数提取
3. **Context 驱动**：通过 Context 实现路由状态的全局共享
4. **嵌套路由**：`<Outlet>` 组件实现子路由渲染

### 路由守卫方案
| 方案 | 适用场景 | 优势 | 劣势 |
|------|---------|------|------|
| **ProtectedRoute 组件** | 简单权限控制 | 灵活、易理解 | 组件层级多 |
| **Loader 函数** | 数据预加载 + 权限 | 声明式、性能好 | 仅限 v6.4+ |
| **useBlocker** | 表单未保存提醒 | 官方支持 | 仅限导航拦截 |
| **全局监听** | 统一处理逻辑 | 集中管理 | 耦合度高 |

### 最佳实践
1. ✅ 使用 `<ProtectedRoute>` 包裹需要权限的路由
2. ✅ Loader 中处理数据获取和权限校验（v6.4+）
3. ✅ 使用 `useBlocker` 防止未保存数据丢失
4. ✅ 懒加载 + 代码分割优化性能
5. ✅ 动态路由配合权限系统实现灵活的访问控制

掌握 React Router 的实现原理和路由守卫技术，是构建复杂单页应用的基础能力。
