---
title: React Server Components 的原理和优势
tags:
  - 前端React
status: robot
class: 前端React
slug: react-server-components-principles-advantages
ref:
---

## 核心要点

**React Server Components (RSC) 是 React 18 引入的全新架构，允许组件在服务器端渲染并直接访问后端资源，零 JS 打包体积，实现更好的性能和用户体验。**

核心特性：
- 🎯 服务器组件不发送到客户端（零打包体积）
- 🔌 直接访问数据库、文件系统等后端资源
- 🚀 与客户端组件无缝协作
- 📦 自动代码分割和懒加载
- 🌊 支持流式渲染 (Streaming SSR)

---

## 详细解答

### 一、什么是 React Server Components

React Server Components 是一种新的组件类型，它在**服务器端执行并渲染**，不会被打包到客户端 JavaScript bundle 中。

#### 组件类型对比

```jsx
// ❌ 传统 SSR：所有组件都会被打包到客户端
// server.js
const html = ReactDOMServer.renderToString(<App />)
// client.js 仍需完整的 App 组件代码用于 hydration

// ✅ RSC：服务器组件不发送到客户端
// ProductList.server.jsx (服务器组件)
async function ProductList() {
  // 直接访问数据库，不需要 API 层
  const products = await db.query('SELECT * FROM products')
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} data={product} />
      ))}
    </div>
  )
}

// ProductCard.client.jsx (客户端组件)
'use client'
export default function ProductCard({ data }) {
  const [liked, setLiked] = useState(false)
  // 交互逻辑在客户端执行
  return (
    <div onClick={() => setLiked(!liked)}>
      {data.name} {liked && '❤️'}
    </div>
  )
}
```

### 二、RSC 的工作原理

#### 1. 渲染流程

```
┌─────────────────────────────────────────────────┐
│  1. 客户端请求页面                                │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  2. 服务器执行 Server Components                 │
│     - 访问数据库/文件系统                         │
│     - 执行异步数据获取                            │
│     - 渲染成 React Element Tree                  │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  3. 序列化为特殊格式（React Server Payload）      │
│     - 不是 HTML，而是 JSON-like 流式数据         │
│     - 包含渲染结果和客户端组件的引用              │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  4. 客户端接收并重构虚拟 DOM                      │
│     - 保留 Client Components 的交互能力          │
│     - 按需加载客户端组件代码                      │
└─────────────────────────────────────────────────┘
```

#### 2. RSC Payload 格式示例

```javascript
// 服务器发送的数据格式（简化版）
{
  "J0": {
    "type": "div",
    "props": {
      "children": [
        "M1", // 引用模块 1（客户端组件）
        {
          "type": "span",
          "props": { "children": "服务器数据：共 100 个商品" }
        }
      ]
    }
  },
  "M1": {
    "id": "./ProductCard.client.jsx",
    "chunks": ["chunk-123.js"], // 客户端组件的代码块
    "props": { "data": { "id": 1, "name": "商品 A" } }
  }
}
```

#### 3. 核心概念：零打包开销

```jsx
// Big.server.jsx (服务器组件)
import { format } from 'date-fns' // 📦 300KB 库
import { marked } from 'marked'    // 📦 50KB 库

async function ArticlePage({ id }) {
  const article = await db.articles.findById(id)

  // 这些重型库只在服务器运行，不会被打包到客户端！
  const formattedDate = format(new Date(article.date), 'PPP')
  const html = marked(article.content)

  return (
    <article>
      <time>{formattedDate}</time>
      <div dangerouslySetInnerHTML={{ __html: html }} />
    </article>
  )
}
```

**结果**：客户端 bundle 体积为 **0KB**（不包含 date-fns 和 marked）

### 三、Server Components vs Client Components

| 特性 | Server Components | Client Components |
|------|-------------------|-------------------|
| **执行位置** | 仅服务器 | 服务器 + 客户端 |
| **文件标识** | `.server.jsx` 或默认 | 需要 `'use client'` 声明 |
| **打包体积** | 不计入客户端 bundle | 计入客户端 bundle |
| **数据获取** | 直接访问后端资源 | 需要通过 API |
| **交互能力** | 无（无状态、无事件） | 支持 state/events/hooks |
| **重新渲染** | 需要服务器请求 | 客户端立即响应 |
| **Props 类型** | 可序列化数据 + 组件 | 可序列化数据（不含函数） |

#### 使用规则

```jsx
// ✅ 允许：Server Component 包含 Client Component
// Page.server.jsx
import ClientButton from './Button.client.jsx'

export default function Page() {
  const data = await fetchData() // 服务器数据获取
  return (
    <div>
      <h1>{data.title}</h1>
      <ClientButton /> {/* 客户端交互 */}
    </div>
  )
}

// ✅ 允许：通过 children 传递 Server Component 到 Client Component
// Layout.client.jsx
'use client'
export default function Layout({ children }) {
  const [theme, setTheme] = useState('light')
  return <div className={theme}>{children}</div>
}

// Page.server.jsx
export default function Page() {
  return (
    <Layout>
      <ServerContent /> {/* ✅ 服务器组件通过 children 传递 */}
    </Layout>
  )
}

// ❌ 禁止：Client Component 直接导入 Server Component
// Button.client.jsx
'use client'
import ServerData from './Data.server.jsx' // ❌ 编译错误

export default function Button() {
  return <button><ServerData /></button>
}
```

### 四、RSC 的核心优势

#### 1. 性能优势：更小的 Bundle 体积

**案例**：电商商品详情页

```jsx
// 传统 CSR：客户端需要下载所有依赖
import Markdown from 'react-markdown'        // 📦 100KB
import { Gallery } from 'react-image-gallery' // 📦 80KB
import { addToCart } from './api'

function ProductPage({ id }) {
  const [product, setProduct] = useState(null)

  useEffect(() => {
    fetch(`/api/products/${id}`).then(r => r.json()).then(setProduct)
  }, [id])

  if (!product) return <Loading />

  return (
    <div>
      <Gallery images={product.images} />
      <Markdown>{product.description}</Markdown>
      <button onClick={() => addToCart(product.id)}>加入购物车</button>
    </div>
  )
}
// 总 bundle 体积：~250KB（压缩前）
```

```jsx
// RSC 方案：只有交互部分在客户端
// ProductPage.server.jsx
import { marked } from 'marked' // 📦 服务器，0 客户端体积
import db from './db'

export default async function ProductPage({ id }) {
  const product = await db.products.findById(id) // 直接查询数据库
  const descriptionHtml = marked(product.description)

  return (
    <div>
      <ServerImageGallery images={product.images} />
      <div dangerouslySetInnerHTML={{ __html: descriptionHtml }} />
      <AddToCartButton productId={product.id} /> {/* 客户端组件 */}
    </div>
  )
}

// AddToCartButton.client.jsx
'use client'
export default function AddToCartButton({ productId }) {
  const [loading, setLoading] = useState(false)

  const handleClick = async () => {
    setLoading(true)
    await fetch('/api/cart', { method: 'POST', body: JSON.stringify({ productId }) })
    setLoading(false)
  }

  return <button onClick={handleClick} disabled={loading}>加入购物车</button>
}
// 客户端 bundle 体积：~5KB（仅按钮交互逻辑）
```

**性能提升**：
- 📦 Bundle 体积减少 **98%** (250KB → 5KB)
- ⚡ FCP (First Contentful Paint) 提升 **2-3x**
- 🎯 TTI (Time to Interactive) 提升 **5x**

#### 2. 数据获取优势：消除瀑布请求

**传统方案的瀑布问题**：

```jsx
// ❌ 传统 CSR：3 层瀑布请求
function App() {
  const [user, setUser] = useState(null)

  useEffect(() => {
    fetch('/api/user').then(r => r.json()).then(setUser) // 请求 1
  }, [])

  if (!user) return <Loading />
  return <Dashboard user={user} />
}

function Dashboard({ user }) {
  const [projects, setProjects] = useState(null)

  useEffect(() => {
    fetch(`/api/users/${user.id}/projects`).then(r => r.json()).then(setProjects) // 请求 2
  }, [user.id])

  if (!projects) return <Loading />
  return projects.map(p => <Project id={p.id} />)
}

function Project({ id }) {
  const [data, setData] = useState(null)

  useEffect(() => {
    fetch(`/api/projects/${id}`).then(r => r.json()).then(setData) // 请求 3
  }, [id])

  if (!data) return <Loading />
  return <div>{data.name}</div>
}

// 时间线：
// 0ms    ─────> 请求用户数据
// 500ms  ─────> 请求项目列表
// 1000ms ─────> 请求项目详情
// 1500ms 渲染完成 ❌ 总耗时 1500ms
```

**RSC 方案：并行数据获取**：

```jsx
// ✅ RSC：在服务器并行获取所有数据
// App.server.jsx
async function App() {
  const user = await db.users.getCurrent() // 服务器直接查询
  return <Dashboard userId={user.id} />
}

// Dashboard.server.jsx
async function Dashboard({ userId }) {
  const projects = await db.projects.findByUser(userId)

  // 并行获取所有项目详情
  const projectsData = await Promise.all(
    projects.map(p => db.projects.findById(p.id))
  )

  return projectsData.map(data => <Project data={data} />)
}

// 时间线（服务器内网速度 <10ms）：
// 0ms   ─────> 并行查询所有数据
// 50ms  渲染完成 ✅ 总耗时 50ms（30x 速度提升！）
```

#### 3. 自动代码分割

```jsx
// 传统方案：需要手动 lazy
const HeavyChart = React.lazy(() => import('./HeavyChart'))

function Dashboard() {
  return (
    <Suspense fallback={<Spinner />}>
      <HeavyChart data={data} />
    </Suspense>
  )
}

// RSC 方案：自动按组件边界分割
// Dashboard.server.jsx
import ClientChart from './Chart.client.jsx' // 自动分割！

export default async function Dashboard() {
  const data = await db.analytics.get()
  return <ClientChart data={data} />
}
// Chart.client.jsx 会自动成为独立的 chunk
```

#### 4. 安全性优势

```jsx
// ✅ 敏感逻辑和密钥只在服务器存在
// UserProfile.server.jsx
import { decrypt } from './crypto' // 加密库不暴露给客户端

async function UserProfile({ id }) {
  const user = await db.users.findById(id)

  // 服务器端解密敏感信息
  const email = decrypt(user.encryptedEmail, process.env.SECRET_KEY)

  // 根据权限过滤数据
  if (!hasPermission(user, 'view_salary')) {
    delete user.salary
  }

  return <ProfileCard user={user} email={email} />
}
// 客户端永远看不到 SECRET_KEY 和加密逻辑
```

### 五、实际应用场景

#### 1. 博客文章页面

```jsx
// ArticlePage.server.jsx
import { marked } from 'marked'
import { readFile } from 'fs/promises'
import { Prism } from 'prism-react-renderer'

export default async function ArticlePage({ slug }) {
  // 直接读取文件系统
  const content = await readFile(`./articles/${slug}.md`, 'utf-8')
  const html = marked(content)

  // 服务器渲染代码高亮（重型库不发送到客户端）
  const highlightedHtml = Prism.highlight(html)

  return (
    <article>
      <CommentSection articleId={slug} /> {/* 客户端交互 */}
      <div dangerouslySetInnerHTML={{ __html: highlightedHtml }} />
    </article>
  )
}

// CommentSection.client.jsx
'use client'
export default function CommentSection({ articleId }) {
  const [comments, setComments] = useState([])

  // 评论的增删改查逻辑
  return <div>{/* 交互式评论区 */}</div>
}
```

#### 2. 电商商品搜索

```jsx
// SearchResults.server.jsx
export default async function SearchResults({ query }) {
  // 服务器端全文搜索（使用 Elasticsearch/数据库）
  const products = await searchEngine.query({
    term: query,
    filters: { inStock: true },
    sort: 'relevance'
  })

  return (
    <div>
      <SearchStats count={products.length} query={query} />
      {products.map(product => (
        <ProductCard key={product.id} data={product} />
      ))}
    </div>
  )
}

// ProductCard.client.jsx
'use client'
export default function ProductCard({ data }) {
  const [inCart, setInCart] = useState(false)

  return (
    <div>
      <img src={data.image} alt={data.name} />
      <h3>{data.name}</h3>
      <Price amount={data.price} />
      <button onClick={() => setInCart(true)}>
        {inCart ? '已加入购物车' : '加入购物车'}
      </button>
    </div>
  )
}
```

### 六、与传统 SSR 的对比

| 维度 | 传统 SSR | React Server Components |
|------|---------|------------------------|
| **Hydration** | 需要完整 hydration | 服务器组件无需 hydration |
| **重新渲染** | 需要完整页面导航 | 可部分更新服务器组件 |
| **代码分割** | 手动 `React.lazy` | 自动按组件边界分割 |
| **数据获取** | getServerSideProps 分离 | 组件内 async/await |
| **SEO** | 支持 | 支持 |
| **首屏速度** | 快（但需 hydration） | 更快（无 hydration） |
| **交互延迟** | 低（hydration 后） | 混合（取决于组件类型） |

### 七、注意事项和限制

#### 1. 不能使用的 API

```jsx
// ❌ Server Components 中禁止使用的
export default async function MyServerComponent() {
  // ❌ 不能使用 useState/useEffect 等 Hooks
  const [state, setState] = useState(0)

  // ❌ 不能使用浏览器 API
  const width = window.innerWidth

  // ❌ 不能使用事件处理器
  return <button onClick={() => alert('hi')}>Click</button>

  // ❌ 不能使用 Context（但可以读取 Server Context）
  const theme = useContext(ThemeContext)
}
```

#### 2. Props 传递限制

```jsx
// ❌ 不能传递函数给 Server Component
<ServerComponent onAction={() => {}} />

// ✅ 正确方式：通过 Server Actions
// ServerComponent.server.jsx
async function handleAction() {
  'use server' // Server Action 标记
  await db.actions.create({ type: 'click' })
}

export default function ServerComponent() {
  return <form action={handleAction}>
    <button type="submit">提交</button>
  </form>
}
```

#### 3. 需要 Bundler 支持

目前需要框架支持：
- ✅ **Next.js 13+ (App Router)**
- ✅ **Remix 未来版本**
- ⏳ **其他框架逐步跟进**

### 八、最佳实践

1. **按交互需求分离组件**
```jsx
// 静态内容 → Server Component
// 交互逻辑 → Client Component
// 尽可能将 'use client' 边界推到叶子节点
```

2. **使用 Suspense 流式渲染**
```jsx
// App.server.jsx
export default function App() {
  return (
    <>
      <Header /> {/* 快速渲染 */}
      <Suspense fallback={<Skeleton />}>
        <SlowComponent /> {/* 慢速数据获取，流式传输 */}
      </Suspense>
    </>
  )
}
```

3. **合理使用缓存**
```jsx
// Next.js 中缓存服务器组件渲染结果
export const revalidate = 3600 // 1 小时重新验证

export default async function ProductList() {
  const products = await fetch('https://api.example.com/products', {
    next: { revalidate: 3600 }
  })
  // ...
}
```

---

## 总结

React Server Components 代表了 React 的范式转变，通过**服务器和客户端的职责分离**，实现了：

1. **极致的性能**：零打包体积 + 并行数据获取 + 自动代码分割
2. **更好的开发体验**：直接访问后端资源，消除 API 层
3. **安全性提升**：敏感逻辑和密钥隔离在服务器
4. **SEO 友好**：完整的服务器渲染支持

在 Next.js 13+ 的 App Router 中，RSC 已成为默认模式，这标志着 React 应用架构的重大进化。掌握 RSC 是现代 React 开发的必备技能。
