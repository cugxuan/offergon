---
title: React Hooks 的底层实现原理
tags:
  - React
status: robot
class: 前端React
slug: react-hooks-implementation-principle
ref:
---

## 核心要点

- **Hooks 本质**：函数组件的状态管理和副作用处理机制，基于 Fiber 链表存储
- **数据结构**：每个 Hook 是一个链表节点，按调用顺序串联在 Fiber.memoizedState 上
- **闭包陷阱**：Hook 依赖闭包捕获状态，但闭包可能引用旧值（需用依赖数组解决）
- **Rules of Hooks**：只能在顶层调用（保证链表顺序一致），不能在条件/循环中使用
- **调度器集成**：Hooks 触发更新会创建 Update 对象，加入 Fiber 的 updateQueue

---

## 详细回答

### 一、为什么需要 Hooks？

#### 类组件的痛点

在 Hooks 出现之前（React 16.8 之前），函数组件是"无状态组件"，只能通过类组件管理状态：

```javascript
class Counter extends React.Component {
  state = { count: 0 };

  componentDidMount() {
    document.title = `Count: ${this.state.count}`;
  }

  componentDidUpdate() {
    document.title = `Count: ${this.state.count}`;
  }

  render() {
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}
```

**问题**：
1. **逻辑复用困难**：HOC 和 Render Props 导致"嵌套地狱"
2. **生命周期复杂**：相关逻辑分散在多个生命周期方法中
3. **this 绑定混乱**：需要手动 bind 或使用箭头函数
4. **代码冗长**：简单功能需要写大量样板代码

---

#### Hooks 的优势

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]); // 依赖数组

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

**优势**：
- **逻辑复用简单**：自定义 Hook 可轻松提取和共享逻辑
- **函数式编程**：无需 this，避免绑定问题
- **代码简洁**：减少样板代码
- **按功能组织代码**：相关逻辑写在一起，而非分散在生命周期中

---

### 二、Hooks 的底层数据结构

#### 1. Hook 对象的结构

每个 Hook 调用都会创建一个 `Hook` 对象，存储在 Fiber 节点的 `memoizedState` 链表上：

```javascript
type Hook = {
  memoizedState: any,       // 当前状态值（useState 的 state、useEffect 的 effect 等）
  baseState: any,           // 基础状态（用于计算最新状态）
  baseQueue: Update | null, // 基础更新队列
  queue: UpdateQueue,       // 待处理的更新队列
  next: Hook | null,        // 指向下一个 Hook（链表）
};
```

**不同 Hook 的 memoizedState 存储内容**：
- `useState`：存储当前 state 值
- `useReducer`：存储当前 state 值
- `useEffect`：存储 effect 对象 `{ create, destroy, deps, ... }`
- `useRef`：存储 `{ current: value }` 对象
- `useMemo`：存储 `[memoizedValue, deps]`
- `useCallback`：存储 `[callback, deps]`

---

#### 2. Hooks 链表的构建

React 通过 **调用顺序** 维护 Hooks 链表：

```javascript
function Component() {
  const [name, setName] = useState('Alice');  // Hook 1
  const [age, setAge] = useState(25);         // Hook 2
  useEffect(() => { /* ... */ }, []);         // Hook 3

  // Fiber.memoizedState 链表结构：
  // Hook1 (name) → Hook2 (age) → Hook3 (effect) → null
}
```

**实现代码（简化）**：

```javascript
let currentFiber = null;    // 当前正在渲染的 Fiber 节点
let workInProgressHook = null; // 当前正在处理的 Hook

function useState(initialState) {
  // 1. 获取或创建 Hook 对象
  const hook = updateWorkInProgressHook();

  // 2. 首次渲染：初始化状态
  if (hook.memoizedState === null) {
    hook.memoizedState = typeof initialState === 'function'
      ? initialState()
      : initialState;
  }

  // 3. 处理更新队列（后续渲染）
  const queue = hook.queue;
  if (queue !== null) {
    // 计算最新状态
    let newState = hook.baseState;
    let update = queue.pending;

    while (update !== null) {
      const action = update.action;
      newState = typeof action === 'function' ? action(newState) : action;
      update = update.next;
    }

    hook.memoizedState = newState;
    queue.pending = null;
  }

  // 4. 返回 [state, setState]
  const dispatch = dispatchSetState.bind(null, currentFiber, queue);
  return [hook.memoizedState, dispatch];
}

function updateWorkInProgressHook() {
  if (workInProgressHook === null) {
    // 第一个 Hook
    workInProgressHook = currentFiber.memoizedState;
  } else {
    // 后续 Hook：沿着链表向下走
    workInProgressHook = workInProgressHook.next;
  }

  // 如果是新 Hook，创建节点
  if (workInProgressHook === null) {
    workInProgressHook = {
      memoizedState: null,
      queue: null,
      next: null,
    };

    // 追加到链表末尾
    if (currentFiber.memoizedState === null) {
      currentFiber.memoizedState = workInProgressHook;
    } else {
      let hook = currentFiber.memoizedState;
      while (hook.next !== null) {
        hook = hook.next;
      }
      hook.next = workInProgressHook;
    }
  }

  return workInProgressHook;
}
```

---

### 三、useState 的实现原理

#### 1. 初始渲染（Mount 阶段）

```javascript
function mountState(initialState) {
  // 创建 Hook 对象
  const hook = mountWorkInProgressHook();

  // 初始化状态
  if (typeof initialState === 'function') {
    initialState = initialState(); // 支持惰性初始化
  }
  hook.memoizedState = hook.baseState = initialState;

  // 创建更新队列
  const queue = {
    pending: null,           // 待处理的更新（环形链表）
    dispatch: null,          // dispatch 函数
    lastRenderedReducer: basicStateReducer, // 状态计算函数
    lastRenderedState: initialState,
  };
  hook.queue = queue;

  // 创建 dispatch 函数（绑定当前 Fiber 和队列）
  const dispatch = dispatchSetState.bind(null, currentFiber, queue);
  queue.dispatch = dispatch;

  return [hook.memoizedState, dispatch];
}
```

---

#### 2. setState 的执行过程

```javascript
function dispatchSetState(fiber, queue, action) {
  // 1. 创建 Update 对象
  const update = {
    action,                  // setState 的参数（新值或函数）
    next: null,              // 下一个更新（环形链表）
  };

  // 2. 将 Update 加入队列（环形链表）
  const pending = queue.pending;
  if (pending === null) {
    // 第一个更新：自己指向自己
    update.next = update;
  } else {
    // 插入到环形链表
    update.next = pending.next;
    pending.next = update;
  }
  queue.pending = update;

  // 3. 调度更新
  scheduleUpdateOnFiber(fiber);
}
```

**环形链表的作用**：
- 快速找到最后一个更新（`queue.pending`）
- 快速找到第一个更新（`queue.pending.next`）

---

#### 3. 更新渲染（Update 阶段）

```javascript
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}

function updateReducer(reducer, initialArg) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;

  // 处理更新队列
  let baseState = hook.baseState;
  const pending = queue.pending;

  if (pending !== null) {
    // 遍历环形链表，计算最新状态
    const first = pending.next;
    let update = first;

    do {
      const action = update.action;
      baseState = reducer(baseState, action); // 计算新状态
      update = update.next;
    } while (update !== first);

    queue.pending = null; // 清空队列
  }

  hook.memoizedState = baseState;
  return [baseState, queue.dispatch];
}

// 基础 reducer（setState 使用）
function basicStateReducer(state, action) {
  return typeof action === 'function' ? action(state) : action;
}
```

---

### 四、useEffect 的实现原理

#### 1. Effect 对象的结构

```javascript
type Effect = {
  tag: number,             // 副作用类型（Passive、Layout 等）
  create: () => void,      // effect 回调函数
  destroy: (() => void) | null, // 清理函数
  deps: Array<any> | null, // 依赖数组
  next: Effect | null,     // 下一个 effect（环形链表）
};
```

---

#### 2. Mount 阶段

```javascript
function mountEffect(create, deps) {
  const hook = mountWorkInProgressHook();

  const nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = pushEffect(
    PassiveEffect | HookHasEffect, // 标记需要执行
    create,
    undefined, // 清理函数（首次渲染无）
    nextDeps
  );
}

function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };

  // 将 effect 加入 Fiber 的 updateQueue（环形链表）
  let componentUpdateQueue = currentFiber.updateQueue;
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect; // 环形
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    const firstEffect = lastEffect.next;
    lastEffect.next = effect;
    effect.next = firstEffect;
    componentUpdateQueue.lastEffect = effect;
  }

  return effect;
}
```

---

#### 3. Update 阶段（依赖对比）

```javascript
function updateEffect(create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  let destroy = undefined;

  if (hook.memoizedState !== null) {
    const prevEffect = hook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;

      // 对比依赖数组
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // 依赖未变化：不执行 effect，只记录
        hook.memoizedState = pushEffect(PassiveEffect, create, destroy, nextDeps);
        return;
      }
    }
  }

  // 依赖变化：标记需要执行 effect
  hook.memoizedState = pushEffect(
    PassiveEffect | HookHasEffect,
    create,
    destroy,
    nextDeps
  );
}

// 浅比较依赖数组
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) return false;

  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (Object.is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }
  return true;
}
```

---

#### 4. Commit 阶段执行 Effect

```javascript
function commitPassiveEffects() {
  // 阶段 1：执行清理函数
  const effects = fiber.updateQueue.lastEffect;
  if (effects !== null) {
    let effect = effects.next;
    do {
      if ((effect.tag & HookHasEffect) !== 0) {
        const destroy = effect.destroy;
        if (destroy !== undefined) {
          destroy(); // 执行上次的清理函数
        }
      }
      effect = effect.next;
    } while (effect !== effects.next);
  }

  // 阶段 2：执行 effect 回调
  effect = effects.next;
  do {
    if ((effect.tag & HookHasEffect) !== 0) {
      const create = effect.create;
      effect.destroy = create(); // 执行 effect，保存清理函数
    }
    effect = effect.next;
  } while (effect !== effects.next);
}
```

**执行时机**：
- `useEffect`：Commit 阶段后异步执行（不阻塞浏览器渲染）
- `useLayoutEffect`：Commit 阶段同步执行（阻塞浏览器渲染）

---

### 五、Rules of Hooks 的原因

#### 1. 为什么不能在条件语句中使用 Hooks？

**错误示例**：

```javascript
function Component({ show }) {
  const [name, setName] = useState('Alice');

  if (show) {
    const [age, setAge] = useState(25); // ❌ 错误！
  }

  useEffect(() => { /* ... */ }, []);
}
```

**问题分析**：

```
首次渲染 (show = true):
  Hook 链表: name → age → effect

第二次渲染 (show = false):
  Hook 链表: name → effect (缺少 age)

第三次渲染 (show = true):
  Hook 链表: name → age → effect
  但 React 会认为第二个 Hook 对应 effect（链表顺序错乱！）
```

**React 的假设**：Hook 的调用顺序在每次渲染中保持一致，通过位置（链表顺序）匹配 Hook 状态。

---

#### 2. 为什么只能在顶层调用？

确保每次渲染时，Hook 的调用次数和顺序完全一致：

```javascript
// ✅ 正确
function Component() {
  const [a, setA] = useState(1);
  const [b, setB] = useState(2);
  return <div>{a + b}</div>;
}

// ❌ 错误（循环中调用）
function Component({ list }) {
  list.forEach(item => {
    const [state, setState] = useState(item); // Hook 次数不固定
  });
}
```

---

### 六、闭包陷阱

#### 问题示例

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count); // 永远打印 0！
      setCount(count + 1); // 永远是 0 + 1
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组

  return <div>{count}</div>;
}
```

**原因**：
- `useEffect` 的回调函数捕获了首次渲染时的 `count`（闭包）
- 由于依赖数组为空，effect 只执行一次，后续 `count` 更新不会重新创建 `setInterval`
- `setInterval` 的回调永远引用初始的 `count = 0`

**解决方案**：

```javascript
// 方案 1：添加依赖
useEffect(() => {
  const timer = setInterval(() => {
    setCount(count + 1); // 每次 count 变化都会重新创建定时器
  }, 1000);
  return () => clearInterval(timer);
}, [count]); // 依赖 count

// 方案 2：使用函数式更新
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prevCount => prevCount + 1); // 不依赖外部 count
  }, 1000);
  return () => clearInterval(timer);
}, []); // 空依赖数组

// 方案 3：使用 useRef
const countRef = useRef(count);
countRef.current = count; // 每次渲染更新

useEffect(() => {
  const timer = setInterval(() => {
    setCount(countRef.current + 1); // 通过 ref 获取最新值
  }, 1000);
  return () => clearInterval(timer);
}, []);
```

---

### 七、自定义 Hook 的原理

自定义 Hook 本质是 **封装 Hooks 逻辑的普通函数**：

```javascript
// 自定义 Hook：管理 localStorage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// 使用
function Component() {
  const [name, setName] = useLocalStorage('name', 'Alice');
  return <input value={name} onChange={(e) => setName(e.target.value)} />;
}
```

**工作原理**：
- 自定义 Hook 内部调用的 `useState`、`useEffect` 等，会被记录到调用它的组件的 Fiber 节点上
- 多个组件调用同一个自定义 Hook，状态是隔离的（每个组件有独立的 Fiber 和 Hook 链表）

---

### 八、总结

React Hooks 的底层实现依赖以下核心机制：

1. **Fiber 节点存储**：Hooks 链表挂载在 `Fiber.memoizedState` 上
2. **调用顺序保证**：通过链表位置匹配 Hook 状态（Rules of Hooks）
3. **更新队列**：`setState` 创建 Update 对象，加入环形链表
4. **依赖对比**：`useEffect` 通过浅比较依赖数组决定是否执行
5. **闭包机制**：Hooks 依赖闭包捕获状态，需注意闭包陷阱

**面试加分点**：
- 能解释为什么不能在条件语句中使用 Hooks
- 理解闭包陷阱的成因和解决方案
- 知道 `useEffect` 和 `useLayoutEffect` 的执行时机差异
- 了解 Hook 链表的数据结构和遍历方式
