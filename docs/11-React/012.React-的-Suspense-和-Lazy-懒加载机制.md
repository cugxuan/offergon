---
title: React 的 Suspense 和 Lazy 懒加载机制
tags:
  - 前端React
status: robot
class: 前端React
slug: react-suspense-lazy-loading
ref:
---

## 核心要点

- **React.lazy** 实现组件级别的代码分割，动态导入组件，减少初始包体积
- **Suspense** 提供声明式的加载状态处理，当子组件未就绪时显示 fallback UI
- 核心原理：通过 **throw Promise** 暂停渲染，Promise resolve 后重新渲染
- 支持场景：组件懒加载、数据获取（配合 React 18+）、服务端渲染（Next.js）
- 最佳实践：配合路由懒加载、预加载、错误边界使用

---

## 详细解答

### 一、React.lazy 的原理和使用

#### 1.1 什么是 React.lazy？

`React.lazy` 是 React 16.6 引入的函数，用于**动态导入组件**，实现代码分割（Code Splitting）。它返回一个懒加载的组件，只有在首次渲染时才会加载对应的代码。

```jsx
import React, { Suspense } from 'react';

// 传统导入：会被打包到主 bundle
// import HeavyComponent from './HeavyComponent';

// 懒加载：会被单独打包成一个 chunk
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

**打包效果对比**：
```bash
# 传统导入
main.js (500KB) - 包含所有组件代码

# 使用 lazy
main.js (100KB) - 主应用代码
1.chunk.js (400KB) - HeavyComponent 单独打包
```

#### 1.2 工作原理

**核心机制**：React.lazy 返回一个特殊组件，渲染时会动态导入模块。

```js
// React.lazy 简化实现
function lazy(loader) {
  let Component = null;
  let error = null;
  let promise = null;

  return function LazyComponent(props) {
    if (Component) {
      // 已加载，直接渲染
      return <Component {...props} />;
    }

    if (error) {
      // 加载失败，抛出错误
      throw error;
    }

    if (!promise) {
      // 首次渲染，执行动态导入
      promise = loader()
        .then(module => {
          Component = module.default || module;
        })
        .catch(err => {
          error = err;
        });
    }

    // 抛出 Promise，触发 Suspense
    throw promise;
  };
}
```

**加载流程**：
1. **首次渲染**：执行 `import()` 返回 Promise，抛出 Promise
2. **Suspense 捕获**：显示 fallback UI，等待 Promise resolve
3. **Promise 完成**：重新渲染 LazyComponent，返回实际组件
4. **后续渲染**：直接使用缓存的组件，不再加载

#### 1.3 使用场景

✅ **适合使用的场景**：
- 大型第三方库（图表库、富文本编辑器）
- 路由页面（不同页面代码分离）
- 低频功能（管理后台、设置页面）
- 条件渲染的重型组件（Modal、Drawer）

```jsx
// 场景 1：路由懒加载
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Home = React.lazy(() => import('./pages/Home'));
const Dashboard = React.lazy(() => import('./pages/Dashboard'));
const Settings = React.lazy(() => import('./pages/Settings'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// 场景 2：条件加载重型组件
function UserProfile() {
  const [showEditor, setShowEditor] = useState(false);

  const RichTextEditor = React.lazy(() => import('./RichTextEditor'));

  return (
    <div>
      <button onClick={() => setShowEditor(true)}>编辑个人简介</button>
      {showEditor && (
        <Suspense fallback={<Spinner />}>
          <RichTextEditor />
        </Suspense>
      )}
    </div>
  );
}
```

#### 1.4 注意事项

**限制 1：只能用于 default export**

```jsx
// ❌ 错误：不支持命名导出
const MyComponent = React.lazy(() => import('./MyComponent').then(m => m.MyComponent));

// ✅ 正确：必须是 default export
// MyComponent.js
export default function MyComponent() {}

// App.js
const MyComponent = React.lazy(() => import('./MyComponent'));

// 🔧 解决方案：创建中间模块
// LazyExports.js
export { MyComponent as default } from './MyComponent';

// App.js
const MyComponent = React.lazy(() => import('./LazyExports'));
```

**限制 2：必须配合 Suspense 使用**

```jsx
// ❌ 错误：缺少 Suspense
const LazyComponent = React.lazy(() => import('./Component'));
<LazyComponent /> // 会报错

// ✅ 正确
<Suspense fallback={<div>加载中...</div>}>
  <LazyComponent />
</Suspense>
```

---

### 二、Suspense 的原理和使用

#### 2.1 什么是 Suspense？

`Suspense` 是一个 React 组件，用于**声明式地处理异步渲染**。当子组件未就绪时（如正在加载），显示 fallback UI；就绪后渲染实际内容。

```jsx
import { Suspense } from 'react';

<Suspense fallback={<LoadingSpinner />}>
  {/* 这里的组件如果抛出 Promise，会触发 Suspense */}
  <AsyncComponent />
</Suspense>
```

#### 2.2 工作原理

**核心机制**：通过 **try-catch 捕获 Promise** 实现异步状态管理。

```js
// Suspense 简化实现
class Suspense extends React.Component {
  state = { pending: false };

  componentDidCatch(error) {
    // 捕获子组件抛出的 Promise
    if (error instanceof Promise) {
      this.setState({ pending: true });

      error.then(() => {
        // Promise resolve 后，重新渲染
        this.setState({ pending: false });
      });
    } else {
      throw error; // 其他错误继续抛出
    }
  }

  render() {
    if (this.state.pending) {
      return this.props.fallback; // 显示加载状态
    }
    return this.props.children; // 显示实际内容
  }
}
```

**渲染流程图**：
```
渲染子组件 → 抛出 Promise → Suspense 捕获 → 显示 fallback
                                   ↓
                         Promise resolve
                                   ↓
                         重新渲染子组件 → 渲染成功
```

#### 2.3 嵌套 Suspense

可以嵌套多个 Suspense 实现**细粒度的加载状态**：

```jsx
function App() {
  return (
    <Suspense fallback={<AppSkeleton />}>
      <Header />
      <Suspense fallback={<ContentSkeleton />}>
        <MainContent />
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>
      </Suspense>
    </Suspense>
  );
}
```

**渲染策略**：
- 每个 Suspense 独立管理其子树的加载状态
- 子组件加载完成后，父级 Suspense 不受影响
- 优先显示最近的父级 Suspense 的 fallback

#### 2.4 与 Error Boundary 结合

```jsx
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <ErrorBoundary fallback={<ErrorPage />}>
      <Suspense fallback={<LoadingPage />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}
```

**处理流程**：
- 加载中 → Suspense 显示 fallback
- 加载失败 → Error Boundary 捕获错误
- 加载成功 → 正常渲染组件

---

### 三、高级用法

#### 3.1 预加载（Preloading）

提前加载组件，减少用户等待时间：

```jsx
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

// 预加载函数
const preloadHeavyComponent = () => {
  import('./HeavyComponent'); // 返回 Promise
};

function App() {
  return (
    <div>
      {/* 鼠标悬停时预加载 */}
      <button
        onMouseEnter={preloadHeavyComponent}
        onClick={() => setShow(true)}
      >
        打开重型组件
      </button>

      {show && (
        <Suspense fallback={<Spinner />}>
          <HeavyComponent />
        </Suspense>
      )}
    </div>
  );
}
```

#### 3.2 自定义懒加载包装器

```jsx
// 带重试机制的懒加载
function lazyWithRetry(componentImport, retries = 3) {
  return React.lazy(async () => {
    for (let i = 0; i < retries; i++) {
      try {
        return await componentImport();
      } catch (error) {
        if (i === retries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      }
    }
  });
}

const MyComponent = lazyWithRetry(() => import('./MyComponent'));
```

#### 3.3 命名 chunk（Webpack）

```jsx
// 通过 magic comment 指定 chunk 名称
const Dashboard = React.lazy(() =>
  import(/* webpackChunkName: "dashboard" */ './Dashboard')
);

// 打包结果
// dashboard.chunk.js (而不是 1.chunk.js)
```

#### 3.4 Suspense 与数据获取（React 18+）

React 18 支持在数据获取时使用 Suspense（需要框架支持）：

```jsx
// 使用支持 Suspense 的数据库（如 Relay、Next.js）
import { fetchUser } from './api';

function UserProfile({ userId }) {
  const user = use(fetchUser(userId)); // use Hook（React 19）

  return <div>{user.name}</div>;
}

function App() {
  return (
    <Suspense fallback={<Skeleton />}>
      <UserProfile userId={123} />
    </Suspense>
  );
}
```

**自定义 Suspense 数据源**：
```js
// 创建支持 Suspense 的资源
function wrapPromise(promise) {
  let status = 'pending';
  let result;

  const suspender = promise.then(
    data => {
      status = 'success';
      result = data;
    },
    error => {
      status = 'error';
      result = error;
    }
  );

  return {
    read() {
      if (status === 'pending') throw suspender; // 触发 Suspense
      if (status === 'error') throw result; // 触发 Error Boundary
      return result;
    }
  };
}

// 使用
const resource = wrapPromise(fetch('/api/user').then(r => r.json()));

function User() {
  const user = resource.read(); // 首次调用会抛出 Promise
  return <div>{user.name}</div>;
}
```

---

### 四、底层原理深入

#### 4.1 Fiber 与 Suspense

Suspense 依赖 React Fiber 架构的可中断渲染特性：

```js
// Fiber 渲染流程
function performUnitOfWork(fiber) {
  try {
    // 执行组件渲染
    const children = fiber.type(fiber.props);
    reconcileChildren(fiber, children);
  } catch (error) {
    if (error instanceof Promise) {
      // 捕获 Promise，标记 Fiber 为挂起状态
      fiber.tag = SuspenseComponent;
      fiber.pendingProps = error;

      // 向上查找最近的 Suspense 边界
      let suspenseBoundary = fiber.return;
      while (suspenseBoundary && suspenseBoundary.tag !== SuspenseComponent) {
        suspenseBoundary = suspenseBoundary.return;
      }

      // 渲染 fallback
      if (suspenseBoundary) {
        suspenseBoundary.effectTag |= ShouldCapture;
      }

      // 注册 Promise 回调
      error.then(() => {
        // Promise resolve 后，重新调度渲染
        scheduleUpdateOnFiber(fiber);
      });
    } else {
      throw error; // 其他错误继续抛出
    }
  }
}
```

#### 4.2 动态 import 原理

```js
// Webpack 编译前
const Component = React.lazy(() => import('./Component'));

// Webpack 编译后
const Component = React.lazy(() => {
  return __webpack_require__.e(/* chunk id */ 123)
    .then(__webpack_require__.bind(null, /* module id */ './Component.js'));
});

// __webpack_require__.e 实现
__webpack_require__.e = function(chunkId) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = `/${chunkId}.chunk.js`;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
};
```

---

### 五、最佳实践

#### 5.1 路由懒加载模式

```jsx
// routes.js
export const routes = [
  {
    path: '/',
    component: React.lazy(() => import('./pages/Home'))
  },
  {
    path: '/dashboard',
    component: React.lazy(() => import('./pages/Dashboard'))
  }
];

// App.js
import { routes } from './routes';

function App() {
  return (
    <Suspense fallback={<PageLoader />}>
      <Routes>
        {routes.map(route => (
          <Route key={route.path} {...route} />
        ))}
      </Routes>
    </Suspense>
  );
}
```

#### 5.2 优雅的加载状态

```jsx
// 延迟显示加载状态，避免闪烁
function DelayedFallback({ delay = 300, children }) {
  const [show, setShow] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => setShow(true), delay);
    return () => clearTimeout(timer);
  }, [delay]);

  return show ? children : null;
}

<Suspense fallback={
  <DelayedFallback>
    <Spinner />
  </DelayedFallback>
}>
  <LazyComponent />
</Suspense>
```

#### 5.3 加载失败重试

```jsx
function LazyComponentWithRetry() {
  const [retryCount, setRetryCount] = useState(0);

  const Component = useMemo(
    () => React.lazy(() =>
      import('./Component').catch(() => {
        // 加载失败，等待重试
        return new Promise(() => {});
      })
    ),
    [retryCount]
  );

  return (
    <ErrorBoundary
      fallbackRender={({ error, resetErrorBoundary }) => (
        <div>
          <p>加载失败：{error.message}</p>
          <button onClick={() => {
            setRetryCount(c => c + 1);
            resetErrorBoundary();
          }}>
            重试
          </button>
        </div>
      )}
    >
      <Suspense fallback={<Spinner />}>
        <Component />
      </Suspense>
    </ErrorBoundary>
  );
}
```

#### 5.4 性能监控

```jsx
import { Suspense, Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  // 上报加载时间
  analytics.track('component_load', {
    componentId: id,
    loadTime: actualDuration
  });
}

<Profiler id="LazyComponent" onRender={onRenderCallback}>
  <Suspense fallback={<Spinner />}>
    <LazyComponent />
  </Suspense>
</Profiler>
```

---

### 六、常见问题

#### Q1：为什么 Suspense 不支持 SSR？

**答**：React 18 之前，Suspense 在服务端会直接渲染 fallback，因为服务端无法等待异步加载。React 18+ 引入了 `renderToPipeableStream` 支持流式 SSR 和 Suspense。

```jsx
// React 18+ 服务端
import { renderToPipeableStream } from 'react-dom/server';

const { pipe } = renderToPipeableStream(
  <Suspense fallback={<Spinner />}>
    <AsyncComponent />
  </Suspense>,
  {
    onShellReady() {
      // 发送 HTML shell
      pipe(response);
    }
  }
);
```

#### Q2：如何避免加载状态闪烁？

**答**：使用延迟显示或骨架屏：
```jsx
<Suspense fallback={
  <DelayedFallback delay={300}>
    <Skeleton />
  </DelayedFallback>
}>
  <LazyComponent />
</Suspense>
```

#### Q3：lazy 组件如何接收 props？

**答**：像普通组件一样传递：
```jsx
const LazyComponent = React.lazy(() => import('./Component'));

<Suspense fallback={<Spinner />}>
  <LazyComponent name="张三" age={25} />
</Suspense>
```

---

### 七、总结

1. **核心原理**：
   - React.lazy 通过动态 `import()` 实现代码分割
   - Suspense 通过捕获 Promise 实现声明式加载状态
   - 两者配合实现组件级别的按需加载

2. **性能优化**：
   - 减少初始 bundle 体积，加快首屏加载
   - 配合路由实现页面级代码分割
   - 使用预加载优化用户体验

3. **注意事项**：
   - 必须配合 Suspense 使用
   - 只支持 default export
   - 需要配合 Error Boundary 处理加载失败

**面试加分点**：
- 能解释 throw Promise 的工作机制
- 了解 Webpack 的 code splitting 原理
- 知道如何使用 React DevTools 查看 chunk 加载情况
- 能实现自定义的 Suspense 数据源（wrapPromise 模式）
