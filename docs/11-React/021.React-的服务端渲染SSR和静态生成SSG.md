---
title: React 的服务端渲染（SSR）和静态生成（SSG）
tags:
  - 前端React
status: robot
class: 前端React
slug: react-ssr-vs-ssg
ref:
---

## 核心要点

**SSR vs SSG 的本质区别**：SSR 在每次请求时动态生成 HTML，SSG 在构建时预生成 HTML；SSR 适合动态内容和个性化场景，SSG 适合内容相对静态的页面；两者都能提升首屏性能和 SEO，但性能和适用场景有显著差异。

---

## 详细回答

### 一、服务端渲染（SSR）

#### 1. 工作原理

SSR（Server-Side Rendering）是在服务器端将 React 组件渲染成 HTML 字符串，然后发送给客户端的技术方案。

**完整流程**：

```
1. 用户请求页面
   ↓
2. 服务器执行 React 组件渲染
   - 调用 renderToString() 或 renderToPipeableStream()
   - 获取数据（API 调用、数据库查询）
   - 生成完整的 HTML 字符串
   ↓
3. 服务器返回 HTML + 序列化数据
   ↓
4. 浏览器展示 HTML（用户可见内容）
   ↓
5. 加载 JavaScript Bundle
   ↓
6. Hydration（水合）
   - React 接管 DOM
   - 绑定事件处理器
   - 恢复交互能力
```

#### 2. 实现方式（Next.js 示例）

```tsx
// pages/posts/[id].tsx
import { GetServerSideProps } from 'next';

interface Post {
  id: string;
  title: string;
  content: string;
  author: string;
}

// 每次请求时都会执行
export const getServerSideProps: GetServerSideProps = async (context) => {
  const { id } = context.params!;

  // 服务器端数据获取
  const res = await fetch(`https://api.example.com/posts/${id}`);
  const post: Post = await res.json();

  // 可以访问请求头、Cookies 等
  const userAgent = context.req.headers['user-agent'];

  return {
    props: {
      post,
      userAgent,
      timestamp: new Date().toISOString(), // 每次请求都不同
    },
  };
};

export default function PostPage({ post, timestamp }: { post: Post; timestamp: string }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>作者：{post.author}</p>
      <div>{post.content}</div>
      <footer>渲染时间：{timestamp}</footer>
    </article>
  );
}
```

#### 3. SSR 的优势

**① SEO 友好**
- 搜索引擎爬虫直接获取完整的 HTML 内容
- 无需执行 JavaScript 即可抓取页面信息
- 元数据（title、meta）在源代码中可见

**② 首屏加载快**
- 用户立即看到渲染好的内容（FCP 更快）
- 无需等待 JavaScript 下载和执行
- 特别适合移动端和弱网环境

**③ 动态内容支持**
- 可根据用户身份展示个性化内容
- 实时数据展示（如股票价格、新闻）
- 支持 A/B 测试和地域化内容

#### 4. SSR 的挑战

**① 服务器负载高**
```tsx
// 每个请求都要执行完整的 React 渲染
export const getServerSideProps: GetServerSideProps = async () => {
  // 复杂的数据处理
  const data = await fetchComplexData();
  const processed = heavyComputation(data); // 服务器 CPU 占用

  return { props: { processed } };
};
```

**② TTFB（首字节时间）可能较慢**
- 服务器需要完成数据获取和渲染才能响应
- 如果 API 调用慢，整个页面响应都会慢

**③ Hydration 成本**
```tsx
// 客户端需要重新执行组件逻辑
useEffect(() => {
  // 这个 effect 在服务端不执行
  // 在客户端 Hydration 时才执行
  setupEventListeners();
}, []);
```

---

### 二、静态生成（SSG）

#### 1. 工作原理

SSG（Static Site Generation）在构建时预先生成所有页面的 HTML，部署后直接通过 CDN 提供静态文件。

**构建流程**：

```
1. 执行 npm run build
   ↓
2. Next.js 调用 getStaticProps
   - 获取所有需要的数据
   - 为每个页面生成 HTML
   ↓
3. 输出静态文件到 .next/server/pages
   ↓
4. 部署到 CDN（Vercel、Cloudflare 等）
   ↓
5. 用户请求 → CDN 直接返回 HTML（无服务器计算）
```

#### 2. 实现方式

**基础静态生成**：

```tsx
// pages/about.tsx
export async function getStaticProps() {
  // 构建时执行一次
  const stats = await fetchSiteStats();

  return {
    props: { stats },
    revalidate: 3600, // ISR: 每小时重新生成
  };
}

export default function About({ stats }) {
  return <div>访问量：{stats.pageViews}</div>;
}
```

**动态路由 + 静态生成**：

```tsx
// pages/blog/[slug].tsx
export async function getStaticPaths() {
  // 构建时告诉 Next.js 需要生成哪些页面
  const posts = await fetchAllPosts();

  return {
    paths: posts.map(post => ({
      params: { slug: post.slug },
    })),
    fallback: 'blocking', // 或 true / false
  };
}

export async function getStaticProps({ params }) {
  const post = await fetchPost(params.slug);

  return {
    props: { post },
    revalidate: 60, // 60秒后重新验证
  };
}

export default function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

#### 3. ISR（增量静态再生）

ISR 是 SSG 的增强版，允许在运行时更新静态页面：

```tsx
export async function getStaticProps() {
  const data = await fetchData();

  return {
    props: { data },
    revalidate: 10, // 10秒后，下一个请求触发重新生成
  };
}

// 工作机制：
// 1. 第一个用户看到旧缓存（10秒前生成的）
// 2. 触发后台重新生成
// 3. 后续用户看到新生成的页面
```

**按需重新验证**（Next.js 12.1+）：

```tsx
// pages/api/revalidate.ts
export default async function handler(req, res) {
  // 验证密钥（防止滥用）
  if (req.query.secret !== process.env.REVALIDATE_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  try {
    // 指定要重新生成的路径
    await res.revalidate('/blog/my-post');
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send('Error revalidating');
  }
}
```

#### 4. SSG 的优势

**① 性能极致**
- HTML 由 CDN 边缘节点提供（全球分发）
- TTFB 接近 0ms（无服务器计算）
- 并发处理能力强（静态文件）

**② 成本低**
- 无需维护运行时服务器
- CDN 成本远低于计算资源
- 自动扩展（CDN 天然高可用）

**③ 安全性高**
- 无运行时代码执行
- 减少攻击面

#### 5. SSG 的限制

**① 构建时间长**
```bash
# 大型网站可能有数千个页面
# 构建时间 = 页面数 × 平均数据获取时间
# 1000页 × 500ms = 8.3分钟
```

**② 数据实时性差**
- 内容更新需要重新构建或等待 revalidate
- 不适合高频变化的数据

---

### 三、SSR vs SSG 对比

| 维度 | SSR | SSG |
|------|-----|-----|
| **渲染时机** | 每次请求时 | 构建时 |
| **TTFB** | 较慢（100-500ms） | 极快（<50ms） |
| **服务器负载** | 高（每次请求都计算） | 低（只提供静态文件） |
| **数据新鲜度** | 实时 | 有延迟（取决于 revalidate） |
| **适用场景** | 用户仪表盘、搜索结果、个性化推荐 | 博客、文档、产品页、营销页面 |
| **成本** | 需要服务器持续运行 | CDN 成本（较低） |
| **扩展性** | 受服务器性能限制 | CDN 自动扩展 |

### 四、选择策略

#### 混合使用示例（Next.js）

```tsx
// pages/index.tsx - 首页用 SSG（高流量）
export async function getStaticProps() {
  return {
    props: { featured: await getFeaturedPosts() },
    revalidate: 60,
  };
}

// pages/dashboard.tsx - 用户仪表盘用 SSR（个性化）
export async function getServerSideProps(context) {
  const session = await getSession(context);
  return {
    props: { userData: await getUserData(session.userId) },
  };
}

// pages/blog/[slug].tsx - 博客文章用 SSG + ISR（内容型）
export async function getStaticProps({ params }) {
  return {
    props: { post: await getPost(params.slug) },
    revalidate: 3600, // 1小时
  };
}
```

#### 决策树

```
是否需要用户个性化内容？
├─ 是 → SSR
│   └─ 例：登录后的仪表盘、用户设置页
│
└─ 否 → 内容更新频率？
    ├─ 高频（秒级）→ SSR
    │   └─ 例：实时股票价格、体育比分
    │
    └─ 低频（分钟/小时级）→ SSG + ISR
        └─ 例：新闻文章、博客、产品目录
```

### 五、性能最佳实践

#### 1. SSR 优化

```tsx
// ① 流式 SSR（React 18）
import { renderToPipeableStream } from 'react-dom/server';

export default function handler(req, res) {
  const { pipe } = renderToPipeableStream(<App />, {
    onShellReady() {
      res.setHeader('Content-Type', 'text/html');
      pipe(res); // 立即发送 Shell（框架）
    },
    onAllReady() {
      // 所有 Suspense 边界解析完成
    },
  });
}

// ② 使用 Suspense 分块加载
<Suspense fallback={<Skeleton />}>
  <HeavyComponent /> {/* 不阻塞首屏 */}
</Suspense>
```

#### 2. SSG 优化

```tsx
// ① 按需静态生成（fallback: 'blocking'）
export async function getStaticPaths() {
  // 只预生成热门页面
  const topPosts = await getTopPosts(100);

  return {
    paths: topPosts.map(p => ({ params: { id: p.id } })),
    fallback: 'blocking', // 其他页面首次访问时生成
  };
}

// ② 使用 CDN 缓存策略
export async function getStaticProps() {
  return {
    props: { data },
    revalidate: 60,
    // 配合 Cache-Control 头使用
  };
}
```

### 六、实战案例

**电商网站架构**：

```
首页              → SSG（revalidate: 300）    - 5分钟更新促销信息
商品分类页        → SSG（fallback: true）     - 按需生成新分类
商品详情页        → SSG（revalidate: 3600）  - 1小时更新库存/价格
用户购物车        → CSR（客户端渲染）         - 纯动态内容
订单确认页        → SSR                       - 实时订单信息
搜索结果页        → SSR                       - 实时搜索
```

**新闻网站架构**：

```
首页              → SSG（revalidate: 60）     - 1分钟更新头条
文章详情页        → SSG（revalidate: 300）    - 5分钟更新阅读量
作者页面          → SSG（fallback: 'blocking'）
热搜榜            → SSR                       - 实时数据
评论区            → CSR                       - 客户端交互
```

---

## 总结

**SSR** 和 **SSG** 都是提升 React 应用性能和 SEO 的重要技术：

1. **SSR** 适合需要实时数据和个性化内容的场景，代价是服务器成本和 TTFB
2. **SSG** 适合内容相对静态的页面，能提供极致性能，但数据新鲜度有限
3. **ISR** 结合了两者优势，是现代 Web 应用的推荐方案
4. 实际项目中通常混合使用，根据每个页面的特点选择合适的渲染策略

理解这些技术的原理和权衡，能帮助我们设计出高性能、低成本、用户体验优秀的 Web 应用。
