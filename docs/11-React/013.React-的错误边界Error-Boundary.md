---
title: React 的错误边界（Error Boundary）
tags:
  - 前端React
status: robot
class: 前端React
slug: react-error-boundary
ref:
---

## 核心要点

- **错误边界**是 React 组件，用于捕获子组件树的 JavaScript 错误，防止整个应用崩溃
- 核心生命周期：`getDerivedStateFromError`（渲染降级 UI）和 `componentDidCatch`（记录错误信息）
- **无法捕获**：事件处理器错误、异步代码错误、SSR 错误、错误边界自身的错误
- 最佳实践：在关键节点设置边界、配合错误监控服务、提供友好的降级 UI
- React 18+ 建议：使用 `react-error-boundary` 库或自定义 Hook 包装

---

## 详细解答

### 一、什么是错误边界？

#### 1.1 核心概念

**错误边界（Error Boundary）** 是一种特殊的 React 组件，用于捕获其**子组件树**中 JavaScript 错误，并：
1. 记录错误信息
2. 显示降级 UI（fallback UI）
3. 防止整个应用崩溃

**React 16 之前的问题**：
```jsx
// React 15：组件内部错误会导致整个应用白屏
function App() {
  return (
    <div>
      <Header />
      <BuggyComponent /> {/* 这里报错会导致整个页面崩溃 */}
      <Footer />
    </div>
  );
}
```

**React 16+ 的解决方案**：
```jsx
<ErrorBoundary fallback={<ErrorPage />}>
  <App />
</ErrorBoundary>
```

#### 1.2 基本实现

错误边界必须是**类组件**，并实现以下两个生命周期方法之一：

```jsx
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  // 1. 静态方法：更新 state，触发降级 UI 渲染
  static getDerivedStateFromError(error) {
    // 返回新的 state
    return { hasError: true };
  }

  // 2. 实例方法：记录错误日志（可选）
  componentDidCatch(error, errorInfo) {
    // 错误上报到监控服务
    console.error('捕获到错误:', error, errorInfo);

    this.setState({
      error: error,
      errorInfo: errorInfo
    });

    // 上报到 Sentry、Bugsnag 等服务
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // 显示降级 UI
      return (
        <div>
          <h1>出错了</h1>
          <details>
            <summary>错误详情</summary>
            <p>{this.state.error?.toString()}</p>
            <pre>{this.state.errorInfo?.componentStack}</pre>
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            重试
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

**使用示例**：
```jsx
function App() {
  return (
    <ErrorBoundary>
      <Header />
      <ErrorBoundary>
        <MainContent />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}
```

---

### 二、工作原理

#### 2.1 两个关键生命周期

| 生命周期 | 调用时机 | 用途 | 特点 |
|---------|---------|------|------|
| `getDerivedStateFromError` | render 阶段 | 更新 state，触发降级 UI | 静态方法，不能执行副作用 |
| `componentDidCatch` | commit 阶段 | 记录错误日志 | 可执行副作用（如上报） |

**执行顺序**：
```
子组件抛出错误
    ↓
getDerivedStateFromError (更新 state)
    ↓
render (渲染降级 UI)
    ↓
componentDidCatch (记录错误)
```

#### 2.2 错误捕获机制

React 内部通过 **try-catch** 包裹组件的渲染、生命周期、事件处理：

```js
// React 内部简化逻辑
function renderComponent(component) {
  try {
    // 执行组件渲染
    return component.render();
  } catch (error) {
    // 查找最近的错误边界
    let errorBoundary = component.parent;
    while (errorBoundary && !errorBoundary.getDerivedStateFromError) {
      errorBoundary = errorBoundary.parent;
    }

    if (errorBoundary) {
      // 调用错误边界的生命周期
      errorBoundary.setState(
        errorBoundary.constructor.getDerivedStateFromError(error)
      );
      errorBoundary.componentDidCatch?.(error, errorInfo);
    } else {
      // 没有错误边界，应用崩溃
      unmountRootComponent();
    }
  }
}
```

#### 2.3 错误信息结构

**error 对象**（标准 JavaScript Error）：
```js
{
  name: 'TypeError',
  message: 'Cannot read property "x" of undefined',
  stack: '...' // 调用堆栈
}
```

**errorInfo 对象**（React 提供）：
```js
{
  componentStack: `
    at BuggyComponent (App.js:10)
    at div
    at App (App.js:5)
  ` // React 组件树堆栈
}
```

---

### 三、错误边界的限制

#### 3.1 无法捕获的错误类型

❌ **事件处理器内的错误**
```jsx
class MyComponent extends React.Component {
  handleClick = () => {
    throw new Error('事件错误'); // 不会被错误边界捕获
  };

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}

// ✅ 解决方案：手动 try-catch
handleClick = () => {
  try {
    // 可能出错的代码
  } catch (error) {
    this.setState({ error });
    logErrorToService(error);
  }
};
```

❌ **异步代码的错误（setTimeout、Promise）**
```jsx
useEffect(() => {
  setTimeout(() => {
    throw new Error('异步错误'); // 不会被捕获
  }, 1000);

  fetch('/api')
    .then(() => {
      throw new Error('Promise 错误'); // 不会被捕获
    });
}, []);

// ✅ 解决方案：使用 try-catch 或 .catch()
useEffect(() => {
  setTimeout(() => {
    try {
      // 可能出错的代码
    } catch (error) {
      reportError(error);
    }
  }, 1000);

  fetch('/api')
    .then(handleSuccess)
    .catch(error => reportError(error));
}, []);
```

❌ **服务端渲染（SSR）错误**
```jsx
// 错误边界仅在客户端生效
// 服务端错误需要在 Node.js 层捕获
```

❌ **错误边界自身的错误**
```jsx
class ErrorBoundary extends React.Component {
  render() {
    if (this.state.hasError) {
      throw new Error('错误边界自己出错了'); // 无法自己捕获
    }
    return this.props.children;
  }
}

// ✅ 解决方案：嵌套多层错误边界
<OuterErrorBoundary>
  <InnerErrorBoundary>
    <App />
  </InnerErrorBoundary>
</OuterErrorBoundary>
```

#### 3.2 为什么不捕获事件处理器错误？

React 团队的设计理念：
1. **事件处理器已经是异步的**，错误不会影响渲染流程
2. **用户可以使用原生 try-catch**，更灵活
3. **避免混淆**：事件错误不应该导致 UI 降级

---

### 四、高级用法

#### 4.1 细粒度错误边界

在不同层级设置边界，实现**局部降级**：

```jsx
function App() {
  return (
    <ErrorBoundary fallback={<FullPageError />}>
      <Header />

      <main>
        <ErrorBoundary fallback={<SidebarError />}>
          <Sidebar />
        </ErrorBoundary>

        <ErrorBoundary fallback={<ContentError />}>
          <MainContent />
        </ErrorBoundary>
      </main>

      <Footer />
    </ErrorBoundary>
  );
}
```

**降级策略**：
- **页面级边界**：捕获整个页面错误，显示全屏错误页
- **区块级边界**：捕获模块错误，仅该区域降级
- **组件级边界**：捕获单个组件错误，不影响其他组件

#### 4.2 重置错误状态

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  resetErrorBoundary = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>出错了</h1>
          <p>{this.state.error?.message}</p>
          {/* 重置按钮 */}
          <button onClick={this.resetErrorBoundary}>重试</button>
          {/* 或使用 props 传入的重置逻辑 */}
          {this.props.fallbackRender?.({
            error: this.state.error,
            resetErrorBoundary: this.resetErrorBoundary
          })}
        </div>
      );
    }

    return this.props.children;
  }
}

// 使用
<ErrorBoundary
  fallbackRender={({ error, resetErrorBoundary }) => (
    <div>
      <h1>错误: {error.message}</h1>
      <button onClick={resetErrorBoundary}>重试</button>
    </div>
  )}
>
  <App />
</ErrorBoundary>
```

#### 4.3 自动重置（依赖路由）

```jsx
import { useLocation } from 'react-router-dom';

function ErrorBoundaryWithRouter({ children }) {
  const location = useLocation();
  const [error, setError] = useState(null);

  // 路由变化时重置错误
  useEffect(() => {
    if (error) {
      setError(null);
    }
  }, [location.pathname]);

  return (
    <ErrorBoundaryClass
      error={error}
      onError={setError}
      onReset={() => setError(null)}
    >
      {children}
    </ErrorBoundaryClass>
  );
}
```

#### 4.4 错误日志上报

```jsx
componentDidCatch(error, errorInfo) {
  // 1. Sentry
  Sentry.captureException(error, {
    contexts: {
      react: {
        componentStack: errorInfo.componentStack
      }
    }
  });

  // 2. 自定义上报
  fetch('/api/log-error', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      errorInfo: errorInfo.componentStack,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    })
  });

  // 3. Google Analytics
  window.gtag?.('event', 'exception', {
    description: error.toString(),
    fatal: false
  });
}
```

---

### 五、使用 react-error-boundary 库

#### 5.1 安装和基本使用

```bash
npm install react-error-boundary
```

```jsx
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <h1>出错了</h1>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>重试</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onError={(error, errorInfo) => {
        console.log('错误:', error);
        console.log('组件栈:', errorInfo.componentStack);
      }}
      onReset={() => {
        // 重置应用状态
        window.location.reload();
      }}
    >
      <MyApp />
    </ErrorBoundary>
  );
}
```

#### 5.2 useErrorHandler Hook

捕获异步错误和事件处理器错误：

```jsx
import { useErrorHandler } from 'react-error-boundary';

function MyComponent() {
  const handleError = useErrorHandler();

  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .catch(error => {
        handleError(error); // 触发最近的错误边界
      });
  }, [handleError]);

  const handleClick = () => {
    try {
      // 可能出错的代码
    } catch (error) {
      handleError(error); // 手动触发错误边界
    }
  };

  return <button onClick={handleClick}>点击</button>;
}
```

#### 5.3 withErrorBoundary HOC

```jsx
import { withErrorBoundary } from 'react-error-boundary';

const MyComponent = () => {
  throw new Error('测试错误');
  return <div>内容</div>;
};

export default withErrorBoundary(MyComponent, {
  FallbackComponent: ErrorFallback,
  onError: (error, errorInfo) => {
    console.log(error, errorInfo);
  }
});
```

---

### 六、最佳实践

#### 6.1 错误边界放置策略

```jsx
// 1. 顶层边界：捕获所有未处理错误
<ErrorBoundary fallback={<FullPageError />}>
  <App />
</ErrorBoundary>

// 2. 路由边界：每个路由页面独立边界
<Routes>
  <Route path="/" element={
    <ErrorBoundary fallback={<HomeError />}>
      <Home />
    </ErrorBoundary>
  } />
  <Route path="/dashboard" element={
    <ErrorBoundary fallback={<DashboardError />}>
      <Dashboard />
    </ErrorBoundary>
  } />
</Routes>

// 3. 组件边界：关键业务组件
<ErrorBoundary fallback={<PaymentError />}>
  <PaymentForm />
</ErrorBoundary>
```

#### 6.2 友好的降级 UI

```jsx
function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div className="error-container">
      <img src="/error-illustration.svg" alt="错误" />
      <h1>抱歉，出现了一些问题</h1>

      {/* 开发环境显示详细错误 */}
      {process.env.NODE_ENV === 'development' && (
        <details>
          <summary>错误详情</summary>
          <pre>{error.message}</pre>
          <pre>{error.stack}</pre>
        </details>
      )}

      {/* 提供多种恢复方式 */}
      <div className="actions">
        <button onClick={resetErrorBoundary}>重试</button>
        <button onClick={() => window.location.href = '/'}>返回首页</button>
        <a href="/help">获取帮助</a>
      </div>
    </div>
  );
}
```

#### 6.3 开发环境 vs 生产环境

```jsx
const ErrorFallback = ({ error, resetErrorBoundary }) => {
  const isDev = process.env.NODE_ENV === 'development';

  return (
    <div>
      <h1>{isDev ? '开发环境错误' : '出错了'}</h1>

      {isDev ? (
        // 开发环境：显示详细堆栈
        <pre>{error.stack}</pre>
      ) : (
        // 生产环境：显示友好提示
        <p>我们已经记录了这个问题，将尽快修复</p>
      )}

      <button onClick={resetErrorBoundary}>重试</button>
    </div>
  );
};
```

#### 6.4 与 Suspense 配合

```jsx
<ErrorBoundary fallback={<ErrorPage />}>
  <Suspense fallback={<LoadingPage />}>
    <LazyComponent />
  </Suspense>
</ErrorBoundary>
```

**处理优先级**：
- 加载中 → Suspense 显示 loading
- 加载失败 → ErrorBoundary 捕获错误
- 渲染错误 → ErrorBoundary 捕获错误

---

### 七、常见问题

#### Q1：为什么错误边界必须是类组件?

**答**：因为需要使用 `getDerivedStateFromError` 和 `componentDidCatch` 生命周期，这两个方法在 Hooks 中没有对应实现。

**解决方案**：
- 使用 `react-error-boundary` 库（内部是类组件，对外提供 Hook）
- 自己封装一个类组件错误边界

```jsx
// 封装成可复用的组件
class ErrorBoundaryClass extends React.Component {
  // ... 实现
}

// 导出 Hook 包装器
export function useErrorBoundary() {
  const [error, setError] = useState(null);

  return {
    ErrorBoundary: ({ children }) => (
      <ErrorBoundaryClass onError={setError}>
        {children}
      </ErrorBoundaryClass>
    ),
    error,
    resetError: () => setError(null)
  };
}
```

#### Q2：如何测试错误边界?

```jsx
import { render, screen } from '@testing-library/react';

// 抑制 console.error（避免测试输出干扰）
beforeAll(() => {
  jest.spyOn(console, 'error').mockImplementation(() => {});
});

afterAll(() => {
  console.error.mockRestore();
});

test('显示错误边界 fallback', () => {
  const BuggyComponent = () => {
    throw new Error('测试错误');
  };

  render(
    <ErrorBoundary fallback={<div>出错了</div>}>
      <BuggyComponent />
    </ErrorBoundary>
  );

  expect(screen.getByText('出错了')).toBeInTheDocument();
});
```

#### Q3：错误边界影响性能吗?

**答**：影响极小。只有在错误发生时才会执行额外逻辑，正常渲染几乎无性能开销。

---

### 八、总结

1. **核心原理**：
   - 通过 `getDerivedStateFromError` 更新 state 触发降级 UI
   - 通过 `componentDidCatch` 记录错误日志
   - 只能捕获子组件树的渲染错误

2. **使用建议**：
   - 在关键节点设置边界（页面级、模块级）
   - 配合错误监控服务（Sentry）
   - 提供友好的降级 UI 和重试机制

3. **注意事项**：
   - 无法捕获事件处理器、异步代码、SSR 错误
   - 必须使用类组件或 `react-error-boundary` 库
   - 开发环境和生产环境应有不同的错误展示策略

**面试加分点**：
- 能说出两个生命周期的区别（render 阶段 vs commit 阶段）
- 了解错误边界的限制和解决方案
- 知道如何配合错误监控服务使用
- 能实现自定义的错误边界组件
