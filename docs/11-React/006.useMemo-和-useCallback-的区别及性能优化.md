---
title: useMemo 和 useCallback 的区别及性能优化
tags:
  - React
status: robot
class: 前端React
slug: usememo-vs-usecallback-performance-optimization
ref:
---

## 核心要点

**useMemo 缓存计算结果值，useCallback 缓存函数引用**。两者都通过依赖数组控制缓存更新，用于避免不必要的重复计算和重渲染。关键区别：`useMemo(() => fn)` 返回 fn 的执行结果，`useCallback(fn)` 返回 fn 本身。滥用反而降低性能，需根据实际场景判断。

---

## 详细解答

### 一、基本概念与区别

#### 1. useMemo 的作用
```javascript
const memoizedValue = useMemo(() => {
  // 执行昂贵的计算
  return computeExpensiveValue(a, b);
}, [a, b]);
```

**useMemo 返回的是计算后的值**。只有当依赖项 `[a, b]` 发生变化时，才会重新执行计算函数，否则直接返回缓存的结果。

#### 2. useCallback 的作用
```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

**useCallback 返回的是函数本身**。只有当依赖项 `[a, b]` 发生变化时，才会返回新的函数引用，否则返回缓存的函数引用。

#### 3. 等价关系
```javascript
// 以下两种写法等价
useCallback(fn, deps)
useMemo(() => fn, deps)
```

### 二、典型使用场景

#### 1. useMemo 的适用场景

**场景 1：昂贵的计算操作**
```javascript
function ProductList({ products, filter }) {
  // 过滤和排序是相对耗时的操作
  const filteredProducts = useMemo(() => {
    console.log('执行过滤和排序');
    return products
      .filter(p => p.category === filter)
      .sort((a, b) => b.price - a.price);
  }, [products, filter]);

  return (
    <div>
      {filteredProducts.map(p => <ProductItem key={p.id} product={p} />)}
    </div>
  );
}
```

**场景 2：避免子组件不必要的重渲染**
```javascript
function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // 如果不用 useMemo，每次 Parent 重渲染时 config 都是新对象
  // 会导致 Child 组件重渲染（即使 count 没变）
  const config = useMemo(() => ({
    color: count > 5 ? 'red' : 'blue',
    size: count * 10
  }), [count]);

  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <Child config={config} />
    </>
  );
}

const Child = React.memo(({ config }) => {
  console.log('Child 渲染');
  return <div style={{ color: config.color }}>Size: {config.size}</div>;
});
```

#### 2. useCallback 的适用场景

**场景 1：传递给子组件的回调函数**
```javascript
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');

  // 如果不用 useCallback，每次父组件渲染时 handleToggle 都是新函数
  // 会导致所有 TodoItem 子组件重渲染
  const handleToggle = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  }, []); // 无依赖，函数引用永不变化

  const handleDelete = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []);

  const filteredTodos = useMemo(() => {
    if (filter === 'all') return todos;
    return todos.filter(t => filter === 'done' ? t.done : !t.done);
  }, [todos, filter]);

  return (
    <div>
      <FilterButtons filter={filter} setFilter={setFilter} />
      {filteredTodos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}

const TodoItem = React.memo(({ todo, onToggle, onDelete }) => {
  console.log('TodoItem 渲染:', todo.id);
  return (
    <div>
      <input
        type="checkbox"
        checked={todo.done}
        onChange={() => onToggle(todo.id)}
      />
      <span>{todo.text}</span>
      <button onClick={() => onDelete(todo.id)}>删除</button>
    </div>
  );
});
```

**场景 2：作为 useEffect 的依赖项**
```javascript
function SearchComponent({ apiEndpoint }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  // 将 fetchData 作为 useEffect 的依赖
  const fetchData = useCallback(async () => {
    if (!query) return;
    const res = await fetch(`${apiEndpoint}?q=${query}`);
    const data = await res.json();
    setResults(data);
  }, [query, apiEndpoint]); // query 或 apiEndpoint 变化时才创建新函数

  useEffect(() => {
    fetchData();
  }, [fetchData]); // 安全的依赖项

  return (
    <div>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <ResultList results={results} />
    </div>
  );
}
```

### 三、性能优化的正确认知

#### 1. 不要过度优化
```javascript
// ❌ 滥用 useMemo（计算成本低于缓存成本）
const sum = useMemo(() => a + b, [a, b]);

// ✅ 简单计算直接执行
const sum = a + b;

// ❌ 不必要的 useCallback（子组件未使用 React.memo）
const handleClick = useCallback(() => setCount(c => c + 1), []);

// ✅ 如果子组件未优化，直接使用内联函数
<button onClick={() => setCount(c => c + 1)}>Click</button>
```

#### 2. 需要优化的场景判断
使用以下条件来判断是否需要 useMemo/useCallback：

**需要使用的情况：**
- 计算成本高（如大数据过滤、排序、复杂计算）
- 对象/数组/函数作为 props 传递给 `React.memo` 包裹的子组件
- 值作为其他 Hook（如 useEffect）的依赖项
- 渲染频繁的列表项

**不需要使用的情况：**
- 简单的计算（如加减乘除、字符串拼接）
- 组件渲染本身就很快
- 子组件没有做 memo 优化
- 依赖项频繁变化（缓存失效频繁）

#### 3. 实际性能测试示例
```javascript
function PerformanceTest() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // 测试：这个计算是否需要 useMemo？
  const expensiveValue = useMemo(() => {
    console.time('计算耗时');
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
      result += i;
    }
    console.timeEnd('计算耗时');
    return result;
  }, [count]);

  // 对比：不使用 useMemo
  // const expensiveValue = (() => {
  //   console.time('计算耗时');
  //   let result = 0;
  //   for (let i = 0; i < 1000000; i++) {
  //     result += i;
  //   }
  //   console.timeEnd('计算耗时');
  //   return result;
  // })();

  return (
    <div>
      {/* 当输入框变化时，观察计算是否重新执行 */}
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <div>Result: {expensiveValue}</div>
    </div>
  );
}
```

### 四、常见陷阱与最佳实践

#### 1. 依赖项数组的正确使用
```javascript
// ❌ 错误：遗漏依赖项
const fetchUser = useCallback(async () => {
  const user = await api.getUser(userId); // userId 未在依赖项中
  setUser(user);
}, []); // ESLint 会警告

// ✅ 正确：包含所有依赖
const fetchUser = useCallback(async () => {
  const user = await api.getUser(userId);
  setUser(user);
}, [userId]);
```

#### 2. 结合 React.memo 使用
```javascript
// 父组件
function Parent() {
  const [count, setCount] = useState(0);

  // 必须配合 useCallback，否则 Child 的 memo 优化失效
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}

// 子组件使用 React.memo 包裹
const Child = React.memo(({ onClick }) => {
  console.log('Child 渲染');
  return <button onClick={onClick}>点击</button>;
});
```

#### 3. 自定义 Hook 中的应用
```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

function useThrottle(callback, delay) {
  const callbackRef = useRef(callback);
  const lastRan = useRef(Date.now());

  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  return useCallback((...args) => {
    if (Date.now() - lastRan.current >= delay) {
      callbackRef.current(...args);
      lastRan.current = Date.now();
    }
  }, [delay]);
}
```

### 五、面试回答要点总结

1. **核心区别**：useMemo 缓存值，useCallback 缓存函数引用
2. **使用场景**：昂贵计算、避免子组件重渲染、作为其他 Hook 依赖项
3. **优化原则**：不要过度优化，简单场景直接计算，配合 React.memo 使用
4. **常见陷阱**：依赖项遗漏、滥用导致性能下降、未配合 memo 使用
5. **实践建议**：先写正常代码，发现性能问题后再优化，使用 React DevTools Profiler 测量
