---
title: React Fiber 架构的工作原理和调度机制
tags:
  - React
status: robot
class: 前端React
slug: react-fiber-architecture-scheduling-mechanism
ref:
---

## 核心要点

- **Fiber 是什么**：一种数据结构，代表工作单元，支持可中断的渲染
- **解决的核心问题**：旧架构 Stack Reconciler 同步阻塞主线程导致卡顿
- **双缓冲技术**：current 树和 workInProgress 树交替工作，实现无感切换
- **时间切片（Time Slicing）**：将长任务拆分为多个小任务，浏览器可在空闲时执行
- **优先级调度**：用户交互 > 动画 > 数据加载，高优先级任务可打断低优先级

---

## 详细回答

### 一、为什么需要 Fiber 架构？

#### React 16 之前的痛点（Stack Reconciler）

在 React 15 及之前的版本，React 使用 **递归的方式** 进行虚拟 DOM 的 Diff 和更新：

```javascript
function reconcile(vnode) {
  // 递归处理子节点
  vnode.children.forEach(child => {
    reconcile(child); // 无法中断！
  });
  // 更新 DOM
  updateDOM(vnode);
}
```

**问题**：
1. **同步递归无法中断**：一旦开始 Diff，必须一次性完成整棵树的对比
2. **主线程被长时间占用**：如果组件树很深（几千个节点），可能阻塞主线程几十甚至上百毫秒
3. **用户体验差**：导致动画卡顿、输入延迟、滚动不流畅（浏览器 16.6ms 内无法完成一帧渲染）

**Fiber 架构的目标**：
- 将渲染工作拆分成多个小任务
- 每个小任务执行完后，浏览器可以暂停去处理更重要的事情（如用户输入、动画）
- 实现 **可中断、可恢复** 的渲染机制

---

### 二、Fiber 的核心概念

#### 1. Fiber 是一种数据结构

每个 Fiber 节点对应一个 React 元素（组件或 DOM 节点），包含以下关键信息：

```javascript
type Fiber = {
  // === 节点身份信息 ===
  type: any,              // 对应的组件类型（函数组件、类组件、DOM 标签等）
  key: string | null,     // React key

  // === 关系指针（链表结构）===
  return: Fiber | null,   // 父节点
  child: Fiber | null,    // 第一个子节点
  sibling: Fiber | null,  // 右边的兄弟节点

  // === 工作相关 ===
  alternate: Fiber | null,      // 双缓冲：指向另一棵树的对应节点
  effectTag: number,            // 副作用标记（插入、更新、删除）
  updateQueue: UpdateQueue,     // 待处理的更新队列

  // === 调度相关 ===
  lanes: Lanes,                 // 优先级信息（React 18）
  childLanes: Lanes,            // 子树的优先级

  // === 状态 ===
  memoizedState: any,           // 组件的 state 或 Hook 链表
  memoizedProps: any,           // 上次渲染的 props
  pendingProps: any,            // 本次渲染的 props

  // === 其他 ===
  stateNode: any,               // 对应的真实 DOM 节点或组件实例
};
```

**关键特性**：
- **链表结构**：通过 `child`、`sibling`、`return` 指针构建树形结构
- **可中断**：遍历链表时可以随时暂停，下次从当前节点继续
- **双缓冲**：`alternate` 指针连接两棵树，实现快速切换

---

#### 2. Fiber 树的结构

Fiber 使用 **单链表 + 指针** 代替递归，可以暂停和恢复遍历：

```
        App (return: null)
         |
         | (child)
         v
       Div (return: App)
         | (child)         (sibling)
         v                    →
       Span              →  Button
    (return: Div)       (return: Div)
```

**遍历方式**：
```javascript
function workLoop(fiber) {
  let currentFiber = fiber;

  while (currentFiber) {
    // 1. 处理当前节点
    performUnitOfWork(currentFiber);

    // 2. 深度优先遍历
    if (currentFiber.child) {
      currentFiber = currentFiber.child; // 优先处理子节点
    } else if (currentFiber.sibling) {
      currentFiber = currentFiber.sibling; // 处理兄弟节点
    } else {
      // 回溯到父节点的兄弟节点
      currentFiber = currentFiber.return;
      while (currentFiber && !currentFiber.sibling) {
        currentFiber = currentFiber.return;
      }
      if (currentFiber) {
        currentFiber = currentFiber.sibling;
      }
    }

    // 3. 检查是否需要暂停（时间切片）
    if (shouldYield()) {
      break; // 归还主线程控制权
    }
  }
}
```

---

### 三、Fiber 的工作机制

#### 1. 双缓冲技术（Double Buffering）

React 维护 **两棵 Fiber 树**：

- **current 树**：当前屏幕上显示的 UI 对应的 Fiber 树
- **workInProgress 树**：正在内存中构建的新 Fiber 树

**工作流程**：

```
初始状态:
  current 树 (屏幕显示)
       |
       | alternate
       v
  workInProgress 树 (构建中)

更新完成后:
  workInProgress 树 → 替换 → current 树（指针切换，瞬间完成）
```

**代码示例**：

```javascript
// 创建 workInProgress 树
function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;

  if (workInProgress === null) {
    // 首次渲染：创建新节点
    workInProgress = createFiber(current.type, pendingProps);
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // 更新：复用已有节点
    workInProgress.pendingProps = pendingProps;
  }

  return workInProgress;
}

// 完成渲染后切换
function commitRoot(finishedWork) {
  // 将 workInProgress 树设置为 current 树
  root.current = finishedWork;
}
```

**优势**：
- 新树构建过程中，用户仍看到旧树（不会出现半成品 UI）
- 切换只需要改变指针，O(1) 复杂度
- 复用节点，减少内存分配

---

#### 2. 时间切片（Time Slicing）

**核心思想**：将一个长任务拆分为多个小任务，每个小任务执行 5ms 后暂停，让浏览器有机会响应用户操作。

**实现原理**（基于 `MessageChannel` 或 `requestIdleCallback`）：

```javascript
// 调度器的简化实现
let workInProgress = null;
let deadline = 0;

function scheduleCallback(callback) {
  const channel = new MessageChannel();
  const port = channel.port2;

  channel.port1.onmessage = () => {
    const timeRemaining = () => deadline - performance.now();

    // 执行工作单元
    while (workInProgress && timeRemaining() > 0) {
      workInProgress = performUnitOfWork(workInProgress);
    }

    // 如果还有剩余工作，继续调度
    if (workInProgress) {
      port.postMessage(null);
    }
  };

  // 初始调度
  deadline = performance.now() + 5; // 5ms 时间片
  port.postMessage(null);
}

// 判断是否需要暂停
function shouldYield() {
  return performance.now() >= deadline;
}
```

**执行过程**：

```
主线程时间轴:
|--- Fiber 工作 (5ms) ---|--- 浏览器渲染 ---|--- Fiber 工作 (5ms) ---|...
                         (用户输入、动画等)
```

---

#### 3. 优先级调度（Lane 模型）

React 18 引入 **Lane**（车道）模型，为不同类型的更新分配优先级：

```javascript
// Lane 优先级（数字越小优先级越高）
const SyncLane = 0b0001;                // 同步更新（如 onClick）
const InputContinuousLane = 0b0010;     // 连续输入（如 onScroll）
const DefaultLane = 0b0100;             // 默认更新（如 setState）
const TransitionLane = 0b1000;          // 过渡更新（如数据加载）
const IdleLane = 0b10000;               // 空闲更新（如日志记录）
```

**调度策略**：

```javascript
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root); // 获取最高优先级的 Lane
  const newCallbackPriority = getHighestPriorityLane(nextLanes);

  // 如果有更高优先级的任务，取消当前任务
  if (existingCallbackPriority !== newCallbackPriority) {
    cancelCallback(existingCallback);
    scheduleCallback(newCallbackPriority, performConcurrentWorkOnRoot);
  }
}
```

**实际案例**：

```javascript
// 高优先级：用户点击
<button onClick={() => setCount(count + 1)}>+1</button>

// 低优先级：过渡更新
startTransition(() => {
  setSearchResults(fetchData()); // 可以被高优先级任务打断
});
```

**效果**：
- 用户点击按钮时，即使有低优先级的数据加载任务，React 也会优先响应点击
- 低优先级任务会被暂停，等高优先级任务完成后再继续

---

### 四、Fiber 的两个工作阶段

#### 1. Render 阶段（可中断）

**任务**：构建 workInProgress 树，标记副作用（增删改）

**主要工作**：
- 调用组件的 `render` 方法
- 执行 Hooks（`useState`、`useEffect` 等）
- 进行 Diff 算法
- 标记 `effectTag`（Placement、Update、Deletion）

**关键特性**：
- 可以被高优先级任务打断
- 不会产生副作用（不修改真实 DOM）
- 可以多次执行同一个节点（被打断后重新开始）

```javascript
function performUnitOfWork(fiber) {
  // 1. 执行组件，得到新的子节点
  const next = beginWork(fiber);

  // 2. 更新 props
  fiber.memoizedProps = fiber.pendingProps;

  // 3. 返回下一个工作单元
  if (next) {
    return next; // 有子节点，继续处理
  } else {
    completeUnitOfWork(fiber); // 完成当前节点
  }
}
```

---

#### 2. Commit 阶段（不可中断）

**任务**：将 workInProgress 树的变更应用到真实 DOM

**主要工作**：
- 执行 DOM 操作（增删改）
- 调用生命周期方法（`componentDidMount`、`useLayoutEffect`）
- 切换 `current` 指针
- 调用 `useEffect`（异步执行）

**关键特性**：
- 同步执行，不可中断（保证 UI 一致性）
- 执行速度快（只操作有变更的节点）
- 分为三个子阶段：
  1. **Before Mutation**：执行 `getSnapshotBeforeUpdate`
  2. **Mutation**：执行 DOM 操作
  3. **Layout**：执行 `componentDidMount`、`useLayoutEffect`

```javascript
function commitRoot(root) {
  const finishedWork = root.finishedWork;

  // 阶段 1：Before Mutation
  commitBeforeMutationEffects(finishedWork);

  // 阶段 2：Mutation（真实 DOM 操作）
  commitMutationEffects(finishedWork);

  // 切换 current 树
  root.current = finishedWork;

  // 阶段 3：Layout
  commitLayoutEffects(finishedWork);
}
```

---

### 五、Fiber 调度的完整流程

```
用户触发更新（setState、事件等）
        ↓
   创建 Update 对象
        ↓
   加入 updateQueue
        ↓
   标记 Lane 优先级
        ↓
   调度 Render 阶段 ← ─ ─ ─ ─ ─ ┐
        ↓                      │ 可中断
   遍历 Fiber 树              │ 高优先级任务
        ↓                      │ 可以插队
   构建 workInProgress 树  ─ ─ ┘
        ↓
   收集副作用（effectList）
        ↓
   进入 Commit 阶段（不可中断）
        ↓
   应用 DOM 变更
        ↓
   切换 current 树
        ↓
   调用副作用（useEffect）
        ↓
   渲染完成
```

---

### 六、实际应用与优化

#### 1. 利用 Transition 降低优先级

```javascript
import { startTransition } from 'react';

function SearchComponent() {
  const [input, setInput] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    // 高优先级：立即更新输入框
    setInput(e.target.value);

    // 低优先级：搜索结果可以延迟
    startTransition(() => {
      setResults(search(e.target.value));
    });
  };

  return (
    <div>
      <input value={input} onChange={handleChange} />
      <Results data={results} />
    </div>
  );
}
```

---

#### 2. 使用 useDeferredValue 延迟更新

```javascript
import { useDeferredValue } from 'react';

function List({ items }) {
  const deferredItems = useDeferredValue(items); // 延迟更新列表

  return (
    <ul>
      {deferredItems.map(item => <li key={item.id}>{item.text}</li>)}
    </ul>
  );
}
```

---

### 七、总结

React Fiber 架构通过以下设计实现了流畅的用户体验：

1. **数据结构**：用链表结构的 Fiber 节点代替递归调用栈
2. **双缓冲**：current 和 workInProgress 两棵树交替工作
3. **时间切片**：将长任务拆分为 5ms 的小任务，避免阻塞主线程
4. **优先级调度**：使用 Lane 模型区分任务优先级，高优先级任务可打断低优先级
5. **两阶段提交**：Render 阶段可中断，Commit 阶段同步执行保证一致性

**面试加分点**：
- 能解释 Fiber 如何解决 React 15 的性能问题
- 理解时间切片的实现原理（MessageChannel/Scheduler）
- 知道 React 18 的并发特性（Transition、Suspense）依赖 Fiber
- 了解 Lane 优先级模型的工作机制
