---
title: React Testing Library 的测试最佳实践
tags:
  - 前端React
status: robot
class: 前端React
slug: react-testing-library-best-practices
ref:
---

## 核心要点

**测试哲学**：React Testing Library 遵循"测试应该尽可能接近用户使用软件的方式"原则，强调通过用户交互角度编写测试，避免测试实现细节。核心是查询 DOM 元素的优先级（byRole > byLabelText > byText > byTestId）、模拟用户行为（userEvent）、异步测试（waitFor、findBy）和可访问性优先。

---

## 详细回答

### 一、核心理念

#### 1. 与 Enzyme 的对比

**Enzyme（旧思路）**：
```tsx
// ❌ 测试实现细节
const wrapper = shallow(<Counter />);
expect(wrapper.state('count')).toBe(0); // 测试内部状态
wrapper.instance().increment(); // 直接调用方法
```

**React Testing Library（推荐）**：
```tsx
// ✅ 测试用户行为
render(<Counter />);
expect(screen.getByText('Count: 0')).toBeInTheDocument();
userEvent.click(screen.getByRole('button', { name: /increment/i }));
expect(screen.getByText('Count: 1')).toBeInTheDocument();
```

#### 2. 核心原则

1. **测试行为，不测试实现** - 组件重构不应破坏测试
2. **按用户视角查询元素** - 使用可访问性查询（Role、Label）
3. **避免测试内部状态** - 测试输出（DOM）而非状态
4. **异步操作要等待** - 使用 `waitFor`、`findBy*` 等待 DOM 更新

---

### 二、查询元素的优先级

#### 1. 查询优先级（从高到低）

**优先级 1：对所有人可访问的查询**

```tsx
// ① getByRole - 最推荐
// 查询按钮
screen.getByRole('button', { name: /submit/i });

// 查询标题
screen.getByRole('heading', { name: /welcome/i, level: 1 });

// 查询文本框
screen.getByRole('textbox', { name: /email/i });

// 查询复选框
screen.getByRole('checkbox', { name: /agree to terms/i });
```

**完整 Role 列表示例**：
```tsx
// 常见的 ARIA Role
button      → <button> 或 <div role="button">
textbox     → <input type="text">
checkbox    → <input type="checkbox">
radio       → <input type="radio">
link        → <a href="...">
heading     → <h1> - <h6>
img         → <img alt="...">
list        → <ul>, <ol>
listitem    → <li>
navigation  → <nav>
article     → <article>
```

```tsx
// ② getByLabelText - 表单元素
<label htmlFor="email">Email Address</label>
<input id="email" type="email" />

screen.getByLabelText(/email address/i);

// 或使用 aria-label
<input type="text" aria-label="Search" />
screen.getByLabelText(/search/i);
```

```tsx
// ③ getByPlaceholderText - 占位符（不推荐作为主查询方式）
<input placeholder="Enter your email" />
screen.getByPlaceholderText(/enter your email/i);
```

```tsx
// ④ getByText - 文本内容
screen.getByText(/welcome back/i);

// 精确匹配
screen.getByText('Welcome Back', { exact: true });

// 部分匹配
screen.getByText(/back/i);
```

**优先级 2：语义化查询**

```tsx
// ⑤ getByAltText - 图片的 alt 属性
<img src="logo.png" alt="Company Logo" />
screen.getByAltText(/company logo/i);
```

```tsx
// ⑥ getByTitle - title 属性
<span title="Close">×</span>
screen.getByTitle(/close/i);
```

**优先级 3：最后的手段**

```tsx
// ⑦ getByTestId - 仅当其他方式不可用时使用
<div data-testid="custom-element">Content</div>
screen.getByTestId('custom-element');
```

#### 2. 查询变体

| 前缀 | 返回值 | 找不到时行为 | 使用场景 |
|------|--------|-------------|----------|
| `getBy*` | 元素 | 抛出错误 | 断言元素存在 |
| `queryBy*` | 元素或 `null` | 返回 `null` | 断言元素不存在 |
| `findBy*` | Promise<元素> | 抛出错误（异步） | 异步元素出现 |
| `getAllBy*` | 数组 | 抛出错误 | 多个元素 |
| `queryAllBy*` | 数组（可能为空） | 返回 `[]` | 多个元素（可选） |
| `findAllBy*` | Promise<数组> | 抛出错误（异步） | 异步多个元素 |

**实战示例**：

```tsx
// ✅ 断言元素存在
expect(screen.getByRole('button')).toBeInTheDocument();

// ✅ 断言元素不存在
expect(screen.queryByRole('dialog')).not.toBeInTheDocument();

// ✅ 等待异步元素出现
const element = await screen.findByText(/loaded/i);

// ✅ 获取多个元素
const items = screen.getAllByRole('listitem');
expect(items).toHaveLength(3);
```

---

### 三、用户交互测试

#### 1. userEvent vs fireEvent

**fireEvent（较低级）**：
```tsx
import { fireEvent } from '@testing-library/react';

// 直接触发事件，没有浏览器的默认行为
fireEvent.click(button);
fireEvent.change(input, { target: { value: 'test' } });
```

**userEvent（推荐）**：
```tsx
import userEvent from '@testing-library/user-event';

// 模拟真实用户操作（包含 focus、blur、键盘事件等）
const user = userEvent.setup();

await user.click(button);
await user.type(input, 'test');
await user.clear(input);
await user.selectOptions(select, 'option1');
```

#### 2. 常见交互示例

**点击操作**：

```tsx
test('点击按钮显示消息', async () => {
  const user = userEvent.setup();
  render(<AlertButton />);

  const button = screen.getByRole('button', { name: /show alert/i });
  await user.click(button);

  expect(screen.getByText(/alert message/i)).toBeInTheDocument();
});
```

**输入文本**：

```tsx
test('输入表单数据', async () => {
  const user = userEvent.setup();
  render(<LoginForm />);

  const emailInput = screen.getByRole('textbox', { name: /email/i });
  const passwordInput = screen.getByLabelText(/password/i);

  await user.type(emailInput, 'test@example.com');
  await user.type(passwordInput, 'password123');

  expect(emailInput).toHaveValue('test@example.com');
  expect(passwordInput).toHaveValue('password123');
});
```

**复选框和单选框**：

```tsx
test('勾选复选框', async () => {
  const user = userEvent.setup();
  render(<TermsCheckbox />);

  const checkbox = screen.getByRole('checkbox', { name: /agree to terms/i });

  expect(checkbox).not.toBeChecked();
  await user.click(checkbox);
  expect(checkbox).toBeChecked();
});
```

**下拉选择**：

```tsx
test('选择下拉选项', async () => {
  const user = userEvent.setup();
  render(<CountrySelect />);

  const select = screen.getByRole('combobox', { name: /country/i });

  await user.selectOptions(select, 'US');
  expect(select).toHaveValue('US');

  // 或通过文本选择
  await user.selectOptions(select, screen.getByRole('option', { name: /united states/i }));
});
```

**键盘操作**：

```tsx
test('键盘导航', async () => {
  const user = userEvent.setup();
  render(<SearchBox />);

  const input = screen.getByRole('textbox');

  await user.type(input, 'React{Enter}'); // 输入后按回车
  expect(screen.getByText(/searching for: react/i)).toBeInTheDocument();

  // Tab 键导航
  await user.tab();
  expect(screen.getByRole('button', { name: /search/i })).toHaveFocus();
});
```

---

### 四、异步测试

#### 1. waitFor - 等待条件满足

```tsx
import { waitFor } from '@testing-library/react';

test('异步加载数据', async () => {
  render(<UserProfile userId="123" />);

  // 初始加载状态
  expect(screen.getByText(/loading/i)).toBeInTheDocument();

  // 等待数据加载完成
  await waitFor(() => {
    expect(screen.getByText(/john doe/i)).toBeInTheDocument();
  });

  // 或更简洁的方式
  await waitFor(() =>
    expect(screen.queryByText(/loading/i)).not.toBeInTheDocument()
  );
});
```

**waitFor 配置选项**：

```tsx
await waitFor(
  () => {
    expect(screen.getByText(/loaded/i)).toBeInTheDocument();
  },
  {
    timeout: 3000, // 最多等待 3 秒（默认 1000ms）
    interval: 100, // 每 100ms 检查一次（默认 50ms）
  }
);
```

#### 2. findBy* - 异步查询（推荐）

```tsx
test('等待元素出现', async () => {
  render(<AsyncComponent />);

  // findBy* 内置了 waitFor 逻辑
  const element = await screen.findByText(/loaded data/i);
  expect(element).toBeInTheDocument();

  // 等效于
  await waitFor(() => expect(screen.getByText(/loaded data/i)).toBeInTheDocument());
});
```

#### 3. waitForElementToBeRemoved - 等待元素移除

```tsx
test('加载完成后移除 spinner', async () => {
  render(<DataFetcher />);

  const spinner = screen.getByTestId('loading-spinner');

  await waitForElementToBeRemoved(spinner);

  expect(screen.getByText(/data loaded/i)).toBeInTheDocument();
});
```

---

### 五、Mock 和数据模拟

#### 1. Mock API 请求

**使用 MSW (Mock Service Worker) - 推荐**：

```tsx
// src/mocks/handlers.ts
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        id: req.params.id,
        name: 'John Doe',
        email: 'john@example.com',
      })
    );
  }),

  rest.post('/api/login', async (req, res, ctx) => {
    const { email, password } = await req.json();

    if (email === 'test@example.com' && password === 'password') {
      return res(ctx.status(200), ctx.json({ token: 'fake-token' }));
    }

    return res(ctx.status(401), ctx.json({ error: 'Invalid credentials' }));
  }),
];

// src/setupTests.ts
import { setupServer } from 'msw/node';
import { handlers } from './mocks/handlers';

export const server = setupServer(...handlers);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

**测试中使用**：

```tsx
import { server } from './setupTests';
import { rest } from 'msw';

test('成功获取用户数据', async () => {
  render(<UserProfile userId="123" />);

  expect(await screen.findByText('John Doe')).toBeInTheDocument();
  expect(screen.getByText('john@example.com')).toBeInTheDocument();
});

test('处理 API 错误', async () => {
  // 覆盖默认 handler
  server.use(
    rest.get('/api/users/:id', (req, res, ctx) => {
      return res(ctx.status(500), ctx.json({ error: 'Server error' }));
    })
  );

  render(<UserProfile userId="123" />);

  expect(await screen.findByText(/failed to load user/i)).toBeInTheDocument();
});
```

#### 2. Mock 模块

```tsx
// Mock 整个模块
jest.mock('axios');

test('使用 mock axios', async () => {
  const mockedAxios = axios as jest.Mocked<typeof axios>;

  mockedAxios.get.mockResolvedValue({
    data: { name: 'Test User' },
  });

  render(<UserComponent />);

  expect(await screen.findByText('Test User')).toBeInTheDocument();
  expect(mockedAxios.get).toHaveBeenCalledWith('/api/user');
});
```

#### 3. Mock 函数（回调）

```tsx
test('调用 onSubmit 回调', async () => {
  const handleSubmit = jest.fn();
  const user = userEvent.setup();

  render(<Form onSubmit={handleSubmit} />);

  await user.type(screen.getByLabelText(/name/i), 'John');
  await user.click(screen.getByRole('button', { name: /submit/i }));

  expect(handleSubmit).toHaveBeenCalledTimes(1);
  expect(handleSubmit).toHaveBeenCalledWith({
    name: 'John',
  });
});
```

---

### 六、组件测试完整示例

#### 示例：登录表单

```tsx
// LoginForm.tsx
import { useState } from 'react';

interface LoginFormProps {
  onLogin: (email: string, password: string) => Promise<void>;
}

export default function LoginForm({ onLogin }: LoginFormProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      await onLogin(email, password);
    } catch (err) {
      setError('Invalid credentials');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} aria-label="Login form">
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </div>

      <div>
        <label htmlFor="password">Password</label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </div>

      {error && <div role="alert">{error}</div>}

      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}
```

```tsx
// LoginForm.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginForm from './LoginForm';

describe('LoginForm', () => {
  test('渲染表单元素', () => {
    const mockLogin = jest.fn();
    render(<LoginForm onLogin={mockLogin} />);

    expect(screen.getByRole('textbox', { name: /email/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();
  });

  test('用户可以输入和提交表单', async () => {
    const user = userEvent.setup();
    const mockLogin = jest.fn().mockResolvedValue(undefined);

    render(<LoginForm onLogin={mockLogin} />);

    // 输入数据
    await user.type(screen.getByRole('textbox', { name: /email/i }), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');

    // 提交表单
    await user.click(screen.getByRole('button', { name: /login/i }));

    // 验证回调被调用
    expect(mockLogin).toHaveBeenCalledWith('test@example.com', 'password123');
  });

  test('显示加载状态', async () => {
    const user = userEvent.setup();
    const mockLogin = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));

    render(<LoginForm onLogin={mockLogin} />);

    await user.type(screen.getByRole('textbox', { name: /email/i }), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');

    const submitButton = screen.getByRole('button', { name: /login/i });
    await user.click(submitButton);

    // 检查加载状态
    expect(screen.getByRole('button', { name: /logging in/i })).toBeDisabled();
  });

  test('显示错误信息', async () => {
    const user = userEvent.setup();
    const mockLogin = jest.fn().mockRejectedValue(new Error('Invalid credentials'));

    render(<LoginForm onLogin={mockLogin} />);

    await user.type(screen.getByRole('textbox', { name: /email/i }), 'wrong@example.com');
    await user.type(screen.getByLabelText(/password/i), 'wrongpassword');
    await user.click(screen.getByRole('button', { name: /login/i }));

    // 等待错误消息出现
    expect(await screen.findByRole('alert')).toHaveTextContent(/invalid credentials/i);
  });

  test('清空之前的错误信息', async () => {
    const user = userEvent.setup();
    const mockLogin = jest
      .fn()
      .mockRejectedValueOnce(new Error('Error'))
      .mockResolvedValueOnce(undefined);

    render(<LoginForm onLogin={mockLogin} />);

    // 第一次提交（失败）
    await user.type(screen.getByRole('textbox', { name: /email/i }), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password');
    await user.click(screen.getByRole('button', { name: /login/i }));

    expect(await screen.findByRole('alert')).toBeInTheDocument();

    // 第二次提交（成功）
    await user.click(screen.getByRole('button', { name: /login/i }));

    // 错误信息应该消失
    expect(screen.queryByRole('alert')).not.toBeInTheDocument();
  });
});
```

---

### 七、高级技巧

#### 1. 自定义渲染函数

```tsx
// test-utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { ReactElement } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });

  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>{children}</BrowserRouter>
    </QueryClientProvider>
  );
};

const customRender = (ui: ReactElement, options?: Omit<RenderOptions, 'wrapper'>) =>
  render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };
```

**使用**：

```tsx
// MyComponent.test.tsx
import { render, screen } from './test-utils'; // 使用自定义 render

test('使用所有 Provider', () => {
  render(<MyComponent />);
  // 组件会自动包裹在 Router 和 QueryClientProvider 中
});
```

#### 2. 测试 React Router

```tsx
import { MemoryRouter } from 'react-router-dom';

test('导航到其他页面', async () => {
  const user = userEvent.setup();

  render(
    <MemoryRouter initialEntries={['/']}>
      <App />
    </MemoryRouter>
  );

  await user.click(screen.getByRole('link', { name: /about/i }));

  expect(screen.getByRole('heading', { name: /about page/i })).toBeInTheDocument();
});
```

#### 3. 测试自定义 Hook

```tsx
// useCounter.ts
import { useState } from 'react';

export function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  return {
    count,
    increment: () => setCount(c => c + 1),
    decrement: () => setCount(c => c - 1),
    reset: () => setCount(initialValue),
  };
}

// useCounter.test.tsx
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

test('useCounter 初始值', () => {
  const { result } = renderHook(() => useCounter(10));
  expect(result.current.count).toBe(10);
});

test('增加计数', () => {
  const { result } = renderHook(() => useCounter());

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});

test('重置计数', () => {
  const { result } = renderHook(() => useCounter(5));

  act(() => {
    result.current.increment();
    result.current.increment();
  });

  expect(result.current.count).toBe(7);

  act(() => {
    result.current.reset();
  });

  expect(result.current.count).toBe(5);
});
```

#### 4. 测试可访问性

```tsx
import { render, screen } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

test('组件应该符合可访问性标准', async () => {
  const { container } = render(<MyForm />);
  const results = await axe(container);

  expect(results).toHaveNoViolations();
});
```

---

### 八、常见错误和解决方案

#### 1. "not wrapped in act(...)" 警告

**错误原因**：状态更新没有包裹在 `act` 中

```tsx
// ❌ 错误
test('bad example', () => {
  render(<Counter />);
  fireEvent.click(screen.getByRole('button'));
  // 状态更新是异步的，但没有等待
});

// ✅ 正确
test('good example', async () => {
  const user = userEvent.setup();
  render(<Counter />);
  await user.click(screen.getByRole('button')); // userEvent 自动处理
});
```

#### 2. "Unable to find element" 错误

**解决方法**：使用 `screen.debug()` 查看当前 DOM

```tsx
test('调试元素查找', () => {
  render(<MyComponent />);

  screen.debug(); // 打印整个 DOM
  screen.debug(screen.getByRole('button')); // 打印特定元素
});
```

#### 3. 测试异步更新时元素未找到

```tsx
// ❌ 错误 - getBy 立即查询
test('bad async test', () => {
  render(<AsyncComponent />);
  expect(screen.getByText(/loaded/i)).toBeInTheDocument(); // 失败
});

// ✅ 正确 - 使用 findBy 或 waitFor
test('good async test', async () => {
  render(<AsyncComponent />);
  expect(await screen.findByText(/loaded/i)).toBeInTheDocument();
});
```

---

### 九、最佳实践总结

#### ✅ 应该做的

1. **优先使用 `getByRole`** - 提升可访问性
2. **使用 `userEvent` 而非 `fireEvent`** - 更接近真实用户行为
3. **测试用户可见的行为** - 不测试实现细节
4. **异步操作使用 `findBy` 或 `waitFor`** - 等待 DOM 更新
5. **使用 MSW 模拟 API** - 更真实的网络请求模拟
6. **编写可访问的组件** - 使用语义化 HTML 和 ARIA

#### ❌ 应该避免的

1. **不要测试内部状态** - `wrapper.state()` 或 `wrapper.instance()`
2. **不要依赖 `data-testid`** - 除非别无选择
3. **不要使用 `container.querySelector`** - 使用语义化查询
4. **不要测试第三方库** - 假设它们已经测试过
5. **不要过度 Mock** - 尽可能测试真实行为

---

## 总结

React Testing Library 的核心思想是**像用户一样测试**：

1. **查询元素**：优先使用 `getByRole`、`getByLabelText`，最后才用 `getByTestId`
2. **用户交互**：使用 `userEvent` 模拟真实操作
3. **异步测试**：使用 `findBy*` 或 `waitFor` 等待更新
4. **Mock 策略**：使用 MSW 模拟 API，mock 回调函数验证行为
5. **可访问性**：编写语义化的 HTML，测试会自然引导你写出更好的代码

遵循这些最佳实践，能写出稳定、可维护、有价值的测试，同时提升组件的可访问性和代码质量。
