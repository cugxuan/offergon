---
title: useRef 的作用和使用场景
tags:
  - 前端React
status: robot
class: 前端React
slug: useref-purpose-and-use-cases
ref:
---

## 核心要点

**useRef 是可变容器，保存跨渲染周期的值且变更不触发重渲染**。主要用途：1）访问 DOM 元素；2）存储不需要触发渲染的可变值（定时器 ID、前值、实例变量）；3）避免 useEffect/useCallback 闭包陷阱。关键特性：`.current` 可变、引用稳定、修改不触发更新。

---

## 详细解答

### 一、useRef 的核心概念

#### 1. 基本用法
```javascript
const ref = useRef(initialValue);
// ref = { current: initialValue }
```

**useRef 返回一个可变的 ref 对象**，其 `.current` 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。

#### 2. 与 useState 的区别
```javascript
function Counter() {
  const [count, setCount] = useState(0);      // 修改会触发重渲染
  const countRef = useRef(0);                  // 修改不会触发重渲染

  const handleClick = () => {
    setCount(count + 1);      // ✅ 触发重渲染，UI 更新
    countRef.current += 1;    // ❌ 不触发重渲染，UI 不更新
    console.log('State:', count, 'Ref:', countRef.current);
  };

  return (
    <div>
      <p>State Count: {count}</p>
      <p>Ref Count: {countRef.current}</p>
      <button onClick={handleClick}>点击</button>
    </div>
  );
}
```

**关键区别：**
- `useState`：数据变化触发重渲染，用于渲染相关的状态
- `useRef`：数据变化不触发重渲染，用于副作用或缓存值

### 二、典型使用场景

#### 场景 1：访问 DOM 元素

**基础用法**
```javascript
function TextInputWithFocusButton() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    // 直接操作 DOM 元素
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>聚焦输入框</button>
    </div>
  );
}
```

**测量 DOM 尺寸**
```javascript
function MeasureExample() {
  const divRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  useEffect(() => {
    if (divRef.current) {
      const { width, height } = divRef.current.getBoundingClientRect();
      setDimensions({ width, height });
    }
  }, []);

  return (
    <div ref={divRef} style={{ padding: '20px', background: '#f0f0f0' }}>
      <p>宽度: {dimensions.width}px</p>
      <p>高度: {dimensions.height}px</p>
    </div>
  );
}
```

**视频播放控制**
```javascript
function VideoPlayer({ src }) {
  const videoRef = useRef(null);

  const handlePlay = () => videoRef.current.play();
  const handlePause = () => videoRef.current.pause();
  const handleSeek = (time) => {
    videoRef.current.currentTime = time;
  };

  return (
    <div>
      <video ref={videoRef} src={src} />
      <button onClick={handlePlay}>播放</button>
      <button onClick={handlePause}>暂停</button>
      <button onClick={() => handleSeek(10)}>跳转到 10 秒</button>
    </div>
  );
}
```

#### 场景 2：保存定时器/间隔器 ID

```javascript
function Timer() {
  const [count, setCount] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);

  const startTimer = () => {
    if (intervalRef.current !== null) return; // 避免重复启动

    intervalRef.current = setInterval(() => {
      setCount(c => c + 1);
    }, 1000);
    setIsRunning(true);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
    setIsRunning(false);
  };

  const resetTimer = () => {
    stopTimer();
    setCount(0);
  };

  useEffect(() => {
    // 组件卸载时清理定时器
    return () => {
      if (intervalRef.current !== null) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  return (
    <div>
      <p>计时: {count} 秒</p>
      <button onClick={startTimer} disabled={isRunning}>开始</button>
      <button onClick={stopTimer} disabled={!isRunning}>停止</button>
      <button onClick={resetTimer}>重置</button>
    </div>
  );
}
```

#### 场景 3：保存上一次的 props 或 state

```javascript
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value; // 在每次渲染后更新为当前值
  });

  return ref.current; // 返回上一次的值
}

// 使用示例
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>当前值: {count}</p>
      <p>上一次的值: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}
```

**对比值变化**
```javascript
function SearchInput({ onSearch }) {
  const [query, setQuery] = useState('');
  const prevQuery = usePrevious(query);

  useEffect(() => {
    if (query !== prevQuery && query.length >= 3) {
      console.log(`搜索词从 "${prevQuery}" 变为 "${query}"`);
      onSearch(query);
    }
  }, [query, prevQuery, onSearch]);

  return (
    <input
      value={query}
      onChange={e => setQuery(e.target.value)}
      placeholder="输入搜索词"
    />
  );
}
```

#### 场景 4：避免闭包陷阱

**问题示例：闭包导致的过期值**
```javascript
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();

    // ❌ 问题：回调函数中的 message 是创建时的快照
    connection.on('message', (msg) => {
      console.log('当前消息:', message); // 永远是空字符串
    });

    return () => connection.disconnect();
  }, [roomId]); // message 不在依赖项中

  return <input value={message} onChange={e => setMessage(e.target.value)} />;
}
```

**解决方案：使用 useRef 保存最新值**
```javascript
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  const messageRef = useRef(message);

  // 始终保持 ref 为最新值
  useEffect(() => {
    messageRef.current = message;
  }, [message]);

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();

    // ✅ 通过 ref 访问最新的 message
    connection.on('message', (msg) => {
      console.log('当前消息:', messageRef.current);
    });

    return () => connection.disconnect();
  }, [roomId]);

  return <input value={message} onChange={e => setMessage(e.target.value)} />;
}
```

**封装成自定义 Hook**
```javascript
function useLatest(value) {
  const ref = useRef(value);

  useEffect(() => {
    ref.current = value;
  });

  return ref;
}

// 使用示例
function Component() {
  const [count, setCount] = useState(0);
  const countRef = useLatest(count);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log('最新的 count:', countRef.current); // 始终是最新值
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组，但能访问最新的 count

  return <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>;
}
```

#### 场景 5：存储组件实例变量

```javascript
function FileUploader() {
  const [uploadProgress, setUploadProgress] = useState(0);
  const xhrRef = useRef(null); // 保存 XMLHttpRequest 实例

  const handleUpload = (file) => {
    const xhr = new XMLHttpRequest();
    xhrRef.current = xhr;

    xhr.upload.addEventListener('progress', (e) => {
      const progress = (e.loaded / e.total) * 100;
      setUploadProgress(progress);
    });

    xhr.addEventListener('load', () => {
      console.log('上传完成');
      xhrRef.current = null;
    });

    xhr.open('POST', '/api/upload');
    xhr.send(file);
  };

  const handleCancel = () => {
    // 中断上传
    if (xhrRef.current) {
      xhrRef.current.abort();
      xhrRef.current = null;
      setUploadProgress(0);
    }
  };

  return (
    <div>
      <input type="file" onChange={e => handleUpload(e.target.files[0])} />
      <progress value={uploadProgress} max="100" />
      <button onClick={handleCancel}>取消上传</button>
    </div>
  );
}
```

### 三、高级用法

#### 1. 回调 Ref（Callback Ref）

```javascript
function MeasureExample() {
  const [height, setHeight] = useState(0);

  // 当 DOM 节点变化时自动调用
  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <div ref={measuredRef}>
      <p>这个 div 的高度是 {Math.round(height)}px</p>
    </div>
  );
}
```

#### 2. 转发 Ref（forwardRef）

```javascript
// 子组件暴露 DOM 引用给父组件
const FancyInput = forwardRef((props, ref) => {
  return (
    <div>
      <input ref={ref} type="text" {...props} />
    </div>
  );
});

// 父组件使用
function Parent() {
  const inputRef = useRef(null);

  return (
    <div>
      <FancyInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>聚焦</button>
    </div>
  );
}
```

**使用 useImperativeHandle 自定义暴露的值**
```javascript
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    // 只暴露特定的方法
    focus: () => inputRef.current.focus(),
    clear: () => { inputRef.current.value = ''; },
    getValue: () => inputRef.current.value
  }));

  return <input ref={inputRef} type="text" {...props} />;
});

// 使用
function Parent() {
  const inputRef = useRef(null);

  const handleSubmit = () => {
    const value = inputRef.current.getValue();
    console.log('输入值:', value);
    inputRef.current.clear();
  };

  return (
    <div>
      <FancyInput ref={inputRef} />
      <button onClick={handleSubmit}>提交并清空</button>
    </div>
  );
}
```

### 四、常见陷阱与最佳实践

#### 1. 不要在渲染期间读写 ref.current
```javascript
// ❌ 错误：渲染期间读取 ref
function BadExample() {
  const ref = useRef(0);
  ref.current += 1; // 会导致不可预测的行为
  return <div>{ref.current}</div>;
}

// ✅ 正确：在事件处理函数或 useEffect 中修改
function GoodExample() {
  const ref = useRef(0);

  useEffect(() => {
    ref.current += 1; // 在副作用中修改
  });

  const handleClick = () => {
    ref.current += 1; // 在事件处理函数中修改
  };

  return <button onClick={handleClick}>点击</button>;
}
```

#### 2. 需要响应式更新时使用 useState
```javascript
// ❌ 错误：UI 不会更新
function BadCounter() {
  const countRef = useRef(0);
  return (
    <div>
      <p>{countRef.current}</p>
      <button onClick={() => { countRef.current += 1; }}>增加</button>
    </div>
  );
}

// ✅ 正确：使用 useState
function GoodCounter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(c => c + 1)}>增加</button>
    </div>
  );
}
```

#### 3. Ref 和严格模式
在 React 18 的严格模式下，组件会在开发环境中双重渲染。确保 ref 的使用不会因此产生副作用。

```javascript
// 正确处理严格模式
function StrictModeComponent() {
  const initRef = useRef(false);

  useEffect(() => {
    if (!initRef.current) {
      // 只执行一次的初始化逻辑
      console.log('初始化');
      initRef.current = true;
    }

    return () => {
      // 清理逻辑
      initRef.current = false;
    };
  }, []);

  return <div>组件</div>;
}
```

### 五、实用自定义 Hook 示例

#### 1. useTimeout
```javascript
function useTimeout(callback, delay) {
  const callbackRef = useRef(callback);
  const timeoutRef = useRef(null);

  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    if (delay !== null) {
      timeoutRef.current = setTimeout(() => {
        callbackRef.current();
      }, delay);

      return () => clearTimeout(timeoutRef.current);
    }
  }, [delay]);
}

// 使用
function Component() {
  const [count, setCount] = useState(0);

  useTimeout(() => {
    console.log('延迟执行，count:', count);
  }, 3000);

  return <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>;
}
```

#### 2. useClickOutside
```javascript
function useClickOutside(callback) {
  const ref = useRef(null);
  const callbackRef = useRef(callback);

  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    const handleClick = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        callbackRef.current();
      }
    };

    document.addEventListener('click', handleClick);
    return () => document.removeEventListener('click', handleClick);
  }, []);

  return ref;
}

// 使用
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useClickOutside(() => setIsOpen(false));

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>切换</button>
      {isOpen && <div>下拉内容</div>}
    </div>
  );
}
```

### 六、面试回答要点总结

1. **核心特性**：可变容器、跨渲染持久、修改不触发更新、引用稳定
2. **主要用途**：DOM 访问、存储实例变量、避免闭包陷阱、保存定时器 ID
3. **与 useState 区别**：useState 触发重渲染用于 UI 状态，useRef 不触发重渲染用于副作用
4. **高级用法**：Callback Ref、forwardRef、useImperativeHandle
5. **最佳实践**：不在渲染期间读写、需要 UI 更新时用 useState、配合 useEffect 使用
