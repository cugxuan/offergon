---
title: React.memo、PureComponent 的原理和使用
tags:
  - 前端React
status: robot
class: 前端React
slug: react-memo-purecomponent-principles-usage
ref:
---

## 核心要点

- **React.memo** 和 **PureComponent** 都是通过 **浅比较（shallow comparison）** 来避免不必要的重新渲染
- **React.memo** 用于函数组件，**PureComponent** 用于类组件
- 核心原理：props 未变化时，跳过 render 阶段，复用上次渲染结果
- 适用场景：纯展示组件、接收复杂 props 但变化频率低的组件
- 注意事项：浅比较无法检测对象/数组内部变化，需配合 `useMemo`/`useCallback` 使用

---

## 详细解答

### 一、React.memo 的原理和使用

#### 1.1 什么是 React.memo？

`React.memo` 是一个**高阶组件（HOC）**，用于对函数组件进行性能优化。它会对组件的 props 进行浅比较，如果 props 没有变化，就跳过重新渲染，直接复用上次的渲染结果。

```jsx
import React from 'react';

const MyComponent = React.memo(function MyComponent({ name, age }) {
  console.log('MyComponent 渲染了');
  return (
    <div>
      <p>姓名: {name}</p>
      <p>年龄: {age}</p>
    </div>
  );
});

export default MyComponent;
```

#### 1.2 工作原理

当父组件重新渲染时，React 会：

1. **对比新旧 props**：使用 `Object.is()` 进行浅比较（类似 `===`）
2. **判断是否跳过渲染**：
   - 如果所有 props 都相等 → 跳过渲染，复用上次结果
   - 如果任何一个 prop 不同 → 执行重新渲染

**源码简化逻辑**：
```js
function memo(Component, compare) {
  return function MemoComponent(props) {
    const prevProps = usePrevious(props);

    // 使用自定义比较函数或默认浅比较
    if (compare ? compare(prevProps, props) : shallowEqual(prevProps, props)) {
      return previousResult; // 复用上次渲染
    }

    return <Component {...props} />; // 重新渲染
  };
}

function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) return true;

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (let key of keysA) {
    if (!Object.is(objA[key], objB[key])) return false;
  }

  return true;
}
```

#### 1.3 自定义比较函数

可以传入第二个参数自定义比较逻辑（注意返回值与 `shouldComponentUpdate` 相反）：

```jsx
const MyComponent = React.memo(
  function MyComponent({ user, theme }) {
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    // 返回 true 表示 props 相等，跳过渲染
    // 返回 false 表示 props 不同，执行渲染
    return prevProps.user.id === nextProps.user.id;
  }
);
```

#### 1.4 常见陷阱

**问题 1：内联对象/函数导致失效**

```jsx
// ❌ 错误：每次父组件渲染都会创建新的对象
function Parent() {
  return <Child style={{ color: 'red' }} onClick={() => {}} />;
}

// ✅ 正确：使用 useMemo/useCallback 缓存
function Parent() {
  const style = useMemo(() => ({ color: 'red' }), []);
  const handleClick = useCallback(() => {}, []);

  return <Child style={style} onClick={handleClick} />;
}
```

**问题 2：children 属性导致失效**

```jsx
// ❌ 错误：每次渲染 children 都是新的 React 元素
function Parent() {
  return (
    <MemoChild>
      <p>内容</p>
    </MemoChild>
  );
}

// ✅ 正确：将 children 提取为稳定的组件
const Content = <p>内容</p>;

function Parent() {
  return <MemoChild>{Content}</MemoChild>;
}
```

---

### 二、PureComponent 的原理和使用

#### 2.1 什么是 PureComponent？

`PureComponent` 是 React 提供的一个基类，继承自 `Component`，它在内部实现了 `shouldComponentUpdate` 方法，会对 `props` 和 `state` 进行浅比较。

```jsx
import React, { PureComponent } from 'react';

class MyComponent extends PureComponent {
  render() {
    console.log('MyComponent 渲染了');
    return (
      <div>
        <p>姓名: {this.props.name}</p>
        <p>年龄: {this.props.age}</p>
      </div>
    );
  }
}
```

#### 2.2 工作原理

`PureComponent` 的核心是自动实现了 `shouldComponentUpdate`：

```js
// React 内部实现（简化版）
class PureComponent extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    return (
      !shallowEqual(this.props, nextProps) ||
      !shallowEqual(this.state, nextState)
    );
  }
}
```

**对比流程**：
1. **浅比较 props**：逐个对比每个 prop 的引用是否相同
2. **浅比较 state**：逐个对比每个 state 的引用是否相同
3. **返回结果**：
   - 如果都相同 → 返回 `false`，跳过渲染
   - 如果任意不同 → 返回 `true`，执行渲染

#### 2.3 与 Component 的区别

| 特性 | Component | PureComponent |
|------|-----------|---------------|
| `shouldComponentUpdate` | 默认返回 `true` | 自动进行浅比较 |
| 性能 | 每次都渲染 | 跳过不必要的渲染 |
| 适用场景 | props/state 经常变化 | props/state 变化少 |

#### 2.4 常见陷阱

**问题 1：直接修改 state 导致失效**

```jsx
// ❌ 错误：直接修改数组，引用未变化
class TodoList extends PureComponent {
  state = { todos: ['学习 React'] };

  addTodo = () => {
    this.state.todos.push('新任务'); // 引用不变，浅比较判定为相同
    this.setState({ todos: this.state.todos }); // 不会触发渲染
  };
}

// ✅ 正确：创建新数组
class TodoList extends PureComponent {
  state = { todos: ['学习 React'] };

  addTodo = () => {
    this.setState({
      todos: [...this.state.todos, '新任务'] // 新引用
    });
  };
}
```

**问题 2：嵌套对象修改**

```jsx
// ❌ 错误：修改嵌套对象
this.setState({
  user: {
    ...this.state.user,
    profile: { ...this.state.user.profile, age: 30 }
  }
});

// ✅ 正确：使用 Immer 等不可变库
import produce from 'immer';

this.setState(
  produce(draft => {
    draft.user.profile.age = 30;
  })
);
```

---

### 三、React.memo vs PureComponent

| 对比项 | React.memo | PureComponent |
|--------|------------|---------------|
| **适用组件** | 函数组件 | 类组件 |
| **比较对象** | 仅 props | props + state |
| **自定义比较** | 支持第二个参数 | 需重写 `shouldComponentUpdate` |
| **使用方式** | 包裹组件 | 继承基类 |
| **现代推荐** | ✅ 推荐（配合 Hooks） | ⚠️ 逐渐被替代 |

---

### 四、最佳实践

#### 4.1 何时使用

✅ **适合使用的场景**：
- 纯展示组件（UI 组件）
- props 复杂但变化频率低的组件
- 列表项组件（配合 `key`）
- 高频渲染的父组件下的子组件

❌ **不适合使用的场景**：
- props 频繁变化的组件
- 组件本身渲染开销很小
- props 包含大量函数/对象且没有做缓存

#### 4.2 配合 Hooks 使用

```jsx
import React, { useState, useMemo, useCallback } from 'react';

const ExpensiveChild = React.memo(({ data, onUpdate }) => {
  console.log('子组件渲染');
  return <div onClick={onUpdate}>{data.value}</div>;
});

function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // 缓存对象，避免每次创建新引用
  const data = useMemo(() => ({ value: count }), [count]);

  // 缓存函数，避免每次创建新引用
  const handleUpdate = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      {/* text 变化不会导致 ExpensiveChild 重新渲染 */}
      <ExpensiveChild data={data} onUpdate={handleUpdate} />
    </div>
  );
}
```

#### 4.3 性能监控

使用 React DevTools Profiler 验证优化效果：

```jsx
import { Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  console.log(`${id} 的 ${phase} 阶段耗时 ${actualDuration}ms`);
}

<Profiler id="MyComponent" onRender={onRenderCallback}>
  <MyComponent />
</Profiler>
```

---

### 五、底层原理深入

#### 5.1 Fiber 节点复用

当 `React.memo` 判定不需要渲染时，React 会：
1. **标记 Fiber 节点**：设置 `didReceiveUpdate = false`
2. **跳过 beginWork 阶段**：不调用组件函数/render 方法
3. **复用子 Fiber 树**：直接克隆上次的 Fiber 子树
4. **跳过 effectTag 标记**：不产生 DOM 更新操作

```js
// React 源码简化
function updateMemoComponent(current, workInProgress, Component, nextProps) {
  const prevProps = current.memoizedProps;

  // 比较 props
  if (shallowEqual(prevProps, nextProps)) {
    // 复用当前 Fiber 节点
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  // 执行组件更新
  return updateFunctionComponent(current, workInProgress, Component, nextProps);
}
```

#### 5.2 浅比较的实现

React 使用 `Object.is()` 进行比较（解决了 `===` 对 `NaN` 和 `+0/-0` 的问题）：

```js
function is(x, y) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || // +0 和 -0
    (x !== x && y !== y) // NaN
  );
}

const objectIs = typeof Object.is === 'function' ? Object.is : is;
```

---

### 六、总结

1. **选择建议**：
   - 函数组件 → 使用 `React.memo` + `useMemo`/`useCallback`
   - 类组件 → 使用 `PureComponent` 或手动实现 `shouldComponentUpdate`

2. **核心原则**：
   - 确保 props 的稳定性（避免内联对象/函数）
   - 使用不可变数据结构更新 state
   - 通过 Profiler 验证优化效果，避免过早优化

3. **性能权衡**：
   - 浅比较本身也有开销，不要滥用
   - 对于简单组件，比较成本可能高于渲染成本
   - 优先优化渲染次数多的组件

**面试加分点**：
- 能说出浅比较的实现细节（`Object.is` vs `===`）
- 理解 Fiber 节点复用机制
- 知道如何使用 Profiler 验证优化效果
- 能举例说明常见陷阱和解决方案
