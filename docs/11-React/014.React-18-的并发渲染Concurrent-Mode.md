---
title: React 18 的并发渲染（Concurrent Mode）
tags:
  - React
status: robot
class: 前端React
slug: react-18-concurrent-rendering
ref:
---

## 核心要点

- **并发渲染**允许 React 同时准备多个版本的 UI，在后台渲染新 UI 的同时保持旧 UI 可交互
- 核心 API：`startTransition`（标记非紧急更新）、`useDeferredValue`（延迟更新值）、`useTransition`（带 loading 状态的过渡）
- 底层原理：基于 Fiber 架构的**时间切片（Time Slicing）**和**可中断渲染**
- 优势：提升用户体验，避免长任务阻塞主线程，保持应用响应性
- 适用场景：大列表渲染、复杂搜索过滤、路由切换、数据密集型应用

---

## 详细解答

### 一、什么是并发渲染？

#### 1.1 核心概念

**并发渲染（Concurrent Rendering）** 是 React 18 引入的新渲染机制，允许 React：
1. **同时准备多个版本的 UI**（而不是一个接一个）
2. **在后台渲染新 UI**，同时保持当前 UI 可交互
3. **中断、暂停、恢复或放弃渲染**，根据优先级调度任务

**传统同步渲染的问题**：
```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    // 搜索 10000 条数据
    const filtered = hugeDataset.filter(item => item.includes(query));
    setResults(filtered); // 这会阻塞主线程，导致输入框卡顿
  }, [query]);

  return (
    <div>
      {/* 渲染 10000 条结果会阻塞 UI */}
      {results.map(item => <Item key={item.id} data={item} />)}
    </div>
  );
}
```

**用户体验问题**：
- 用户输入 "a" → React 开始渲染 10000 条结果
- 用户继续输入 "ab" → 必须等待上次渲染完成
- **主线程被长时间占用，输入框无法响应**

**并发渲染的解决方案**：
```jsx
import { useState, useDeferredValue } from 'react';

function SearchResults({ query }) {
  const deferredQuery = useDeferredValue(query); // 延迟更新查询

  const results = useMemo(() => {
    return hugeDataset.filter(item => item.includes(deferredQuery));
  }, [deferredQuery]);

  return (
    <div>
      {results.map(item => <Item key={item.id} data={item} />)}
    </div>
  );
}
```

**效果**：
- 用户输入 "a" → React 开始渲染，但可以被打断
- 用户继续输入 "ab" → React 中断 "a" 的渲染，开始渲染 "ab"
- **输入框始终保持流畅**

#### 1.2 并发 vs 并行

| 概念 | 定义 | 类比 |
|------|------|------|
| **并发（Concurrent）** | 同时处理多个任务，通过时间切片交替执行 | 一个人做饭时，水烧开前去切菜 |
| **并行（Parallel）** | 真正的多任务同时执行（多核 CPU） | 两个人同时做饭 |

**React 并发渲染是并发而非并行**：
- JavaScript 是单线程的，无法真正并行
- 通过**时间切片**将渲染任务拆分成小块，交替执行
- 优先执行高优先级任务（如用户输入）

---

### 二、核心 API

#### 2.1 startTransition

将状态更新标记为**非紧急过渡**，允许被更高优先级的更新打断。

```jsx
import { startTransition } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const newQuery = e.target.value;

    // 紧急更新：立即更新输入框（高优先级）
    setQuery(newQuery);

    // 非紧急更新：标记为过渡（低优先级）
    startTransition(() => {
      const filtered = hugeDataset.filter(item => item.includes(newQuery));
      setResults(filtered);
    });
  };

  return (
    <div>
      <input value={query} onChange={handleChange} />
      {/* 结果列表的渲染可以被打断 */}
      <ResultsList results={results} />
    </div>
  );
}
```

**工作原理**：
1. **紧急更新**（`setQuery`）：立即执行，保证输入框流畅
2. **过渡更新**（`startTransition` 内的 `setResults`）：可被打断，在后台渲染
3. 如果用户继续输入，React 会**中断过渡渲染**，优先处理新的输入

**适用场景**：
- 搜索过滤
- 标签页切换
- 数据排序
- 复杂动画

#### 2.2 useTransition

`useTransition` 是 `startTransition` 的 Hook 版本，额外提供 `isPending` 状态。

```jsx
import { useState, useTransition } from 'react';

function TabContainer() {
  const [activeTab, setActiveTab] = useState('home');
  const [isPending, startTransition] = useTransition();

  const handleTabClick = (tab) => {
    startTransition(() => {
      setActiveTab(tab); // 标记为过渡
    });
  };

  return (
    <div>
      <button onClick={() => handleTabClick('home')}>首页</button>
      <button onClick={() => handleTabClick('profile')}>个人资料</button>

      {/* 显示加载状态 */}
      {isPending && <Spinner />}

      {/* 标签页内容 */}
      {activeTab === 'home' && <HomePage />}
      {activeTab === 'profile' && <ProfilePage />}
    </div>
  );
}
```

**返回值**：
- `isPending`：布尔值，表示过渡是否正在进行
- `startTransition`：函数，用于标记过渡更新

**与 loading 状态的区别**：
```jsx
// ❌ 传统方式：手动管理 loading
const [isLoading, setIsLoading] = useState(false);

const handleClick = () => {
  setIsLoading(true);
  fetchData().then(data => {
    setData(data);
    setIsLoading(false);
  });
};

// ✅ useTransition：自动管理过渡状态
const [isPending, startTransition] = useTransition();

const handleClick = () => {
  startTransition(() => {
    setData(newData); // React 自动追踪过渡状态
  });
};
```

#### 2.3 useDeferredValue

延迟更新某个值，使其滞后于其他更新。

```jsx
import { useState, useDeferredValue, useMemo } from 'react';

function SearchResults() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query); // 延迟版本

  // 使用延迟值进行计算
  const results = useMemo(() => {
    console.log('搜索:', deferredQuery);
    return hugeDataset.filter(item => item.includes(deferredQuery));
  }, [deferredQuery]);

  return (
    <div>
      {/* 输入框使用实时值，保持响应 */}
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
      />

      {/* 显示过渡状态 */}
      {query !== deferredQuery && <div>搜索中...</div>}

      {/* 结果列表使用延迟值 */}
      <ul>
        {results.map(item => <li key={item.id}>{item.name}</li>)}
      </ul>
    </div>
  );
}
```

**工作原理**：
1. 用户输入 "a" → `query = "a"`, `deferredQuery` 仍是 ""
2. React 开始渲染 `deferredQuery = "a"` 的结果
3. 用户继续输入 "ab" → `query = "ab"`, React 中断渲染
4. 重新开始渲染 `deferredQuery = "ab"` 的结果

**与 debounce 的区别**：
```jsx
// debounce：固定延迟时间
const debouncedQuery = useDebounce(query, 300); // 总是延迟 300ms

// useDeferredValue：根据系统性能动态调整
const deferredQuery = useDeferredValue(query); // React 自动决定延迟时间
```

---

### 三、底层原理

#### 3.1 时间切片（Time Slicing）

React 将渲染任务拆分成多个小块（每块约 5ms），在每个时间片之间检查是否有更高优先级的任务。

```js
// React 内部简化逻辑
function workLoop(deadline) {
  let shouldYield = false;

  while (nextUnitOfWork && !shouldYield) {
    // 执行一小块工作
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);

    // 检查是否需要让出主线程
    shouldYield = deadline.timeRemaining() < 1; // 剩余时间 < 1ms
  }

  if (nextUnitOfWork) {
    // 还有工作未完成，继续调度
    requestIdleCallback(workLoop);
  } else {
    // 工作完成，提交到 DOM
    commitRoot();
  }
}

// 开始调度
requestIdleCallback(workLoop);
```

**执行流程**：
```
[渲染任务 1 (5ms)] → [检查更高优先级任务] → [渲染任务 2 (5ms)] → ...
                ↓
          发现用户输入（高优先级）
                ↓
          中断当前渲染，处理输入
                ↓
          恢复渲染或重新开始
```

#### 3.2 优先级调度（Lane Model）

React 18 使用 **Lane 模型**管理不同优先级的更新。

```js
// React 内部优先级定义（简化）
const SyncLane = 0b0001;              // 同步更新（最高优先级）
const InputContinuousLane = 0b0010;   // 连续输入
const DefaultLane = 0b0100;           // 默认更新
const TransitionLane = 0b1000;        // 过渡更新（最低优先级）

// 更新调度
function scheduleUpdateOnFiber(fiber, lane) {
  if (lane === SyncLane) {
    // 立即同步执行（如 onClick）
    performSyncWorkOnRoot(fiber);
  } else if (lane === TransitionLane) {
    // 可中断的并发渲染
    ensureRootIsScheduled(fiber);
  }
}
```

**优先级示例**：
```jsx
function App() {
  const [count, setCount] = useState(0);
  const [list, setList] = useState([]);

  const handleClick = () => {
    // 高优先级：立即执行
    setCount(c => c + 1);

    // 低优先级：可被打断
    startTransition(() => {
      setList(generateLargeList());
    });
  };

  return (
    <div>
      <button onClick={handleClick}>点击: {count}</button>
      <LargeList data={list} />
    </div>
  );
}
```

**执行顺序**：
1. 用户点击按钮 → `setCount` 立即执行（高优先级）
2. 按钮显示新的 count
3. React 开始渲染 `LargeList`（低优先级）
4. 如果用户再次点击 → 中断 `LargeList` 渲染，优先更新 count

#### 3.3 双缓冲 Fiber 树

React 维护两棵 Fiber 树：
1. **current 树**：当前屏幕显示的 UI
2. **workInProgress 树**：后台正在构建的新 UI

```js
// Fiber 节点结构
class FiberNode {
  alternate: FiberNode | null; // 指向另一棵树的对应节点

  // 在 workInProgress 树中渲染
  function beginWork(workInProgress) {
    // 构建新的子 Fiber 节点
    reconcileChildren(workInProgress, nextChildren);
  }

  // 渲染完成后，切换指针
  function commitRoot() {
    root.current = finishedWork; // 将 workInProgress 树设为 current
  }
}
```

**并发渲染流程**：
```
用户输入 "a"
    ↓
在 workInProgress 树中渲染 "a" 的结果 (可中断)
    ↓
用户输入 "ab" (高优先级)
    ↓
放弃 "a" 的 workInProgress 树，重新开始渲染 "ab"
    ↓
"ab" 渲染完成 → 提交到 DOM (commitRoot)
    ↓
current 树更新为 "ab" 的树
```

---

### 四、实战案例

#### 4.1 大列表优化

```jsx
import { useState, useDeferredValue, useMemo } from 'react';

function ProductList() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);

  // 模拟 10000 条商品数据
  const allProducts = useMemo(() => generateProducts(10000), []);

  // 使用延迟值过滤
  const filteredProducts = useMemo(() => {
    console.log('过滤中...', deferredQuery);
    return allProducts.filter(p =>
      p.name.toLowerCase().includes(deferredQuery.toLowerCase())
    );
  }, [deferredQuery, allProducts]);

  return (
    <div>
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="搜索商品"
      />

      {/* 显示过渡状态 */}
      {query !== deferredQuery && (
        <div style={{ opacity: 0.5 }}>搜索中...</div>
      )}

      {/* 渲染结果（可被中断） */}
      <div>
        {filteredProducts.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
}
```

#### 4.2 标签页切换

```jsx
import { useState, useTransition } from 'react';

function Tabs() {
  const [tab, setTab] = useState('home');
  const [isPending, startTransition] = useTransition();

  const handleTabChange = (newTab) => {
    startTransition(() => {
      setTab(newTab);
    });
  };

  return (
    <div>
      <div className="tabs">
        <button onClick={() => handleTabChange('home')}>首页</button>
        <button onClick={() => handleTabChange('posts')}>文章</button>
        <button onClick={() => handleTabChange('contact')}>联系</button>
      </div>

      {/* 过渡期间显示旧内容 + 加载提示 */}
      <div style={{ opacity: isPending ? 0.5 : 1 }}>
        {tab === 'home' && <Home />}
        {tab === 'posts' && <Posts />}
        {tab === 'contact' && <Contact />}
      </div>

      {isPending && <Spinner />}
    </div>
  );
}
```

#### 4.3 路由切换优化

```jsx
import { useTransition } from 'react';
import { useNavigate } from 'react-router-dom';

function Navigation() {
  const [isPending, startTransition] = useTransition();
  const navigate = useNavigate();

  const handleNavigate = (path) => {
    startTransition(() => {
      navigate(path); // 路由切换标记为过渡
    });
  };

  return (
    <nav>
      <button onClick={() => handleNavigate('/')}>首页</button>
      <button onClick={() => handleNavigate('/dashboard')}>
        仪表盘
      </button>

      {isPending && <LoadingBar />}
    </nav>
  );
}
```

---

### 五、启用并发渲染

#### 5.1 使用 createRoot（必需）

```jsx
// React 17 及之前
import ReactDOM from 'react-dom';
ReactDOM.render(<App />, document.getElementById('root')); // 同步渲染

// React 18（启用并发特性）
import { createRoot } from 'react-dom/client';
const root = createRoot(document.getElementById('root'));
root.render(<App />); // 并发渲染
```

**区别**：
- `ReactDOM.render`：传统同步渲染模式
- `createRoot`：启用并发特性（但不自动使用）

#### 5.2 并发特性是可选的

```jsx
// 不使用并发 API，行为与 React 17 相同
function App() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}

// 使用 startTransition 后，才启用并发渲染
function App() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    startTransition(() => {
      setCount(c => c + 1); // 这次更新是并发的
    });
  };

  return <button onClick={handleClick}>{count}</button>;
}
```

---

### 六、性能对比

#### 6.1 传统渲染 vs 并发渲染

**场景**：用户在搜索框输入，过滤 10000 条数据

| 指标 | 传统渲染 | 并发渲染 |
|------|---------|---------|
| **首次输入响应** | 300ms（等待渲染） | 16ms（立即响应） |
| **连续输入** | 每次输入都阻塞 | 流畅，无感知 |
| **总渲染时间** | 300ms | 320ms（稍慢） |
| **用户体验** | 卡顿 | 流畅 |

**关键**：并发渲染**不是为了加快渲染速度**，而是**保持应用响应性**。

#### 6.2 性能监控

```jsx
import { Profiler } from 'react';

function App() {
  const onRenderCallback = (
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime
  ) => {
    console.log(`${id} 渲染耗时: ${actualDuration}ms`);
  };

  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <SearchResults />
    </Profiler>
  );
}
```

---

### 七、最佳实践

#### 7.1 何时使用 startTransition

✅ **适合使用**：
- 搜索过滤
- 标签页切换
- 数据排序/分组
- 复杂计算（图表渲染）

❌ **不适合使用**：
- 受控输入（会导致输入延迟）
- 紧急更新（如弹窗关闭）

```jsx
// ❌ 错误：不要在受控输入上使用
const handleChange = (e) => {
  startTransition(() => {
    setValue(e.target.value); // 输入会延迟
  });
};

// ✅ 正确：分离紧急和非紧急更新
const handleChange = (e) => {
  setValue(e.target.value); // 紧急更新
  startTransition(() => {
    setSearchResults(search(e.target.value)); // 非紧急更新
  });
};
```

#### 7.2 配合 useMemo 使用

```jsx
function ExpensiveComponent({ query }) {
  const deferredQuery = useDeferredValue(query);

  // ✅ 必须配合 useMemo，否则每次都会重新计算
  const results = useMemo(() => {
    return expensiveComputation(deferredQuery);
  }, [deferredQuery]);

  return <ResultsList results={results} />;
}
```

#### 7.3 避免滥用

```jsx
// ❌ 错误：所有更新都标记为过渡
const handleClick = () => {
  startTransition(() => {
    setCount(c => c + 1); // 简单更新不需要过渡
  });
};

// ✅ 正确：只在必要时使用
const handleClick = () => {
  setCount(c => c + 1); // 直接更新
};
```

---

### 八、常见问题

#### Q1：并发渲染会自动优化性能吗？

**答**：不会。并发渲染只是提供了**能力**，需要开发者使用 `startTransition` 等 API 手动标记。

#### Q2：所有组件都会并发渲染吗？

**答**：不会。只有被 `startTransition` 或 `useDeferredValue` 标记的更新才是并发的。

#### Q3：并发渲染会导致组件多次渲染吗？

**答**：可能会。React 可能会多次调用组件函数，但**只会提交一次**到 DOM。

```jsx
function MyComponent() {
  console.log('渲染'); // 可能打印多次
  return <div>内容</div>;
}

// 确保副作用只执行一次
useEffect(() => {
  console.log('提交'); // 只打印一次
}, []);
```

---

### 九、总结

1. **核心价值**：
   - 保持应用响应性，避免长任务阻塞主线程
   - 通过优先级调度，优先处理用户交互
   - 提升复杂应用的用户体验

2. **使用建议**：
   - 在大列表、搜索、标签页等场景使用
   - 配合 `useMemo` 避免不必要的计算
   - 使用 React DevTools Profiler 验证效果

3. **注意事项**：
   - 必须使用 `createRoot` 启用
   - 不要在受控输入上使用 `startTransition`
   - 并发渲染可能导致组件多次调用（副作用要放在 useEffect）

**面试加分点**：
- 能解释时间切片和优先级调度的原理
- 了解 Lane 模型和双缓冲 Fiber 树
- 知道并发渲染的使用场景和限制
- 能对比 `startTransition` 和 `useDeferredValue` 的区别
