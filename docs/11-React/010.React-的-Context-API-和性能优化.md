---
title: React 的 Context API 和性能优化
tags:
  - 前端React
status: robot
class: 前端React
slug: react-context-api-performance-optimization
ref:
---

## 核心要点

**Context API 用于跨组件层级传递数据，避免 props 逐层传递（prop drilling）**。核心概念：Provider 提供数据、Consumer 消费数据、useContext 简化使用。性能问题：Provider value 变化会导致所有消费者重渲染。优化方案：拆分 Context、useMemo 缓存 value、组合 Context、使用状态管理库。

---

## 详细解答

### 一、Context API 基础

#### 1. 什么是 Context
Context 提供了一种在组件树中共享数据的方式，无需通过 props 逐层传递。

```javascript
// 创建 Context
const ThemeContext = React.createContext('light');

// Provider 提供数据
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// 消费数据方式 1：useContext（推荐）
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>按钮</button>;
}

// 消费数据方式 2：Consumer
function ThemedButton() {
  return (
    <ThemeContext.Consumer>
      {theme => <button className={theme}>按钮</button>}
    </ThemeContext.Consumer>
  );
}
```

#### 2. 为什么需要 Context

**问题：Props Drilling（属性钻取）**
```javascript
// ❌ 问题：中间组件需要传递不使用的 props
function App() {
  const [user, setUser] = useState({ name: 'Alice', avatar: '/avatar.jpg' });

  return <Layout user={user} />;
}

function Layout({ user }) {
  return (
    <div>
      <Header user={user} />
      <Content user={user} />
    </div>
  );
}

function Header({ user }) {
  return <UserMenu user={user} />;
}

function UserMenu({ user }) {
  return <Avatar user={user} />;
}

function Avatar({ user }) {
  return <img src={user.avatar} alt={user.name} />;
}
```

**解决方案：使用 Context**
```javascript
// ✅ 解决：使用 Context 跨层级传递
const UserContext = createContext(null);

function App() {
  const [user, setUser] = useState({ name: 'Alice', avatar: '/avatar.jpg' });

  return (
    <UserContext.Provider value={user}>
      <Layout />
    </UserContext.Provider>
  );
}

function Layout() {
  return (
    <div>
      <Header />
      <Content />
    </div>
  );
}

function Header() {
  return <UserMenu />;
}

function UserMenu() {
  return <Avatar />;
}

function Avatar() {
  const user = useContext(UserContext); // 直接获取
  return <img src={user.avatar} alt={user.name} />;
}
```

### 二、Context API 的使用方式

#### 1. 基础用法

```javascript
// 1. 创建 Context（设置默认值）
const ThemeContext = createContext('light');

// 2. 提供数据
function App() {
  const [theme, setTheme] = useState('dark');

  return (
    <ThemeContext.Provider value={theme}>
      <Toolbar />
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        切换主题
      </button>
    </ThemeContext.Provider>
  );
}

// 3. 消费数据
function Toolbar() {
  return <ThemedButton />;
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button className={`theme-${theme}`}>按钮</button>;
}
```

#### 2. 传递复杂数据和方法

```javascript
const UserContext = createContext(null);

function App() {
  const [user, setUser] = useState(null);

  const login = useCallback((userData) => {
    setUser(userData);
  }, []);

  const logout = useCallback(() => {
    setUser(null);
  }, []);

  // 传递对象，包含状态和方法
  const value = useMemo(() => ({
    user,
    login,
    logout
  }), [user, login, logout]);

  return (
    <UserContext.Provider value={value}>
      <Dashboard />
    </UserContext.Provider>
  );
}

function Dashboard() {
  const { user, logout } = useContext(UserContext);

  if (!user) {
    return <LoginForm />;
  }

  return (
    <div>
      <h1>欢迎, {user.name}</h1>
      <button onClick={logout}>登出</button>
    </div>
  );
}

function LoginForm() {
  const { login } = useContext(UserContext);

  const handleSubmit = (e) => {
    e.preventDefault();
    login({ name: 'Alice', id: 1 });
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">登录</button>
    </form>
  );
}
```

#### 3. 多个 Context 嵌套

```javascript
const ThemeContext = createContext('light');
const UserContext = createContext(null);
const LanguageContext = createContext('en');

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <UserContext.Provider value={{ name: 'Alice' }}>
        <LanguageContext.Provider value="zh">
          <Dashboard />
        </LanguageContext.Provider>
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}

function Dashboard() {
  const theme = useContext(ThemeContext);
  const user = useContext(UserContext);
  const language = useContext(LanguageContext);

  return (
    <div className={theme}>
      {language === 'zh' ? '欢迎' : 'Welcome'}, {user.name}
    </div>
  );
}
```

### 三、Context 的性能问题

#### 1. 核心问题：不必要的重渲染

```javascript
const AppContext = createContext(null);

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('light');

  // ❌ 问题：每次渲染都创建新对象
  const value = {
    user,
    setUser,
    theme,
    setTheme
  };

  return (
    <AppContext.Provider value={value}>
      <ComponentA />
      <ComponentB />
    </AppContext.Provider>
  );
}

function ComponentA() {
  const { user } = useContext(AppContext);
  console.log('ComponentA 渲染');
  return <div>{user.name}</div>;
}

function ComponentB() {
  const { theme } = useContext(AppContext);
  console.log('ComponentB 渲染');
  return <div className={theme}>主题内容</div>;
}

// 问题：
// 1. 当 theme 改变时，ComponentA 也会重渲染（即使它只用 user）
// 2. 每次 App 渲染，value 都是新对象，触发所有消费者重渲染
```

#### 2. 问题原因分析

```javascript
// Provider 的 value 比较使用 Object.is()
// 每次渲染创建新对象，引用不同，导致重渲染

// 第一次渲染
const value1 = { user: { name: 'Alice' }, theme: 'light' };

// 第二次渲染（即使数据相同）
const value2 = { user: { name: 'Alice' }, theme: 'light' };

Object.is(value1, value2); // false - 引用不同！
```

### 四、性能优化方案

#### 方案 1：使用 useMemo 缓存 value

```javascript
function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('light');

  // ✅ 使用 useMemo 缓存对象
  const value = useMemo(() => ({
    user,
    setUser,
    theme,
    setTheme
  }), [user, theme]); // 只有依赖项变化时才创建新对象

  return (
    <AppContext.Provider value={value}>
      <ComponentA />
      <ComponentB />
    </AppContext.Provider>
  );
}
```

#### 方案 2：拆分 Context

```javascript
// ✅ 拆分为多个独立的 Context
const UserContext = createContext(null);
const ThemeContext = createContext('light');

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('light');

  const userValue = useMemo(() => ({ user, setUser }), [user]);
  const themeValue = useMemo(() => ({ theme, setTheme }), [theme]);

  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        <ComponentA />
        <ComponentB />
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// ComponentA 只订阅 UserContext
function ComponentA() {
  const { user } = useContext(UserContext);
  console.log('ComponentA 渲染');
  return <div>{user.name}</div>;
}

// ComponentB 只订阅 ThemeContext
function ComponentB() {
  const { theme } = useContext(ThemeContext);
  console.log('ComponentB 渲染');
  return <div className={theme}>主题内容</div>;
}

// 现在：theme 改变时，ComponentA 不会重渲染 ✅
```

#### 方案 3：拆分状态和方法

```javascript
// 将频繁变化的状态和不变的方法分开
const UserStateContext = createContext(null);
const UserActionsContext = createContext(null);

function UserProvider({ children }) {
  const [user, setUser] = useState(null);

  // 方法用 useCallback 稳定引用
  const actions = useMemo(() => ({
    login: (userData) => setUser(userData),
    logout: () => setUser(null),
    updateProfile: (updates) => setUser(prev => ({ ...prev, ...updates }))
  }), []);

  return (
    <UserActionsContext.Provider value={actions}>
      <UserStateContext.Provider value={user}>
        {children}
      </UserStateContext.Provider>
    </UserActionsContext.Provider>
  );
}

// 自定义 Hooks 简化使用
function useUserState() {
  return useContext(UserStateContext);
}

function useUserActions() {
  return useContext(UserActionsContext);
}

// 使用
function UserProfile() {
  const user = useUserState(); // 只有 user 变化时重渲染
  return <div>{user?.name}</div>;
}

function LoginButton() {
  const { login } = useUserActions(); // actions 不变，永不重渲染
  return <button onClick={() => login({ name: 'Alice' })}>登录</button>;
}
```

#### 方案 4：使用 React.memo 隔离更新

```javascript
const CountContext = createContext(0);

function App() {
  const [count, setCount] = useState(0);

  return (
    <CountContext.Provider value={count}>
      <ExpensiveTree />
      <button onClick={() => setCount(c => c + 1)}>增加</button>
    </CountContext.Provider>
  );
}

// ❌ 问题：count 变化时，整个 ExpensiveTree 都会重渲染
function ExpensiveTree() {
  return (
    <div>
      <ComponentA />
      <ComponentB />
      <CountDisplay />
    </div>
  );
}

// ✅ 解决方案：将使用 Context 的部分用 memo 包裹
const ExpensiveTree = React.memo(function ExpensiveTree() {
  return (
    <div>
      <ComponentA />
      <ComponentB />
      <CountDisplay />
    </div>
  );
});

// 或者更精细地控制
function App() {
  const [count, setCount] = useState(0);

  return (
    <CountContext.Provider value={count}>
      <ExpensiveTreeWrapper />
      <button onClick={() => setCount(c => c + 1)}>增加</button>
    </CountContext.Provider>
  );
}

function ExpensiveTreeWrapper() {
  return (
    <div>
      <MemoizedComponentA />
      <MemoizedComponentB />
      <CountDisplay />
    </div>
  );
}

const MemoizedComponentA = React.memo(ComponentA);
const MemoizedComponentB = React.memo(ComponentB);
```

#### 方案 5：使用 Context Selector 模式

```javascript
// 自定义实现 Context Selector
function createContextSelector(context) {
  return function useContextSelector(selector) {
    const value = useContext(context);
    const selectedValue = selector(value);

    // 使用 ref 保存上次的值
    const prevRef = useRef(selectedValue);

    // 只有选中的值变化时才触发重渲染
    useEffect(() => {
      prevRef.current = selectedValue;
    });

    return selectedValue;
  };
}

const AppContext = createContext(null);

function App() {
  const [state, setState] = useState({
    user: { name: 'Alice' },
    theme: 'light',
    count: 0
  });

  const value = useMemo(() => ({ state, setState }), [state]);

  return (
    <AppContext.Provider value={value}>
      <ComponentA />
      <ComponentB />
      <button onClick={() => setState(s => ({ ...s, count: s.count + 1 }))}>
        增加计数
      </button>
    </AppContext.Provider>
  );
}

// 使用 selector 只订阅需要的部分
const useAppContextSelector = createContextSelector(AppContext);

function ComponentA() {
  const userName = useAppContextSelector(({ state }) => state.user.name);
  console.log('ComponentA 渲染');
  return <div>{userName}</div>;
}

function ComponentB() {
  const theme = useAppContextSelector(({ state }) => state.theme);
  console.log('ComponentB 渲染');
  return <div className={theme}>主题</div>;
}

// 现在：count 变化时，ComponentA 和 ComponentB 都不会重渲染 ✅
```

#### 方案 6：使用第三方库

```javascript
// 使用 use-context-selector 库
import { createContext, useContextSelector } from 'use-context-selector';

const AppContext = createContext(null);

function App() {
  const [state, setState] = useState({
    user: { name: 'Alice' },
    theme: 'light',
    count: 0
  });

  return (
    <AppContext.Provider value={{ state, setState }}>
      <ComponentA />
      <ComponentB />
    </AppContext.Provider>
  );
}

function ComponentA() {
  // 只订阅 user.name
  const userName = useContextSelector(
    AppContext,
    ({ state }) => state.user.name
  );
  return <div>{userName}</div>;
}

function ComponentB() {
  // 只订阅 theme
  const theme = useContextSelector(
    AppContext,
    ({ state }) => state.theme
  );
  return <div className={theme}>主题</div>;
}
```

### 五、Context 的最佳实践

#### 1. 创建自定义 Provider 组件

```javascript
// ✅ 封装 Context 逻辑
const ThemeContext = createContext(null);

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const value = useMemo(() => ({
    theme,
    toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light')
  }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 自定义 Hook 简化使用
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 使用
function App() {
  return (
    <ThemeProvider>
      <Dashboard />
    </ThemeProvider>
  );
}

function Dashboard() {
  const { theme, toggleTheme } = useTheme();
  return (
    <div className={theme}>
      <button onClick={toggleTheme}>切换主题</button>
    </div>
  );
}
```

#### 2. 合理设置默认值

```javascript
// ✅ 提供有意义的默认值
const ThemeContext = createContext({
  theme: 'light',
  toggleTheme: () => console.warn('ThemeProvider not found')
});

// 或使用 null 并在 Hook 中检查
const UserContext = createContext(null);

function useUser() {
  const context = useContext(UserContext);
  if (context === null) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}
```

#### 3. 避免过度使用 Context

```javascript
// ❌ 不要为简单的 props 使用 Context
function App() {
  const [count, setCount] = useState(0);
  return (
    <CountContext.Provider value={count}>
      <Parent />
    </CountContext.Provider>
  );
}

function Parent() {
  return <Child />;
}

function Child() {
  const count = useContext(CountContext);
  return <div>{count}</div>;
}

// ✅ 简单场景直接传 props
function App() {
  const [count, setCount] = useState(0);
  return <Parent count={count} />;
}

function Parent({ count }) {
  return <Child count={count} />;
}

function Child({ count }) {
  return <div>{count}</div>;
}
```

### 六、Context vs 状态管理库

| 特性 | Context API | Redux/Zustand |
|------|------------|---------------|
| **学习成本** | 低（React 内置） | 中到高 |
| **性能优化** | 需手动优化 | 内置优化 |
| **DevTools** | 无 | 有 |
| **中间件** | 无 | 有（Redux） |
| **适用场景** | 轻量级状态共享 | 复杂应用状态管理 |

**使用建议：**
- **使用 Context**：主题、国际化、用户信息等不频繁变化的全局状态
- **使用状态管理库**：频繁变化、复杂交互、需要中间件的应用状态

### 七、面试回答要点总结

1. **定义**：Context 提供跨组件层级共享数据的方式，避免 props drilling
2. **核心 API**：createContext、Provider、useContext（或 Consumer）
3. **性能问题**：Provider value 变化导致所有消费者重渲染，引用相等性检查
4. **优化方案**：
   - useMemo 缓存 value
   - 拆分 Context（按功能/频率）
   - 分离状态和方法
   - React.memo 隔离更新
   - Context Selector 模式
5. **最佳实践**：封装 Provider、自定义 Hook、错误边界、合理默认值
6. **使用场景**：主题、国际化、用户认证、全局配置等轻量级状态共享
