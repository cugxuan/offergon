---
title: React 的状态管理方案对比（Redux vs Zustand vs Jotai）
tags:
  - React
status: robot
class: 前端React
slug: react-state-management-redux-vs-zustand-vs-jotai
ref:
---

## 核心要点

**React 状态管理方案经历了从 Redux 单一巨石到 Zustand/Jotai 等轻量化、原子化的演进，选择时需权衡项目规模、团队熟悉度、性能需求和开发体验。**

快速对比：
- 🏛️ **Redux**: 集中式、可预测、工具链完善，适合大型应用和复杂业务逻辑
- 🪶 **Zustand**: 极简 API、基于 Hooks、无样板代码，适合中小型项目
- ⚛️ **Jotai**: 原子化状态、细粒度更新、React 18 优先，适合性能敏感场景

---

## 详细解答

### 一、Redux：老牌集中式状态管理

#### 1. 核心概念

Redux 遵循 **Flux 架构**，采用单向数据流和集中式 Store。

```
Action → Dispatch → Reducer → Store → View
          ↑                              ↓
          └──────── User Interaction ────┘
```

#### 2. 基本用法

```javascript
// ========== 传统 Redux ==========
// store.js
import { createStore } from 'redux'

const initialState = {
  count: 0,
  user: null
}

function rootReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 }
    case 'SET_USER':
      return { ...state, user: action.payload }
    default:
      return state
  }
}

const store = createStore(rootReducer)

// actions.js
export const increment = () => ({ type: 'INCREMENT' })
export const setUser = (user) => ({ type: 'SET_USER', payload: user })

// Component.jsx
import { useDispatch, useSelector } from 'react-redux'
import { increment } from './actions'

function Counter() {
  const count = useSelector(state => state.count)
  const dispatch = useDispatch()

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+1</button>
    </div>
  )
}
```

#### 3. Redux Toolkit (现代最佳实践)

```javascript
// ========== Redux Toolkit (RTK) ==========
// counterSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

// 异步 thunk
export const fetchUser = createAsyncThunk(
  'user/fetch',
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`)
    return response.json()
  }
)

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    count: 0,
    user: null,
    status: 'idle'
  },
  reducers: {
    increment: (state) => {
      // 使用 Immer，可直接修改 state
      state.count += 1
    },
    decrement: (state) => {
      state.count -= 1
    },
    incrementByAmount: (state, action) => {
      state.count += action.payload
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.status = 'succeeded'
        state.user = action.payload
      })
      .addCase(fetchUser.rejected, (state) => {
        state.status = 'failed'
      })
  }
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions
export default counterSlice.reducer

// store.js
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from './counterSlice'

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
})

// Component.jsx
import { useDispatch, useSelector } from 'react-redux'
import { increment, fetchUser } from './counterSlice'

function App() {
  const { count, user, status } = useSelector(state => state.counter)
  const dispatch = useDispatch()

  useEffect(() => {
    dispatch(fetchUser(123))
  }, [])

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+1</button>
      {status === 'loading' && <p>Loading user...</p>}
      {user && <p>User: {user.name}</p>}
    </div>
  )
}
```

#### 4. Redux 优势

✅ **强大的开发工具**
- Redux DevTools：时间旅行调试、状态快照、动作回放
- 完整的状态历史记录

✅ **可预测性**
- 纯函数 Reducer，相同输入必然得到相同输出
- 严格的单向数据流

✅ **生态系统成熟**
- redux-saga / redux-thunk / RTK Query（异步处理）
- redux-persist（状态持久化）
- reselect（记忆化选择器）

✅ **适合大型应用**
- 严格的代码组织规范
- 易于团队协作和代码审查

#### 5. Redux 劣势

❌ **样板代码多**（即使使用 RTK 也需要较多配置）
❌ **学习曲线陡峭**（Action、Reducer、Middleware、Selector 等概念）
❌ **性能开销**（所有 selector 在每次 dispatch 后都会重新执行）
❌ **过度工程化**（小型项目使用 Redux 可能杀鸡用牛刀）

---

### 二、Zustand：极简主义的 Hook-First 方案

#### 1. 核心理念

Zustand (德语"状态") 采用 **Hook-First** 设计，抛弃 Redux 的样板代码，直接使用函数式 API。

#### 2. 基本用法

```javascript
// ========== Zustand ==========
// store.js
import { create } from 'zustand'

const useStore = create((set, get) => ({
  // 状态
  count: 0,
  user: null,
  todos: [],

  // 同步 actions
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),

  // 异步 actions
  fetchUser: async (userId) => {
    const response = await fetch(`/api/users/${userId}`)
    const user = await response.json()
    set({ user })
  },

  // 复杂逻辑（可访问当前状态）
  addTodo: (text) => {
    const newTodo = { id: Date.now(), text, done: false }
    set((state) => ({ todos: [...state.todos, newTodo] }))
  },

  toggleTodo: (id) => {
    set((state) => ({
      todos: state.todos.map(todo =>
        todo.id === id ? { ...todo, done: !todo.done } : todo
      )
    }))
  },

  // 使用 get() 访问其他状态
  getActiveTodos: () => {
    return get().todos.filter(todo => !todo.done)
  }
}))

export default useStore

// Component.jsx
import useStore from './store'

function Counter() {
  // 选择需要的状态（自动订阅）
  const count = useStore(state => state.count)
  const increment = useStore(state => state.increment)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  )
}

function UserProfile() {
  const user = useStore(state => state.user)
  const fetchUser = useStore(state => state.fetchUser)

  useEffect(() => {
    fetchUser(123)
  }, [])

  return user ? <p>{user.name}</p> : <p>Loading...</p>
}
```

#### 3. 高级特性

**3.1 中间件（Middleware）**

```javascript
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

const useStore = create(
  devtools(
    persist(
      (set) => ({
        count: 0,
        increment: () => set((state) => ({ count: state.count + 1 }))
      }),
      {
        name: 'counter-storage', // localStorage key
        partialize: (state) => ({ count: state.count }) // 只持久化部分状态
      }
    )
  )
)
```

**3.2 切片模式（Slice Pattern）**

```javascript
// userSlice.js
const createUserSlice = (set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null })
})

// counterSlice.js
const createCounterSlice = (set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
})

// store.js
const useStore = create((...a) => ({
  ...createUserSlice(...a),
  ...createCounterSlice(...a)
}))
```

**3.3 选择器优化**

```javascript
import { shallow } from 'zustand/shallow'

// ❌ 问题：每次 store 更新都会重新渲染
function BadComponent() {
  const { count, user } = useStore(state => ({
    count: state.count,
    user: state.user
  }))
  // 每次都会创建新对象，导致重新渲染
}

// ✅ 方案 1：使用 shallow 比较
function GoodComponent() {
  const { count, user } = useStore(
    state => ({ count: state.count, user: state.user }),
    shallow
  )
}

// ✅ 方案 2：分别订阅
function BetterComponent() {
  const count = useStore(state => state.count)
  const user = useStore(state => state.user)
}
```

#### 4. Zustand 优势

✅ **极简 API**（单个 `create` 函数搞定所有）
✅ **零样板代码**（无需 Provider、Actions、Reducers）
✅ **体积小**（压缩后仅 1.2KB）
✅ **TypeScript 友好**（完整类型推导）
✅ **可在 React 外使用**（原生 JS 也能用）
✅ **性能优秀**（基于订阅机制，精准更新）

#### 5. Zustand 劣势

❌ **缺少严格约束**（自由度高可能导致代码混乱）
❌ **DevTools 功能较弱**（相比 Redux DevTools）
❌ **中间件生态较小**

---

### 三、Jotai：原子化状态的未来

#### 1. 核心理念

Jotai (日语"状态") 受 Recoil 启发，采用 **原子化 (Atomic)** 设计，每个状态是独立的原子 (atom)，组件只订阅需要的原子。

```
传统模式：Store → Selector → Component（粗粒度）
Jotai：  Atom → Component（细粒度）
```

#### 2. 基本用法

```javascript
// ========== Jotai ==========
// atoms.js
import { atom } from 'jotai'

// 原始原子
export const countAtom = atom(0)
export const userAtom = atom(null)

// 派生原子（类似计算属性）
export const doubleCountAtom = atom(
  (get) => get(countAtom) * 2
)

// 可写派生原子
export const incrementAtom = atom(
  (get) => get(countAtom),
  (get, set) => set(countAtom, get(countAtom) + 1)
)

// 异步原子
export const userDataAtom = atom(async (get) => {
  const userId = get(userIdAtom)
  const response = await fetch(`/api/users/${userId}`)
  return response.json()
})

// Component.jsx
import { useAtom, useAtomValue, useSetAtom } from 'jotai'
import { countAtom, doubleCountAtom, incrementAtom } from './atoms'

function Counter() {
  // useAtom：读 + 写
  const [count, setCount] = useAtom(countAtom)

  // useAtomValue：只读
  const doubleCount = useAtomValue(doubleCountAtom)

  // useSetAtom：只写（性能优化，不会因读值变化而重渲染）
  const increment = useSetAtom(incrementAtom)

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <button onClick={increment}>Increment Atom</button>
    </div>
  )
}
```

#### 3. 高级特性

**3.1 原子依赖关系**

```javascript
import { atom } from 'jotai'

// 依赖链：A → B → C
const userIdAtom = atom(1)

const userAtom = atom(async (get) => {
  const userId = get(userIdAtom) // 依赖 userIdAtom
  const res = await fetch(`/api/users/${userId}`)
  return res.json()
})

const userNameAtom = atom((get) => {
  const user = get(userAtom) // 依赖 userAtom
  return user?.name ?? 'Anonymous'
})

// 当 userIdAtom 变化时，userAtom 和 userNameAtom 会自动重新计算
```

**3.2 原子家族 (Atom Families)**

```javascript
import { atomFamily } from 'jotai/utils'

// 动态创建原子（类似 React Query 的 key）
const todoAtomFamily = atomFamily((id) =>
  atom(async () => {
    const res = await fetch(`/api/todos/${id}`)
    return res.json()
  })
)

function TodoItem({ id }) {
  const todo = useAtomValue(todoAtomFamily(id))
  return <div>{todo.title}</div>
}
```

**3.3 持久化**

```javascript
import { atomWithStorage } from 'jotai/utils'

// 自动同步到 localStorage
const darkModeAtom = atomWithStorage('darkMode', false)

function ThemeToggle() {
  const [darkMode, setDarkMode] = useAtom(darkModeAtom)
  return (
    <button onClick={() => setDarkMode(!darkMode)}>
      {darkMode ? '🌙' : '☀️'}
    </button>
  )
}
```

**3.4 异步操作与 Suspense**

```javascript
import { Suspense } from 'react'
import { atom, useAtomValue } from 'jotai'

const postsAtom = atom(async () => {
  const res = await fetch('/api/posts')
  return res.json()
})

function Posts() {
  const posts = useAtomValue(postsAtom) // 异步原子自动触发 Suspense
  return (
    <ul>
      {posts.map(post => <li key={post.id}>{post.title}</li>)}
    </ul>
  )
}

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Posts />
    </Suspense>
  )
}
```

#### 4. Jotai 优势

✅ **细粒度更新**（只更新使用该原子的组件，性能极佳）
✅ **天然支持 Suspense 和 Concurrent Mode**
✅ **TypeScript 极致体验**（完美类型推导）
✅ **无需 Provider**（可选的 Provider 用于作用域隔离）
✅ **调试友好**（每个原子可单独追踪）
✅ **适合复杂依赖关系**（原子间依赖自动管理）

#### 5. Jotai 劣势

❌ **学习新概念**（原子化思维需要适应）
❌ **原子碎片化**（原子过多时管理复杂）
❌ **生态较新**（文档和社区相对较小）

---

### 四、综合对比表

| 维度 | Redux (RTK) | Zustand | Jotai |
|------|------------|---------|-------|
| **Bundle 大小** | ~15KB (RTK) | 1.2KB | 2.9KB |
| **学习曲线** | 陡峭 | 平缓 | 中等 |
| **样板代码** | 中等（RTK 已简化） | 极少 | 少 |
| **TypeScript** | 良好（需手动定义） | 优秀（自动推导） | 极致（完美推导） |
| **DevTools** | 强大（Redux DevTools） | 基础（需中间件） | 基础（官方工具） |
| **性能** | 良好（selector 优化） | 优秀（订阅机制） | 极致（原子化更新） |
| **异步处理** | RTK Query / Thunk / Saga | 内置 async/await | 原生 async atom + Suspense |
| **中间件** | 丰富 | 有（官方 + 社区） | 有限 |
| **持久化** | redux-persist | zustand/middleware | jotai/utils |
| **React 外使用** | 可以（需配置） | 原生支持 | 不支持 |
| **适用场景** | 大型应用、复杂业务 | 中小型项目 | 性能敏感、React 18+ |

---

### 五、实战选择指南

#### 场景 1：大型企业级应用（电商、后台管理）

**推荐 Redux Toolkit**

```javascript
// 复杂的业务逻辑和中间件
import { configureStore } from '@reduxjs/toolkit'
import { api } from './services/api' // RTK Query

const store = configureStore({
  reducer: {
    auth: authReducer,
    products: productsReducer,
    cart: cartReducer,
    orders: ordersReducer,
    [api.reducerPath]: api.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(
      api.middleware,
      loggerMiddleware,
      analyticsMiddleware
    )
})
```

**理由**：
- 严格的代码规范便于团队协作
- Redux DevTools 强大的调试能力
- 成熟的异步方案（RTK Query 替代 React Query）
- 完善的生态系统

#### 场景 2：中小型创业项目（快速迭代）

**推荐 Zustand**

```javascript
// 快速开发，无需复杂配置
const useAppStore = create((set, get) => ({
  user: null,
  theme: 'light',
  notifications: [],

  login: async (credentials) => {
    const user = await authApi.login(credentials)
    set({ user })
  },

  toggleTheme: () => set(state => ({
    theme: state.theme === 'light' ? 'dark' : 'light'
  })),

  addNotification: (message) => set(state => ({
    notifications: [...state.notifications, { id: Date.now(), message }]
  }))
}))
```

**理由**：
- 开发速度快，代码量少
- 易于重构和调整
- 学习成本低，新成员快速上手
- 性能足够好

#### 场景 3：高性能 Dashboard（大量数据可视化）

**推荐 Jotai**

```javascript
// 细粒度状态管理，避免不必要的重渲染
import { atom } from 'jotai'
import { atomFamily } from 'jotai/utils'

// 每个图表是独立的原子
const chartDataFamily = atomFamily((chartId) =>
  atom(async () => {
    const res = await fetch(`/api/charts/${chartId}`)
    return res.json()
  })
)

const selectedChartIdAtom = atom('chart1')
const selectedChartDataAtom = atom((get) =>
  get(chartDataFamily(get(selectedChartIdAtom)))
)

// 只有使用该图表数据的组件会更新
function Chart({ id }) {
  const data = useAtomValue(chartDataFamily(id))
  return <HeavyChart data={data} />
}
```

**理由**：
- 原子化更新避免全局重渲染
- 天然支持 Suspense，优化加载体验
- 依赖追踪自动化

#### 场景 4：服务端渲染 (SSR) 应用

**推荐 Redux 或 Zustand**

```javascript
// Redux SSR
// server.js
const store = createStore(rootReducer)
const initialState = store.getState()
const html = renderToString(<App store={store} />)
// 将 initialState 注入 HTML

// client.js
const preloadedState = window.__INITIAL_STATE__
const store = createStore(rootReducer, preloadedState)
```

**理由**：
- Redux 和 Zustand 对 SSR 支持更成熟
- Jotai 的 SSR 支持相对复杂（需要特殊处理）

---

### 六、迁移策略

#### 从 Redux 迁移到 Zustand

```javascript
// Redux 代码
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1 },
    decrement: (state) => { state.value -= 1 }
  }
})

// Zustand 等效代码
const useCounterStore = create((set) => ({
  value: 0,
  increment: () => set(state => ({ value: state.value + 1 })),
  decrement: () => set(state => ({ value: state.value - 1 }))
}))

// 组件迁移
// Before (Redux)
const value = useSelector(state => state.counter.value)
const dispatch = useDispatch()
dispatch(increment())

// After (Zustand)
const value = useCounterStore(state => state.value)
const increment = useCounterStore(state => state.increment)
increment()
```

#### 混合使用策略

```javascript
// 渐进式迁移：Redux 主状态 + Zustand 局部状态
// Redux: 全局用户状态、路由状态
const store = configureStore({ reducer: { auth: authReducer } })

// Zustand: 页面级临时状态
const usePageStore = create((set) => ({
  filter: 'all',
  setFilter: (filter) => set({ filter })
}))

function App() {
  return (
    <Provider store={store}>
      <Routes>
        <Route path="/products" element={<ProductsPage />} />
      </Routes>
    </Provider>
  )
}

function ProductsPage() {
  const user = useSelector(state => state.auth.user) // Redux
  const filter = usePageStore(state => state.filter) // Zustand
  // ...
}
```

---

### 七、最佳实践总结

#### Redux 最佳实践
1. ✅ 使用 Redux Toolkit，避免手写 action types
2. ✅ 用 RTK Query 替代手动管理异步状态
3. ✅ 使用 `createEntityAdapter` 管理规范化数据
4. ✅ 合理拆分 slice，避免单个 reducer 过大

#### Zustand 最佳实践
1. ✅ 使用切片模式组织大型 store
2. ✅ 用 `shallow` 或分别订阅避免不必要的重渲染
3. ✅ 异步逻辑放在 action 中，保持 UI 组件纯粹
4. ✅ 利用 middleware 扩展功能（devtools、persist）

#### Jotai 最佳实践
1. ✅ 保持原子粒度细，一个原子只管一件事
2. ✅ 用派生原子（derived atoms）代替 useMemo
3. ✅ 异步原子结合 Suspense 使用
4. ✅ 使用 `atomFamily` 管理动态数据列表

---

## 总结

选择状态管理方案没有银弹，需要综合考虑：

| 如果你的项目... | 推荐方案 |
|----------------|---------|
| 是大型企业应用，需要严格规范 | **Redux Toolkit** |
| 是中小型项目，追求开发效率 | **Zustand** |
| 对性能极致要求，大量细粒度状态 | **Jotai** |
| 需要强大的 DevTools 和调试能力 | **Redux** |
| 团队对 React 18+ 特性熟悉 | **Jotai** |
| 需要在 React 外使用状态 | **Zustand** |

**趋势**：Redux 仍是大型项目首选，Zustand 是新项目的热门选择，Jotai 代表着未来方向（原子化 + Concurrent）。掌握多种方案，根据场景灵活选择才是最佳策略。
