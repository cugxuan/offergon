---
title: Next.js 的 App Router 和 Pages Router 区别
tags:
  - 前端React
status: robot
class: 前端React
slug: nextjs-app-router-vs-pages-router
ref:
---

## 核心要点

**App Router vs Pages Router 的本质**：App Router（Next.js 13+）基于 React Server Components 构建，支持嵌套布局、流式渲染、细粒度数据获取；Pages Router 是传统的文件系统路由，使用 getServerSideProps/getStaticProps 进行数据获取。App Router 代表了 Next.js 的未来，但 Pages Router 依然稳定且向后兼容。

---

## 详细回答

### 一、Pages Router（传统方案）

#### 1. 核心特性

Pages Router 是 Next.js 从 v1 开始就存在的路由系统，基于 `pages/` 目录的文件系统路由。

**目录结构**：

```
pages/
├── index.tsx              → /
├── about.tsx              → /about
├── blog/
│   ├── index.tsx          → /blog
│   └── [slug].tsx         → /blog/:slug
├── api/
│   └── users.ts           → /api/users
└── _app.tsx               → 全局布局
```

#### 2. 数据获取方式

```tsx
// pages/posts/[id].tsx
import { GetServerSideProps, GetStaticProps, GetStaticPaths } from 'next';

// ① 服务端渲染（每次请求）
export const getServerSideProps: GetServerSideProps = async (context) => {
  const post = await fetchPost(context.params.id);
  return { props: { post } };
};

// ② 静态生成（构建时）
export const getStaticProps: GetStaticProps = async (context) => {
  const post = await fetchPost(context.params.id);
  return {
    props: { post },
    revalidate: 60, // ISR
  };
};

// ③ 动态路由的静态路径
export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await fetchAllPosts();
  return {
    paths: posts.map(p => ({ params: { id: p.id } })),
    fallback: 'blocking',
  };
};

export default function PostPage({ post }) {
  return <div>{post.title}</div>;
}
```

#### 3. 布局系统

**全局布局**（`_app.tsx`）：

```tsx
// pages/_app.tsx
export default function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  );
}
```

**嵌套布局**（需手动实现）：

```tsx
// pages/dashboard/settings.tsx
import DashboardLayout from '@/layouts/DashboardLayout';

export default function Settings() {
  return <div>Settings Content</div>;
}

Settings.getLayout = function getLayout(page) {
  return <DashboardLayout>{page}</DashboardLayout>;
};
```

#### 4. 路由导航

```tsx
import { useRouter } from 'next/router';
import Link from 'next/link';

export default function Page() {
  const router = useRouter();
  const { id } = router.query; // 获取路由参数

  const handleClick = () => {
    router.push('/dashboard'); // 编程式导航
  };

  return <Link href="/about">About</Link>; // 声明式导航
}
```

---

### 二、App Router（新架构 - Next.js 13+）

#### 1. 核心特性

App Router 引入了全新的路由系统，基于 `app/` 目录，深度集成 React Server Components。

**目录结构**：

```
app/
├── layout.tsx             → 根布局（必需）
├── page.tsx               → / 首页
├── about/
│   └── page.tsx           → /about
├── blog/
│   ├── layout.tsx         → /blog 的布局
│   ├── page.tsx           → /blog
│   └── [slug]/
│       └── page.tsx       → /blog/:slug
├── dashboard/
│   ├── layout.tsx         → 嵌套布局
│   ├── page.tsx           → /dashboard
│   └── settings/
│       └── page.tsx       → /dashboard/settings
└── api/
    └── users/
        └── route.ts       → /api/users
```

#### 2. Server Components 与 Client Components

**Server Component**（默认）：

```tsx
// app/posts/[id]/page.tsx
// 默认是 Server Component，在服务器执行
export default async function PostPage({ params }: { params: { id: string } }) {
  // 直接在组件内 async/await 获取数据
  const post = await fetch(`https://api.example.com/posts/${params.id}`).then(res => res.json());

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}

// 生成静态参数（类似 getStaticPaths）
export async function generateStaticParams() {
  const posts = await fetchAllPosts();
  return posts.map(post => ({ id: post.id }));
}

// 控制渲染策略
export const dynamic = 'force-dynamic'; // 强制动态渲染（SSR）
export const revalidate = 3600; // ISR（1小时）
```

**Client Component**（需显式声明）：

```tsx
// app/components/Counter.tsx
'use client'; // 必须在文件顶部声明

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

**组合使用**：

```tsx
// app/dashboard/page.tsx (Server Component)
import ClientComponent from './ClientComponent';

export default async function Dashboard() {
  const data = await fetchData(); // 服务器获取数据

  return (
    <div>
      <h1>Dashboard</h1>
      <ServerSideData data={data} />
      <ClientComponent /> {/* 客户端交互组件 */}
    </div>
  );
}
```

#### 3. 嵌套布局系统

App Router 的布局自动嵌套，无需手动配置：

```tsx
// app/layout.tsx（根布局）
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Header />
        {children}
        <Footer />
      </body>
    </html>
  );
}

// app/dashboard/layout.tsx（嵌套布局）
export default function DashboardLayout({ children }) {
  return (
    <div className="dashboard">
      <Sidebar />
      <main>{children}</main>
    </div>
  );
}

// app/dashboard/settings/page.tsx
export default function Settings() {
  return <div>Settings</div>;
}

// 渲染结果：
// <RootLayout>
//   <DashboardLayout>
//     <Settings />
//   </DashboardLayout>
// </RootLayout>
```

**布局特性**：

- 布局在路由切换时**保持状态**（不重新挂载）
- 布局可以访问路由参数和 searchParams
- 支持 `loading.tsx` 和 `error.tsx` 特殊文件

#### 4. 数据获取的革命性变化

**Pages Router 的问题**：

```tsx
// pages/post/[id].tsx
export async function getServerSideProps({ params }) {
  const post = await fetchPost(params.id);
  const comments = await fetchComments(params.id);
  const author = await fetchAuthor(post.authorId);

  // 所有数据在一个地方获取，组件无法控制
  return { props: { post, comments, author } };
}
```

**App Router 的解决方案**：

```tsx
// app/post/[id]/page.tsx
async function Post({ id }: { id: string }) {
  const post = await fetchPost(id); // 组件内获取
  return <div>{post.title}</div>;
}

async function Comments({ postId }: { postId: string }) {
  const comments = await fetchComments(postId); // 另一个组件独立获取
  return <ul>{comments.map(c => <li key={c.id}>{c.text}</li>)}</ul>;
}

export default async function PostPage({ params }) {
  return (
    <div>
      <Post id={params.id} />
      <Suspense fallback={<CommentsLoading />}>
        <Comments postId={params.id} />
      </Suspense>
    </div>
  );
}
```

**自动请求去重**：

```tsx
// app/post/[id]/page.tsx
async function fetchPost(id: string) {
  // Next.js 自动缓存和去重相同的 fetch 请求
  const res = await fetch(`https://api.example.com/posts/${id}`);
  return res.json();
}

export default async function Page({ params }) {
  const post1 = await fetchPost(params.id); // 发起请求
  const post2 = await fetchPost(params.id); // 使用缓存，不重复请求
  // post1 === post2
}
```

#### 5. 流式渲染与 Suspense

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';

async function SlowComponent() {
  await new Promise(resolve => setTimeout(resolve, 3000));
  return <div>Slow data loaded</div>;
}

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <FastContent />

      <Suspense fallback={<div>Loading slow data...</div>}>
        <SlowComponent />
      </Suspense>
    </div>
  );
}

// 渲染流程：
// 1. 立即发送 <h1>Dashboard</h1> + <FastContent />
// 2. 显示 "Loading slow data..."
// 3. 3秒后流式发送 <SlowComponent /> 的 HTML
```

#### 6. 路由导航

```tsx
// app/components/Navigation.tsx
'use client';

import { useRouter, usePathname, useSearchParams } from 'next/navigation';
import Link from 'next/link';

export default function Navigation() {
  const router = useRouter();
  const pathname = usePathname(); // 当前路径
  const searchParams = useSearchParams(); // URL 参数

  return (
    <>
      <Link href="/dashboard">Dashboard</Link>
      <button onClick={() => router.push('/settings')}>
        Go to Settings
      </button>
      <p>Current path: {pathname}</p>
    </>
  );
}
```

---

### 三、核心差异对比

| 特性 | Pages Router | App Router |
|------|-------------|-----------|
| **目录** | `pages/` | `app/` |
| **React 版本** | 支持所有版本 | 需要 React 18+ |
| **组件类型** | 客户端组件 | Server Components（默认） + Client Components |
| **数据获取** | `getServerSideProps`、`getStaticProps` | 组件内 `async/await` |
| **布局系统** | 手动实现（通过 `_app.tsx`） | 原生嵌套布局（`layout.tsx`） |
| **加载状态** | 手动实现 | `loading.tsx` 文件约定 |
| **错误处理** | `_error.tsx` | `error.tsx`（支持错误边界） |
| **流式渲染** | 不支持 | 原生支持（Suspense + Streaming） |
| **并行路由** | 不支持 | 支持（Parallel Routes） |
| **拦截路由** | 不支持 | 支持（Intercepting Routes） |
| **数据缓存** | 手动控制 | 自动缓存和去重 |
| **路由组** | 不支持 | 支持（`(group)` 语法） |

### 四、高级特性对比

#### 1. Parallel Routes（并行路由）

App Router 独有功能，允许同时渲染多个页面：

```
app/
├── layout.tsx
├── @team/
│   └── page.tsx           → 团队槽位
├── @analytics/
│   └── page.tsx           → 分析槽位
└── page.tsx               → 主内容
```

```tsx
// app/layout.tsx
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode;
  team: React.ReactNode;
  analytics: React.ReactNode;
}) {
  return (
    <div>
      <div>{children}</div>
      <div className="sidebar">
        {team}
        {analytics}
      </div>
    </div>
  );
}
```

#### 2. Intercepting Routes（拦截路由）

创建模态框等场景：

```
app/
├── feed/
│   └── page.tsx           → /feed
├── photo/
│   └── [id]/
│       └── page.tsx       → /photo/123
└── @modal/
    └── (..)photo/
        └── [id]/
            └── page.tsx   → 拦截 /photo/123，显示模态框
```

#### 3. Route Groups（路由组）

组织路由而不影响 URL 结构：

```
app/
├── (marketing)/
│   ├── layout.tsx         → 营销页面布局
│   ├── about/
│   │   └── page.tsx       → /about (无 marketing 前缀)
│   └── contact/
│       └── page.tsx       → /contact
└── (shop)/
    ├── layout.tsx         → 商店布局
    └── products/
        └── page.tsx       → /products
```

### 五、性能对比

#### 1. 包体积

**Pages Router**：
- 所有组件都是客户端组件
- 整个页面的 JavaScript 都会发送到客户端

```tsx
// pages/index.tsx
import HeavyLibrary from 'heavy-library'; // 整个库发送到客户端

export default function Home({ data }) {
  return <HeavyLibrary data={data} />;
}
```

**App Router**：
- Server Components 的代码**不会发送到客户端**
- 只有 Client Components 的代码才会打包

```tsx
// app/page.tsx (Server Component)
import HeavyLibrary from 'heavy-library'; // 仅在服务器运行

export default async function Home() {
  const data = await fetchData();
  const processed = HeavyLibrary.process(data); // 服务器处理
  return <DisplayData data={processed} />; // 只发送结果
}
```

**实际效果**：

```
Pages Router:  Bundle size: 200KB (包含 heavy-library)
App Router:    Bundle size: 50KB  (heavy-library 仅服务器运行)
```

#### 2. 数据获取性能

**Pages Router（瀑布流）**：

```tsx
// pages/post/[id].tsx
export async function getServerSideProps({ params }) {
  const post = await fetchPost(params.id);        // 1秒
  const author = await fetchAuthor(post.authorId); // 1秒
  const related = await fetchRelated(post.tags);   // 1秒
  // 总时间：3秒（串行）
  return { props: { post, author, related } };
}
```

**App Router（并行 + 流式）**：

```tsx
// app/post/[id]/page.tsx
export default async function PostPage({ params }) {
  // 三个请求并行发起
  const postPromise = fetchPost(params.id);
  const authorPromise = fetchAuthor(postPromise.then(p => p.authorId));
  const relatedPromise = fetchRelated(postPromise.then(p => p.tags));

  return (
    <>
      <Suspense fallback={<PostSkeleton />}>
        <Post promise={postPromise} /> {/* 1秒后显示 */}
      </Suspense>

      <Suspense fallback={<AuthorSkeleton />}>
        <Author promise={authorPromise} /> {/* 1秒后显示 */}
      </Suspense>

      <Suspense fallback={<RelatedSkeleton />}>
        <Related promise={relatedPromise} /> {/* 1秒后显示 */}
      </Suspense>
    </>
  );
}
// 总时间：1秒（并行 + 渐进式渲染）
```

### 六、迁移建议

#### 1. 渐进式迁移

Next.js 13+ 支持同时使用两种路由：

```
project/
├── app/              → 新页面用 App Router
│   └── dashboard/
│       └── page.tsx
└── pages/            → 旧页面保留 Pages Router
    ├── index.tsx
    └── about.tsx
```

**优先级**：App Router > Pages Router（URL 冲突时）

#### 2. 迁移路径

**Step 1：创建根布局**

```tsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

**Step 2：逐页迁移**

```tsx
// 旧代码（pages/posts/[id].tsx）
export async function getServerSideProps({ params }) {
  const post = await fetchPost(params.id);
  return { props: { post } };
}

export default function Post({ post }) {
  return <div>{post.title}</div>;
}

// 新代码（app/posts/[id]/page.tsx）
export default async function Post({ params }: { params: { id: string } }) {
  const post = await fetchPost(params.id);
  return <div>{post.title}</div>;
}
```

**Step 3：迁移数据获取**

| Pages Router | App Router |
|--------------|-----------|
| `getServerSideProps` | `export const dynamic = 'force-dynamic'` + async 组件 |
| `getStaticProps` | async 组件（默认静态） |
| `getStaticPaths` | `generateStaticParams` |
| `getInitialProps` | 不推荐使用（迁移到 Server Component） |

### 七、最佳实践

#### 1. App Router 使用建议

**✅ 应该使用 Server Component 的场景**：
- 数据获取（API 调用、数据库查询）
- 访问后端资源（文件系统、环境变量）
- 包含敏感信息（API 密钥、令牌）
- 依赖大型库（仅服务器需要）

**✅ 应该使用 Client Component 的场景**：
- 事件监听器（`onClick`、`onChange` 等）
- React Hooks（`useState`、`useEffect` 等）
- 浏览器 API（localStorage、window 等）
- 交互和动画

#### 2. 组件组合模式

```tsx
// app/posts/[id]/page.tsx (Server Component)
import ClientInteraction from './ClientInteraction';

export default async function PostPage({ params }) {
  const post = await fetchPost(params.id); // 服务器获取数据

  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>

      {/* 通过 props 传递数据给 Client Component */}
      <ClientInteraction postId={post.id} initialLikes={post.likes} />
    </article>
  );
}

// app/posts/[id]/ClientInteraction.tsx (Client Component)
'use client';

import { useState } from 'react';

export default function ClientInteraction({ postId, initialLikes }) {
  const [likes, setLikes] = useState(initialLikes);

  const handleLike = async () => {
    await fetch(`/api/posts/${postId}/like`, { method: 'POST' });
    setLikes(likes + 1);
  };

  return <button onClick={handleLike}>👍 {likes}</button>;
}
```

### 八、选择建议

**选择 Pages Router 的情况**：
- 现有项目稳定运行，无迫切需求
- 团队不熟悉 Server Components
- 依赖不兼容 Server Components 的库
- 需要 `getInitialProps`（虽不推荐）

**选择 App Router 的情况**：
- 新项目启动
- 需要极致性能（减少客户端 JS）
- 需要流式渲染和 Suspense
- 复杂的嵌套布局需求
- 想使用最新的 React 特性

---

## 总结

**App Router 是 Next.js 的未来方向**，它通过 React Server Components、流式渲染、嵌套布局等特性，带来了：

1. **更好的性能**：减少客户端 JavaScript，更快的首屏加载
2. **更好的开发体验**：组件内数据获取，自动布局嵌套
3. **更灵活的架构**：Parallel Routes、Intercepting Routes 等高级功能

**Pages Router 仍然稳定可靠**，适合：
- 现有项目维护
- 团队学习曲线考虑
- 特定场景需求

对于新项目，**强烈推荐使用 App Router**，它代表了 React 和 Next.js 的发展方向。对于现有项目，可以采取渐进式迁移策略，逐步享受新特性带来的好处。
