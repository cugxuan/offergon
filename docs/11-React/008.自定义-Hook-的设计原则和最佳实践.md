---
title: 自定义 Hook 的设计原则和最佳实践
tags:
  - 前端React
status: robot
class: 前端React
slug: custom-hook-design-principles-best-practices
ref:
---

## 核心要点

**自定义 Hook 是以 `use` 开头的函数，用于复用状态逻辑**。设计原则：1）单一职责，专注一个功能；2）良好的输入输出接口设计；3）处理边界情况和清理逻辑；4）遵循 Hook 规则。最佳实践：命名规范、依赖管理、性能优化、测试覆盖。

---

## 详细解答

### 一、自定义 Hook 的基本概念

#### 1. 什么是自定义 Hook
自定义 Hook 是一个 JavaScript 函数，其名称以 "use" 开头，函数内部可以调用其他的 Hook。它允许你将组件逻辑提取到可重用的函数中。

```javascript
// 基础示例
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width;
}

// 使用
function MyComponent() {
  const width = useWindowWidth();
  return <div>窗口宽度: {width}px</div>;
}
```

#### 2. 为什么需要自定义 Hook

**问题场景：逻辑重复**
```javascript
// ❌ 在多个组件中重复相同的逻辑
function ComponentA() {
  const [data, setData] = useState(null);
  useEffect(() => {
    fetch('/api/data').then(res => res.json()).then(setData);
  }, []);
  return <div>{data}</div>;
}

function ComponentB() {
  const [data, setData] = useState(null);
  useEffect(() => {
    fetch('/api/data').then(res => res.json()).then(setData);
  }, []);
  return <div>{data}</div>;
}
```

**解决方案：提取为自定义 Hook**
```javascript
// ✅ 提取可复用逻辑
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setError(null);
      })
      .catch(err => setError(err))
      .finally(() => setLoading(false));
  }, [url]);

  return { data, loading, error };
}

// 使用
function ComponentA() {
  const { data, loading, error } = useFetch('/api/data');
  if (loading) return <div>加载中...</div>;
  if (error) return <div>错误: {error.message}</div>;
  return <div>{data}</div>;
}
```

### 二、设计原则

#### 原则 1：单一职责
每个自定义 Hook 应该专注于一个明确的功能。

```javascript
// ❌ 错误：Hook 做了太多事情
function useUserDashboard() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [notifications, setNotifications] = useState([]);
  const [settings, setSettings] = useState({});
  // ... 太多职责
}

// ✅ 正确：拆分为多个专注的 Hook
function useUser() {
  const [user, setUser] = useState(null);
  // 只处理用户相关逻辑
  return { user, setUser };
}

function usePosts(userId) {
  const [posts, setPosts] = useState([]);
  // 只处理文章相关逻辑
  return { posts, setPosts };
}

function useNotifications(userId) {
  const [notifications, setNotifications] = useState([]);
  // 只处理通知相关逻辑
  return { notifications, setNotifications };
}
```

#### 原则 2：清晰的接口设计

**输入参数设计**
```javascript
// ❌ 不好：参数过多
function useFetch(url, method, headers, body, cache, credentials) {
  // ...
}

// ✅ 好：使用配置对象
function useFetch(url, options = {}) {
  const {
    method = 'GET',
    headers = {},
    body = null,
    cache = 'default',
    credentials = 'same-origin'
  } = options;
  // ...
}
```

**返回值设计**
```javascript
// 简单情况：返回单个值
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  // ...
  return width;
}

// 复杂情况：返回对象（可扩展）
function useFetch(url) {
  // ...
  return {
    data,
    loading,
    error,
    refetch: () => { /* ... */ }
  };
}

// 需要顺序解构：返回数组（类似 useState）
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  const toggle = useCallback(() => setValue(v => !v), []);
  return [value, toggle];
}
```

#### 原则 3：处理边界情况和清理

```javascript
function useWebSocket(url) {
  const [data, setData] = useState(null);
  const [status, setStatus] = useState('disconnected');
  const wsRef = useRef(null);

  useEffect(() => {
    // 边界检查：url 为空时不连接
    if (!url) return;

    setStatus('connecting');
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => setStatus('connected');
    ws.onmessage = (event) => setData(JSON.parse(event.data));
    ws.onerror = () => setStatus('error');
    ws.onclose = () => setStatus('disconnected');

    // ✅ 清理逻辑：关闭连接
    return () => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    };
  }, [url]);

  // 提供手动发送消息的方法
  const send = useCallback((message) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    }
  }, []);

  return { data, status, send };
}
```

#### 原则 4：遵循 Hook 规则

```javascript
// ❌ 错误：在条件语句中调用 Hook
function useBadExample(shouldFetch) {
  if (shouldFetch) {
    const [data, setData] = useState(null); // 错误！
  }
}

// ✅ 正确：Hook 在顶层调用
function useGoodExample(shouldFetch) {
  const [data, setData] = useState(null);

  useEffect(() => {
    if (shouldFetch) {
      // 条件逻辑放在 Hook 内部
      fetchData().then(setData);
    }
  }, [shouldFetch]);

  return data;
}
```

### 三、最佳实践

#### 1. 命名规范

```javascript
// ✅ 必须以 "use" 开头
function useCounter() { /* ... */ }
function useLocalStorage() { /* ... */ }
function usePrevious() { /* ... */ }

// ❌ 错误：不以 "use" 开头（ESLint 会警告）
function counter() { /* ... */ }
function getWindowSize() { /* ... */ }
```

#### 2. 参数和返回值的类型安全（TypeScript）

```typescript
// 完整的类型定义
interface UseFetchOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  headers?: Record<string, string>;
  body?: any;
}

interface UseFetchReturn<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

function useFetch<T = any>(
  url: string,
  options?: UseFetchOptions
): UseFetchReturn<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(() => {
    setLoading(true);
    fetch(url, options)
      .then(res => res.json())
      .then((data: T) => {
        setData(data);
        setError(null);
      })
      .catch(err => setError(err))
      .finally(() => setLoading(false));
  }, [url, options]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

// 使用时有类型提示
interface User {
  id: number;
  name: string;
}

function UserProfile() {
  const { data, loading } = useFetch<User>('/api/user');
  // data 的类型是 User | null
}
```

#### 3. 依赖管理

```javascript
// ❌ 错误：缺少依赖项
function useBadFetch(url, processData) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(processData) // processData 应该在依赖项中
      .then(setData);
  }, [url]); // ESLint 会警告

  return data;
}

// ✅ 正确：包含所有依赖项
function useGoodFetch(url, processData) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(processData)
      .then(setData);
  }, [url, processData]); // 包含所有依赖

  return data;
}

// ✅ 更好：使用 useCallback 稳定化函数引用
function useBetterFetch(url, processData) {
  const [data, setData] = useState(null);

  const stableProcessData = useCallback(processData, []);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(stableProcessData)
      .then(setData);
  }, [url, stableProcessData]);

  return data;
}
```

#### 4. 性能优化

```javascript
function useExpensiveComputation(input) {
  // ✅ 使用 useMemo 缓存计算结果
  const result = useMemo(() => {
    return expensiveOperation(input);
  }, [input]);

  // ✅ 使用 useCallback 缓存函数引用
  const handler = useCallback(() => {
    console.log('处理:', input);
  }, [input]);

  return { result, handler };
}
```

#### 5. 错误处理

```javascript
function useAsyncData(fetchFn) {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  const execute = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await fetchFn();
      setData(result);
    } catch (err) {
      setError(err);
      // 可选：上报错误到监控系统
      console.error('useAsyncData error:', err);
    } finally {
      setLoading(false);
    }
  }, [fetchFn]);

  return { data, error, loading, execute };
}
```

### 四、常见自定义 Hook 模式

#### 1. 状态管理类

**useToggle**
```javascript
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);

  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return [value, { toggle, setTrue, setFalse }];
}

// 使用
function Modal() {
  const [isOpen, { toggle, setTrue, setFalse }] = useToggle(false);

  return (
    <>
      <button onClick={setTrue}>打开</button>
      {isOpen && <div>模态框内容 <button onClick={setFalse}>关闭</button></div>}
    </>
  );
}
```

**useLocalStorage**
```javascript
function useLocalStorage(key, initialValue) {
  // 从 localStorage 读取初始值
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // 更新 localStorage 和 state
  const setValue = useCallback((value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  }, [key, storedValue]);

  return [storedValue, setValue];
}

// 使用
function App() {
  const [name, setName] = useLocalStorage('name', '');
  return <input value={name} onChange={e => setName(e.target.value)} />;
}
```

#### 2. 副作用类

**useDebounce**
```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

// 使用：搜索输入防抖
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // 发起搜索请求
      console.log('搜索:', debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      value={searchTerm}
      onChange={e => setSearchTerm(e.target.value)}
      placeholder="搜索..."
    />
  );
}
```

**useInterval**
```javascript
function useInterval(callback, delay) {
  const savedCallback = useRef(callback);

  // 保存最新的 callback
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // 设置 interval
  useEffect(() => {
    if (delay === null) return;

    const id = setInterval(() => {
      savedCallback.current();
    }, delay);

    return () => clearInterval(id);
  }, [delay]);
}

// 使用
function Timer() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    setCount(c => c + 1);
  }, 1000);

  return <div>计数: {count}</div>;
}
```

#### 3. 数据获取类

**useAsync**
```javascript
function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState('idle');
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  const execute = useCallback(async () => {
    setStatus('pending');
    setData(null);
    setError(null);

    try {
      const response = await asyncFunction();
      setData(response);
      setStatus('success');
    } catch (error) {
      setError(error);
      setStatus('error');
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { execute, status, data, error };
}

// 使用
function UserProfile({ userId }) {
  const { status, data, error, execute } = useAsync(
    () => fetch(`/api/users/${userId}`).then(res => res.json()),
    true
  );

  if (status === 'pending') return <div>加载中...</div>;
  if (status === 'error') return <div>错误: {error.message}</div>;
  if (status === 'success') return <div>{data.name}</div>;

  return <button onClick={execute}>重新加载</button>;
}
```

### 五、测试自定义 Hook

```javascript
// 使用 @testing-library/react-hooks
import { renderHook, act } from '@testing-library/react-hooks';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  it('应该初始化为 0', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  it('应该能够递增', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  it('应该能够递减', () => {
    const { result } = renderHook(() => useCounter(10));

    act(() => {
      result.current.decrement();
    });

    expect(result.current.count).toBe(9);
  });
});
```

### 六、面试回答要点总结

1. **定义**：以 "use" 开头的函数，用于复用组件逻辑，可以调用其他 Hook
2. **设计原则**：单一职责、清晰接口、边界处理、遵循 Hook 规则
3. **最佳实践**：命名规范（use前缀）、类型安全、依赖管理、性能优化、错误处理
4. **常见模式**：状态管理（useToggle、useLocalStorage）、副作用（useDebounce、useInterval）、数据获取（useAsync、useFetch）
5. **测试**：使用 @testing-library/react-hooks 进行单元测试
6. **优势**：逻辑复用、关注点分离、提高可维护性、减少代码重复
