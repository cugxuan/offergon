---
title: useEffect 的执行时机和清理机制
tags:
  - React
status: robot
class: 前端React
slug: useeffect-execution-cleanup-mechanism
ref:
---

## 核心要点

- **执行时机**：Commit 阶段后异步执行，不阻塞浏览器渲染（DOM 已更新，屏幕未绘制）
- **清理机制**：组件卸载或依赖变化时，先执行上次 effect 的清理函数，再执行新 effect
- **依赖数组**：浅比较决定是否执行，空数组只执行一次，无数组每次都执行
- **与 useLayoutEffect 区别**：useLayoutEffect 同步执行（阻塞渲染），适合 DOM 测量
- **常见陷阱**：闭包捕获旧值、依赖遗漏、清理函数缺失导致内存泄漏

---

## 详细回答

### 一、useEffect 的完整执行流程

#### 完整生命周期

```javascript
function Component({ id }) {
  useEffect(() => {
    console.log('1. Effect 执行');
    fetchData(id);

    return () => {
      console.log('2. 清理函数执行');
      cancelRequest();
    };
  }, [id]);

  return <div>Content</div>;
}
```

**执行顺序**：

```
首次渲染:
  ↓
渲染组件（执行 Component 函数）
  ↓
React 进行 Diff 和 DOM 更新（Commit 阶段）
  ↓
浏览器绘制屏幕（用户看到新 UI）
  ↓
【异步】执行 useEffect 回调
  ↓
保存清理函数（用于下次清理）

---

依赖变化（id 从 1 → 2）:
  ↓
重新渲染组件
  ↓
React 更新 DOM
  ↓
浏览器绘制屏幕
  ↓
【异步】先执行上次的清理函数
  ↓
然后执行新的 effect 回调
  ↓
保存新的清理函数

---

组件卸载:
  ↓
执行清理函数
  ↓
组件从 DOM 中移除
```

---

### 二、执行时机详解

#### 1. useEffect：异步执行（不阻塞渲染）

```javascript
function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('useEffect 执行'); // 最后执行
  });

  console.log('组件渲染'); // 先执行

  return <div>{count}</div>;
}

// 输出顺序：
// 1. 组件渲染
// 2. （浏览器绘制屏幕）
// 3. useEffect 执行
```

**底层实现**：
- effect 在 Commit 阶段后通过 `requestIdleCallback` 或 `MessageChannel` 异步调度
- 浏览器完成绘制后才执行 effect，避免阻塞用户交互

**适用场景**：
- 数据获取（fetch、axios）
- 订阅事件（addEventListener）
- 手动修改 DOM（非关键布局操作）
- 日志记录

---

#### 2. useLayoutEffect：同步执行（阻塞渲染）

```javascript
function Example() {
  const [width, setWidth] = useState(0);
  const ref = useRef();

  useLayoutEffect(() => {
    const rect = ref.current.getBoundingClientRect();
    setWidth(rect.width); // 同步测量 DOM
    console.log('useLayoutEffect 执行'); // 第2执行
  });

  console.log('组件渲染'); // 第1执行

  return <div ref={ref}>{width}</div>;
}

// 输出顺序：
// 1. 组件渲染
// 2. useLayoutEffect 执行
// 3. （浏览器绘制屏幕）
```

**执行时机**：
- Commit 阶段同步执行（DOM 更新后，浏览器绘制前）
- 等价于类组件的 `componentDidMount` / `componentDidUpdate`

**适用场景**：
- DOM 测量（getBoundingClientRect）
- 根据 DOM 尺寸调整布局（避免闪烁）
- 需要在绘制前同步更新 DOM

**对比**：

| 特性 | useEffect | useLayoutEffect |
|------|-----------|----------------|
| **执行时机** | DOM 更新后，异步执行 | DOM 更新后，同步执行 |
| **是否阻塞渲染** | 否 | 是 |
| **用户体验** | 可能看到中间状态 | 不会看到中间状态 |
| **性能影响** | 小 | 大（阻塞主线程） |
| **适用场景** | 数据获取、订阅 | DOM 测量、防闪烁 |

---

### 三、依赖数组的深入理解

#### 1. 无依赖数组：每次渲染都执行

```javascript
useEffect(() => {
  console.log('每次渲染都执行');
});
```

**等价于**：
```javascript
componentDidMount() {
  console.log('组件挂载');
}

componentDidUpdate() {
  console.log('组件更新');
}
```

---

#### 2. 空依赖数组：只执行一次

```javascript
useEffect(() => {
  console.log('只在挂载时执行一次');
  return () => console.log('只在卸载时清理一次');
}, []);
```

**等价于**：
```javascript
componentDidMount() {
  console.log('只在挂载时执行一次');
}

componentWillUnmount() {
  console.log('只在卸载时清理一次');
}
```

**常见用途**：
- 全局事件监听
- WebSocket 连接
- 定时器

---

#### 3. 依赖数组：依赖变化时执行

```javascript
useEffect(() => {
  console.log(`userId 变化了: ${userId}`);
  fetchUserData(userId);
}, [userId]);
```

**依赖对比机制**（浅比较）：

```javascript
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) return false;

  for (let i = 0; i < prevDeps.length; i++) {
    if (Object.is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false; // 发现不同，执行 effect
  }
  return true; // 所有依赖相同，跳过 effect
}
```

**关键点**：
- 使用 `Object.is()` 比较（类似 `===`，但处理 `NaN` 和 `+0/-0`）
- 对象/数组比较的是引用，不是内容
- 依赖变化 → 先执行清理函数 → 再执行新 effect

---

#### 4. 依赖遗漏的问题

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('Alice');

  useEffect(() => {
    console.log(`${name} 的计数: ${count}`);
  }, [count]); // ❌ 缺少 name 依赖

  // 当 name 变化时，effect 不会重新执行！
}
```

**解决方案**：
- 使用 ESLint 插件 `eslint-plugin-react-hooks` 检测
- 规则：effect 中使用的所有外部变量都必须声明为依赖

---

### 四、清理机制详解

#### 1. 为什么需要清理？

**问题场景**：

```javascript
function ChatRoom({ roomId }) {
  useEffect(() => {
    const socket = connectToRoom(roomId);
    // ❌ 没有清理！切换房间时会创建多个连接
  }, [roomId]);
}
```

**后果**：
- 内存泄漏（未清理的订阅、定时器）
- 多个重复的监听器
- 组件卸载后仍执行回调（导致 setState 报错）

---

#### 2. 清理函数的执行时机

```javascript
function Component({ id }) {
  useEffect(() => {
    console.log(`订阅 ${id}`);

    return () => {
      console.log(`取消订阅 ${id}`);
    };
  }, [id]);
}

// 首次渲染 (id = 1):
// 输出: 订阅 1

// id 变化 (1 → 2):
// 输出: 取消订阅 1
//      订阅 2

// 组件卸载:
// 输出: 取消订阅 2
```

**清理时机**：
1. **依赖变化时**：先执行旧 effect 的清理，再执行新 effect
2. **组件卸载时**：执行最后一次 effect 的清理

---

#### 3. 常见清理场景

**场景 1：定时器清理**

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Tick');
  }, 1000);

  return () => clearInterval(timer); // 清理定时器
}, []);
```

---

**场景 2：事件监听器清理**

```javascript
useEffect(() => {
  const handleResize = () => {
    console.log('Window resized');
  };

  window.addEventListener('resize', handleResize);

  return () => window.removeEventListener('resize', handleResize);
}, []);
```

---

**场景 3：取消网络请求**

```javascript
useEffect(() => {
  const controller = new AbortController();

  fetch(`/api/users/${userId}`, { signal: controller.signal })
    .then(res => res.json())
    .then(data => setUser(data))
    .catch(err => {
      if (err.name === 'AbortError') {
        console.log('请求被取消');
      }
    });

  return () => controller.abort(); // 组件卸载时取消请求
}, [userId]);
```

---

**场景 4：订阅清理**

```javascript
useEffect(() => {
  const subscription = props.source.subscribe(data => {
    setData(data);
  });

  return () => subscription.unsubscribe();
}, [props.source]);
```

---

### 五、常见陷阱和解决方案

#### 陷阱 1：闭包捕获旧值

**问题代码**：

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count); // 永远是 0
      setCount(count + 1); // 永远是 0 + 1
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组

  return <div>{count}</div>;
}
```

**原因**：
- effect 只执行一次，闭包捕获了初始的 `count = 0`
- 后续 `count` 更新，但定时器的回调仍引用旧值

**解决方案**：

```javascript
// 方案 1：添加依赖（会重启定时器）
useEffect(() => {
  const timer = setInterval(() => {
    setCount(count + 1);
  }, 1000);
  return () => clearInterval(timer);
}, [count]);

// 方案 2：函数式更新（推荐）
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prev => prev + 1); // 不依赖外部 count
  }, 1000);
  return () => clearInterval(timer);
}, []);

// 方案 3：useRef
const countRef = useRef(count);
countRef.current = count; // 每次渲染更新

useEffect(() => {
  const timer = setInterval(() => {
    setCount(countRef.current + 1);
  }, 1000);
  return () => clearInterval(timer);
}, []);
```

---

#### 陷阱 2：依赖对象/数组导致无限循环

**问题代码**：

```javascript
function Component({ user }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetchData(user).then(setData);
  }, [user]); // ❌ user 是对象，每次渲染都是新引用

  // 无限循环：渲染 → effect → setData → 重新渲染 → effect → ...
}
```

**解决方案**：

```javascript
// 方案 1：只依赖对象的具体属性
useEffect(() => {
  fetchData(user.id).then(setData);
}, [user.id]);

// 方案 2：使用 useMemo 稳定引用
const userMemo = useMemo(() => ({ id: user.id, name: user.name }), [user.id, user.name]);

useEffect(() => {
  fetchData(userMemo).then(setData);
}, [userMemo]);

// 方案 3：自定义比较（使用 use-deep-compare-effect）
import { useDeepCompareEffect } from 'use-deep-compare';

useDeepCompareEffect(() => {
  fetchData(user).then(setData);
}, [user]);
```

---

#### 陷阱 3：组件卸载后 setState 导致警告

**问题代码**：

```javascript
function Component() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetchData().then(res => {
      setData(res); // ❌ 组件可能已卸载
    });
  }, []);

  // 警告: Can't perform a React state update on an unmounted component
}
```

**解决方案**：

```javascript
useEffect(() => {
  let cancelled = false;

  fetchData().then(res => {
    if (!cancelled) {
      setData(res); // 只在组件未卸载时更新
    }
  });

  return () => {
    cancelled = true; // 清理时标记为已取消
  };
}, []);
```

---

### 六、高级用法

#### 1. 条件执行 Effect

```javascript
useEffect(() => {
  if (!userId) return; // 提前退出

  fetchUserData(userId);
}, [userId]);
```

---

#### 2. 多个独立的 Effect

```javascript
function Component({ userId, theme }) {
  // Effect 1：用户数据
  useEffect(() => {
    fetchUserData(userId);
  }, [userId]);

  // Effect 2：主题切换
  useEffect(() => {
    document.body.className = theme;
  }, [theme]);

  // ✅ 按功能分离，而非按生命周期合并
}
```

---

#### 3. 自定义 Hook 封装 Effect

```javascript
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width;
}

// 使用
function Component() {
  const width = useWindowWidth();
  return <div>窗口宽度: {width}px</div>;
}
```

---

### 七、底层实现原理

#### Effect 对象结构

```javascript
type Effect = {
  tag: number,             // PassiveEffect | LayoutEffect
  create: () => void,      // effect 回调
  destroy: (() => void) | null, // 清理函数
  deps: Array<any> | null, // 依赖数组
  next: Effect | null,     // 下一个 effect（环形链表）
};
```

---

#### Commit 阶段执行

```javascript
function commitPassiveEffects(fiber) {
  const effects = fiber.updateQueue.lastEffect;

  // 阶段 1：执行所有清理函数
  let effect = effects.next;
  do {
    if ((effect.tag & HookHasEffect) !== 0) {
      const destroy = effect.destroy;
      if (destroy !== undefined) {
        destroy();
      }
    }
    effect = effect.next;
  } while (effect !== effects.next);

  // 阶段 2：执行所有 effect 回调
  effect = effects.next;
  do {
    if ((effect.tag & HookHasEffect) !== 0) {
      const create = effect.create;
      effect.destroy = create(); // 保存清理函数
    }
    effect = effect.next;
  } while (effect !== effects.next);
}
```

---

### 八、总结

**核心要点**：

1. **执行时机**：
   - useEffect：DOM 更新后异步执行，不阻塞渲染
   - useLayoutEffect：DOM 更新后同步执行，阻塞渲染

2. **清理机制**：
   - 依赖变化时：先清理旧 effect，再执行新 effect
   - 组件卸载时：执行最后一次清理

3. **依赖数组**：
   - 浅比较决定是否执行
   - 必须包含 effect 中使用的所有外部变量

4. **常见陷阱**：
   - 闭包捕获旧值 → 使用函数式更新或 useRef
   - 对象依赖导致循环 → 只依赖具体属性
   - 卸载后 setState → 使用清理函数标记取消

**面试加分点**：
- 能对比 useEffect 和 useLayoutEffect 的执行时机
- 理解清理函数的执行顺序
- 知道依赖数组的浅比较机制
- 能解决闭包陷阱和内存泄漏问题
- 了解 React 18 的 Strict Mode 会双调 effect（开发环境）
