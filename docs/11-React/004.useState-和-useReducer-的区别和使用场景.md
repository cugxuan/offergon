---
title: useState 和 useReducer 的区别和使用场景
tags:
  - React
status: robot
class: 前端React
slug: usestate-vs-usereducer-difference-use-cases
ref:
---

## 核心要点

- **本质关系**：useState 是 useReducer 的语法糖，底层都调用同一套更新机制
- **核心区别**：useState 适合简单状态，useReducer 适合复杂状态逻辑和多状态联动
- **状态更新方式**：useState 直接设置新值，useReducer 通过 dispatch(action) 触发
- **可预测性**：useReducer 的 reducer 是纯函数，便于测试和时间旅行调试
- **性能优化**：useReducer 的 dispatch 引用稳定，可避免子组件不必要的重渲染

---

## 详细回答

### 一、useState 的基本用法

#### 简单场景

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+1 (函数式)</button>
    </div>
  );
}
```

**特点**：
- API 简洁，适合单一状态管理
- 支持直接传值或函数式更新
- 适合独立的、不相关的状态

---

#### useState 的局限性

**场景 1：多个状态相互依赖**

```javascript
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async () => {
    setLoading(true);
    setError(null); // 需要手动重置

    try {
      await submitForm({ name, email });
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // 问题：
  // 1. 多个 setState 分散，逻辑不聚合
  // 2. 状态更新顺序难以保证（异步批处理）
  // 3. 重置状态需要多次调用 set 函数
}
```

---

**场景 2：复杂的状态转换逻辑**

```javascript
function TodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = (text) => {
    setTodos(prev => [...prev, { id: Date.now(), text, done: false }]);
  };

  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  // 问题：
  // 1. 每个操作都需要写一遍复杂的更新逻辑
  // 2. 逻辑分散在不同的函数中，难以维护
  // 3. 难以实现撤销/重做功能
}
```

---

### 二、useReducer 的基本用法

#### 语法结构

```javascript
const [state, dispatch] = useReducer(reducer, initialState, init);
```

**参数**：
- `reducer`：状态更新逻辑函数 `(state, action) => newState`
- `initialState`：初始状态
- `init`（可选）：惰性初始化函数，返回初始状态

**返回值**：
- `state`：当前状态
- `dispatch`：派发 action 的函数（引用永远不变）

---

#### 基础示例

```javascript
// 1. 定义 reducer
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// 2. 使用 useReducer
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
    </div>
  );
}
```

---

### 三、useState 和 useReducer 的底层实现

#### useState 的实现（简化）

```javascript
function useState(initialState) {
  // useState 实际上是调用 useReducer 的语法糖
  return useReducer(
    basicStateReducer,  // 内置的简单 reducer
    initialState
  );
}

function basicStateReducer(state, action) {
  // action 可以是新值或函数
  return typeof action === 'function' ? action(state) : action;
}
```

**关键点**：
- useState 本质是 useReducer 的特殊情况
- 底层复用同一套 Hook 链表和更新队列机制

---

#### useReducer 的实现（简化）

```javascript
function useReducer(reducer, initialState, init) {
  // 1. 获取 Hook 对象
  const hook = updateWorkInProgressHook();

  // 2. 初始化状态
  if (hook.memoizedState === null) {
    hook.memoizedState = init ? init(initialState) : initialState;
  }

  // 3. 处理更新队列
  const queue = hook.queue;
  if (queue.pending !== null) {
    let newState = hook.baseState;
    let update = queue.pending.next; // 环形链表的第一个

    do {
      const action = update.action;
      newState = reducer(newState, action); // 调用 reducer 计算新状态
      update = update.next;
    } while (update !== queue.pending.next);

    hook.memoizedState = newState;
    queue.pending = null;
  }

  // 4. 返回 [state, dispatch]
  const dispatch = dispatchReducerAction.bind(null, currentFiber, queue, reducer);
  return [hook.memoizedState, dispatch];
}
```

---

### 四、核心区别对比

| 特性 | useState | useReducer |
|------|---------|------------|
| **API 复杂度** | 简单（直接 setState） | 稍复杂（需要定义 reducer） |
| **适用场景** | 简单、独立的状态 | 复杂、相互关联的状态 |
| **状态更新** | `setState(newValue)` 或 `setState(prev => newValue)` | `dispatch({ type, payload })` |
| **更新逻辑位置** | 分散在各处 | 集中在 reducer 中 |
| **可测试性** | 一般（逻辑分散） | 优秀（reducer 是纯函数） |
| **dispatch 引用** | 稳定 | 稳定（更适合传递给子组件） |
| **时间旅行调试** | 困难 | 容易（记录 action 历史） |
| **性能优化** | 需要 useCallback 包裹更新函数 | dispatch 天然稳定，无需 useCallback |

---

### 五、实际使用场景对比

#### 场景 1：简单计数器 → 用 useState

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

**理由**：状态简单，逻辑直观，无需 reducer 的额外抽象。

---

#### 场景 2：表单状态管理 → 用 useReducer

```javascript
const initialState = {
  name: '',
  email: '',
  password: '',
  errors: {},
  loading: false,
};

function formReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD':
      return {
        ...state,
        [action.field]: action.value,
        errors: { ...state.errors, [action.field]: null }, // 清除错误
      };

    case 'SET_ERRORS':
      return { ...state, errors: action.errors };

    case 'SUBMIT_START':
      return { ...state, loading: true, errors: {} };

    case 'SUBMIT_SUCCESS':
      return initialState; // 重置表单

    case 'SUBMIT_FAILURE':
      return { ...state, loading: false, errors: action.errors };

    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(formReducer, initialState);

  const handleChange = (field) => (e) => {
    dispatch({ type: 'UPDATE_FIELD', field, value: e.target.value });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    dispatch({ type: 'SUBMIT_START' });

    try {
      await submitForm(state);
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (errors) {
      dispatch({ type: 'SUBMIT_FAILURE', errors });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={state.name} onChange={handleChange('name')} />
      {state.errors.name && <span>{state.errors.name}</span>}

      <input value={state.email} onChange={handleChange('email')} />
      {state.errors.email && <span>{state.errors.email}</span>}

      <button disabled={state.loading}>Submit</button>
    </form>
  );
}
```

**优势**：
- 所有状态转换逻辑集中在 reducer 中
- 状态更新具有原子性（一次 dispatch 更新多个字段）
- 易于测试（reducer 是纯函数）
- 可以轻松添加日志中间件或时间旅行

---

#### 场景 3：Todo 列表 → 用 useReducer

```javascript
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.text, done: false }];

    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );

    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.id);

    case 'CLEAR_COMPLETED':
      return state.filter(todo => !todo.done);

    default:
      return state;
  }
}

function TodoList() {
  const [todos, dispatch] = useReducer(todoReducer, []);

  return (
    <div>
      <button onClick={() => dispatch({ type: 'ADD_TODO', text: 'New Task' })}>
        Add Todo
      </button>

      {todos.map(todo => (
        <div key={todo.id}>
          <input
            type="checkbox"
            checked={todo.done}
            onChange={() => dispatch({ type: 'TOGGLE_TODO', id: todo.id })}
          />
          <span>{todo.text}</span>
          <button onClick={() => dispatch({ type: 'DELETE_TODO', id: todo.id })}>
            Delete
          </button>
        </div>
      ))}

      <button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}>
        Clear Completed
      </button>
    </div>
  );
}
```

**优势**：
- 复杂的数组操作逻辑集中管理
- 容易扩展新的操作类型（如批量删除、排序）
- dispatch 引用稳定，传递给子组件不会导致重渲染

---

### 六、性能优化：dispatch 的稳定性

#### 问题场景（useState）

```javascript
function Parent() {
  const [count, setCount] = useState(0);

  // ❌ 每次渲染都会创建新函数
  const increment = () => setCount(count + 1);

  return <Child onIncrement={increment} />;
}

const Child = React.memo(({ onIncrement }) => {
  console.log('Child rendered'); // 每次 Parent 渲染都会执行
  return <button onClick={onIncrement}>+1</button>;
});
```

**解决方案**：

```javascript
// 方案 1：useCallback
const increment = useCallback(() => setCount(prev => prev + 1), []);

// 方案 2：useReducer（更优雅）
function Parent() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  // ✅ dispatch 引用永远不变
  return <Child onIncrement={dispatch} />;
}

const Child = React.memo(({ onIncrement }) => {
  return <button onClick={() => onIncrement({ type: 'INCREMENT' })}>+1</button>;
});
```

---

### 七、高级用法：惰性初始化

#### useState 的惰性初始化

```javascript
// ❌ 每次渲染都会调用 expensiveComputation
const [state, setState] = useState(expensiveComputation());

// ✅ 只在首次渲染时调用
const [state, setState] = useState(() => expensiveComputation());
```

---

#### useReducer 的惰性初始化

```javascript
function init(initialCount) {
  return { count: initialCount };
}

function Counter({ initialCount }) {
  // 第三个参数是初始化函数
  const [state, dispatch] = useReducer(reducer, initialCount, init);

  return <div>Count: {state.count}</div>;
}
```

**用途**：
- 从 props、localStorage 等计算初始状态
- 重置状态时可以调用 `dispatch({ type: 'RESET', payload: initialCount })`

---

### 八、何时选择 useReducer？

**推荐使用 useReducer 的场景**：

1. ✅ **多个状态相互依赖**（如表单的 data、errors、loading）
2. ✅ **状态更新逻辑复杂**（多个条件判断、多步骤操作）
3. ✅ **需要统一管理状态转换**（便于维护和测试）
4. ✅ **需要传递 dispatch 给子组件**（避免 useCallback）
5. ✅ **实现撤销/重做功能**（记录 action 历史）
6. ✅ **需要时间旅行调试**（Redux DevTools 支持）

**继续使用 useState 的场景**：

1. ✅ **状态简单独立**（布尔值、数字、字符串）
2. ✅ **无复杂更新逻辑**（直接赋值即可）
3. ✅ **状态之间无关联**（切换显示、计数器等）

---

### 九、总结

**核心要点**：

1. **本质关系**：useState 是 useReducer 的简化版，底层机制相同
2. **选择标准**：
   - 简单状态 → useState（快速开发）
   - 复杂状态 → useReducer（可维护性、可测试性）
3. **性能优化**：useReducer 的 dispatch 天然稳定，适合传递给子组件
4. **最佳实践**：
   - 从 useState 开始，当逻辑变复杂时重构为 useReducer
   - Reducer 必须是纯函数（无副作用、可预测）
   - 使用 TypeScript 定义 Action 类型，避免 typo

**面试加分点**：
- 理解 useState 是 useReducer 的语法糖
- 能说明 dispatch 引用稳定性的优势
- 知道何时重构 useState 为 useReducer
- 了解 Redux 和 useReducer 的关系（Redux 是全局版的 useReducer）
