---
title: React 的虚拟 DOM 和 Diff 算法原理
tags:
  - 前端React
status: robot
class: 前端React
slug: react-virtual-dom-and-diff-algorithm
ref:
---

## 核心要点

- **虚拟DOM本质**：用 JavaScript 对象描述真实 DOM 结构的轻量级副本
- **Diff 算法策略**：同层比较 + 三大优化假设（Tree/Component/Element）
- **性能优势**：批量更新减少 DOM 操作，计算成本 < 重排重绘成本
- **key 属性作用**：帮助 Diff 算法精准识别节点移动，避免错误复用

---

## 详细回答

### 一、虚拟 DOM 的本质

虚拟 DOM（Virtual DOM）是 React 的核心机制之一，它是一个用 **JavaScript 对象** 来描述真实 DOM 树结构的抽象层。

**为什么需要虚拟 DOM？**

直接操作真实 DOM 的性能成本很高，因为：
1. DOM 操作会触发浏览器的重排（reflow）和重绘（repaint）
2. 频繁的 DOM 操作会导致性能瓶颈
3. 直接操作 DOM 难以追踪和优化变更

虚拟 DOM 的优势：
- **性能优化**：通过 Diff 算法找出最小变更集，批量更新真实 DOM
- **跨平台能力**：虚拟 DOM 是平台无关的，可以渲染到不同平台（Web、Native、Canvas）
- **开发体验**：声明式编程，开发者只需关心状态变化，UI 自动更新

**虚拟 DOM 结构示例：**

```javascript
// JSX 写法
<div className="container">
  <h1>Hello</h1>
  <p>World</p>
</div>

// 对应的虚拟 DOM 对象
{
  type: 'div',
  props: {
    className: 'container',
    children: [
      {
        type: 'h1',
        props: { children: 'Hello' }
      },
      {
        type: 'p',
        props: { children: 'World' }
      }
    ]
  }
}
```

---

### 二、Diff 算法的核心原理

React 的 Diff 算法通过 **三大策略** 将传统 O(n³) 复杂度的树对比优化到 **O(n)**：

#### 1. Tree Diff（树层级比较）

**策略：只对同层节点进行比较，跨层级移动视为删除+创建**

- React 只会比较虚拟 DOM 树的同一层级节点
- 如果节点跨层级移动，React 不会尝试复用，而是：
  - 删除旧层级的节点
  - 在新层级创建新节点

**示例：**

```javascript
// 旧树
<div>
  <span>A</span>
</div>

// 新树（span 移到外层）
<div></div>
<span>A</span>

// React 的处理：
// 1. 删除 div 下的 span
// 2. 创建新的 span（不会复用）
```

**优化建议**：避免跨层级的节点移动，保持 DOM 结构稳定。

---

#### 2. Component Diff（组件层级比较）

**策略：同类型组件递归 Diff，不同类型直接替换**

- **同类型组件**：继续递归比较虚拟 DOM 树
- **不同类型组件**：直接销毁旧组件，创建新组件（包括子树）

**示例：**

```javascript
// 旧组件
<ComponentA />

// 新组件
<ComponentB />

// React 的处理：
// 1. 卸载 ComponentA（调用 componentWillUnmount）
// 2. 挂载 ComponentB（调用 componentDidMount）
```

**优化手段**：使用 `shouldComponentUpdate` 或 `React.memo` 避免不必要的组件更新。

---

#### 3. Element Diff（元素层级比较）

**策略：通过 key 属性识别列表元素的增删改移**

对于同一层级的子元素列表，React 提供三种操作：

1. **INSERT_MARKUP**（插入）：新节点不在旧集合中
2. **MOVE_EXISTING**（移动）：节点在旧集合中，但位置变化
3. **REMOVE_NODE**（删除）：节点在旧集合中，但新集合没有

**key 的重要性：**

```javascript
// 没有 key 的情况（低效）
旧列表: [A, B, C]
新列表: [B, A, C]

// React 会：
// 1. 更新第 1 个元素 A → B
// 2. 更新第 2 个元素 B → A
// 3. 复用第 3 个元素 C
// 结果：2 次 DOM 更新

// 有 key 的情况（高效）
旧列表: [<A key="a"/>, <B key="b"/>, <C key="c"/>]
新列表: [<B key="b"/>, <A key="a"/>, <C key="c"/>]

// React 会：
// 1. 通过 key 识别出 A 和 B 只是调换了位置
// 2. 移动 DOM 节点，不需要更新内容
// 结果：只是移动操作，更高效
```

**key 使用原则：**
- ✅ 使用稳定、唯一的标识符（如 ID）
- ❌ 避免使用数组索引（index）作为 key
- ❌ 避免使用随机数或不稳定的值

---

### 三、Diff 算法的执行流程

```javascript
// 简化的 Diff 流程伪代码
function diff(oldVNode, newVNode) {
  // 1. 节点类型不同 → 直接替换
  if (oldVNode.type !== newVNode.type) {
    return replaceNode(oldVNode, newVNode);
  }

  // 2. 文本节点 → 比较内容
  if (typeof newVNode === 'string') {
    if (oldVNode !== newVNode) {
      return updateText(oldVNode, newVNode);
    }
    return null;
  }

  // 3. 同类型元素 → 比较属性和子节点
  const patches = [];

  // 比较属性
  patches.push(...diffProps(oldVNode.props, newVNode.props));

  // 比较子节点（Element Diff）
  patches.push(...diffChildren(oldVNode.children, newVNode.children));

  return patches;
}

// 子节点 Diff（利用 key 优化）
function diffChildren(oldChildren, newChildren) {
  const patches = [];
  const oldMap = createKeyMap(oldChildren); // 建立 key → node 映射

  newChildren.forEach((newChild, index) => {
    const oldChild = oldMap[newChild.key];

    if (!oldChild) {
      patches.push({ type: 'INSERT', node: newChild, index });
    } else if (oldChild.index !== index) {
      patches.push({ type: 'MOVE', node: newChild, from: oldChild.index, to: index });
    }
    // 递归比较子树
    patches.push(...diff(oldChild, newChild));
  });

  return patches;
}
```

---

### 四、实际性能考量

**虚拟 DOM 不一定比直接操作 DOM 快！**

关键在于场景：
- ✅ **大量复杂更新**：虚拟 DOM 通过 Diff 减少不必要的 DOM 操作
- ❌ **简单局部更新**：虚拟 DOM 的计算成本可能超过直接操作 DOM

**React 的优势在于**：
1. 开发效率高（声明式 UI）
2. 自动批量更新（减少重排重绘）
3. 可预测的性能表现

**优化技巧：**
- 合理使用 `React.memo`、`useMemo`、`useCallback`
- 列表渲染必须提供稳定的 key
- 避免在渲染函数中创建新对象/函数（导致无意义的 Diff）
- 使用 `shouldComponentUpdate` 或 `PureComponent` 跳过不必要的更新

---

### 五、总结

React 的虚拟 DOM 和 Diff 算法通过以下设计实现高效更新：

1. **虚拟 DOM**：用 JS 对象描述 UI，提供抽象层和跨平台能力
2. **同层比较**：只比较同一层级节点，O(n) 复杂度
3. **组件类型判断**：不同类型直接替换，避免无效对比
4. **key 属性优化**：精准识别列表元素的移动、增删

**面试加分点**：
- 理解虚拟 DOM 不是银弹，需要根据场景选择方案
- 能说明 key 的工作原理和最佳实践
- 了解 React 18 的并发特性对 Diff 的影响（时间切片、可中断渲染）
