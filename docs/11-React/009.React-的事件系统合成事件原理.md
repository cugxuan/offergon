---
title: React 的事件系统（合成事件）原理
tags:
  - React
status: robot
class: 前端React
slug: react-synthetic-event-system
ref:
---

## 核心要点

**React 合成事件（SyntheticEvent）是对原生 DOM 事件的跨浏览器封装**。核心机制：事件委托（React 17前委托到document，17+委托到root）、事件池复用（17后废弃）、统一的事件对象接口、自动批处理更新。优势：跨浏览器兼容、性能优化、与 React 更新机制集成。

---

## 详细解答

### 一、React 事件系统基础

#### 1. 什么是合成事件
合成事件是 React 模拟原生 DOM 事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。

```javascript
function handleClick(e) {
  // e 是 React 的 SyntheticEvent，不是原生 Event
  console.log(e); // SyntheticEvent
  console.log(e.nativeEvent); // 原生的 MouseEvent

  e.preventDefault(); // 阻止默认行为
  e.stopPropagation(); // 阻止冒泡
}

<button onClick={handleClick}>点击</button>
```

#### 2. 为什么需要合成事件

**问题 1：浏览器兼容性**
```javascript
// 原生事件在不同浏览器中的差异
// IE: event.srcElement
// 其他浏览器: event.target

// React 合成事件统一接口
function handleClick(e) {
  console.log(e.target); // 所有浏览器中都可用
}
```

**问题 2：事件处理器管理复杂**
```javascript
// 原生方式：手动管理事件监听器
class NativeComponent {
  componentDidMount() {
    this.button.addEventListener('click', this.handleClick);
  }

  componentWillUnmount() {
    this.button.removeEventListener('click', this.handleClick); // 容易忘记
  }
}

// React 方式：自动管理
function ReactComponent() {
  const handleClick = () => { /* ... */ };
  return <button onClick={handleClick}>点击</button>;
  // React 自动处理绑定和清理
}
```

### 二、事件委托机制

#### 1. React 17 之前的事件委托

在 React 17 之前，所有事件都被委托到 `document` 节点上。

```javascript
// React 16
<div id="root">
  <button onClick={handleClick}>点击我</button>
</div>

// 实际执行逻辑：
// 1. React 不会直接在 button 上绑定事件
// 2. 而是在 document 上绑定一个统一的事件监听器
// 3. 当点击 button 时，事件冒泡到 document
// 4. React 的事件监听器捕获事件，查找对应的处理函数并执行
```

**原理示意：**
```
用户点击 Button
    ↓
原生事件冒泡到 Document
    ↓
React 在 Document 上的监听器捕获事件
    ↓
React 创建 SyntheticEvent 对象
    ↓
React 找到对应的事件处理函数并执行
```

#### 2. React 17+ 的事件委托变化

React 17 将事件委托从 `document` 改为 React 树的根 DOM 容器（root）。

```javascript
// React 17+
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

// 事件被委托到 #root 节点，而不是 document
```

**为什么改变？**
1. **多个 React 版本共存**：允许页面上同时运行多个 React 版本
2. **微前端场景**：避免不同应用之间的事件冲突
3. **与原生事件更好地集成**

```javascript
// React 17 之前的问题
document.addEventListener('click', () => {
  console.log('原生事件');
}, false);

function App() {
  const handleClick = (e) => {
    e.stopPropagation(); // 无法阻止原生事件
    console.log('React 事件');
  };

  return <button onClick={handleClick}>点击</button>;
}

// 输出：React 事件 → 原生事件
// e.stopPropagation() 只能阻止 React 合成事件的冒泡，
// 无法阻止原生事件（因为事件已经冒泡到 document）

// React 17+ 解决了这个问题
```

### 三、事件池（Event Pooling）机制

#### 1. React 16 及之前的事件池

为了性能优化，React 16 及之前版本使用了事件池机制。

```javascript
// React 16
function handleClick(e) {
  console.log(e.type); // "click"

  setTimeout(() => {
    console.log(e.type); // null - 事件对象已被回收
  }, 0);
}

// 为什么？
// React 重用 SyntheticEvent 对象以提高性能
// 事件处理函数执行完后，所有属性会被清空并放回池中
```

**解决方法：**
```javascript
// 方法 1：调用 e.persist()
function handleClick(e) {
  e.persist(); // 从事件池中移除，阻止回收
  setTimeout(() => {
    console.log(e.type); // "click" - 可以正常访问
  }, 0);
}

// 方法 2：提前保存需要的属性
function handleClick(e) {
  const eventType = e.type;
  setTimeout(() => {
    console.log(eventType); // "click"
  }, 0);
}
```

#### 2. React 17+ 废弃事件池

React 17 废弃了事件池机制，因为现代浏览器性能已经足够好。

```javascript
// React 17+
function handleClick(e) {
  console.log(e.type); // "click"

  setTimeout(() => {
    console.log(e.type); // "click" - 仍然可以访问
  }, 0);

  // 不再需要 e.persist()
}
```

### 四、合成事件与原生事件的区别

#### 1. 命名差异
```javascript
// 原生 HTML
<button onclick="handleClick()">点击</button>

// React（驼峰命名）
<button onClick={handleClick}>点击</button>
```

#### 2. 事件处理函数形式
```javascript
// 原生 HTML
<button onclick="alert('点击了')">点击</button>

// React（传入函数）
<button onClick={() => alert('点击了')}>点击</button>
```

#### 3. 阻止默认行为
```javascript
// 原生 HTML（可以返回 false）
<a href="#" onclick="return false">链接</a>

// React（必须显式调用 preventDefault）
function handleClick(e) {
  e.preventDefault(); // 不能只返回 false
  console.log('阻止了默认行为');
}

<a href="#" onClick={handleClick}>链接</a>
```

#### 4. 事件对象访问
```javascript
function handleEvent(e) {
  // e 是 SyntheticEvent 对象
  console.log(e.nativeEvent); // 访问原生事件对象

  // 合成事件的属性
  console.log(e.type);        // 事件类型
  console.log(e.target);      // 触发事件的元素
  console.log(e.currentTarget); // 绑定事件的元素
}
```

### 五、事件执行顺序

#### 1. 原生事件 vs React 事件的执行顺序

```javascript
function App() {
  const buttonRef = useRef(null);

  useEffect(() => {
    // 原生事件监听（捕获阶段）
    buttonRef.current.addEventListener('click', () => {
      console.log('1. 原生事件 - 捕获');
    }, true);

    // 原生事件监听（冒泡阶段）
    buttonRef.current.addEventListener('click', () => {
      console.log('3. 原生事件 - 冒泡');
    }, false);

    // document 上的原生事件
    document.addEventListener('click', () => {
      console.log('5. Document 原生事件');
    });

    return () => {
      buttonRef.current?.removeEventListener('click', () => {});
      document.removeEventListener('click', () => {});
    };
  }, []);

  const handleClick = () => {
    console.log('2. React 合成事件');
  };

  const handleClickParent = () => {
    console.log('4. React 父组件事件');
  };

  return (
    <div onClick={handleClickParent}>
      <button ref={buttonRef} onClick={handleClick}>
        点击测试
      </button>
    </div>
  );
}

// React 16 输出顺序：
// 1. 原生事件 - 捕获
// 3. 原生事件 - 冒泡
// 2. React 合成事件
// 4. React 父组件事件
// 5. Document 原生事件

// React 17+ 输出顺序（取决于 root 的位置）：
// 1. 原生事件 - 捕获
// 2. React 合成事件
// 4. React 父组件事件
// 3. 原生事件 - 冒泡
// 5. Document 原生事件
```

#### 2. 阻止事件传播的影响

```javascript
function App() {
  const handleClick = (e) => {
    e.stopPropagation(); // 阻止 React 事件冒泡
    console.log('Button React 事件');
  };

  const handleParentClick = () => {
    console.log('Parent React 事件'); // 不会执行
  };

  useEffect(() => {
    document.addEventListener('click', () => {
      console.log('Document 原生事件'); // React 17+ 会执行
    });
  }, []);

  return (
    <div onClick={handleParentClick}>
      <button onClick={handleClick}>点击</button>
    </div>
  );
}
```

### 六、常见陷阱与最佳实践

#### 1. 异步访问事件对象

```javascript
// ❌ 错误：React 16 中异步访问会出错
function handleClick(e) {
  setTimeout(() => {
    console.log(e.type); // React 16: null, React 17+: "click"
  }, 0);
}

// ✅ React 16 解决方案
function handleClick(e) {
  e.persist(); // 保留事件对象
  setTimeout(() => {
    console.log(e.type); // "click"
  }, 0);
}

// ✅ React 17+ 无需处理
function handleClick(e) {
  setTimeout(() => {
    console.log(e.type); // "click"
  }, 0);
}
```

#### 2. 混合使用原生事件和合成事件

```javascript
// ⚠️ 谨慎：混合使用可能导致意外行为
function Component() {
  const ref = useRef(null);

  useEffect(() => {
    const handleNativeClick = (e) => {
      console.log('原生事件');
      e.stopPropagation(); // 只能阻止原生事件冒泡
    };

    ref.current.addEventListener('click', handleNativeClick);
    return () => ref.current?.removeEventListener('click', handleNativeClick);
  }, []);

  const handleReactClick = (e) => {
    console.log('React 事件'); // 仍会执行
    e.stopPropagation(); // 阻止 React 事件冒泡
  };

  return <button ref={ref} onClick={handleReactClick}>点击</button>;
}

// ✅ 最佳实践：统一使用 React 合成事件
```

#### 3. 表单事件处理

```javascript
function Form() {
  const handleSubmit = (e) => {
    e.preventDefault(); // 阻止表单提交
    const formData = new FormData(e.target);
    console.log(Object.fromEntries(formData));
  };

  const handleChange = (e) => {
    // 可以安全地访问 e.target.value
    console.log(e.target.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="username" onChange={handleChange} />
      <button type="submit">提交</button>
    </form>
  );
}
```

#### 4. 自定义事件触发

```javascript
// 在 React 组件中触发自定义事件
function CustomButton({ onCustomEvent }) {
  const handleClick = () => {
    // 触发自定义逻辑
    onCustomEvent({ data: 'custom data' });
  };

  return <button onClick={handleClick}>点击</button>;
}

// 使用
function App() {
  const handleCustomEvent = (data) => {
    console.log('自定义事件:', data);
  };

  return <CustomButton onCustomEvent={handleCustomEvent} />;
}
```

### 七、性能优化

#### 1. 事件处理函数的优化

```javascript
// ❌ 每次渲染都创建新函数
function BadComponent() {
  return <button onClick={() => console.log('clicked')}>点击</button>;
}

// ✅ 使用 useCallback 缓存函数
function GoodComponent() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return <button onClick={handleClick}>点击</button>;
}

// ✅ 类组件中使用类方法
class GoodClassComponent extends React.Component {
  handleClick = () => {
    console.log('clicked');
  }

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}
```

#### 2. 避免在循环中创建内联函数

```javascript
// ❌ 性能差：每个 item 都创建新函数
function BadList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => console.log(item.id)}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}

// ✅ 性能好：使用事件委托
function GoodList({ items, onItemClick }) {
  const handleClick = (e) => {
    const id = e.target.dataset.id;
    onItemClick(id);
  };

  return (
    <ul onClick={handleClick}>
      {items.map(item => (
        <li key={item.id} data-id={item.id}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

### 八、面试回答要点总结

1. **合成事件定义**：对原生事件的跨浏览器封装，统一接口，自动管理生命周期
2. **事件委托**：React 17前委托到document，17+委托到root容器，减少内存占用
3. **事件池**：React 16使用事件池复用对象提升性能，17+废弃（现代浏览器性能已够）
4. **执行顺序**：原生捕获 → React事件 → 原生冒泡，stopPropagation只影响同类型事件
5. **最佳实践**：优先使用合成事件、避免混用原生事件、使用useCallback优化、表单正确处理preventDefault
6. **优势**：跨浏览器兼容、性能优化、与React更新机制集成（批处理）、统一的事件管理
