---
title: Redux 的中间件机制和 redux-saga 原理
tags:
  - 前端React
status: robot
class: 前端React
slug: redux-middleware-saga-principle
ref:
---

## 核心要点

**Redux 中间件是拦截 Action 到达 Reducer 之间的增强器，redux-saga 通过 Generator 函数和 Effects 系统实现了优雅的副作用管理，将复杂异步逻辑从组件中解耦。**

关键概念：
- 🔌 **中间件机制**：洋葱模型，`dispatch → M1 → M2 → reducer → M2 → M1`
- 🌊 **redux-saga**：基于 Generator 的副作用管理库
- ⚡ **Effects**：声明式的副作用描述（call、put、select、take 等）
- 🎯 **可测试性**：纯函数 + Effect 描述符 = 易测试

---

## 详细解答

### 一、Redux 中间件机制

#### 1. 什么是中间件

中间件是 Redux 的插件系统，允许在 **Action 被派发** 和 **到达 Reducer** 之间插入自定义逻辑。

```
Dispatch Action → Middleware 1 → Middleware 2 → Middleware N → Reducer
```

**典型应用场景**：
- 日志记录（记录每个 Action 和状态变化）
- 异步处理（redux-thunk、redux-saga）
- 错误监控（捕获异常并上报）
- 路由同步（react-router-redux）
- 性能分析（埋点统计）

#### 2. 中间件的洋葱模型

```javascript
// 假设有 3 个中间件
const store = createStore(
  reducer,
  applyMiddleware(logger, thunk, crashReporter)
)

// 执行流程（洋葱模型）：
dispatch(action)
  → logger（前）
    → thunk（前）
      → crashReporter（前）
        → Reducer 处理
      → crashReporter（后）
    → thunk（后）
  → logger（后）
→ 通知订阅者
```

可视化：
```
┌─────────────────── logger ───────────────────┐
│ before                                 after │
│  ┌─────────────── thunk ────────────────┐   │
│  │ before                         after │   │
│  │  ┌────── crashReporter ──────┐      │   │
│  │  │ before           after     │      │   │
│  │  │        ┌────────┐         │      │   │
│  │  │        │Reducer │         │      │   │
│  │  │        └────────┘         │      │   │
│  │  └───────────────────────────┘      │   │
│  └──────────────────────────────────────┘   │
└──────────────────────────────────────────────┘
```

#### 3. 中间件的实现原理

**3.1 中间件签名**

```javascript
// 标准的 Redux 中间件签名
const middleware = (store) => (next) => (action) => {
  // store: { getState, dispatch }
  // next: 下一个中间件或 reducer
  // action: 被派发的 action

  // 前置处理
  console.log('dispatching', action)

  // 调用下一个中间件（必须调用！）
  const result = next(action)

  // 后置处理
  console.log('next state', store.getState())

  return result
}
```

**3.2 手写简单中间件**

```javascript
// ========== 日志中间件 ==========
const logger = (store) => (next) => (action) => {
  console.group(action.type)
  console.log('prev state:', store.getState())
  console.log('action:', action)

  const result = next(action)

  console.log('next state:', store.getState())
  console.groupEnd()

  return result
}

// ========== 性能监控中间件 ==========
const performanceMonitor = (store) => (next) => (action) => {
  const start = performance.now()

  const result = next(action)

  const end = performance.now()
  console.log(`Action ${action.type} took ${end - start}ms`)

  return result
}

// ========== 错误捕获中间件 ==========
const crashReporter = (store) => (next) => (action) => {
  try {
    return next(action)
  } catch (err) {
    console.error('Caught an exception!', err)
    // 发送错误到监控服务
    Sentry.captureException(err, {
      extra: {
        action,
        state: store.getState()
      }
    })
    throw err
  }
}
```

**3.3 异步中间件：redux-thunk**

```javascript
// redux-thunk 源码（简化版）
const thunk = (store) => (next) => (action) => {
  // 如果 action 是函数，则执行它
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState)
  }

  // 否则传递给下一个中间件
  return next(action)
}

// 使用示例
const fetchUser = (userId) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_REQUEST' })

    try {
      const response = await fetch(`/api/users/${userId}`)
      const user = await response.json()
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user })
    } catch (error) {
      dispatch({ type: 'FETCH_USER_FAILURE', error })
    }
  }
}

// 组件中
dispatch(fetchUser(123)) // 派发函数而非对象！
```

#### 4. applyMiddleware 的实现原理

```javascript
// Redux applyMiddleware 简化实现
function applyMiddleware(...middlewares) {
  return (createStore) => (reducer, preloadedState) => {
    const store = createStore(reducer, preloadedState)

    let dispatch = store.dispatch

    // 提供给中间件的 API
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action) => dispatch(action) // 闭包引用，确保始终是最新的 dispatch
    }

    // 执行所有中间件，得到包装后的 dispatch 链
    const chain = middlewares.map(middleware => middleware(middlewareAPI))

    // 从右到左组合中间件
    // compose([f, g, h]) => f(g(h(x)))
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch // 返回增强后的 dispatch
    }
  }
}

// compose 工具函数
function compose(...funcs) {
  if (funcs.length === 0) return (arg) => arg
  if (funcs.length === 1) return funcs[0]

  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

**执行过程分析**：

```javascript
const middlewares = [logger, thunk, crashReporter]

// 1. 所有中间件接收 store API
const chain = [
  logger({ getState, dispatch }),
  thunk({ getState, dispatch }),
  crashReporter({ getState, dispatch })
]
// chain = [(next) => (action) => {...}, (next) => (action) => {...}, ...]

// 2. compose 从右到左组合
// compose(logger, thunk, crashReporter)(store.dispatch)
// = logger(thunk(crashReporter(store.dispatch)))

// 3. 最终的 dispatch 调用链
dispatch(action)
  → logger's (action) => {}
    → thunk's (action) => {}
      → crashReporter's (action) => {}
        → store.dispatch(action) // 原始 dispatch
```

---

### 二、redux-saga 核心原理

#### 1. 为什么需要 redux-saga

**redux-thunk 的局限性**：

```javascript
// ❌ 复杂异步逻辑难以管理
const complexFlow = () => async (dispatch, getState) => {
  dispatch({ type: 'START' })

  // 逻辑 1：轮询等待某个条件
  while (!getState().ready) {
    await delay(1000)
  }

  // 逻辑 2：并发请求
  const [users, posts] = await Promise.all([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/posts').then(r => r.json())
  ])

  // 逻辑 3：竞态条件（只取最快的）
  const fastestData = await Promise.race([
    fetch('/api/fast').then(r => r.json()),
    fetch('/api/slow').then(r => r.json())
  ])

  dispatch({ type: 'COMPLETE', payload: { users, posts, fastestData } })
}

// 问题：
// 1. 无法取消（用户快速切换页面时产生冗余请求）
// 2. 难以测试（需要 mock fetch、delay）
// 3. 逻辑混乱（业务逻辑和副作用耦合）
```

**redux-saga 的优势**：

```javascript
// ✅ redux-saga：声明式、可测试、可取消
import { call, put, race, select, delay } from 'redux-saga/effects'

function* complexFlow() {
  yield put({ type: 'START' })

  // 逻辑 1：轮询等待
  while (!(yield select(state => state.ready))) {
    yield delay(1000)
  }

  // 逻辑 2：并发请求
  const [users, posts] = yield all([
    call(fetch, '/api/users'),
    call(fetch, '/api/posts')
  ])

  // 逻辑 3：竞态条件
  const { fast } = yield race({
    fast: call(fetch, '/api/fast'),
    slow: call(fetch, '/api/slow')
  })

  yield put({ type: 'COMPLETE', payload: { users, posts, fastestData: fast } })
}

// 优势：
// 1. 可取消（task.cancel()）
// 2. 易测试（Effects 是纯对象）
// 3. 清晰（Generator 线性流程）
```

#### 2. Generator 基础回顾

```javascript
// Generator 函数（带 * 号）
function* countGenerator() {
  console.log('Start')
  yield 1          // 暂停点 1
  console.log('Middle')
  yield 2          // 暂停点 2
  console.log('End')
  return 3         // 结束
}

const gen = countGenerator()

console.log(gen.next()) // { value: 1, done: false } + 打印 'Start'
console.log(gen.next()) // { value: 2, done: false } + 打印 'Middle'
console.log(gen.next()) // { value: 3, done: true }  + 打印 'End'

// Generator 的双向通信
function* dataGenerator() {
  const a = yield 'Give me A'
  console.log('Got A:', a)

  const b = yield 'Give me B'
  console.log('Got B:', b)

  return a + b
}

const gen2 = dataGenerator()
console.log(gen2.next())      // { value: 'Give me A', done: false }
console.log(gen2.next(10))    // 传入 10 作为第一个 yield 的返回值
                               // 打印 'Got A: 10'
                               // { value: 'Give me B', done: false }
console.log(gen2.next(20))    // 传入 20
                               // 打印 'Got B: 20'
                               // { value: 30, done: true }
```

#### 3. redux-saga 的 Effects 系统

Effects 是**描述副作用的纯对象**，由 saga middleware 执行。

```javascript
// ========== 核心 Effects ==========

// 1. call - 调用函数（同步或异步）
yield call(fetch, '/api/users')
// 返回 { type: 'CALL', fn: fetch, args: ['/api/users'] }

// 2. put - 派发 Action
yield put({ type: 'USER_LOADED', payload: user })
// 返回 { type: 'PUT', action: { type: 'USER_LOADED', ... } }

// 3. select - 读取 Redux state
const userId = yield select(state => state.user.id)
// 返回 { type: 'SELECT', selector: (state) => state.user.id }

// 4. take - 等待特定 Action（阻塞）
const action = yield take('BUTTON_CLICKED')
console.log('Button was clicked with payload:', action.payload)

// 5. takeEvery - 监听每个 Action（非阻塞）
yield takeEvery('FETCH_USER', fetchUserSaga)
// 每次 FETCH_USER 时都启动新的 fetchUserSaga

// 6. takeLatest - 只保留最新的（自动取消旧任务）
yield takeLatest('SEARCH_INPUT', searchSaga)
// 用户快速输入时，只执行最后一次搜索

// 7. fork - 非阻塞调用
const task = yield fork(backgroundTask)
// 继续执行，不等待 backgroundTask 完成

// 8. cancel - 取消任务
yield cancel(task)

// 9. all - 并发执行（类似 Promise.all）
const [users, posts] = yield all([
  call(fetchUsers),
  call(fetchPosts)
])

// 10. race - 竞态（类似 Promise.race）
const { data, timeout } = yield race({
  data: call(fetchData),
  timeout: delay(5000)
})

if (timeout) {
  console.log('Request timeout!')
}
```

#### 4. redux-saga 基本用法

**4.1 简单异步请求**

```javascript
// sagas/userSaga.js
import { call, put, takeEvery } from 'redux-saga/effects'
import * as api from '../api'

// Worker Saga：处理具体逻辑
function* fetchUserSaga(action) {
  try {
    const userId = action.payload

    // 发起 loading 状态
    yield put({ type: 'FETCH_USER_REQUEST' })

    // 调用 API（阻塞，等待完成）
    const user = yield call(api.fetchUser, userId)

    // 成功
    yield put({ type: 'FETCH_USER_SUCCESS', payload: user })
  } catch (error) {
    // 失败
    yield put({ type: 'FETCH_USER_FAILURE', error })
  }
}

// Watcher Saga：监听 Action
function* watchFetchUser() {
  yield takeEvery('FETCH_USER', fetchUserSaga)
}

// Root Saga
export default function* rootSaga() {
  yield all([
    watchFetchUser(),
    // 其他 watcher sagas...
  ])
}

// store.js
import createSagaMiddleware from 'redux-saga'
import rootSaga from './sagas'

const sagaMiddleware = createSagaMiddleware()
const store = createStore(
  reducer,
  applyMiddleware(sagaMiddleware)
)

sagaMiddleware.run(rootSaga) // 启动 saga
```

**4.2 复杂流程控制**

```javascript
// ========== 登录流程示例 ==========
function* loginFlow() {
  while (true) {
    // 1. 等待登录请求
    const { payload } = yield take('LOGIN_REQUEST')

    // 2. 发起登录 API 调用
    const { user, error } = yield call(loginApi, payload)

    if (user) {
      yield put({ type: 'LOGIN_SUCCESS', user })

      // 3. 登录成功后，启动后台任务
      const bgTask = yield fork(fetchUserDataInBackground, user.id)

      // 4. 等待登出或会话过期
      const action = yield take(['LOGOUT', 'SESSION_EXPIRED'])

      if (action.type === 'LOGOUT') {
        yield call(logoutApi)
        yield cancel(bgTask) // 取消后台任务
      }

      yield put({ type: 'LOGOUT_SUCCESS' })
    } else {
      yield put({ type: 'LOGIN_FAILURE', error })
    }
  }
}

// 后台任务
function* fetchUserDataInBackground(userId) {
  while (true) {
    yield call(syncUserData, userId)
    yield delay(60000) // 每分钟同步一次
  }
}
```

**4.3 防抖和节流**

```javascript
import { debounce, throttle } from 'redux-saga/effects'

// 防抖：用户停止输入 500ms 后才执行
function* watchSearchInput() {
  yield debounce(500, 'SEARCH_INPUT', searchSaga)
}

// 节流：1秒内最多执行一次
function* watchScroll() {
  yield throttle(1000, 'WINDOW_SCROLL', handleScrollSaga)
}
```

**4.4 重试机制**

```javascript
import { retry, delay } from 'redux-saga/effects'

function* fetchWithRetry() {
  try {
    // 最多重试 3 次，间隔 2 秒
    const data = yield retry(3, 2000, fetchApi)
    yield put({ type: 'FETCH_SUCCESS', data })
  } catch (error) {
    yield put({ type: 'FETCH_FAILED', error })
  }
}

// 自定义重试逻辑
function* customRetry() {
  let retries = 0
  const maxRetries = 3

  while (retries < maxRetries) {
    try {
      const data = yield call(fetchApi)
      yield put({ type: 'SUCCESS', data })
      return
    } catch (error) {
      retries++
      if (retries >= maxRetries) {
        yield put({ type: 'FAILED', error })
      } else {
        yield delay(Math.pow(2, retries) * 1000) // 指数退避
      }
    }
  }
}
```

#### 5. 高级模式

**5.1 请求竞态处理（最新请求优先）**

```javascript
// 场景：用户快速输入搜索关键词
function* watchSearch() {
  yield takeLatest('SEARCH', searchSaga)
  // 自动取消旧的 searchSaga，只保留最新的
}

function* searchSaga(action) {
  const { query } = action.payload
  const results = yield call(searchApi, query)
  yield put({ type: 'SEARCH_SUCCESS', results })
}
```

**5.2 乐观更新 + 回滚**

```javascript
function* updateUserSaga(action) {
  const { userId, updates } = action.payload

  // 1. 保存旧状态
  const oldUser = yield select(state => state.users[userId])

  // 2. 乐观更新 UI
  yield put({ type: 'UPDATE_USER_OPTIMISTIC', userId, updates })

  try {
    // 3. 发送请求
    yield call(updateUserApi, userId, updates)
    yield put({ type: 'UPDATE_USER_SUCCESS' })
  } catch (error) {
    // 4. 失败时回滚
    yield put({ type: 'UPDATE_USER_ROLLBACK', userId, oldUser })
    yield put({ type: 'SHOW_ERROR', message: 'Update failed' })
  }
}
```

**5.3 Channel 通信**

```javascript
import { channel } from 'redux-saga'
import { take, put, fork } from 'redux-saga/effects'

// 创建事件通道（类似 EventEmitter）
function* watchMessages() {
  const chan = yield call(channel)

  // 启动消费者
  yield fork(messageConsumer, chan)

  // 启动生产者
  yield fork(messageProducer, chan)
}

function* messageProducer(chan) {
  while (true) {
    const action = yield take('SEND_MESSAGE')
    yield put(chan, action.payload) // 发送到 channel
  }
}

function* messageConsumer(chan) {
  while (true) {
    const message = yield take(chan) // 从 channel 接收
    yield call(processMessage, message)
  }
}
```

#### 6. 测试 saga（核心优势）

```javascript
// saga
function* fetchUserSaga(action) {
  const userId = action.payload
  const user = yield call(api.fetchUser, userId)
  yield put({ type: 'FETCH_USER_SUCCESS', payload: user })
}

// 测试（无需 mock fetch！）
import { call, put } from 'redux-saga/effects'

test('fetchUserSaga', () => {
  const action = { type: 'FETCH_USER', payload: 123 }
  const gen = fetchUserSaga(action)

  // 第 1 步：验证 call effect
  expect(gen.next().value).toEqual(
    call(api.fetchUser, 123)
  )

  // 第 2 步：注入 mock 数据
  const mockUser = { id: 123, name: 'Alice' }
  expect(gen.next(mockUser).value).toEqual(
    put({ type: 'FETCH_USER_SUCCESS', payload: mockUser })
  )

  // 第 3 步：验证完成
  expect(gen.next().done).toBe(true)
})

// 测试错误流程
test('fetchUserSaga error handling', () => {
  const gen = fetchUserSaga({ payload: 123 })

  gen.next() // call effect

  // 注入错误
  const error = new Error('Network error')
  expect(gen.throw(error).value).toEqual(
    put({ type: 'FETCH_USER_FAILURE', error })
  )
})
```

#### 7. redux-saga 实现原理（简化版）

```javascript
// 简化的 saga middleware 实现
function createSagaMiddleware() {
  const sagaTasks = []

  const middleware = (store) => (next) => (action) => {
    // 1. 先让 action 到达 reducer
    const result = next(action)

    // 2. 通知所有 saga 有新 action
    sagaTasks.forEach(task => task.next(action))

    return result
  }

  // run 方法：启动 root saga
  middleware.run = (rootSaga) => {
    const task = runSaga(rootSaga, store)
    sagaTasks.push(task)
  }

  return middleware
}

// 执行 saga generator
function runSaga(saga, store) {
  const gen = saga()

  function processNext(arg) {
    const { value: effect, done } = gen.next(arg)

    if (done) return

    // 解析 effect 并执行
    if (effect.type === 'CALL') {
      const result = effect.fn(...effect.args)

      if (result.then) {
        // 异步函数
        result.then(processNext)
      } else {
        // 同步函数
        processNext(result)
      }
    } else if (effect.type === 'PUT') {
      store.dispatch(effect.action)
      processNext()
    } else if (effect.type === 'SELECT') {
      const result = effect.selector(store.getState())
      processNext(result)
    } else if (effect.type === 'TAKE') {
      // 等待特定 action（简化实现）
      const unsubscribe = store.subscribe(() => {
        const state = store.getState()
        // 检查是否是目标 action...
        unsubscribe()
        processNext(action)
      })
    }
  }

  processNext()

  return gen
}
```

---

### 三、redux-saga vs redux-thunk

| 维度 | redux-thunk | redux-saga |
|------|-------------|------------|
| **学习曲线** | 简单（就是函数） | 陡峭（Generator + Effects） |
| **代码量** | 少 | 多 |
| **可测试性** | 困难（需 mock 副作用） | 容易（Effect 是纯对象） |
| **流程控制** | 基础（async/await） | 强大（take、race、fork 等） |
| **取消请求** | 手动实现 | 内置支持 |
| **复杂异步** | 难以维护 | 声明式，清晰 |
| **适用场景** | 简单异步请求 | 复杂业务流程、WebSocket、轮询 |

**示例对比**：

```javascript
// ========== redux-thunk ==========
const fetchUser = (userId) => async (dispatch) => {
  dispatch({ type: 'LOADING' })

  try {
    const user = await fetch(`/api/users/${userId}`).then(r => r.json())
    dispatch({ type: 'SUCCESS', user })
  } catch (error) {
    dispatch({ type: 'ERROR', error })
  }
}

// ========== redux-saga ==========
function* fetchUserSaga(action) {
  yield put({ type: 'LOADING' })

  try {
    const user = yield call(fetch, `/api/users/${action.payload}`)
    yield put({ type: 'SUCCESS', user })
  } catch (error) {
    yield put({ type: 'ERROR', error })
  }
}

function* watchFetchUser() {
  yield takeLatest('FETCH_USER', fetchUserSaga)
}
```

---

### 四、实战最佳实践

#### 1. 组织结构

```
src/
  store/
    sagas/
      index.js           # Root saga
      userSaga.js        # 用户相关 saga
      orderSaga.js       # 订单相关 saga
      authSaga.js        # 认证相关 saga
    slices/
      userSlice.js       # Redux Toolkit slice
    index.js             # Store 配置
```

#### 2. 与 Redux Toolkit 结合

```javascript
// userSlice.js (RTK)
import { createSlice } from '@reduxjs/toolkit'

const userSlice = createSlice({
  name: 'user',
  initialState: { data: null, loading: false },
  reducers: {
    fetchUserRequest: (state) => { state.loading = true },
    fetchUserSuccess: (state, action) => {
      state.data = action.payload
      state.loading = false
    },
    fetchUserFailure: (state) => { state.loading = false }
  }
})

export const { fetchUserRequest, fetchUserSuccess, fetchUserFailure } = userSlice.actions
export default userSlice.reducer

// userSaga.js
import { call, put, takeLatest } from 'redux-saga/effects'
import { fetchUserRequest, fetchUserSuccess, fetchUserFailure } from './userSlice'

function* fetchUserSaga(action) {
  try {
    const user = yield call(api.fetchUser, action.payload)
    yield put(fetchUserSuccess(user))
  } catch (error) {
    yield put(fetchUserFailure())
  }
}

export default function* userSagaWatcher() {
  yield takeLatest(fetchUserRequest.type, fetchUserSaga)
}
```

#### 3. 错误处理统一化

```javascript
// 全局错误处理 saga
function* globalErrorHandler() {
  yield takeEvery('*', function* (action) {
    if (action.type.endsWith('_FAILURE')) {
      yield put({ type: 'SHOW_TOAST', message: action.error.message })
      yield call(logErrorToServer, action.error)
    }
  })
}
```

#### 4. 性能优化

```javascript
// 使用 channel 批量处理
import { actionChannel, take, call } from 'redux-saga/effects'

function* watchRequests() {
  // 创建缓冲通道
  const requestChan = yield actionChannel('API_REQUEST')

  while (true) {
    // 从通道中取出 action（排队处理，避免并发过多）
    const action = yield take(requestChan)
    yield call(handleRequest, action)
  }
}
```

---

## 总结

### 中间件机制
- Redux 中间件基于**洋葱模型**，通过函数组合增强 dispatch
- `applyMiddleware` 通过 compose 从右到左组合中间件
- 中间件可以拦截、修改、延迟甚至阻止 Action

### redux-saga
- 基于 **Generator** 和 **Effects** 实现声明式副作用管理
- 核心优势：**可测试**（Effects 是纯对象）、**可取消**、**强大的流程控制**
- 适合复杂异步场景：轮询、WebSocket、多步骤流程、竞态处理

### 选择建议
- **简单异步**：redux-thunk（或 RTK createAsyncThunk）
- **复杂业务流程**：redux-saga
- **现代项目**：考虑 RTK Query（内置缓存、自动重试）

掌握 redux-saga 能够优雅地处理复杂异步逻辑，是高级 React 开发者的必备技能。
