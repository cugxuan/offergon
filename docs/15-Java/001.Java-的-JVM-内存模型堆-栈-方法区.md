---
title: Java 的 JVM 内存模型（堆、栈、方法区）
tags:
  - Java
  - 内存管理
status: robot
class: Java
slug: jvm-memory-model-heap-stack-method-area
ref:
---

## 核心要点

- **堆（Heap）**：存储对象实例，分为新生代和老年代，是垃圾回收的主要区域
- **栈（Stack）**：存储局部变量和方法调用信息，线程私有，自动管理内存
- **方法区（Method Area）**：存储类信息、常量池、静态变量，JDK8后改为元空间（Metaspace）

## 详细解答

### 1. 堆内存（Heap Memory）

堆是JVM中最大的内存区域，用于存储所有对象实例和数组。

**特点：**
- 线程共享
- 垃圾收集的主要区域
- 在JVM启动时创建

**分代结构：**
```
堆内存
├── 新生代（Young Generation）
│   ├── Eden区：新对象分配的区域
│   ├── Survivor0（S0）：经过一次GC存活的对象
│   └── Survivor1（S1）：经过多次GC存活的对象
└── 老年代（Old Generation）
    └── 长期存活的对象
```

**内存分配过程：**
1. 新对象首先在Eden区分配
2. Eden区满时触发Minor GC
3. 存活对象移至Survivor区
4. 经过多次GC后仍存活的对象晋升到老年代

### 2. 栈内存（Stack Memory）

栈是线程私有的内存区域，用于存储方法调用和局部变量。

**组成部分：**
- **局部变量表**：存储方法参数和局部变量
- **操作数栈**：存储计算过程中的中间结果
- **动态链接**：指向运行时常量池的方法引用
- **方法出口**：方法返回地址

**生命周期：**
```java
public void method() {
    int a = 10;        // 局部变量存储在栈中
    String str = "hello"; // str引用存储在栈中，"hello"对象存储在堆中
    method2();         // 方法调用信息压入栈
} // 方法结束，栈帧弹出，局部变量自动销毁
```

### 3. 方法区（Method Area）

方法区存储类的元数据信息，是线程共享的内存区域。

**存储内容：**
- **类信息**：类的访问标志、字段描述、方法描述等
- **运行时常量池**：编译期常量、字符串常量池
- **静态变量**：类的静态成员变量
- **即时编译器编译后的代码**：JIT编译的本地代码

**JDK版本差异：**
```
JDK 7及以前：方法区 = 永久代（PermGen）
JDK 8及以后：方法区 = 元空间（Metaspace）
```

**元空间的优势：**
- 使用本地内存，不再受JVM堆大小限制
- 减少OOM错误
- 提高GC效率

### 4. 内存分配示例

```java
public class MemoryExample {
    private static String staticVar = "静态变量"; // 存储在方法区

    public void createObjects() {
        int localVar = 100;           // 存储在栈的局部变量表
        String str = new String("hello"); // str引用在栈，对象在堆

        List<Integer> list = new ArrayList<>(); // list引用在栈，ArrayList对象在堆
        list.add(localVar);           // Integer对象在堆
    }
}
```

### 5. 内存溢出场景

**堆溢出（OutOfMemoryError: Java heap space）：**
```java
List<Object> list = new ArrayList<>();
while (true) {
    list.add(new Object()); // 不断创建对象，导致堆内存耗尽
}
```

**栈溢出（StackOverflowError）：**
```java
public void recursiveMethod() {
    recursiveMethod(); // 无限递归，导致栈溢出
}
```

**方法区溢出（OutOfMemoryError: Metaspace）：**
```java
// 动态生成大量类，导致元空间溢出
while (true) {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(Object.class);
    enhancer.setCallback(NoOp.INSTANCE);
    enhancer.create();
}
```

### 6. 调优参数

**堆内存调优：**
```bash
-Xms2g          # 初始堆大小
-Xmx4g          # 最大堆大小
-Xmn1g          # 新生代大小
-XX:SurvivorRatio=8  # Eden:Survivor = 8:1
```

**栈内存调优：**
```bash
-Xss1m          # 每个线程的栈大小
```

**方法区调优：**
```bash
-XX:MetaspaceSize=256m    # 元空间初始大小
-XX:MaxMetaspaceSize=512m # 元空间最大大小
```

### 总结

JVM内存模型的设计充分考虑了Java程序的运行特点：
- 堆用于动态分配，支持垃圾回收
- 栈用于方法调用，自动管理生命周期
- 方法区用于存储类信息，提供运行时支持

理解这三个区域的特点和作用，对于Java程序的性能调优和问题排查至关重要。
