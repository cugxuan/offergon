---
title: HashMap 的底层实现和扩容机制
tags:
  - Java
status: robot
class: Java
slug: hashmap-implementation-resize-mechanism
ref:
---

## 核心要点

- **底层结构演进**：数组+链表（JDK1.7）→ 数组+链表+红黑树（JDK1.8+）
- **哈希算法优化**：扰动函数减少哈希冲突，提高分布均匀性
- **扩容机制**：负载因子0.75触发扩容，容量翻倍，重新哈希分布
- **性能优化**：红黑树化（链表长度≥8）、尾插法避免环形链表

## 详细解答

### 1. HashMap整体架构

HashMap是基于哈希表实现的Map接口，通过key的hashCode确定存储位置，是Java中最常用的集合类之一。

**核心组成部分：**
- **Node数组**：存储键值对的桶（bucket）
- **哈希函数**：将key映射到数组索引
- **冲突解决**：链表法 + 红黑树优化
- **扩容机制**：动态调整容量

### 2. JDK 1.7 vs JDK 1.8+ 架构对比

#### JDK 1.7 架构
```java
// JDK 1.7 的简化结构
public class HashMap<K,V> {
    // 默认初始容量 16
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 << 30;

    // 默认负载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 存储数据的数组
    Entry<K,V>[] table;

    // 当前元素个数
    int size;

    // 扩容阈值 = capacity * load factor
    int threshold;

    // 负载因子
    final float loadFactor;
}

// JDK 1.7 的链表节点
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;  // 指向下一个节点
    final int hash;
}
```

#### JDK 1.8+ 架构
```java
// JDK 1.8+ 的简化结构
public class HashMap<K,V> {
    // 红黑树化阈值
    static final int TREEIFY_THRESHOLD = 8;

    // 红黑树退化为链表阈值
    static final int UNTREEIFY_THRESHOLD = 6;

    // 红黑树化的最小桶数组容量
    static final int MIN_TREEIFY_CAPACITY = 64;

    // 存储数据的数组
    Node<K,V>[] table;

    // 当前元素个数
    int size;

    // 扩容阈值
    int threshold;
}

// JDK 1.8+ 的链表节点
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}

// 红黑树节点
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // 父节点
    TreeNode<K,V> left;    // 左子节点
    TreeNode<K,V> right;   // 右子节点
    TreeNode<K,V> prev;    // 前一个节点（用于删除时维护链表结构）
    boolean red;           // 颜色标识
}
```

### 3. 哈希算法详解

#### 哈希函数实现
```java
// JDK 1.8 中的hash方法
static final int hash(Object key) {
    int h;
    // 如果key为null，hash值为0
    // 否则使用key的hashCode的高16位和低16位进行异或运算
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// 获取数组索引的方法
// 在put/get方法中使用：(n - 1) & hash
// 其中n是数组长度，必须是2的幂
```

#### 为什么要进行扰动计算？
```java
// 扰动函数的作用演示
public class HashDisturbanceDemo {
    public static void main(String[] args) {
        // 假设数组长度为16，则n-1 = 15 = 0000 1111（二进制）
        // 只有低4位参与运算，高位信息会丢失

        // 没有扰动的情况
        int hash1 = "Aa".hashCode();  // 2112
        int hash2 = "BB".hashCode();  // 2112
        System.out.println("相同hashCode: " + (hash1 == hash2)); // true

        // 进行扰动后
        int disturbed1 = hash1 ^ (hash1 >>> 16);
        int disturbed2 = hash2 ^ (hash2 >>> 16);

        // 计算在长度为16的数组中的索引
        int index1 = (16 - 1) & disturbed1;
        int index2 = (16 - 1) & disturbed2;

        System.out.println("扰动后的索引1: " + index1);
        System.out.println("扰动后的索引2: " + index2);

        // 通过扰动函数，相同hashCode的key可能得到不同的索引
        // 减少哈希冲突的概率
    }
}
```

#### 为什么数组长度必须是2的幂？
```java
public class PowerOfTwoDemo {
    public static void main(String[] args) {
        // 当数组长度是2的幂时，n-1的二进制表示全为1
        // 例如：16-1=15，二进制为 0000 1111
        // 这样 hash & (n-1) 能够均匀分布到各个桶中

        int arrayLength = 16;  // 2^4
        int mask = arrayLength - 1;  // 15 = 0000 1111

        // 演示不同hash值的分布
        for (int hash = 0; hash < 32; hash++) {
            int index = hash & mask;
            System.out.println("hash=" + hash + ", index=" + index);
        }

        // 如果数组长度不是2的幂（比如15）
        int badLength = 15;
        int badMask = badLength - 1;  // 14 = 0000 1110
        // 这会导致索引0永远不会被使用（因为最低位始终为0）
        // 造成分布不均匀
    }
}
```

### 4. 核心操作实现

#### put操作详解
```java
// JDK 1.8 put方法的简化实现
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;

    // 1. 如果table为空或长度为0，进行初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

    // 2. 计算索引位置，如果该位置为空，直接插入
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;

        // 3. 如果key已存在，记录已存在的节点
        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        // 4. 如果是红黑树节点，使用红黑树插入
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // 5. 链表插入
        else {
            for (int binCount = 0; ; ++binCount) {
                // 到达链表尾部，插入新节点
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 如果链表长度达到阈值，转换为红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }
                // 找到相同key的节点
                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }

        // 6. 如果key已存在，更新value
        if (e != null) {
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }

    ++modCount;
    // 7. 如果size超过阈值，进行扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

#### get操作详解
```java
// get方法的简化实现
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;

    // 1. 检查table是否为空，计算索引位置
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {

        // 2. 检查第一个节点
        if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k))))
            return first;

        // 3. 如果有后续节点
        if ((e = first.next) != null) {
            // 4. 如果是红黑树，使用红黑树查找
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);

            // 5. 链表查找
            do {
                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

### 5. 扩容机制详解

#### 扩容触发条件
```java
// 扩容触发的条件
public class ResizeTrigger {
    // 1. 初始化时，第一次put操作
    // 2. size > threshold（threshold = capacity * loadFactor）
    // 3. 链表转红黑树时，如果数组容量 < MIN_TREEIFY_CAPACITY(64)

    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();

        // 默认容量16，负载因子0.75，阈值为12
        // 当添加第13个元素时会触发扩容
        for (int i = 0; i < 13; i++) {
            map.put("key" + i, "value" + i);
            System.out.println("Size: " + map.size());
        }
    }
}
```

#### 扩容过程实现
```java
// resize方法的简化实现
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;

    if (oldCap > 0) {
        // 如果已达到最大容量，不再扩容
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 容量翻倍，阈值也翻倍
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1;
    }
    // 初始化情况处理
    else if (oldThr > 0)
        newCap = oldThr;
    else {
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }

    // 计算新的阈值
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }

    threshold = newThr;
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;

    // 重新分配已有元素
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;

                // 单个节点
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                // 红黑树
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                // 链表
                else {
                    // JDK 1.8 优化：将链表分成两部分
                    Node<K,V> loHead = null, loTail = null;  // 低位链表
                    Node<K,V> hiHead = null, hiTail = null;  // 高位链表
                    Node<K,V> next;

                    do {
                        next = e.next;
                        // 原位置
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原位置 + oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);

                    // 放入新数组
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

#### JDK 1.8 扩容优化
```java
// JDK 1.8 扩容优化原理
public class ResizeOptimization {
    public static void main(String[] args) {
        // 假设原数组长度为16，扩容后为32
        int oldCap = 16;  // 10000 (二进制)
        int newCap = 32;  // 100000 (二进制)

        // 原来的计算方式：hash & (oldCap - 1)
        // 新的计算方式：hash & (newCap - 1)

        // 关键观察：hash & oldCap
        // 如果结果为0，说明hash的第5位为0，新位置 = 原位置
        // 如果结果为1，说明hash的第5位为1，新位置 = 原位置 + oldCap

        // 示例：
        int hash1 = 0b10101;  // 21
        int hash2 = 0b11101;  // 29

        int oldIndex1 = hash1 & (oldCap - 1);  // 21 & 15 = 5
        int oldIndex2 = hash2 & (oldCap - 1);  // 29 & 15 = 13

        System.out.println("原索引1: " + oldIndex1);  // 5
        System.out.println("原索引2: " + oldIndex2);  // 13

        // 判断是否需要移动
        boolean move1 = (hash1 & oldCap) != 0;  // false
        boolean move2 = (hash2 & oldCap) != 0;  // true

        int newIndex1 = move1 ? oldIndex1 + oldCap : oldIndex1;  // 5
        int newIndex2 = move2 ? oldIndex2 + oldCap : oldIndex2;  // 13 + 16 = 29

        System.out.println("新索引1: " + newIndex1);  // 5
        System.out.println("新索引2: " + newIndex2);  // 29

        // 这样避免了重新计算hash & (newCap - 1)，提高了效率
    }
}
```

### 6. 红黑树优化

#### 链表转红黑树的条件
```java
// 红黑树化的条件判断
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;

    // 条件1：数组为空或长度小于64，先进行扩容而不是树化
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    // 条件2：对应桶不为空，进行树化
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,V> hd = null, tl = null;

        // 将链表节点转换为树节点
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);

        // 构建红黑树
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```

#### 红黑树退化为链表
```java
// 当红黑树节点数量 <= 6时，退化为链表
final Node<K,V> untreeify(HashMap<K,V> map) {
    Node<K,V> hd = null, tl = null;
    for (Node<K,V> q = this; q != null; q = q.next) {
        Node<K,V> p = map.replacementNode(q, null);
        if (tl == null)
            hd = p;
        else
            tl.next = p;
        tl = p;
    }
    return hd;
}
```

### 7. 负载因子和性能分析

#### 负载因子的影响
```java
public class LoadFactorAnalysis {
    public static void main(String[] args) {
        // 负载因子0.75的选择是时间和空间的平衡

        // 负载因子过小（如0.5）：
        // 优点：冲突少，查询快
        // 缺点：空间利用率低，内存浪费

        // 负载因子过大（如1.0）：
        // 优点：空间利用率高
        // 缺点：冲突多，性能下降

        // 测试不同负载因子的性能
        testLoadFactor(0.5f);
        testLoadFactor(0.75f);
        testLoadFactor(1.0f);
    }

    static void testLoadFactor(float loadFactor) {
        Map<Integer, String> map = new HashMap<>(16, loadFactor);

        long startTime = System.nanoTime();

        // 插入数据
        for (int i = 0; i < 10000; i++) {
            map.put(i, "value" + i);
        }

        // 查询数据
        for (int i = 0; i < 10000; i++) {
            map.get(i);
        }

        long endTime = System.nanoTime();
        System.out.printf("负载因子%.2f，耗时：%d纳秒%n",
            loadFactor, endTime - startTime);
    }
}
```

### 8. 线程安全问题

#### JDK 1.7 的死循环问题
```java
// JDK 1.7 中的头插法可能导致死循环
// 扩容时，如果多个线程同时操作，可能形成环形链表

// 问题场景：
// 线程1和线程2同时执行扩容操作
// 原链表：A -> B -> C
// 线程1执行到一半时被挂起
// 线程2完成扩容：B -> A -> null
// 线程1恢复执行，可能形成 A -> B -> A 的环形链表

// JDK 1.8 解决方案：
// 1. 使用尾插法，避免链表顺序颠倒
// 2. 将链表分成两部分，降低形成环的概率
```

#### 线程安全的替代方案
```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;

public class ThreadSafeMaps {
    public static void main(String[] args) {
        // 方案1：使用ConcurrentHashMap（推荐）
        Map<String, String> concurrentMap = new ConcurrentHashMap<>();

        // 方案2：使用Collections.synchronizedMap
        Map<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());

        // 方案3：使用Hashtable（不推荐，性能差）
        Map<String, String> hashtable = new Hashtable<>();

        // 注意：即使使用synchronizedMap，遍历时仍需同步
        synchronized (syncMap) {
            for (Map.Entry<String, String> entry : syncMap.entrySet()) {
                // 安全的遍历
            }
        }
    }
}
```

### 9. 性能优化建议

#### 容量规划
```java
public class CapacityPlanning {
    public static void main(String[] args) {
        // 错误做法：使用默认容量
        Map<String, String> badMap = new HashMap<>(); // 默认16

        // 如果要存储1000个元素，会触发多次扩容
        // 16 -> 32 -> 64 -> 128 -> 256 -> 512 -> 1024

        // 正确做法：预估容量
        int expectedSize = 1000;
        int initialCapacity = (int)(expectedSize / 0.75f) + 1;
        Map<String, String> goodMap = new HashMap<>(initialCapacity);

        // 或使用Google Guava库的Maps.newHashMapWithExpectedSize
        // Map<String, String> guavaMap = Maps.newHashMapWithExpectedSize(1000);
    }
}
```

#### 自定义hashCode和equals
```java
public class HashCodeOptimization {
    static class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        // 高质量的hashCode实现
        @Override
        public int hashCode() {
            int result = 17;
            result = 31 * result + (name != null ? name.hashCode() : 0);
            result = 31 * result + age;
            return result;
        }

        // equals必须与hashCode保持一致
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;

            Person person = (Person) obj;
            return age == person.age &&
                   (name != null ? name.equals(person.name) : person.name == null);
        }
    }

    public static void main(String[] args) {
        Map<Person, String> personMap = new HashMap<>();

        Person p1 = new Person("Alice", 25);
        Person p2 = new Person("Alice", 25);

        personMap.put(p1, "Engineer");

        // 由于重写了hashCode和equals，p2能找到对应的值
        System.out.println(personMap.get(p2)); // "Engineer"
    }
}
```

### 10. 总结

HashMap的设计体现了计算机科学中多个重要概念：

1. **空间时间权衡**：通过负载因子平衡内存使用和性能
2. **动态调整**：扩容机制适应数据规模变化
3. **算法优化**：红黑树优化最坏情况性能
4. **工程实践**：JDK版本间的持续优化改进

掌握HashMap的实现原理，不仅有助于正确使用这个核心数据结构，也为理解其他哈希表实现和设计高性能系统奠定基础。
