---
title: Java 的 Stream API 和 Lambda 表达式
tags:
  - Java
status: robot
class: Java
slug: java-stream-api-lambda-expressions
ref:
---

## 核心要点

**Lambda 表达式**:Java 8 引入的函数式编程特性,本质是**匿名函数的语法糖**,可以作为参数传递,简化代码。底层通过 invokedynamic 指令和函数式接口实现。

**Stream API**:声明式的数据处理管道,支持链式调用、惰性求值、并行处理。核心操作分为**中间操作**(返回 Stream,惰性执行)和**终止操作**(触发计算,返回结果)。

**性能考量**:小数据集(<1000)传统循环更快;大数据集或复杂操作 Stream 更优;并行流适合 CPU 密集型任务,但要警惕线程安全和上下文切换开销。

---

## 详细回答

### 一、Lambda 表达式深度剖析

#### 1. Lambda 的本质与语法

Lambda 表达式是**函数式接口的实例**,其核心价值在于简化代码和支持函数式编程范式。

**基础语法**:
```java
// 完整形式
(参数列表) -> {
    方法体;
    return 返回值;
}

// 简化形式
() -> expression                    // 无参数
x -> x * 2                          // 单参数可省略括号
(x, y) -> x + y                     // 多参数
(String s) -> s.length()            // 显式类型声明
```

**演进对比**:
```java
// Java 7 之前:匿名内部类
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Button clicked");
    }
});

// Java 8:Lambda 表达式
button.addActionListener(e -> System.out.println("Button clicked"));

// 方法引用(更简洁)
button.addActionListener(System.out::println);
```

#### 2. 函数式接口(Functional Interface)

Lambda 的类型约束基于**函数式接口**:只有一个抽象方法的接口。

**核心内置接口**:

```java
// 1. Function<T, R>:接收 T,返回 R
Function<String, Integer> lengthFunc = s -> s.length();
Integer len = lengthFunc.apply("hello");  // 5

// 2. Consumer<T>:接收 T,无返回(消费型)
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");

// 3. Supplier<T>:无参数,返回 T(供给型)
Supplier<Double> randomSupplier = () -> Math.random();
Double value = randomSupplier.get();

// 4. Predicate<T>:接收 T,返回 boolean(断言型)
Predicate<Integer> isEven = n -> n % 2 == 0;
boolean result = isEven.test(4);  // true

// 5. BiFunction<T, U, R>:接收两个参数
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
Integer sum = add.apply(3, 5);  // 8
```

**自定义函数式接口**:
```java
@FunctionalInterface  // 注解不是必须,但推荐使用(编译期检查)
public interface Calculator {
    int calculate(int a, int b);

    // 可以有 default 方法和 static 方法
    default int multiply(int a, int b) {
        return a * b;
    }
}

// 使用
Calculator add = (a, b) -> a + b;
Calculator subtract = (a, b) -> a - b;
```

#### 3. 方法引用(Method Reference)

方法引用是 Lambda 的进一步简化,语法:`类名::方法名`

**四种形式**:
```java
// 1. 静态方法引用
Function<String, Integer> parser = Integer::parseInt;
Integer num = parser.apply("123");

// 2. 实例方法引用(特定对象)
String str = "Hello";
Supplier<Integer> lengthSupplier = str::length;
Integer len = lengthSupplier.get();

// 3. 实例方法引用(任意对象)
Function<String, String> upperCaseFunc = String::toUpperCase;
String result = upperCaseFunc.apply("hello");  // "HELLO"

// 4. 构造器引用
Supplier<List<String>> listSupplier = ArrayList::new;
List<String> list = listSupplier.get();

BiFunction<String, Integer, User> userCreator = User::new;
User user = userCreator.apply("Alice", 25);
```

#### 4. Lambda 的底层实现

**关键技术:invokedynamic**

Java 8 使用 `invokedynamic` 字节码指令(Java 7 引入)实现 Lambda,而非简单的语法糖翻译为匿名内部类。

**对比分析**:
```java
// 匿名内部类:编译时生成 Outer$1.class
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Anonymous");
    }
};

// Lambda:运行时动态生成,不产生额外 .class 文件
Runnable r2 = () -> System.out.println("Lambda");
```

**字节码层面**:
```
// Lambda 编译后生成:
1. 一个静态方法(实际逻辑)
private static void lambda$main$0() {
    System.out.println("Lambda");
}

2. invokedynamic 指令动态链接
invokedynamic #2,  0  // InvokeDynamic #0:run:()Ljava/lang/Runnable;
```

**优势**:
- 启动更快(延迟生成类)
- 内存占用更少(无额外类文件)
- JVM 优化空间更大(可内联)

#### 5. 变量捕获与闭包

Lambda 可以访问外部变量,但有**事实最终(effectively final)**的限制:

```java
public void captureExample() {
    int localVar = 10;  // 隐式 final

    Runnable r = () -> {
        System.out.println(localVar);  // 可以访问
        // localVar = 20;  // 编译错误!不能修改
    };

    // localVar = 20;  // 如果取消注释,Lambda 行会编译错误
}
```

**原因**:
- Lambda 可能在不同线程执行,变量可能已出栈
- JVM 通过**拷贝变量值**到 Lambda 对象中实现捕获
- 如果允许修改,会导致外部变量与 Lambda 内部副本不一致

**绕过限制**(不推荐):
```java
// 使用数组或包装类(引用不变,内容可变)
final int[] counter = {0};
list.forEach(item -> counter[0]++);

// 使用 AtomicInteger(线程安全)
AtomicInteger counter = new AtomicInteger(0);
list.forEach(item -> counter.incrementAndGet());
```

---

### 二、Stream API 核心原理

#### 1. Stream 的设计哲学

Stream 不是数据结构,而是**数据处理的抽象管道**,核心特征:

1. **不存储数据**:Stream 从数据源(集合、数组、IO)获取数据
2. **惰性求值**:中间操作不会立即执行,直到遇到终止操作
3. **可消费性**:一个 Stream 只能使用一次,用完即关闭
4. **内部迭代**:由 Stream 库控制迭代,而非外部显式循环

**创建 Stream**:
```java
// 1. 从集合
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();

// 2. 从数组
String[] array = {"a", "b", "c"};
Stream<String> stream = Arrays.stream(array);

// 3. 通过 Stream 静态方法
Stream<Integer> stream = Stream.of(1, 2, 3);
Stream<Integer> iterate = Stream.iterate(0, n -> n + 2).limit(10);  // 0,2,4...18
Stream<Double> generate = Stream.generate(Math::random).limit(5);

// 4. 从文件
Stream<String> lines = Files.lines(Paths.get("file.txt"));
```

#### 2. 中间操作(Intermediate Operations)

中间操作返回新的 Stream,支持链式调用,采用**惰性求值**。

**核心操作**:

```java
List<String> words = Arrays.asList("apple", "banana", "cherry", "date");

// 1. filter:过滤
Stream<String> filtered = words.stream()
    .filter(s -> s.length() > 5);  // ["banana", "cherry"]

// 2. map:转换
Stream<Integer> lengths = words.stream()
    .map(String::length);  // [5, 6, 6, 4]

// 3. flatMap:扁平化处理(一对多映射)
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);
Stream<Integer> flattened = nested.stream()
    .flatMap(Collection::stream);  // [1, 2, 3, 4]

// 4. distinct:去重(基于 equals)
Stream<String> distinct = Stream.of("a", "b", "a", "c")
    .distinct();  // ["a", "b", "c"]

// 5. sorted:排序
Stream<String> sorted = words.stream()
    .sorted();  // 自然排序

Stream<String> sortedByLength = words.stream()
    .sorted(Comparator.comparingInt(String::length));  // 按长度排序

// 6. limit/skip:截取
Stream<String> limited = words.stream().limit(2);   // 前 2 个
Stream<String> skipped = words.stream().skip(2);    // 跳过前 2 个

// 7. peek:调试用(副作用操作)
words.stream()
    .peek(s -> System.out.println("Processing: " + s))
    .map(String::toUpperCase)
    .peek(s -> System.out.println("Mapped: " + s))
    .collect(Collectors.toList());
```

#### 3. 终止操作(Terminal Operations)

终止操作触发实际计算,返回非 Stream 结果或产生副作用。

**收集结果**:
```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// 1. collect:最强大的收集器
List<String> list = words.stream()
    .filter(s -> s.length() > 5)
    .collect(Collectors.toList());

Set<String> set = words.stream()
    .collect(Collectors.toSet());

Map<Integer, String> map = words.stream()
    .collect(Collectors.toMap(
        String::length,           // key
        s -> s,                   // value
        (v1, v2) -> v1 + "," + v2 // 冲突处理
    ));

// 分组
Map<Integer, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(String::length));
// {5=[apple], 6=[banana, cherry]}

// 分区(特殊的分组,只有 true/false)
Map<Boolean, List<String>> partitioned = words.stream()
    .collect(Collectors.partitioningBy(s -> s.length() > 5));

// 拼接字符串
String joined = words.stream()
    .collect(Collectors.joining(", ", "[", "]"));
// "[apple, banana, cherry]"

// 2. 聚合操作
long count = words.stream().count();

Optional<String> max = words.stream()
    .max(Comparator.naturalOrder());

Optional<String> min = words.stream().min(Comparator.naturalOrder());

// 3. 匹配操作
boolean anyMatch = words.stream().anyMatch(s -> s.startsWith("a"));
boolean allMatch = words.stream().allMatch(s -> s.length() > 3);
boolean noneMatch = words.stream().noneMatch(s -> s.isEmpty());

// 4. 查找操作
Optional<String> first = words.stream()
    .filter(s -> s.startsWith("b"))
    .findFirst();

Optional<String> any = words.stream()
    .filter(s -> s.startsWith("c"))
    .findAny();  // 并行流时效率更高

// 5. 归约操作(reduce)
Optional<String> concatenated = words.stream()
    .reduce((s1, s2) -> s1 + "," + s2);

int totalLength = words.stream()
    .map(String::length)
    .reduce(0, Integer::sum);  // 初始值 + 累加器
```

#### 4. 惰性求值机制

**核心原理**:中间操作只是构建操作链,终止操作触发时才一次性执行全部操作。

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

Stream<String> stream = words.stream()
    .filter(s -> {
        System.out.println("Filter: " + s);
        return s.length() > 5;
    })
    .map(s -> {
        System.out.println("Map: " + s);
        return s.toUpperCase();
    });

// 到这里,没有任何输出!因为中间操作未执行

List<String> result = stream.collect(Collectors.toList());

// 输出:
// Filter: apple
// Filter: banana
// Map: banana
// Filter: cherry
// Map: cherry
```

**优势**:
- **性能优化**:可以合并操作(loop fusion),避免多次遍历
- **短路操作**:如 `findFirst` 找到结果后立即停止
- **无限流支持**:`Stream.iterate` 生成无限序列,配合 `limit` 按需计算

**短路示例**:
```java
// 只遍历到找到第一个符合条件的元素
Optional<String> result = Stream.of("a", "bb", "ccc", "dddd")
    .filter(s -> {
        System.out.println("Checking: " + s);
        return s.length() > 2;
    })
    .findFirst();

// 输出:
// Checking: a
// Checking: bb
// Checking: ccc
// 找到后停止,不会检查 "dddd"
```

#### 5. 并行流(Parallel Stream)

并行流使用 **ForkJoinPool** 自动分解任务到多个线程。

**使用方式**:
```java
// 1. 从顺序流转换
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.parallelStream()
    .mapToInt(Integer::intValue)
    .sum();

// 2. 将顺序流转为并行流
int sum2 = numbers.stream()
    .parallel()
    .mapToInt(Integer::intValue)
    .sum();
```

**适用场景**:
- ✅ **CPU 密集型任务**(复杂计算)
- ✅ **大数据集**(百万级以上)
- ✅ **无状态操作**(如 map、filter)

**不适用场景**:
- ❌ **小数据集**(<1000):线程开销大于收益
- ❌ **有顺序要求**:除非使用 `forEachOrdered`
- ❌ **有副作用或状态操作**:线程安全问题

**陷阱示例**:
```java
// 错误:线程不安全
List<Integer> result = new ArrayList<>();
IntStream.range(0, 1000)
    .parallel()
    .forEach(result::add);  // ArrayList 不是线程安全的!

// 正确:使用线程安全的收集器
List<Integer> result = IntStream.range(0, 1000)
    .parallel()
    .boxed()
    .collect(Collectors.toList());
```

---

### 三、实战技巧与性能优化

#### 1. 常见业务场景

**场景 1:数据转换与聚合**
```java
// 需求:统计订单总金额,按用户分组
class Order {
    String userId;
    double amount;
}

Map<String, Double> userTotalAmount = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getUserId,
        Collectors.summingDouble(Order::getAmount)
    ));
```

**场景 2:复杂过滤与排序**
```java
// 需求:找出销售额前 10 的产品,排除已下架的
List<Product> top10 = products.stream()
    .filter(p -> p.getStatus() == Status.ACTIVE)
    .filter(p -> p.getSales() > 100)
    .sorted(Comparator.comparingDouble(Product::getSales).reversed())
    .limit(10)
    .collect(Collectors.toList());
```

**场景 3:嵌套集合处理**
```java
// 需求:提取所有订单中的商品 ID(去重)
class Order {
    List<Item> items;
}

Set<Long> allItemIds = orders.stream()
    .flatMap(order -> order.getItems().stream())
    .map(Item::getId)
    .collect(Collectors.toSet());
```

**场景 4:条件统计**
```java
// 需求:统计各年龄段用户数
Map<String, Long> ageGroupCount = users.stream()
    .collect(Collectors.groupingBy(
        user -> {
            int age = user.getAge();
            if (age < 18) return "未成年";
            else if (age < 30) return "青年";
            else if (age < 50) return "中年";
            else return "老年";
        },
        Collectors.counting()
    ));
```

#### 2. 性能对比与选择

**基准测试**(数据量 100 万):

```java
List<Integer> numbers = IntStream.range(0, 1_000_000)
    .boxed()
    .collect(Collectors.toList());

// 1. 传统 for 循环
long start = System.currentTimeMillis();
int sum1 = 0;
for (Integer num : numbers) {
    if (num % 2 == 0) {
        sum1 += num * 2;
    }
}
System.out.println("For loop: " + (System.currentTimeMillis() - start) + "ms");

// 2. Stream
start = System.currentTimeMillis();
int sum2 = numbers.stream()
    .filter(n -> n % 2 == 0)
    .mapToInt(n -> n * 2)
    .sum();
System.out.println("Stream: " + (System.currentTimeMillis() - start) + "ms");

// 3. Parallel Stream
start = System.currentTimeMillis();
int sum3 = numbers.parallelStream()
    .filter(n -> n % 2 == 0)
    .mapToInt(n -> n * 2)
    .sum();
System.out.println("Parallel Stream: " + (System.currentTimeMillis() - start) + "ms");
```

**典型结果**:
- 传统循环:80ms
- Stream:120ms (装箱拆箱开销)
- Parallel Stream:35ms (多核优势)

**优化建议**:
1. **使用基本类型流**:避免装箱
   ```java
   // 慢
   int sum = list.stream()
       .mapToInt(Integer::intValue)
       .sum();

   // 快
   int sum = IntStream.range(0, list.size())
       .map(list::get)
       .sum();
   ```

2. **避免频繁创建 Stream**:
   ```java
   // 不好
   for (int i = 0; i < 1000; i++) {
       long count = list.stream().count();  // 重复创建 Stream
   }

   // 好
   long count = list.size();  // 直接使用
   ```

3. **合理使用并行流**:
   ```java
   // 设置并行度(不推荐,全局影响)
   System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "4");

   // 使用自定义线程池(推荐)
   ForkJoinPool customPool = new ForkJoinPool(4);
   customPool.submit(() ->
       list.parallelStream()
           .forEach(System.out::println)
   ).get();
   ```

#### 3. 常见陷阱

**陷阱 1:Stream 重复使用**
```java
Stream<String> stream = list.stream();
stream.forEach(System.out::println);
stream.forEach(System.out::println);  // 报错:stream has already been operated upon or closed
```

**陷阱 2:无限流未限制**
```java
// 死循环!
Stream.iterate(0, n -> n + 1)
    .forEach(System.out::println);  // 必须加 limit()
```

**陷阱 3:并行流修改共享状态**
```java
int[] sum = {0};
IntStream.range(0, 1000)
    .parallel()
    .forEach(i -> sum[0] += i);  // 结果不确定!数据竞争
```

**陷阱 4:过度使用导致可读性下降**
```java
// 不好:过于复杂
Map<String, Map<String, List<Order>>> result = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getRegion,
        Collectors.groupingBy(
            Order::getCategory,
            Collectors.filtering(
                o -> o.getAmount() > 1000,
                Collectors.toList()
            )
        )
    ));

// 好:分步处理,提高可读性
List<Order> highValueOrders = orders.stream()
    .filter(o -> o.getAmount() > 1000)
    .collect(Collectors.toList());

Map<String, Map<String, List<Order>>> result = highValueOrders.stream()
    .collect(Collectors.groupingBy(
        Order::getRegion,
        Collectors.groupingBy(Order::getCategory)
    ));
```

---

### 四、总结

**Lambda 表达式的价值**:
1. 简化代码,减少样板代码
2. 支持函数式编程范式(高阶函数、闭包)
3. 底层通过 invokedynamic 实现,性能优于匿名内部类

**Stream API 的核心优势**:
1. 声明式编程,关注"做什么"而非"怎么做"
2. 惰性求值,自动优化执行计划
3. 天然支持并行处理,充分利用多核 CPU

**使用原则**:
1. ✅ 简单场景优先 Stream,提高代码可读性
2. ✅ 复杂业务逻辑可拆分为多个 Stream 操作
3. ✅ 性能敏感场景进行基准测试
4. ✅ 并行流需评估数据规模和任务类型
5. ❌ 不要为了使用而使用,过度抽象反而降低可读性

Java 8 的这两个特性标志着 Java 从纯面向对象向"面向对象 + 函数式"的混合范式转变,大幅提升了语言表达能力和开发效率。在现代 Java 开发中,熟练掌握 Lambda 和 Stream 是必备技能。
