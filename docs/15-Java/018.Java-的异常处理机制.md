---
title: Java 的异常处理机制
tags:
  - Java
status: robot
class: Java
slug: java-exception-handling-mechanism
ref:
---

## 核心要点

**异常体系**:分为 **Checked 异常**(编译期强制处理,如 IOException)和 **Unchecked 异常**(运行时异常,如 NullPointerException)。Error 表示严重错误,不应捕获。

**处理机制**:try-catch-finally 保证资源清理,try-with-resources(Java 7+)自动关闭资源。throws 声明异常传播,throw 主动抛出异常。

**最佳实践**:细粒度异常捕获、避免空 catch、自定义异常携带业务语义、不要用异常控制流程、finally 不要 return(会覆盖 try/catch 的返回值)。

---

## 详细回答

### 一、Java 异常体系架构

#### 1. 异常继承层次

```
Throwable (所有异常的根类)
├── Error (严重错误,不应捕获)
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   └── VirtualMachineError
│
└── Exception (可处理的异常)
    ├── Checked Exception (受检异常,编译期强制处理)
    │   ├── IOException
    │   │   ├── FileNotFoundException
    │   │   └── SocketException
    │   ├── SQLException
    │   ├── ClassNotFoundException
    │   └── InterruptedException
    │
    └── RuntimeException (运行时异常,Unchecked)
        ├── NullPointerException
        ├── IndexOutOfBoundsException
        ├── IllegalArgumentException
        ├── ClassCastException
        └── ConcurrentModificationException
```

#### 2. Checked vs Unchecked 异常

**Checked 异常(受检异常)**

特点:
- 编译器强制要求处理(try-catch 或 throws)
- 通常表示外部环境导致的可恢复错误
- 调用者有能力且应该处理的异常

典型场景:
```java
// 文件 IO:文件可能不存在
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path);  // 可能抛出 FileNotFoundException
    // 读取逻辑...
    reader.close();
}

// 网络请求:连接可能失败
public void connectServer() throws SocketException {
    Socket socket = new Socket("localhost", 8080);
    // 连接逻辑...
}

// 数据库操作:SQL 可能有误
public void queryData() throws SQLException {
    Connection conn = DriverManager.getConnection(url);
    // 查询逻辑...
}
```

**Unchecked 异常(运行时异常)**

特点:
- 编译器不强制处理
- 通常表示编程错误或不可恢复的错误
- 应该在开发阶段修复,而非捕获处理

典型场景:
```java
// 1. 空指针:编程错误
String str = null;
str.length();  // NullPointerException

// 2. 数组越界:编程错误
int[] arr = new int[5];
int value = arr[10];  // IndexOutOfBoundsException

// 3. 类型转换错误:编程错误
Object obj = "hello";
Integer num = (Integer) obj;  // ClassCastException

// 4. 非法参数:调用者错误
public void setAge(int age) {
    if (age < 0 || age > 150) {
        throw new IllegalArgumentException("年龄范围无效: " + age);
    }
    this.age = age;
}
```

**选择原则**:
- 外部因素导致,调用者能处理 → Checked 异常
- 编程错误,应该修复代码 → Unchecked 异常

#### 3. Error 类型(不应捕获)

Error 表示严重的系统级错误,程序无法恢复:

```java
// 1. OutOfMemoryError:堆内存耗尽
List<byte[]> list = new ArrayList<>();
while (true) {
    list.add(new byte[1024 * 1024]);  // 不断分配内存
}

// 2. StackOverflowError:栈溢出(通常是无限递归)
public void recursion() {
    recursion();  // 无终止条件
}

// 3. NoClassDefFoundError:类加载失败
// 编译时存在,运行时缺失依赖
```

**原则**:不要 catch Error,应该让程序崩溃并修复根本问题。

---

### 二、异常处理语法机制

#### 1. try-catch-finally 详解

**基础用法**:
```java
public void basicTryCatch() {
    try {
        // 可能抛出异常的代码
        int result = 10 / 0;
    } catch (ArithmeticException e) {
        // 异常处理逻辑
        System.out.println("除零错误: " + e.getMessage());
    } finally {
        // 无论是否异常都会执行
        System.out.println("清理资源");
    }
}
```

**多重 catch**:
```java
public void multiCatch() {
    try {
        String str = null;
        str.length();  // NullPointerException

        int[] arr = new int[5];
        arr[10] = 1;   // IndexOutOfBoundsException

    } catch (NullPointerException e) {
        System.out.println("空指针异常");
    } catch (IndexOutOfBoundsException e) {
        System.out.println("数组越界");
    } catch (Exception e) {
        // 捕获其他所有异常(放在最后)
        System.out.println("未知异常: " + e.getClass().getName());
    }
}
```

**Java 7+ 多异常合并捕获**:
```java
try {
    // 可能抛出多种异常的代码
} catch (IOException | SQLException e) {
    // 用同一个 catch 处理多种异常
    log.error("IO 或 SQL 错误", e);
    // 注意:e 是 final 的,不能重新赋值
}
```

**finally 的执行时机**:

```java
public int finallyDemo() {
    try {
        System.out.println("try 块");
        return 1;
    } catch (Exception e) {
        System.out.println("catch 块");
        return 2;
    } finally {
        System.out.println("finally 块");
        // 这里 return 会覆盖 try/catch 的返回值!(不推荐)
        // return 3;
    }
}

// 执行顺序:
// 1. 输出 "try 块"
// 2. 准备返回 1(但不立即返回)
// 3. 输出 "finally 块"
// 4. 返回 1
```

**finally 不执行的极端情况**:
```java
try {
    System.exit(0);  // 强制退出 JVM
} finally {
    System.out.println("不会执行");
}

try {
    while (true);  // 死循环,永远到不了 finally
} finally {
    System.out.println("不会执行");
}
```

#### 2. try-with-resources(自动资源管理)

Java 7 引入,自动关闭实现了 `AutoCloseable` 接口的资源。

**传统方式(繁琐且易错)**:
```java
public void oldWay() {
    FileReader reader = null;
    try {
        reader = new FileReader("file.txt");
        // 读取文件...
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (reader != null) {
            try {
                reader.close();  // 关闭也可能抛异常!
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**try-with-resources(推荐)**:
```java
public void newWay() {
    try (FileReader reader = new FileReader("file.txt")) {
        // 读取文件...
    } catch (IOException e) {
        e.printStackTrace();
    }
    // reader 会自动关闭,即使发生异常
}
```

**多资源管理**:
```java
try (
    FileInputStream fis = new FileInputStream("input.txt");
    FileOutputStream fos = new FileOutputStream("output.txt")
) {
    // 文件复制逻辑...
} catch (IOException e) {
    e.printStackTrace();
}
// 关闭顺序:fos -> fis (逆序关闭)
```

**Java 9+ 增强**(可使用 final 变量):
```java
FileReader reader = new FileReader("file.txt");
try (reader) {  // Java 9+ 允许直接使用已有变量
    // 读取文件...
}
```

**自定义 AutoCloseable 资源**:
```java
public class Connection implements AutoCloseable {
    public Connection() {
        System.out.println("打开连接");
    }

    public void send(String data) {
        System.out.println("发送数据: " + data);
    }

    @Override
    public void close() {
        System.out.println("关闭连接");
    }
}

// 使用
try (Connection conn = new Connection()) {
    conn.send("Hello");
}
// 自动调用 conn.close()
```

#### 3. throws 与 throw 关键字

**throws:方法签名声明可能抛出的异常**
```java
// 声明方法可能抛出 IOException
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path);
    // 读取逻辑...
}

// 调用者必须处理
public void caller() {
    try {
        readFile("file.txt");
    } catch (IOException e) {
        // 处理异常
    }
}

// 或者继续向上抛出
public void caller2() throws IOException {
    readFile("file.txt");
}
```

**throw:主动抛出异常**
```java
public void validateAge(int age) {
    if (age < 0 || age > 150) {
        // 主动抛出异常
        throw new IllegalArgumentException("年龄无效: " + age);
    }
}

// 自定义异常后再抛出
public void businessMethod() throws BusinessException {
    try {
        // 底层操作
        dbOperation();
    } catch (SQLException e) {
        // 包装为业务异常抛出
        throw new BusinessException("数据库操作失败", e);
    }
}
```

---

### 三、自定义异常设计

#### 1. 创建自定义异常

**Checked 异常**(继承 Exception):
```java
public class BusinessException extends Exception {
    private int errorCode;

    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }

    public BusinessException(int errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public int getErrorCode() {
        return errorCode;
    }
}
```

**Unchecked 异常**(继承 RuntimeException):
```java
public class InvalidRequestException extends RuntimeException {
    private Map<String, String> errors;

    public InvalidRequestException(String message) {
        super(message);
    }

    public InvalidRequestException(String message, Map<String, String> errors) {
        super(message);
        this.errors = errors;
    }

    public Map<String, String> getErrors() {
        return errors;
    }
}
```

#### 2. 异常链(Cause Chain)

保留原始异常信息,便于问题追踪:

```java
public void serviceMethod() throws ServiceException {
    try {
        // DAO 层操作
        userDao.save(user);
    } catch (SQLException e) {
        // 包装为业务异常,保留原始异常
        throw new ServiceException("用户保存失败", e);
    }
}

// 打印异常链
try {
    serviceMethod();
} catch (ServiceException e) {
    e.printStackTrace();
    // 输出:
    // ServiceException: 用户保存失败
    //   Caused by: SQLException: Duplicate entry 'user1'
}
```

#### 3. 分层异常设计

**典型三层架构**:
```java
// Controller 层
@RestController
public class UserController {
    @PostMapping("/user")
    public Result createUser(@RequestBody User user) {
        try {
            userService.createUser(user);
            return Result.success();
        } catch (DuplicateUserException e) {
            return Result.error(400, "用户已存在");
        } catch (ServiceException e) {
            return Result.error(500, "服务异常");
        }
    }
}

// Service 层
public class UserService {
    public void createUser(User user) throws ServiceException {
        try {
            userDao.insert(user);
        } catch (DuplicateKeyException e) {
            throw new DuplicateUserException("用户名已存在: " + user.getName());
        } catch (DataAccessException e) {
            throw new ServiceException("数据库操作失败", e);
        }
    }
}

// DAO 层
public class UserDao {
    public void insert(User user) throws DataAccessException {
        // 数据库操作...
    }
}
```

---

### 四、最佳实践与常见陷阱

#### 1. 异常处理最佳实践

**✅ 1. 细粒度异常捕获**
```java
// 不好:捕获范围太大
try {
    readFile();
    parseData();
    saveToDb();
} catch (Exception e) {
    // 无法区分具体是哪一步失败
}

// 好:分别处理
try {
    Data data = readFile();
    Object parsed = parseData(data);
    saveToDb(parsed);
} catch (IOException e) {
    log.error("文件读取失败", e);
} catch (ParseException e) {
    log.error("数据解析失败", e);
} catch (SQLException e) {
    log.error("数据库保存失败", e);
}
```

**✅ 2. 不要吞掉异常**
```java
// 极度危险!
try {
    criticalOperation();
} catch (Exception e) {
    // 空 catch,异常被完全吞掉
}

// 至少要记录日志
try {
    criticalOperation();
} catch (Exception e) {
    log.error("操作失败", e);  // 记录完整堆栈
    throw e;  // 或者重新抛出
}
```

**✅ 3. 异常信息要有意义**
```java
// 不好:信息不足
throw new RuntimeException("错误");

// 好:提供上下文信息
throw new RuntimeException(
    String.format("用户创建失败:用户名=%s, 邮箱=%s", username, email)
);
```

**✅ 4. 使用标准异常**
```java
// 优先使用 JDK 内置异常
throw new IllegalArgumentException("参数不能为空");
throw new IllegalStateException("对象状态无效");
throw new UnsupportedOperationException("不支持此操作");

// 而不是自定义
throw new MyParameterException("参数不能为空");
```

**✅ 5. 资源一定要释放**
```java
// 使用 try-with-resources
try (Connection conn = dataSource.getConnection()) {
    // 操作数据库...
}

// 或者 finally
Connection conn = null;
try {
    conn = dataSource.getConnection();
    // 操作...
} finally {
    if (conn != null) {
        try {
            conn.close();
        } catch (SQLException e) {
            log.error("关闭连接失败", e);
        }
    }
}
```

#### 2. 常见陷阱

**❌ 陷阱 1:finally 中 return**
```java
public int trap1() {
    try {
        return 1;
    } finally {
        return 2;  // 会覆盖 try 中的 return!
    }
}
// 返回 2,try 的返回值被吞掉

// 正确做法:不要在 finally 中 return
```

**❌ 陷阱 2:finally 中抛出异常**
```java
public void trap2() throws Exception {
    try {
        throw new RuntimeException("try 异常");
    } finally {
        throw new Exception("finally 异常");  // 会覆盖 try 的异常!
    }
}
// 调用者只能捕获到 "finally 异常",原始异常丢失
```

**❌ 陷阱 3:用异常控制业务流程**
```java
// 不好:异常开销大
public int findIndex(String[] arr, String target) {
    try {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i].equals(target)) {
                throw new FoundException(i);  // 用异常表示找到
            }
        }
    } catch (FoundException e) {
        return e.getIndex();
    }
    return -1;
}

// 好:用返回值
public int findIndex(String[] arr, String target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i].equals(target)) {
            return i;
        }
    }
    return -1;
}
```

**❌ 陷阱 4:过度使用 Checked 异常**
```java
// 不好:强制调用者处理无关紧要的异常
public void setAge(int age) throws InvalidAgeException {
    if (age < 0) {
        throw new InvalidAgeException("年龄无效");
    }
}

// 好:参数校验用 RuntimeException
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("年龄无效");
    }
}
```

**❌ 陷阱 5:捕获后不处理就重新抛出**
```java
// 无意义的 catch
try {
    operation();
} catch (Exception e) {
    throw e;  // 什么都没做就重新抛出,没有意义
}

// 要么处理,要么直接 throws
public void method() throws Exception {
    operation();  // 让异常自然传播
}
```

#### 3. 性能考量

**异常的开销**:
```java
// 创建异常对象的开销来自填充堆栈信息
public class PerformanceTest {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        // 抛出 100 万次异常
        for (int i = 0; i < 1_000_000; i++) {
            try {
                throw new Exception();
            } catch (Exception e) {
                // 捕获
            }
        }

        System.out.println("耗时: " + (System.currentTimeMillis() - start) + "ms");
        // 通常需要数百毫秒,比正常控制流慢得多
    }
}
```

**优化建议**:
1. 不要用异常控制正常业务流程
2. 频繁抛出的场景考虑使用返回值或状态码
3. 性能敏感场景可禁用堆栈填充:
   ```java
   public class LightweightException extends Exception {
       @Override
       public synchronized Throwable fillInStackTrace() {
           return this;  // 不填充堆栈,提升性能
       }
   }
   ```

---

### 五、现代 Java 异常处理模式

#### 1. 函数式风格(Optional + Result 模式)

**使用 Optional 避免 NPE**:
```java
// 传统方式
public String getUserName(Long userId) {
    User user = userDao.findById(userId);
    if (user != null) {
        return user.getName();
    }
    return "Unknown";
}

// Optional 方式
public String getUserName(Long userId) {
    return userDao.findById(userId)  // 返回 Optional<User>
        .map(User::getName)
        .orElse("Unknown");
}
```

**Result 模式(类似 Rust/Go 的错误处理)**:
```java
public class Result<T, E> {
    private T value;
    private E error;
    private boolean success;

    public static <T, E> Result<T, E> success(T value) {
        Result<T, E> result = new Result<>();
        result.value = value;
        result.success = true;
        return result;
    }

    public static <T, E> Result<T, E> error(E error) {
        Result<T, E> result = new Result<>();
        result.error = error;
        result.success = false;
        return result;
    }

    public boolean isSuccess() { return success; }
    public T getValue() { return value; }
    public E getError() { return error; }
}

// 使用
public Result<User, String> createUser(User user) {
    if (userDao.existsByName(user.getName())) {
        return Result.error("用户名已存在");
    }
    User saved = userDao.save(user);
    return Result.success(saved);
}

// 调用
Result<User, String> result = createUser(newUser);
if (result.isSuccess()) {
    System.out.println("创建成功: " + result.getValue());
} else {
    System.out.println("创建失败: " + result.getError());
}
```

#### 2. Spring 全局异常处理

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        ErrorResponse error = new ErrorResponse(e.getErrorCode(), e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        log.error("未处理的异常", e);
        ErrorResponse error = new ErrorResponse(500, "服务器内部错误");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

---

### 六、总结

**异常处理的核心原则**:
1. **明确区分** Checked 和 Unchecked 异常的使用场景
2. **细粒度捕获**,不要用一个 `catch(Exception)` 包打天下
3. **不要吞掉异常**,至少要记录日志
4. **资源必须释放**,优先使用 try-with-resources
5. **异常信息要有意义**,包含足够的上下文
6. **不要用异常控制业务流程**,异常是用来处理异常情况的
7. **finally 不要 return**,会覆盖正常返回值

**现代 Java 的趋势**:
- 更倾向于使用 Unchecked 异常(如 Spring 的 DataAccessException)
- 结合 Optional、Result 模式减少异常使用
- 框架层面提供全局异常处理(如 Spring @ControllerAdvice)

异常处理是一个在"健壮性"与"简洁性"之间权衡的艺术。过度使用会导致代码冗长,处理不当又会导致程序脆弱。理解异常的本质,在合适的场景使用合适的策略,是高质量代码的标志之一。
