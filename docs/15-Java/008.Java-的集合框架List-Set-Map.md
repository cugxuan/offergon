---
title: Java 的集合框架（List、Set、Map）
tags:
  - Java
status: robot
class: Java
slug: java-collections-framework-list-set-map
ref:
---

## 核心要点

- **三大接口体系**：List（有序可重复）、Set（无序不重复）、Map（键值对映射）
- **核心实现类**：ArrayList/LinkedList、HashSet/TreeSet、HashMap/TreeMap
- **选择原则**：根据性能特征和使用场景选择合适的实现类
- **线程安全**：大部分集合类非线程安全，需要通过工具类或并发集合保证安全性

## 详细解答

### 1. 集合框架概述

Java集合框架（Java Collections Framework）是Java中最重要的API之一，提供了一套设计精良的接口和类，用于存储和操作对象集合。

**集合框架的优势：**
- 统一的接口设计，降低学习成本
- 提供高质量的数据结构实现
- 支持泛型，提供类型安全
- 丰富的工具方法和算法

### 2. Collection接口层次结构

```java
// 集合框架的根接口
Collection<E>
├── List<E>          // 有序集合，允许重复元素
│   ├── ArrayList<E>    // 基于数组的动态列表
│   ├── LinkedList<E>   // 基于双向链表的列表
│   └── Vector<E>       // 线程安全的动态数组（基本不用）
│       └── Stack<E>    // 栈实现（建议用Deque代替）
├── Set<E>           // 无重复元素的集合
│   ├── HashSet<E>      // 基于哈希表的集合
│   ├── LinkedHashSet<E>// 保持插入顺序的哈希集合
│   └── SortedSet<E>    // 有序集合接口
│       └── TreeSet<E>  // 基于红黑树的有序集合
└── Queue<E>         // 队列接口
    ├── Deque<E>        // 双端队列
    │   ├── ArrayDeque<E>  // 基于数组的双端队列
    │   └── LinkedList<E>  // 也实现了Deque接口
    └── PriorityQueue<E>   // 优先级队列

// Map接口（不继承Collection）
Map<K,V>
├── HashMap<K,V>        // 基于哈希表的映射
├── LinkedHashMap<K,V>  // 保持插入或访问顺序的哈希映射
├── TreeMap<K,V>        // 基于红黑树的有序映射
├── ConcurrentHashMap<K,V> // 线程安全的哈希映射
└── Hashtable<K,V>      // 线程安全的哈希表（基本不用）
```

### 3. List接口详解

List是有序的Collection，允许重复元素，提供基于索引的访问。

#### ArrayList - 动态数组
```java
public class ArrayListDemo {
    public static void main(String[] args) {
        // 创建ArrayList
        List<String> arrayList = new ArrayList<>();

        // 添加元素
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add("Cherry");
        arrayList.add(1, "Blueberry"); // 在指定位置插入

        // 访问元素
        String first = arrayList.get(0);
        System.out.println("第一个元素: " + first);

        // 修改元素
        arrayList.set(2, "Coconut");

        // 删除元素
        arrayList.remove("Apple");        // 按值删除
        arrayList.remove(0);             // 按索引删除

        // 遍历
        for (String fruit : arrayList) {
            System.out.println(fruit);
        }

        // 使用索引遍历
        for (int i = 0; i < arrayList.size(); i++) {
            System.out.println(i + ": " + arrayList.get(i));
        }

        // 使用Iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if ("Banana".equals(fruit)) {
                iterator.remove(); // 安全删除
            }
        }
    }
}
```

**ArrayList特点：**
- 基于数组实现，支持随机访问
- 查询快（O(1)），插入删除慢（O(n)）
- 扩容机制：容量不足时扩容50%
- 线程不安全

#### LinkedList - 双向链表
```java
public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<>();

        // 添加元素
        linkedList.add(1);
        linkedList.add(2);
        linkedList.addFirst(0);    // 在头部添加
        linkedList.addLast(3);     // 在尾部添加

        // 访问元素
        int first = linkedList.getFirst();
        int last = linkedList.getLast();

        // 删除元素
        linkedList.removeFirst();  // 删除头部元素
        linkedList.removeLast();   // 删除尾部元素

        // 作为队列使用
        linkedList.offer(4);       // 入队
        linkedList.offer(5);
        Integer polled = linkedList.poll(); // 出队

        // 作为栈使用
        linkedList.push(6);        // 入栈
        linkedList.push(7);
        Integer popped = linkedList.pop();  // 出栈

        System.out.println(linkedList);
    }
}
```

**LinkedList特点：**
- 基于双向链表实现
- 插入删除快（O(1)），查询慢（O(n)）
- 实现了List、Deque、Queue接口
- 适合频繁插入删除的场景

#### Vector - 线程安全的列表
```java
// Vector是线程安全的，但性能较差，基本被ArrayList取代
Vector<String> vector = new Vector<>();
vector.add("Thread Safe");

// 如需线程安全的List，推荐使用：
List<String> safeList = Collections.synchronizedList(new ArrayList<>());
// 或使用并发包中的CopyOnWriteArrayList
List<String> concurrentList = new CopyOnWriteArrayList<>();
```

### 4. Set接口详解

Set不允许重复元素，提供数学意义上的集合抽象。

#### HashSet - 哈希集合
```java
public class HashSetDemo {
    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();

        // 添加元素
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Apple");  // 重复元素不会被添加

        System.out.println("Set大小: " + hashSet.size()); // 输出: 2

        // 检查元素存在
        boolean hasApple = hashSet.contains("Apple");

        // 删除元素
        hashSet.remove("Banana");

        // 遍历（无序）
        for (String fruit : hashSet) {
            System.out.println(fruit);
        }

        // 集合操作
        Set<String> set1 = new HashSet<>(Arrays.asList("A", "B", "C"));
        Set<String> set2 = new HashSet<>(Arrays.asList("B", "C", "D"));

        // 并集
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("并集: " + union); // [A, B, C, D]

        // 交集
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("交集: " + intersection); // [B, C]

        // 差集
        Set<String> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("差集: " + difference); // [A]
    }
}
```

**HashSet特点：**
- 基于HashMap实现
- 查询、插入、删除平均时间复杂度O(1)
- 元素无序
- 允许null值

#### LinkedHashSet - 保持插入顺序的集合
```java
public class LinkedHashSetDemo {
    public static void main(String[] args) {
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("Third");
        linkedHashSet.add("First");
        linkedHashSet.add("Second");

        // 遍历时保持插入顺序
        linkedHashSet.forEach(System.out::println);
        // 输出: Third, First, Second
    }
}
```

#### TreeSet - 有序集合
```java
public class TreeSetDemo {
    public static void main(String[] args) {
        // 自然排序
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(5);
        numbers.add(2);
        numbers.add(8);
        numbers.add(1);

        System.out.println(numbers); // [1, 2, 5, 8] - 自动排序

        // 自定义排序
        TreeSet<String> words = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
        words.add("banana");
        words.add("Apple");
        words.add("cherry");

        System.out.println(words); // [Apple, banana, cherry]

        // TreeSet特有方法
        System.out.println("第一个元素: " + numbers.first());
        System.out.println("最后一个元素: " + numbers.last());
        System.out.println("小于5的元素: " + numbers.headSet(5));
        System.out.println("大于等于5的元素: " + numbers.tailSet(5));
        System.out.println("2到8之间: " + numbers.subSet(2, 8));
    }
}
```

**TreeSet特点：**
- 基于红黑树实现
- 元素自动排序
- 查询、插入、删除时间复杂度O(log n)
- 不允许null值

### 5. Map接口详解

Map存储键值对，键不能重复，每个键最多映射到一个值。

#### HashMap - 哈希映射
```java
public class HashMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> hashMap = new HashMap<>();

        // 添加键值对
        hashMap.put("Apple", 10);
        hashMap.put("Banana", 20);
        hashMap.put("Cherry", 15);

        // 访问值
        Integer appleCount = hashMap.get("Apple");
        Integer orangeCount = hashMap.getOrDefault("Orange", 0);

        // 更新值
        hashMap.put("Apple", 12);  // 更新现有键
        hashMap.putIfAbsent("Orange", 5); // 键不存在时才添加

        // 删除
        hashMap.remove("Banana");

        // 遍历方式
        // 1. 遍历键
        for (String key : hashMap.keySet()) {
            System.out.println(key + " -> " + hashMap.get(key));
        }

        // 2. 遍历值
        for (Integer value : hashMap.values()) {
            System.out.println("Value: " + value);
        }

        // 3. 遍历键值对
        for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }

        // 4. 使用forEach（Java 8+）
        hashMap.forEach((key, value) -> {
            System.out.println(key + " => " + value);
        });

        // 高级操作（Java 8+）
        hashMap.compute("Apple", (key, value) -> value + 1);
        hashMap.computeIfAbsent("Grape", key -> 8);
        hashMap.merge("Apple", 5, Integer::sum);
    }
}
```

**HashMap特点：**
- 基于哈希表实现
- 查询、插入、删除平均时间复杂度O(1)
- 允许null键和null值
- 线程不安全

#### LinkedHashMap - 保持顺序的映射
```java
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        // 保持插入顺序
        Map<String, Integer> insertionOrder = new LinkedHashMap<>();
        insertionOrder.put("C", 3);
        insertionOrder.put("A", 1);
        insertionOrder.put("B", 2);

        System.out.println("插入顺序: " + insertionOrder);
        // 输出: {C=3, A=1, B=2}

        // 保持访问顺序（LRU缓存）
        Map<String, Integer> accessOrder = new LinkedHashMap<>(16, 0.75f, true);
        accessOrder.put("A", 1);
        accessOrder.put("B", 2);
        accessOrder.put("C", 3);

        accessOrder.get("A"); // 访问A，A会移到最后
        System.out.println("访问顺序: " + accessOrder);
        // 输出: {B=2, C=3, A=1}
    }
}
```

#### TreeMap - 有序映射
```java
public class TreeMapDemo {
    public static void main(String[] args) {
        TreeMap<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("Charlie", 30);
        treeMap.put("Alice", 25);
        treeMap.put("Bob", 35);

        System.out.println(treeMap); // {Alice=25, Bob=35, Charlie=30}

        // TreeMap特有方法
        System.out.println("第一个键: " + treeMap.firstKey());
        System.out.println("最后一个键: " + treeMap.lastKey());
        System.out.println("小于Charlie的映射: " + treeMap.headMap("Charlie"));
        System.out.println("大于等于Bob的映射: " + treeMap.tailMap("Bob"));

        // 自定义排序
        TreeMap<String, Integer> customSort = new TreeMap<>(
            (a, b) -> b.compareTo(a) // 逆序
        );
        customSort.putAll(treeMap);
        System.out.println("逆序: " + customSort);
    }
}
```

### 6. 集合的线程安全性

#### 传统同步方案
```java
public class ThreadSafeCollections {
    public static void main(String[] args) {
        // 使用Collections工具类创建线程安全的集合
        List<String> safeList = Collections.synchronizedList(new ArrayList<>());
        Set<String> safeSet = Collections.synchronizedSet(new HashSet<>());
        Map<String, Integer> safeMap = Collections.synchronizedMap(new HashMap<>());

        // 注意：遍历时仍需要同步
        synchronized (safeList) {
            for (String item : safeList) {
                System.out.println(item);
            }
        }
    }
}
```

#### 并发集合（推荐）
```java
import java.util.concurrent.*;

public class ConcurrentCollections {
    public static void main(String[] args) {
        // 高性能的并发集合
        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        CopyOnWriteArrayList<String> copyOnWriteList = new CopyOnWriteArrayList<>();
        ConcurrentLinkedQueue<String> concurrentQueue = new ConcurrentLinkedQueue<>();

        // ConcurrentHashMap示例
        concurrentMap.put("key1", 1);
        concurrentMap.compute("key1", (key, value) -> value + 1);
        concurrentMap.putIfAbsent("key2", 2);

        // 分段锁机制，性能优于Hashtable
        System.out.println(concurrentMap);
    }
}
```

### 7. 集合选择指南

#### 性能对比表

| 操作 | ArrayList | LinkedList | HashSet | TreeSet | HashMap | TreeMap |
|------|-----------|------------|---------|---------|---------|---------|
| 插入 | O(1)摊销/O(n)最坏 | O(1) | O(1)平均 | O(log n) | O(1)平均 | O(log n) |
| 删除 | O(n) | O(1) | O(1)平均 | O(log n) | O(1)平均 | O(log n) |
| 查找 | O(1) | O(n) | O(1)平均 | O(log n) | O(1)平均 | O(log n) |
| 空间 | O(n) | O(n) | O(n) | O(n) | O(n) | O(n) |

#### 选择建议
```java
public class CollectionChoice {

    // 选择List实现
    public void chooseList() {
        // 频繁随机访问 -> ArrayList
        List<String> randomAccess = new ArrayList<>();

        // 频繁插入删除 -> LinkedList
        List<String> frequentModify = new LinkedList<>();

        // 线程安全 -> CopyOnWriteArrayList或同步包装
        List<String> threadSafe = new CopyOnWriteArrayList<>();
    }

    // 选择Set实现
    public void chooseSet() {
        // 快速查找，无序 -> HashSet
        Set<String> fastLookup = new HashSet<>();

        // 保持插入顺序 -> LinkedHashSet
        Set<String> orderedSet = new LinkedHashSet<>();

        // 自动排序 -> TreeSet
        Set<String> sortedSet = new TreeSet<>();
    }

    // 选择Map实现
    public void chooseMap() {
        // 通用场景 -> HashMap
        Map<String, Object> general = new HashMap<>();

        // 保持顺序 -> LinkedHashMap
        Map<String, Object> ordered = new LinkedHashMap<>();

        // 自动排序 -> TreeMap
        Map<String, Object> sorted = new TreeMap<>();

        // 高并发 -> ConcurrentHashMap
        Map<String, Object> concurrent = new ConcurrentHashMap<>();
    }
}
```

### 8. 集合工具类和最佳实践

#### Collections工具类
```java
import java.util.Collections;

public class CollectionsUtils {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9));

        // 排序
        Collections.sort(numbers);
        Collections.sort(numbers, Collections.reverseOrder());

        // 查找
        int index = Collections.binarySearch(numbers, 4);
        int max = Collections.max(numbers);
        int min = Collections.min(numbers);

        // 修改
        Collections.shuffle(numbers);  // 随机打乱
        Collections.reverse(numbers);  // 反转
        Collections.rotate(numbers, 2); // 旋转
        Collections.fill(numbers, 0);   // 填充

        // 创建不可变集合
        List<String> immutableList = Collections.unmodifiableList(
            Arrays.asList("A", "B", "C")
        );

        // 创建空集合
        List<String> emptyList = Collections.emptyList();
        Set<String> emptySet = Collections.emptySet();
        Map<String, String> emptyMap = Collections.emptyMap();

        // 单元素集合
        List<String> singletonList = Collections.singletonList("single");
        Set<String> singletonSet = Collections.singleton("single");
    }
}
```

#### 自定义比较器
```java
public class CustomComparator {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        );

        // 按年龄排序
        Collections.sort(people, (p1, p2) -> p1.age - p2.age);

        // 使用Comparator工具方法（Java 8+）
        people.sort(Comparator.comparing(Person::getName));
        people.sort(Comparator.comparingInt(Person::getAge).reversed());

        // 多级排序
        people.sort(Comparator.comparing(Person::getAge)
                   .thenComparing(Person::getName));
    }

    static class Person {
        String name;
        int age;

        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        String getName() { return name; }
        int getAge() { return age; }
    }
}
```

#### 集合与Stream API
```java
import java.util.stream.Collectors;

public class CollectionWithStreams {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");

        // 过滤和转换
        List<String> upperCaseWords = words.stream()
            .filter(word -> word.length() > 5)
            .map(String::toUpperCase)
            .collect(Collectors.toList());

        // 分组
        Map<Integer, List<String>> wordsByLength = words.stream()
            .collect(Collectors.groupingBy(String::length));

        // 统计
        Map<Integer, Long> lengthCounts = words.stream()
            .collect(Collectors.groupingBy(
                String::length,
                Collectors.counting()
            ));

        // 转换为其他集合类型
        Set<String> wordSet = words.stream()
            .collect(Collectors.toSet());

        TreeSet<String> sortedWords = words.stream()
            .collect(Collectors.toCollection(TreeSet::new));
    }
}
```

### 9. 性能优化建议

1. **选择合适的初始容量**：
```java
// 避免频繁扩容
List<String> list = new ArrayList<>(1000);
Map<String, Integer> map = new HashMap<>(1000);
```

2. **使用合适的负载因子**：
```java
// HashMap默认负载因子0.75，可根据需要调整
Map<String, Integer> map = new HashMap<>(1000, 0.8f);
```

3. **避免装箱拆箱**：
```java
// 使用专门的原始类型集合库（如Eclipse Collections、Trove）
// 或使用数组代替List<Integer>
```

4. **选择正确的遍历方式**：
```java
// 对于ArrayList，使用索引遍历更快
for (int i = 0; i < list.size(); i++) {
    String item = list.get(i);
}

// 对于LinkedList，使用增强for循环
for (String item : linkedList) {
    // 处理item
}
```

Java集合框架是Java编程的基础，熟练掌握各种集合类的特点和使用场景，能够显著提高代码的性能和可维护性。
