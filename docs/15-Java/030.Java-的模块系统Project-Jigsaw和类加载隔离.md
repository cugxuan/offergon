---
title: Java 的模块系统（Project Jigsaw）和类加载隔离
tags:
  - Java
status: robot
class: Java
slug: java-module-system-classloader-isolation
ref:
---

## 核心要点提炼

**Java 模块系统的核心概念：**
- 模块化系统提供强封装和明确的依赖关系
- `module-info.java` 文件定义模块的导出、依赖和服务
- 模块路径（Module Path）与类路径（Class Path）并存
- 可读性（Readability）和可访问性（Accessibility）控制模块间交互
- 新的类加载器层次结构支持模块系统

## 详细回答

### 1. Java 模块系统概述

#### 1.1 Project Jigsaw 的背景和目标

Java 9 引入的 Project Jigsaw（模块系统）主要解决以下问题：

1. **大型单体 JAR 包**：JDK 自身是一个巨大的单体，应用往往只使用其中很小一部分
2. **封装性不足**：传统的 public 修饰符暴露了太多内部实现
3. **依赖地狱**：复杂的类路径导致运行时错误难以预测
4. **配置复杂**：缺乏明确的依赖声明机制

```java
// 传统方式的问题示例
// 在类路径中，任何 public 类都可以被任意访问
// 无法控制模块间的依赖关系
import sun.misc.Unsafe;  // 不应该被应用代码直接使用

public class ProblematicCode {
    public void useInternalAPI() {
        Unsafe unsafe = Unsafe.getUnsafe();  // 危险的内部 API 使用
        // ...
    }
}
```

#### 1.2 模块系统的核心组件

```java
// module-info.java 文件结构
module com.example.myapp {
    // 导出包供其他模块使用
    exports com.example.myapp.api;
    exports com.example.myapp.spi to com.example.implementation;  // 限定导出

    // 声明依赖的模块
    requires java.base;          // 隐式依赖，所有模块都需要
    requires java.logging;       // 显式依赖
    requires transitive java.sql;  // 传递依赖

    // 开放包用于反射（如框架使用）
    opens com.example.myapp.internal to java.base;
    opens com.example.myapp.entity;  // 对所有模块开放

    // 服务提供和使用
    provides com.example.spi.DatabaseDriver with com.example.impl.MySQLDriver;
    uses com.example.spi.DatabaseDriver;
}
```

### 2. 模块声明详解

#### 2.1 exports 指令

```java
// 基本导出
module com.example.library {
    exports com.example.library.api;  // 导出给所有模块
}

// 限定导出（qualified exports）
module com.example.framework {
    exports com.example.framework.internal to
        com.example.plugin1,
        com.example.plugin2;  // 只导出给特定模块
}

// 在代码中的体现
// com.example.library.api 包中的类
package com.example.library.api;

public class PublicAPI {  // 可以被其他模块使用
    public void doSomething() { }
}

// com.example.library.internal 包中的类
package com.example.library.internal;

public class InternalClass {  // 不能被其他模块访问
    public void internalMethod() { }
}
```

#### 2.2 requires 指令

```java
module com.example.consumer {
    // 基本依赖
    requires java.logging;

    // 传递依赖：使用该模块的其他模块也会自动依赖 java.sql
    requires transitive java.sql;

    // 静态依赖：编译时需要，运行时可选
    requires static java.compiler;

    // 组合使用
    requires transitive static com.example.optional;
}

// 传递依赖的示例
module com.example.database {
    requires transitive java.sql;  // 传递依赖
    exports com.example.database.api;
}

module com.example.app {
    requires com.example.database;
    // 自动获得对 java.sql 的访问权限（因为传递依赖）
}

// 应用代码
import java.sql.Connection;  // 可以直接使用，因为传递依赖
import com.example.database.api.DatabaseManager;

public class App {
    public void connectToDatabase() {
        DatabaseManager manager = new DatabaseManager();
        Connection conn = manager.getConnection();  // 都可以使用
    }
}
```

#### 2.3 opens 指令

```java
module com.example.entity {
    // 开放包用于反射访问（如 JPA、JSON 序列化等）
    opens com.example.entity.model;
    opens com.example.entity.dto to com.fasterxml.jackson.databind;
}

// 实体类示例
package com.example.entity.model;

public class User {
    private String name;
    private int age;

    // 即使是 private 字段，框架也可以通过反射访问
    // 因为包被 opens 了
}

// 框架代码可以这样访问
public class FrameworkCode {
    public void processEntity(Object entity) throws Exception {
        Class<?> clazz = entity.getClass();
        Field[] fields = clazz.getDeclaredFields();  // 可以访问 private 字段
        for (Field field : fields) {
            field.setAccessible(true);  // 因为 opens，这里会成功
            Object value = field.get(entity);
            // 处理字段值
        }
    }
}
```

### 3. 类加载器层次结构

#### 3.1 新的类加载器架构

```java
// Java 9+ 的类加载器层次结构
public class ClassLoaderHierarchy {

    public static void demonstrateClassLoaders() {
        // Bootstrap ClassLoader（引导类加载器）
        // 加载 java.base 模块中的核心类
        ClassLoader bootstrapLoader = String.class.getClassLoader();
        System.out.println("Bootstrap: " + bootstrapLoader);  // null

        // Platform ClassLoader（平台类加载器，原 Extension ClassLoader）
        // 加载平台模块（java.se, java.desktop 等）
        ClassLoader platformLoader = ClassLoader.getPlatformClassLoader();
        System.out.println("Platform: " + platformLoader);

        // System ClassLoader（系统类加载器，原 Application ClassLoader）
        // 加载应用模块和类路径上的类
        ClassLoader systemLoader = ClassLoader.getSystemClassLoader();
        System.out.println("System: " + systemLoader);

        // 验证层次关系
        ClassLoader currentLoader = systemLoader;
        while (currentLoader != null) {
            System.out.println("Current: " + currentLoader);
            currentLoader = currentLoader.getParent();
        }
    }
}
```

#### 3.2 模块加载机制

```java
// ModuleFinder 和 ModuleLayer 的使用
import java.lang.module.*;
import java.nio.file.Path;
import java.nio.file.Paths;

public class ModuleLoadingExample {

    public static void loadCustomModule() {
        try {
            // 1. 创建模块查找器
            Path modulePath = Paths.get("modules");
            ModuleFinder finder = ModuleFinder.of(modulePath);

            // 2. 查找特定模块
            Optional<ModuleReference> moduleRef = finder.find("com.example.plugin");

            if (moduleRef.isPresent()) {
                // 3. 创建配置
                ModuleFinder systemFinder = ModuleFinder.ofSystem();
                Configuration configuration = ModuleLayer.boot()
                    .configuration()
                    .resolve(finder, systemFinder, Set.of("com.example.plugin"));

                // 4. 创建新的模块层
                ModuleLayer.Controller controller = ModuleLayer.defineModulesWithOneLoader(
                    configuration,
                    List.of(ModuleLayer.boot()),
                    ClassLoader.getSystemClassLoader()
                );

                ModuleLayer layer = controller.layer();

                // 5. 获取模块中的类
                Optional<Module> module = layer.findModule("com.example.plugin");
                if (module.isPresent()) {
                    Class<?> pluginClass = module.get()
                        .getClassLoader()
                        .loadClass("com.example.plugin.PluginImpl");

                    Object pluginInstance = pluginClass.getDeclaredConstructor().newInstance();
                    System.out.println("Plugin loaded: " + pluginInstance);
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 4. 模块间的可见性控制

#### 4.1 可读性（Readability）

```java
// 模块的可读性关系
public class ModuleReadability {

    public static void checkReadability() {
        // 获取当前模块
        Module currentModule = ModuleReadability.class.getModule();

        // 检查对其他模块的可读性
        Module javaBaseModule = String.class.getModule();
        Module javaLoggingModule = java.util.logging.Logger.class.getModule();

        System.out.println("Can read java.base: " +
            currentModule.canRead(javaBaseModule));  // true
        System.out.println("Can read java.logging: " +
            currentModule.canRead(javaLoggingModule));  // 取决于 requires 声明

        // 运行时添加可读性（需要 --add-modules 或 --add-reads）
        // currentModule.addReads(someModule);  // 需要适当权限
    }
}
```

#### 4.2 可访问性（Accessibility）

```java
// 包的可访问性示例
module com.example.provider {
    exports com.example.provider.api;
    // com.example.provider.internal 包不被导出
}

// 在另一个模块中
module com.example.consumer {
    requires com.example.provider;
}

// Consumer 模块中的代码
package com.example.consumer;

import com.example.provider.api.PublicService;  // ✓ 可以访问
// import com.example.provider.internal.InternalClass;  // ✗ 编译错误

public class ConsumerCode {
    public void useProvider() {
        PublicService service = new PublicService();  // ✓ 可以使用
        // InternalClass internal = new InternalClass();  // ✗ 无法访问
    }
}
```

### 5. 兼容性和迁移

#### 5.1 Unnamed Module（未命名模块）

```java
// 传统的 JAR 包在模块系统中作为未命名模块运行
// 未命名模块的特性：
// 1. 可以读取所有其他模块
// 2. 导出所有包
// 3. 但其他命名模块默认不能读取未命名模块

public class UnnamedModuleExample {
    public static void main(String[] args) {
        // 在传统 JAR 中运行的代码
        // 仍然可以访问所有 JDK 模块的导出包

        java.util.List<String> list = new java.util.ArrayList<>();
        java.util.logging.Logger logger = java.util.logging.Logger.getLogger("test");

        // 但命名模块不能依赖这些类
    }
}
```

#### 5.2 Automatic Module（自动模块）

```java
// 普通 JAR 放在模块路径上会成为自动模块
// 自动模块的特性：
// 1. 模块名从 JAR 文件名派生
// 2. 导出所有包
// 3. 可以读取所有其他模块

// 例如：common-utils-1.0.jar 变成自动模块 common.utils
module com.example.app {
    requires common.utils;  // 可以依赖自动模块
}
```

### 6. 服务提供者机制

#### 6.1 服务接口定义

```java
// 服务接口模块
module com.example.spi {
    exports com.example.spi;
}

// 服务接口
package com.example.spi;

public interface DatabaseDriver {
    void connect(String url);
    void disconnect();
    String getDriverName();
}
```

#### 6.2 服务提供者实现

```java
// MySQL 驱动实现模块
module com.example.mysql {
    requires com.example.spi;
    provides com.example.spi.DatabaseDriver with com.example.mysql.MySQLDriver;
}

// MySQL 驱动实现
package com.example.mysql;

import com.example.spi.DatabaseDriver;

public class MySQLDriver implements DatabaseDriver {
    @Override
    public void connect(String url) {
        System.out.println("Connecting to MySQL: " + url);
    }

    @Override
    public void disconnect() {
        System.out.println("Disconnecting from MySQL");
    }

    @Override
    public String getDriverName() {
        return "MySQL Driver";
    }
}
```

#### 6.3 服务使用者

```java
// 服务使用者模块
module com.example.app {
    requires com.example.spi;
    uses com.example.spi.DatabaseDriver;
}

// 应用代码
package com.example.app;

import com.example.spi.DatabaseDriver;
import java.util.ServiceLoader;

public class DatabaseApp {
    public static void main(String[] args) {
        // 使用 ServiceLoader 加载服务
        ServiceLoader<DatabaseDriver> drivers = ServiceLoader.load(DatabaseDriver.class);

        for (DatabaseDriver driver : drivers) {
            System.out.println("Found driver: " + driver.getDriverName());
            driver.connect("jdbc:mysql://localhost:3306/test");
            driver.disconnect();
        }

        // 或者查找特定驱动
        drivers.stream()
            .filter(provider -> provider.get().getDriverName().contains("MySQL"))
            .findFirst()
            .ifPresent(provider -> {
                DatabaseDriver driver = provider.get();
                driver.connect("jdbc:mysql://localhost:3306/prod");
            });
    }
}
```

### 7. 反射和模块系统

#### 7.1 强封装对反射的影响

```java
// 传统反射在模块系统中的限制
public class ReflectionExample {

    public static void demonstrateReflectionLimits() {
        try {
            // 尝试访问未导出包中的类
            Class<?> internalClass = Class.forName("jdk.internal.misc.Unsafe");

            // 在模块系统中，这会抛出异常（除非使用 --add-exports）
            Object instance = internalClass.getDeclaredConstructor().newInstance();

        } catch (Exception e) {
            System.out.println("Cannot access internal class: " + e.getMessage());
        }

        try {
            // 访问已导出但未开放的类的私有成员
            Class<?> stringClass = String.class;
            Field valueField = stringClass.getDeclaredField("value");

            valueField.setAccessible(true);  // 在模块系统中可能失败

        } catch (Exception e) {
            System.out.println("Cannot access private field: " + e.getMessage());
        }
    }
}
```

#### 7.2 opens 指令的使用

```java
// 通过 opens 允许深度反射
module com.example.entity {
    // 允许特定模块进行深度反射
    opens com.example.entity.model to
        com.fasterxml.jackson.databind,
        org.hibernate.core;

    // 或者对所有模块开放
    opens com.example.entity.dto;
}

// JPA 实体示例
package com.example.entity.model;

import javax.persistence.*;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username")
    private String username;

    @Column(name = "email")
    private String email;

    // Hibernate 可以通过反射访问这些私有字段
    // 因为包被 opens 到 org.hibernate.core
}
```

### 8. 实际应用场景

#### 8.1 微服务架构中的模块化

```java
// 核心服务模块
module com.company.user.service {
    requires com.company.common.api;
    requires java.sql;
    requires transitive com.company.user.api;

    exports com.company.user.service;

    provides com.company.common.api.Service with com.company.user.service.UserServiceImpl;
}

// 用户 API 模块
module com.company.user.api {
    exports com.company.user.api.dto;
    exports com.company.user.api.service;
}

// 通用 API 模块
module com.company.common.api {
    exports com.company.common.api;
    exports com.company.common.api.exception;
}
```

#### 8.2 插件系统设计

```java
// 插件系统核心模块
module com.company.plugin.core {
    exports com.company.plugin.api;

    uses com.company.plugin.api.Plugin;
}

// 插件接口
package com.company.plugin.api;

public interface Plugin {
    String getName();
    String getVersion();
    void initialize();
    void execute();
    void shutdown();
}

// 具体插件实现
module com.company.plugin.weather {
    requires com.company.plugin.core;
    requires java.net.http;

    provides com.company.plugin.api.Plugin with com.company.plugin.weather.WeatherPlugin;
}

// 插件加载器
public class PluginLoader {
    public static void loadPlugins() {
        ServiceLoader<Plugin> plugins = ServiceLoader.load(Plugin.class);

        for (Plugin plugin : plugins) {
            System.out.println("Loading plugin: " + plugin.getName());
            plugin.initialize();
        }
    }
}
```

### 9. 工具和命令

#### 9.1 模块相关的 JDK 工具

```bash
# 编译模块
javac --module-path modules -d out --module-source-path src $(find src -name "*.java")

# 运行模块化应用
java --module-path modules --module com.example.app/com.example.app.Main

# 列出模块信息
java --module-path modules --list-modules

# 描述模块
java --module-path modules --describe-module com.example.app

# jlink 创建自定义运行时映像
jlink --module-path modules:$JAVA_HOME/jmods \
      --add-modules com.example.app \
      --output custom-runtime

# jdeps 分析依赖
jdeps --module-path modules --module com.example.app
```

#### 9.2 模块兼容性选项

```bash
# 添加模块到根模块集
java --add-modules java.base,java.logging MyApp

# 添加导出（用于访问内部 API）
java --add-exports java.base/sun.nio.ch=ALL-UNNAMED MyApp

# 添加开放（用于深度反射）
java --add-opens java.base/java.lang=ALL-UNNAMED MyApp

# 添加读取关系
java --add-reads source.module=target.module MyApp

# 禁用强封装（不推荐）
java --illegal-access=permit MyApp
```

## 总结

Java 模块系统（Project Jigsaw）通过以下机制实现了更好的封装性和可维护性：

1. **强封装**：通过 `exports` 和 `opens` 精确控制包的可见性
2. **明确依赖**：通过 `requires` 声明模块间的依赖关系
3. **服务解耦**：通过 `provides` 和 `uses` 实现松耦合的服务架构
4. **类加载隔离**：新的类加载器层次结构支持模块间的隔离

模块系统不仅解决了传统 Java 应用的"依赖地狱"问题，还为构建大型、可维护的应用提供了强大的架构支持。虽然迁移到模块系统需要一定的工作量，但对于新项目，采用模块化设计能够带来更好的代码组织和运行时安全性。
