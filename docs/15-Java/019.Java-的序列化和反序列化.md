---
title: Java 的序列化和反序列化
tags:
  - Java
status: robot
class: Java
slug: java-serialization-and-deserialization
ref:
---

## 核心要点

**序列化定义**:将对象转换为字节流以便存储或传输,反序列化是逆过程。实现 `Serializable` 接口即可使用 Java 原生序列化。

**核心机制**:`serialVersionUID` 控制版本兼容性;`transient` 关键字排除字段;`writeObject/readObject` 自定义序列化逻辑;`Externalizable` 接口提供完全控制。

**现代实践**:Java 原生序列化性能差且有安全隐患,生产环境推荐使用 **JSON**(Jackson/Gson)、**Protobuf**、**Kryo** 等高性能序列化框架。

---

## 详细回答

### 一、序列化基础概念

#### 1. 什么是序列化

**序列化(Serialization)**:将内存中的对象转换为字节序列,以便:
- 持久化存储(保存到文件/数据库)
- 网络传输(RPC 调用、消息队列)
- 进程间通信(IPC)

**反序列化(Deserialization)**:将字节序列恢复为对象。

**核心接口**:
```java
// 标记接口,无方法定义
public interface Serializable {
}

// 类实现接口即可序列化
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;
    private int age;

    // 构造器、getter/setter...
}
```

#### 2. 基本使用示例

**序列化到文件**:
```java
public class SerializeDemo {
    public static void main(String[] args) {
        User user = new User("Alice", 25);

        // 序列化
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("user.ser"))) {
            oos.writeObject(user);
            System.out.println("对象已序列化");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 反序列化
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("user.ser"))) {
            User deserializedUser = (User) ois.readObject();
            System.out.println("反序列化对象: " + deserializedUser);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

**网络传输示例**:
```java
// 服务端:接收对象
ServerSocket server = new ServerSocket(8080);
Socket socket = server.accept();
ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
User user = (User) ois.readObject();

// 客户端:发送对象
Socket socket = new Socket("localhost", 8080);
ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
oos.writeObject(new User("Bob", 30));
oos.flush();
```

---

### 二、Java 原生序列化机制

#### 1. serialVersionUID 详解

**作用**:序列化版本控制,确保序列化和反序列化的类版本兼容。

**生成规则**:
```java
public class User implements Serializable {
    // 1. 显式声明(强烈推荐)
    private static final long serialVersionUID = 1L;

    // 2. 不声明:JVM 自动生成(基于类结构的哈希值)
    // 问题:任何改动(增删字段、改方法)都会导致 UID 变化
}
```

**版本不匹配的后果**:
```java
// 序列化时:User 类 serialVersionUID = 1L
User user = new User("Alice", 25);
serialize(user, "user.ser");

// 修改 User 类后(增加字段 email)
// 如果没有显式 UID,自动生成的 UID 会变化
// 反序列化时报错:
try {
    User user = deserialize("user.ser");
} catch (InvalidClassException e) {
    // local class incompatible:
    // stream classdesc serialVersionUID = 12345
    // local class serialVersionUID = 67890
}
```

**最佳实践**:
```java
// 总是显式声明 serialVersionUID
private static final long serialVersionUID = 1L;

// 兼容性修改:
// ✅ 增加字段(新版本可以反序列化旧数据,新字段为默认值)
// ✅ 删除字段(旧字段被忽略)
// ❌ 修改字段类型(不兼容)
// ❌ 修改类的继承关系(不兼容)
```

#### 2. transient 关键字

**作用**:标记字段不参与序列化。

**使用场景**:
```java
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private String username;
    private transient String password;  // 密码不序列化
    private transient Thread workThread;  // 线程对象无法序列化
    private transient Socket connection;  // 连接对象无意义
    private transient Logger logger;  // 日志对象每次创建

    // static 字段也不会序列化(属于类,不属于对象)
    private static int userCount;
}
```

**验证示例**:
```java
User user = new User("alice", "secret123");
serialize(user, "user.ser");

User deserializedUser = deserialize("user.ser");
System.out.println(deserializedUser.getUsername());  // alice
System.out.println(deserializedUser.getPassword());  // null (transient)
```

#### 3. 自定义序列化逻辑

**通过 writeObject/readObject 方法**:

```java
public class SecureUser implements Serializable {
    private static final long serialVersionUID = 1L;

    private String username;
    private transient String password;  // 标记为 transient

    // 自定义序列化
    private void writeObject(ObjectOutputStream oos) throws IOException {
        // 1. 先调用默认序列化(处理非 transient 字段)
        oos.defaultWriteObject();

        // 2. 手动处理 password:加密后写入
        String encryptedPassword = encrypt(password);
        oos.writeObject(encryptedPassword);
    }

    // 自定义反序列化
    private void readObject(ObjectInputStream ois)
            throws IOException, ClassNotFoundException {
        // 1. 先调用默认反序列化
        ois.defaultReadObject();

        // 2. 手动读取并解密 password
        String encryptedPassword = (String) ois.readObject();
        this.password = decrypt(encryptedPassword);
    }

    private String encrypt(String text) {
        // 加密逻辑(如 AES)
        return Base64.getEncoder().encodeToString(text.getBytes());
    }

    private String decrypt(String encrypted) {
        return new String(Base64.getDecoder().decode(encrypted));
    }
}
```

**完全自定义:使用 Externalizable 接口**:
```java
public class CustomUser implements Externalizable {
    private String username;
    private int age;

    // 必须提供无参构造器!
    public CustomUser() {
    }

    public CustomUser(String username, int age) {
        this.username = username;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        // 完全控制序列化过程
        out.writeUTF(username);
        out.writeInt(age);
        // 可以按需序列化,不需要 transient
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException {
        // 完全控制反序列化过程(顺序必须一致)
        this.username = in.readUTF();
        this.age = in.readInt();
    }
}
```

**Serializable vs Externalizable**:

| 特性 | Serializable | Externalizable |
|------|--------------|----------------|
| 实现难度 | 简单(自动) | 复杂(手动) |
| 性能 | 较慢(反射) | 较快(无反射) |
| 控制力 | 有限 | 完全控制 |
| 无参构造器 | 不需要 | 必须提供 |

#### 4. 序列化继承链

**规则**:
- 父类实现 `Serializable`,子类自动可序列化
- 父类未实现,子类实现:父类字段不会序列化(使用默认值)

**示例**:
```java
// 父类未实现 Serializable
class Animal {
    protected String species = "Unknown";

    public Animal() {
        System.out.println("Animal 无参构造器被调用");
    }
}

// 子类实现 Serializable
class Dog extends Animal implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;

    public Dog(String name) {
        this.species = "Canine";
        this.name = name;
    }
}

// 测试
Dog dog = new Dog("Buddy");
dog.species = "Canine Modified";

serialize(dog, "dog.ser");

Dog deserializedDog = deserialize("dog.ser");
System.out.println(deserializedDog.name);     // Buddy (子类字段序列化)
System.out.println(deserializedDog.species);  // Unknown (父类字段未序列化,使用默认值)
// 反序列化时会调用父类无参构造器!
```

**最佳实践**:
- 如果父类有重要字段,应该让父类也实现 `Serializable`
- 确保继承链中的所有非 Serializable 类有无参构造器

---

### 三、序列化的高级特性

#### 1. 单例模式的序列化问题

**问题**:反序列化会破坏单例模式。

```java
public class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;

    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return INSTANCE;
    }
}

// 测试
Singleton s1 = Singleton.getInstance();
serialize(s1, "singleton.ser");
Singleton s2 = deserialize("singleton.ser");

System.out.println(s1 == s2);  // false! 破坏了单例
```

**解决方案:使用 readResolve 方法**:
```java
public class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;

    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return INSTANCE;
    }

    // 关键:反序列化时返回单例对象
    private Object readResolve() {
        return INSTANCE;
    }
}

// 现在 s1 == s2 返回 true
```

#### 2. 枚举的序列化

**枚举天然支持序列化**,且保证单例:
```java
public enum Color implements Serializable {
    RED, GREEN, BLUE;
}

// 序列化和反序列化枚举
Color color = Color.RED;
serialize(color, "color.ser");
Color deserializedColor = deserialize("color.ser");

System.out.println(color == deserializedColor);  // true (保证单例)
```

**原理**:枚举序列化时只保存枚举名称,反序列化时通过 `Enum.valueOf()` 获取,天然保证唯一性。

#### 3. 序列化代理模式

**用于保护敏感数据和简化复杂对象的序列化**:

```java
public class Period implements Serializable {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
        if (start.after(end)) {
            throw new IllegalArgumentException("开始时间晚于结束时间");
        }
    }

    // 序列化代理类
    private static class SerializationProxy implements Serializable {
        private static final long serialVersionUID = 1L;

        private final Date start;
        private final Date end;

        SerializationProxy(Period period) {
            this.start = period.start;
            this.end = period.end;
        }

        // 反序列化时调用,返回外部类对象
        private Object readResolve() {
            return new Period(start, end);  // 调用构造器,保证校验逻辑执行
        }
    }

    // 序列化时返回代理对象
    private Object writeReplace() {
        return new SerializationProxy(this);
    }

    // 防止直接反序列化外部类
    private void readObject(ObjectInputStream ois) throws InvalidObjectException {
        throw new InvalidObjectException("必须使用代理");
    }
}
```

**优势**:
- 保护不变性约束(通过构造器校验)
- 防止伪造字节流攻击
- 简化复杂对象的序列化逻辑

---

### 四、序列化的问题与安全风险

#### 1. 性能问题

**Java 原生序列化的开销**:
```java
// 性能测试
User user = new User("Alice", 25);

// 1. Java 原生序列化
long start = System.currentTimeMillis();
for (int i = 0; i < 100000; i++) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(user);
    byte[] bytes = baos.toByteArray();
}
System.out.println("Java 序列化: " + (System.currentTimeMillis() - start) + "ms");

// 2. JSON 序列化(Jackson)
ObjectMapper mapper = new ObjectMapper();
start = System.currentTimeMillis();
for (int i = 0; i < 100000; i++) {
    String json = mapper.writeValueAsString(user);
}
System.out.println("JSON 序列化: " + (System.currentTimeMillis() - start) + "ms");
```

**典型结果**:
- Java 原生:1500ms,字节大小 ~200 bytes
- JSON(Jackson):300ms,字节大小 ~50 bytes
- Protobuf:100ms,字节大小 ~20 bytes

**原因**:
- Java 序列化包含完整的类元数据(类名、字段描述符等)
- 使用反射机制,性能差
- 字节流冗余度高

#### 2. 安全风险

**反序列化漏洞(CVE 级别)**:

攻击者可以构造恶意字节流,在反序列化时执行任意代码。

**经典攻击场景**:
```java
// 恶意类:重写 readObject 方法
public class MaliciousClass implements Serializable {
    private void readObject(ObjectInputStream ois) throws IOException {
        // 反序列化时执行恶意代码!
        Runtime.getRuntime().exec("rm -rf /");  // 删除文件
        // 或者反弹 shell、窃取数据等
    }
}

// 受害者代码
try (ObjectInputStream ois = new ObjectInputStream(untrustedInput)) {
    Object obj = ois.readObject();  // 危险!如果是恶意字节流,代码会被执行
}
```

**真实案例**:
- **Apache Commons Collections 漏洞**(CVE-2015-6420):利用反序列化执行任意代码
- **Spring Framework 漏洞**(CVE-2016-1000027):反序列化 RCE
- **WebLogic 漏洞**:大量反序列化相关漏洞

**防御措施**:
```java
// 1. 使用白名单过滤
public class SafeObjectInputStream extends ObjectInputStream {
    private static final Set<String> ALLOWED_CLASSES = Set.of(
        "com.example.User",
        "com.example.Order"
    );

    public SafeObjectInputStream(InputStream in) throws IOException {
        super(in);
    }

    @Override
    protected Class<?> resolveClass(ObjectStreamClass desc)
            throws IOException, ClassNotFoundException {
        if (!ALLOWED_CLASSES.contains(desc.getName())) {
            throw new InvalidClassException("不允许的类: " + desc.getName());
        }
        return super.resolveClass(desc);
    }
}

// 2. 不要反序列化不可信来源的数据
// 3. 使用更安全的序列化方案(JSON、Protobuf)
```

#### 3. 版本兼容性问题

**字段类型变化**:
```java
// 旧版本
public class User implements Serializable {
    private int age;  // int 类型
}

// 新版本
public class User implements Serializable {
    private long age;  // 改为 long 类型
}

// 反序列化旧数据时报错:
// incompatible types for field age
```

**解决方案**:
```java
// 使用自定义 readObject 兼容旧版本
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
    ObjectInputStream.GetField fields = ois.readFields();

    try {
        // 尝试读取新版本字段
        this.age = fields.get("age", 0L);
    } catch (IllegalArgumentException e) {
        // 兼容旧版本(int 类型)
        this.age = (long) fields.get("age", 0);
    }
}
```

---

### 五、现代序列化方案对比

#### 1. JSON 序列化(Jackson/Gson)

**优势**:
- ✅ 人类可读,方便调试
- ✅ 跨语言支持
- ✅ 性能较好(比 Java 原生快 5-10 倍)
- ✅ 安全性高(无代码执行风险)

**使用示例**:
```java
// Jackson
ObjectMapper mapper = new ObjectMapper();

// 序列化
String json = mapper.writeValueAsString(user);
// {"name":"Alice","age":25}

// 反序列化
User user = mapper.readValue(json, User.class);

// Gson
Gson gson = new Gson();
String json = gson.toJson(user);
User user = gson.fromJson(json, User.class);
```

**劣势**:
- ❌ 不支持所有 Java 类型(如循环引用)
- ❌ 字节大小比二进制格式大

#### 2. Protobuf(Protocol Buffers)

**优势**:
- ✅ 极致性能(比 JSON 快 5-10 倍)
- ✅ 字节极小(比 JSON 小 3-5 倍)
- ✅ 强类型约束
- ✅ 向前/向后兼容

**定义 .proto 文件**:
```protobuf
syntax = "proto3";

message User {
  string name = 1;
  int32 age = 2;
  string email = 3;
}
```

**使用示例**:
```java
// 序列化
User user = User.newBuilder()
    .setName("Alice")
    .setAge(25)
    .setEmail("alice@example.com")
    .build();

byte[] bytes = user.toByteArray();

// 反序列化
User deserializedUser = User.parseFrom(bytes);
```

**劣势**:
- ❌ 需要预先定义 schema(.proto 文件)
- ❌ 不可读(二进制格式)

#### 3. Kryo(高性能 Java 序列化)

**优势**:
- ✅ 性能极佳(比 Java 原生快 10 倍)
- ✅ 字节小(无类元数据)
- ✅ 无需实现 Serializable

**使用示例**:
```java
Kryo kryo = new Kryo();

// 序列化
Output output = new Output(new FileOutputStream("user.bin"));
kryo.writeObject(output, user);
output.close();

// 反序列化
Input input = new Input(new FileInputStream("user.bin"));
User user = kryo.readObject(input, User.class);
input.close();
```

**劣势**:
- ❌ 仅支持 Java
- ❌ 版本兼容性需手动处理

#### 4. 方案选择指南

| 场景 | 推荐方案 | 原因 |
|------|----------|------|
| Web API | JSON | 跨语言、可读性 |
| 微服务间通信 | Protobuf/gRPC | 性能、强类型 |
| 消息队列 | JSON/Protobuf | 通用性、性能 |
| 本地缓存 | Kryo | 极致性能 |
| 数据持久化 | JSON/数据库 | 兼容性、查询能力 |
| 遗留系统 | Java 原生 | 兼容现有代码 |

---

### 六、最佳实践总结

#### 1. Java 原生序列化的使用建议

**✅ 推荐做法**:
```java
public class User implements Serializable {
    // 1. 总是显式声明 serialVersionUID
    private static final long serialVersionUID = 1L;

    private String username;

    // 2. 敏感字段使用 transient
    private transient String password;

    // 3. 提供自定义序列化逻辑(如需)
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject();
        // 加密 password 后写入
    }

    private void readObject(ObjectInputStream ois)
            throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        // 解密 password
    }

    // 4. 单例模式使用 readResolve
    private Object readResolve() {
        return INSTANCE;
    }
}
```

**❌ 避免的错误**:
```java
// 1. 不声明 serialVersionUID
// 2. 序列化敏感数据(密码、密钥)
// 3. 反序列化不可信数据
// 4. 依赖序列化做深拷贝(性能差)
```

#### 2. 生产环境推荐方案

```java
// Web 服务:使用 JSON
@RestController
public class UserController {
    @PostMapping("/user")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // Spring 自动使用 Jackson 序列化/反序列化
        return ResponseEntity.ok(user);
    }
}

// RPC 服务:使用 Protobuf + gRPC
service UserService {
  rpc GetUser(UserRequest) returns (UserResponse);
}

// 分布式缓存:使用 Kryo 或 JSON
@Cacheable(value = "users", key = "#userId")
public User getUserById(Long userId) {
    // Spring Cache 支持配置序列化方式
    return userDao.findById(userId);
}
```

#### 3. 安全清单

- [ ] 不反序列化来自不可信源的数据
- [ ] 使用白名单验证反序列化的类
- [ ] 敏感数据不直接序列化,或加密后存储
- [ ] 定期更新依赖库,修复已知漏洞
- [ ] 生产环境避免使用 Java 原生序列化

---

### 七、总结

**Java 序列化的本质**:
- 将对象状态持久化或传输的机制
- 通过 `Serializable` 接口标记,`ObjectOutputStream/ObjectInputStream` 操作

**核心知识点**:
1. **serialVersionUID**:版本控制的关键
2. **transient**:排除不需要序列化的字段
3. **writeObject/readObject**:自定义序列化逻辑
4. **readResolve**:保护单例模式
5. **Externalizable**:完全控制序列化过程

**现代开发建议**:
- ❌ **避免使用 Java 原生序列化**:性能差、有安全风险、跨语言支持弱
- ✅ **Web API 使用 JSON**:通用、可读、安全
- ✅ **高性能场景使用 Protobuf**:体积小、速度快、强类型
- ✅ **Java 内部使用 Kryo**:极致性能,无需 schema

序列化是分布式系统和持久化的基础技术,理解其原理和陷阱对于构建健壮的系统至关重要。在面试中,能够结合实际场景分析不同序列化方案的优劣,并给出合理建议,是高级工程师的必备能力。
