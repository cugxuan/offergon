---
title: Java 的锁机制（synchronized、ReentrantLock）
tags:
  - Java
  - 同步原语
status: robot
class: Java
slug: java-lock-mechanism-synchronized-reentrantlock
ref:
---

## 要点提炼

- **synchronized**：JVM内置锁，自动获取释放，支持重入和偏向锁优化
- **ReentrantLock**：显式锁，需手动释放，支持公平锁、中断、超时
- **性能对比**：低竞争synchronized更快，高竞争ReentrantLock更好
- **选择原则**：简单场景用synchronized，复杂需求用ReentrantLock

## 详细解答

### 1. synchronized关键字

#### 1.1 基本用法

```java
public class SynchronizedExample {
    private int count = 0;
    private final Object lock = new Object();

    // 1. 修饰实例方法（锁当前实例）
    public synchronized void incrementMethod() {
        count++;
    }

    // 2. 修饰静态方法（锁类对象）
    public static synchronized void staticMethod() {
        // 静态方法同步
    }

    // 3. 修饰代码块（锁指定对象）
    public void incrementBlock() {
        synchronized (this) {
            count++;
        }
    }

    // 4. 使用自定义锁对象
    public void incrementCustomLock() {
        synchronized (lock) {
            count++;
        }
    }
}
```

#### 1.2 synchronized的实现原理

**字节码层面：**
```java
// Java代码
public void increment() {
    synchronized (this) {
        count++;
    }
}

// 字节码（简化）
monitorenter  // 获取锁
// count++的字节码
monitorexit   // 释放锁
monitorexit   // 异常时释放锁
```

**JVM层面实现：**
- 基于监视器（Monitor）机制
- 每个对象都有一个监视器
- 监视器包含：所有者线程、重入计数、等待队列

#### 1.3 synchronized的优化

**锁升级过程：**
```
无锁状态 → 偏向锁 → 轻量级锁 → 重量级锁
```

```java
// 偏向锁：只有一个线程访问时，记录线程ID
// 轻量级锁：少量线程竞争时，使用CAS操作
// 重量级锁：多线程竞争激烈时，使用操作系统互斥量

public class LockOptimization {
    private int value = 0;

    // JVM会根据竞争情况自动优化锁级别
    public synchronized void increment() {
        value++;
    }
}
```

### 2. ReentrantLock详解

#### 2.1 基本用法

```java
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    // 基本用法
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // 必须在finally中释放
        }
    }

    // 尝试获取锁
    public void tryIncrement() {
        if (lock.tryLock()) {
            try {
                count++;
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("获取锁失败");
        }
    }

    // 超时获取锁
    public void timeoutIncrement() throws InterruptedException {
        if (lock.tryLock(3, TimeUnit.SECONDS)) {
            try {
                count++;
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("获取锁超时");
        }
    }

    // 可中断的锁获取
    public void interruptibleIncrement() throws InterruptedException {
        lock.lockInterruptibly();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}
```

#### 2.2 公平锁与非公平锁

```java
// 非公平锁（默认）：性能更好，可能导致饥饿
ReentrantLock unfairLock = new ReentrantLock(false);

// 公平锁：按申请顺序获取锁，性能较差但避免饥饿
ReentrantLock fairLock = new ReentrantLock(true);

public class FairVsUnfair {
    private final ReentrantLock fairLock = new ReentrantLock(true);
    private final ReentrantLock unfairLock = new ReentrantLock(false);

    public void fairMethod() {
        fairLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 获得公平锁");
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            fairLock.unlock();
        }
    }

    public void unfairMethod() {
        unfairLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 获得非公平锁");
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            unfairLock.unlock();
        }
    }
}
```

#### 2.3 Condition条件变量

```java
public class ConditionExample {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private final Object[] items = new Object[100];
    private int putptr, takeptr, count;

    // 生产者
    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await(); // 队列满时等待
            }
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal(); // 通知消费者
        } finally {
            lock.unlock();
        }
    }

    // 消费者
    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await(); // 队列空时等待
            }
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal(); // 通知生产者
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

### 3. synchronized vs ReentrantLock对比

#### 3.1 功能对比

| 特性 | synchronized | ReentrantLock |
|------|-------------|---------------|
| 锁获取方式 | 自动 | 手动 |
| 锁释放方式 | 自动 | 手动（finally） |
| 可中断性 | 不支持 | 支持 |
| 超时获取 | 不支持 | 支持 |
| 公平性 | 非公平 | 可配置 |
| 条件变量 | 单一（wait/notify） | 多个Condition |
| 重入性 | 支持 | 支持 |
| 性能监控 | 有限 | 丰富API |

#### 3.2 性能对比

```java
public class PerformanceComparison {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    // synchronized版本
    public synchronized void synchronizedIncrement() {
        count++;
    }

    // ReentrantLock版本
    public void lockIncrement() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    // 性能测试
    public static void performanceTest() {
        int threadCount = 10;
        int iterations = 100000;

        // 测试synchronized
        long start = System.nanoTime();
        // ... 测试代码
        long syncTime = System.nanoTime() - start;

        // 测试ReentrantLock
        start = System.nanoTime();
        // ... 测试代码
        long lockTime = System.nanoTime() - start;

        System.out.println("synchronized: " + syncTime + "ns");
        System.out.println("ReentrantLock: " + lockTime + "ns");
    }
}
```

**性能特点：**
- **低竞争场景**：synchronized性能更好（JVM优化）
- **高竞争场景**：ReentrantLock性能更好（更灵活的唤醒机制）
- **Java 6之后**：synchronized性能大幅提升，差距缩小

### 4. 重入性详解

#### 4.1 什么是重入

```java
public class ReentrantExample {
    // synchronized重入
    public synchronized void methodA() {
        System.out.println("methodA");
        methodB(); // 同一线程可以再次获取锁
    }

    public synchronized void methodB() {
        System.out.println("methodB");
    }

    // ReentrantLock重入
    private final ReentrantLock lock = new ReentrantLock();

    public void lockMethodA() {
        lock.lock();
        try {
            System.out.println("lockMethodA");
            lockMethodB(); // 可重入
        } finally {
            lock.unlock();
        }
    }

    public void lockMethodB() {
        lock.lock();
        try {
            System.out.println("lockMethodB");
        } finally {
            lock.unlock();
        }
    }
}
```

#### 4.2 重入计数

```java
public class ReentrantCounter {
    private final ReentrantLock lock = new ReentrantLock();

    public void showHoldCount() {
        lock.lock();
        try {
            System.out.println("持有计数: " + lock.getHoldCount());
            if (lock.getHoldCount() < 3) {
                showHoldCount(); // 递归调用
            }
        } finally {
            lock.unlock();
        }
    }
}
```

### 5. 死锁问题与解决

#### 5.1 死锁示例

```java
public class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    // 可能产生死锁的代码
    public void method1() {
        synchronized (lock1) {
            System.out.println("获取lock1");
            synchronized (lock2) {
                System.out.println("获取lock2");
            }
        }
    }

    public void method2() {
        synchronized (lock2) {
            System.out.println("获取lock2");
            synchronized (lock1) {
                System.out.println("获取lock1");
            }
        }
    }
}
```

#### 5.2 解决死锁

```java
public class DeadlockSolution {
    private final ReentrantLock lock1 = new ReentrantLock();
    private final ReentrantLock lock2 = new ReentrantLock();

    // 解决方案1：统一加锁顺序
    public void orderedLocking() {
        lock1.lock();
        try {
            lock2.lock();
            try {
                // 业务逻辑
            } finally {
                lock2.unlock();
            }
        } finally {
            lock1.unlock();
        }
    }

    // 解决方案2：超时获取锁
    public void timeoutLocking() throws InterruptedException {
        boolean acquired1 = lock1.tryLock(1, TimeUnit.SECONDS);
        if (acquired1) {
            try {
                boolean acquired2 = lock2.tryLock(1, TimeUnit.SECONDS);
                if (acquired2) {
                    try {
                        // 业务逻辑
                    } finally {
                        lock2.unlock();
                    }
                } else {
                    System.out.println("获取lock2超时");
                }
            } finally {
                lock1.unlock();
            }
        } else {
            System.out.println("获取lock1超时");
        }
    }
}
```

### 6. 最佳实践

#### 6.1 选择原则

```java
// 使用synchronized的场景：
// 1. 简单的同步需求
// 2. 不需要超时或中断
// 3. 代码简洁性要求高

public class SimpleSync {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }
}

// 使用ReentrantLock的场景：
// 1. 需要超时获取锁
// 2. 需要中断响应
// 3. 需要公平锁
// 4. 需要多个条件变量

public class ComplexSync {
    private final ReentrantLock lock = new ReentrantLock(true); // 公平锁
    private final Condition condition = lock.newCondition();

    public void complexOperation() throws InterruptedException {
        if (lock.tryLock(5, TimeUnit.SECONDS)) {
            try {
                // 复杂业务逻辑
                condition.await();
            } finally {
                lock.unlock();
            }
        }
    }
}
```

#### 6.2 常见错误

```java
public class CommonMistakes {
    private final ReentrantLock lock = new ReentrantLock();

    // 错误1：忘记释放锁
    public void badMethod1() {
        lock.lock();
        if (someCondition()) {
            return; // 忘记释放锁！
        }
        lock.unlock();
    }

    // 正确做法
    public void goodMethod1() {
        lock.lock();
        try {
            if (someCondition()) {
                return;
            }
            // 业务逻辑
        } finally {
            lock.unlock(); // 总是在finally中释放
        }
    }

    // 错误2：在获取锁之前就进入try块
    public void badMethod2() {
        try {
            lock.lock(); // 如果获取锁失败，finally仍会执行
            // 业务逻辑
        } finally {
            lock.unlock(); // 可能释放未持有的锁
        }
    }

    // 正确做法
    public void goodMethod2() {
        lock.lock(); // 在try块外获取锁
        try {
            // 业务逻辑
        } finally {
            lock.unlock();
        }
    }

    private boolean someCondition() { return true; }
}
```

### 7. 监控和调试

#### 7.1 锁状态监控

```java
public class LockMonitoring {
    private final ReentrantLock lock = new ReentrantLock();

    public void monitorLock() {
        System.out.println("是否被锁定: " + lock.isLocked());
        System.out.println("是否被当前线程持有: " + lock.isHeldByCurrentThread());
        System.out.println("等待队列长度: " + lock.getQueueLength());
        System.out.println("重入次数: " + lock.getHoldCount());
        System.out.println("是否公平锁: " + lock.isFair());
    }
}
```

#### 7.2 死锁检测

```java
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;

public class DeadlockDetection {
    public static void detectDeadlock() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();

        if (deadlockedThreads != null) {
            System.out.println("检测到死锁线程:");
            for (long threadId : deadlockedThreads) {
                System.out.println("线程ID: " + threadId);
            }
        } else {
            System.out.println("未检测到死锁");
        }
    }
}
```

### 8. 面试重点

1. **synchronized和ReentrantLock的区别**
2. **锁的升级过程和JVM优化**
3. **什么是重入性，为什么需要重入**
4. **死锁的产生条件和解决方案**
5. **公平锁和非公平锁的区别**
6. **Condition的使用场景**
7. **如何选择使用哪种锁机制**
8. **锁的性能优化策略**
