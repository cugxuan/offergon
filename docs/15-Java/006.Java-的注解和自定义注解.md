---
title: Java 的注解和自定义注解
tags:
  - Java
status: robot
class: Java
slug: java-annotations-and-custom-annotations
ref:
---

## 核心要点

- **注解是Java 5引入的元数据机制**：提供代码的额外信息，不直接影响代码执行
- **三种元注解**：@Target（使用位置）、@Retention（保留策略）、@Documented（文档化）、@Inherited（继承性）
- **注解处理方式**：编译时处理器和运行时反射
- **自定义注解创建**：使用@interface关键字，结合元注解定义行为

## 详细解答

### 1. 注解的基本概念

注解（Annotation）是Java 5引入的一种元数据机制，用于为代码提供额外的信息。它本身不会影响代码的执行，但可以被编译器、工具或运行时环境读取和处理。

**注解的作用：**
- 提供编译时检查（如@Override）
- 配置框架行为（如Spring的@Component）
- 生成代码或文档
- 运行时处理（如通过反射）

### 2. Java内置注解

**基本注解：**
```java
// 标记方法重写父类方法
@Override
public String toString() {
    return "example";
}

// 标记过时的方法或类
@Deprecated
public void oldMethod() {
    // 已废弃的方法
}

// 抑制编译器警告
@SuppressWarnings("unchecked")
public List<String> getList() {
    return new ArrayList();
}
```

### 3. 元注解详解

元注解是用来注解其他注解的注解：

#### @Target - 指定注解使用位置
```java
public enum ElementType {
    TYPE,          // 类、接口、枚举
    FIELD,         // 字段
    METHOD,        // 方法
    PARAMETER,     // 参数
    CONSTRUCTOR,   // 构造器
    LOCAL_VARIABLE,// 局部变量
    ANNOTATION_TYPE,// 注解类型
    PACKAGE        // 包
}

@Target({ElementType.TYPE, ElementType.METHOD})
public @interface MyAnnotation {
}
```

#### @Retention - 指定注解保留策略
```java
public enum RetentionPolicy {
    SOURCE,   // 源码级别，编译后丢弃
    CLASS,    // 字节码级别，运行时不可用
    RUNTIME   // 运行时级别，可通过反射获取
}

@Retention(RetentionPolicy.RUNTIME)
public @interface RuntimeAnnotation {
}
```

#### @Documented 和 @Inherited
```java
// 注解包含在JavaDoc中
@Documented
public @interface DocumentedAnnotation {
}

// 注解可以被子类继承
@Inherited
public @interface InheritedAnnotation {
}
```

### 4. 自定义注解实践

#### 简单自定义注解
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecution {
    String value() default "";
    boolean printArgs() default false;
    boolean printResult() default false;
}
```

#### 带参数的复杂注解
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ValidatePermission {
    // 必需参数
    String[] roles();

    // 可选参数
    String message() default "权限不足";
    int priority() default 0;

    // 枚举参数
    OperationType operation() default OperationType.READ;

    // 数组参数
    String[] excludeFields() default {};
}

enum OperationType {
    READ, WRITE, DELETE, UPDATE
}
```

### 5. 注解处理器实现

#### 运行时注解处理（反射）
```java
public class AnnotationProcessor {

    public static void processAnnotations(Object obj) {
        Class<?> clazz = obj.getClass();

        // 处理类级别注解
        if (clazz.isAnnotationPresent(ValidatePermission.class)) {
            ValidatePermission annotation = clazz.getAnnotation(ValidatePermission.class);
            System.out.println("角色要求: " + Arrays.toString(annotation.roles()));
        }

        // 处理方法级别注解
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            if (method.isAnnotationPresent(LogExecution.class)) {
                LogExecution logAnnotation = method.getAnnotation(LogExecution.class);
                processLogAnnotation(method, logAnnotation);
            }
        }
    }

    private static void processLogAnnotation(Method method, LogExecution annotation) {
        System.out.println("方法 " + method.getName() + " 需要记录日志");
        if (annotation.printArgs()) {
            System.out.println("需要打印参数");
        }
        if (annotation.printResult()) {
            System.out.println("需要打印返回值");
        }
    }
}
```

#### 编译时注解处理器
```java
@SupportedAnnotationTypes("com.example.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class MyAnnotationProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations,
                          RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) {
            // 编译时处理逻辑
            processingEnv.getMessager().printMessage(
                Diagnostic.Kind.NOTE,
                "处理注解元素: " + element.getSimpleName()
            );
        }
        return true;
    }
}
```

### 6. 实际应用场景

#### Web开发中的注解应用
```java
@RestController
@RequestMapping("/api/users")
@ValidatePermission(roles = {"ADMIN", "USER"})
public class UserController {

    @GetMapping("/{id}")
    @LogExecution(printArgs = true, printResult = true)
    @ValidatePermission(roles = {"USER"}, operation = OperationType.READ)
    public User getUserById(@PathVariable Long id) {
        return userService.findById(id);
    }

    @PostMapping
    @Valid
    @ValidatePermission(roles = {"ADMIN"}, operation = OperationType.WRITE)
    public User createUser(@RequestBody @Valid CreateUserRequest request) {
        return userService.create(request);
    }
}
```

#### 数据验证注解
```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
public @interface PhoneNumber {
    String message() default "无效的手机号码格式";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    String pattern() default "^1[3-9]\\d{9}$";
}

// 使用示例
public class User {
    @NotNull
    @PhoneNumber
    private String phoneNumber;

    @Email(message = "邮箱格式不正确")
    private String email;
}
```

### 7. 注解的最佳实践

#### 性能考虑
```java
// 避免过度使用反射，可以缓存注解信息
public class AnnotationCache {
    private static final Map<Class<?>, List<Method>> ANNOTATED_METHODS =
        new ConcurrentHashMap<>();

    public static List<Method> getAnnotatedMethods(Class<?> clazz,
                                                  Class<? extends Annotation> annotationType) {
        return ANNOTATED_METHODS.computeIfAbsent(clazz, k -> {
            return Arrays.stream(k.getDeclaredMethods())
                    .filter(method -> method.isAnnotationPresent(annotationType))
                    .collect(Collectors.toList());
        });
    }
}
```

#### 注解组合使用
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Component
@Transactional
@ValidatePermission(roles = {"ADMIN"})
public @interface AdminService {
    String value() default "";
}

// 使用组合注解
@AdminService("userManagement")
public class UserManagementService {
    // 自动获得 @Component, @Transactional, @ValidatePermission 的功能
}
```

### 8. 注意事项和限制

1. **注解参数限制**：只能使用基本类型、String、Class、enum、注解和这些类型的数组
2. **性能影响**：运行时注解处理依赖反射，可能影响性能
3. **版本兼容性**：注解的保留策略影响向后兼容性
4. **调试困难**：注解驱动的代码可能难以调试

注解是Java中强大的元编程工具，合理使用可以大大提高代码的可读性和可维护性，是现代Java框架的重要基础。
