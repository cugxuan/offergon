---
title: Java 的 AQS（AbstractQueuedSynchronizer）原理
tags:
  - Java
status: robot
class: Java
slug: java-aqs-principle
ref:
---

## 要点提炼

- **AQS定位**：并发包的核心基础框架，采用模板方法模式
- **核心机制**：state状态+FIFO等待队列+CAS操作
- **锁模式**：支持独占锁和共享锁两种模式
- **应用实例**：ReentrantLock、Semaphore、CountDownLatch等都基于AQS实现

## 详细解答

### 1. AQS概述

#### 1.1 什么是AQS

```java
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    // 核心字段：同步状态
    private volatile int state;

    // 等待队列的头节点
    private transient volatile Node head;

    // 等待队列的尾节点
    private transient volatile Node tail;
}
```

**AQS的作用：**
- 提供同步器的基础框架
- 管理同步状态（state）
- 维护线程等待队列
- 提供独占和共享两种锁模式

#### 1.2 AQS的设计思想

```java
// AQS使用模板方法模式，子类需要实现以下方法：

// 独占模式
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); }
protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); }

// 共享模式
protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException(); }
protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException(); }

// 判断是否为独占模式
protected boolean isHeldExclusively() { throw new UnsupportedOperationException(); }
```

### 2. AQS核心数据结构

#### 2.1 Node节点结构

```java
static final class Node {
    // 节点模式
    static final Node SHARED = new Node();    // 共享模式标记
    static final Node EXCLUSIVE = null;       // 独占模式标记

    // 节点状态
    static final int CANCELLED =  1;  // 线程被取消
    static final int SIGNAL    = -1;  // 需要唤醒后继节点
    static final int CONDITION = -2;  // 等待条件
    static final int PROPAGATE = -3;  // 共享模式下需要传播

    volatile int waitStatus;          // 节点状态
    volatile Node prev;               // 前驱节点
    volatile Node next;               // 后继节点
    volatile Thread thread;           // 对应的线程
    Node nextWaiter;                  // 条件队列中的下一个节点
}
```

#### 2.2 等待队列结构

```java
// AQS维护一个FIFO双向链表
// head -> Node1 <-> Node2 <-> Node3 <- tail
//         |       |       |
//      Thread1  Thread2  Thread3

public class AQSQueueExample {
    // 队列示例（简化）
    private volatile Node head;  // 虚拟头节点，不对应具体线程
    private volatile Node tail;  // 尾节点

    // 入队操作（简化版）
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // 队列为空，需要初始化
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
}
```

### 3. 独占锁实现原理

#### 3.1 acquire流程

```java
// acquire方法的完整流程
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&                    // 1. 尝试获取锁
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 2. 失败则入队等待
        selfInterrupt();                       // 3. 处理中断
}

// 详细流程分析
public class AcquireFlowAnalysis {
    // 步骤1：尝试获取锁（子类实现）
    protected boolean tryAcquire(int arg) {
        // ReentrantLock的实现示例
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 无锁状态，尝试CAS获取
            if (!hasQueuedPredecessors() && compareAndSetState(0, arg)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        } else if (current == getExclusiveOwnerThread()) {
            // 重入锁
            int nextc = c + arg;
            setState(nextc);
            return true;
        }
        return false;
    }

    // 步骤2：创建节点并入队
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

    // 步骤3：在队列中等待
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                // 如果前驱是头节点，再次尝试获取锁
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 检查是否需要阻塞
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
}
```

#### 3.2 release流程

```java
// release方法的完整流程
public final boolean release(int arg) {
    if (tryRelease(arg)) {           // 1. 尝试释放锁
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);      // 2. 唤醒后继节点
        return true;
    }
    return false;
}

// 详细流程分析
public class ReleaseFlowAnalysis {
    // 步骤1：尝试释放锁（子类实现）
    protected boolean tryRelease(int arg) {
        // ReentrantLock的实现示例
        int c = getState() - arg;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    // 步骤2：唤醒后继节点
    private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);

        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            // 从尾部向前找到最前面的有效节点
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);  // 唤醒线程
    }
}
```

### 4. 共享锁实现原理

#### 4.1 acquireShared流程

```java
// 共享模式获取锁
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)      // 1. 尝试获取共享锁
        doAcquireShared(arg);           // 2. 失败则进入共享队列
}

// 共享模式的队列等待
private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);  // 添加共享节点
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);  // 关键：传播唤醒
                    p.next = null;
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

// 设置头节点并传播唤醒
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    setHead(node);

    // 如果还有剩余资源，继续唤醒后继节点
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

#### 4.2 releaseShared流程

```java
// 共享模式释放锁
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {        // 1. 尝试释放共享锁
        doReleaseShared();              // 2. 唤醒等待的共享节点
        return true;
    }
    return false;
}

// 释放共享锁并唤醒后继节点
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;
        }
        if (h == head)
            break;
    }
}
```

### 5. 基于AQS的实现示例

#### 5.1 自定义独占锁

```java
public class CustomMutex implements Lock {
    private final Sync sync = new Sync();

    // 基于AQS的同步器实现
    private static class Sync extends AbstractQueuedSynchronizer {
        // 是否处于独占模式
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 尝试获取锁
        public boolean tryAcquire(int acquires) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        // 尝试释放锁
        protected boolean tryRelease(int releases) {
            if (getState() == 0) throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        // 创建条件变量
        Condition newCondition() {
            return new ConditionObject();
        }
    }

    // 实现Lock接口方法
    public void lock() { sync.acquire(1); }
    public boolean tryLock() { return sync.tryAcquire(1); }
    public void unlock() { sync.release(1); }
    public Condition newCondition() { return sync.newCondition(); }

    // 其他方法省略...
}
```

#### 5.2 自定义共享锁（计数信号量）

```java
public class CustomSemaphore {
    private final Sync sync;

    public CustomSemaphore(int permits) {
        sync = new Sync(permits);
    }

    private static class Sync extends AbstractQueuedSynchronizer {
        Sync(int permits) {
            setState(permits);
        }

        // 尝试获取共享锁
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }

        // 尝试释放共享锁
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next < current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }

        protected int tryAcquireShared(int arg) {
            return nonfairTryAcquireShared(arg);
        }
    }

    public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }

    public void release() {
        sync.releaseShared(1);
    }
}
```

### 6. 常用AQS实现类分析

#### 6.1 ReentrantLock

```java
// ReentrantLock中的Sync实现
abstract static class Sync extends AbstractQueuedSynchronizer {
    // 非公平锁的tryAcquire实现
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;  // 重入计数
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}

// 公平锁和非公平锁的区别
static final class FairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 关键差异：检查是否有前驱节点
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // ... 重入逻辑相同
        return false;
    }
}
```

#### 6.2 CountDownLatch

```java
// CountDownLatch的Sync实现
private static final class Sync extends AbstractQueuedSynchronizer {
    Sync(int count) {
        setState(count);  // 设置初始计数
    }

    int getCount() {
        return getState();
    }

    // 尝试获取共享锁（等待计数为0）
    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

    // 尝试释放共享锁（递减计数）
    protected boolean tryReleaseShared(int releases) {
        for (;;) {
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c-1;
            if (compareAndSetState(c, nextc))
                return nextc == 0;  // 只有计数为0时才唤醒等待线程
        }
    }
}

// 使用示例
CountDownLatch latch = new CountDownLatch(3);

// 等待线程
latch.await();  // 调用acquireSharedInterruptibly(1)

// 工作线程
latch.countDown();  // 调用releaseShared(1)
```

#### 6.3 Semaphore

```java
// Semaphore的Sync实现
abstract static class Sync extends AbstractQueuedSynchronizer {
    Sync(int permits) {
        setState(permits);
    }

    final int getPermits() {
        return getState();
    }

    // 非公平获取
    final int nonfairTryAcquireShared(int acquires) {
        for (;;) {
            int available = getState();
            int remaining = available - acquires;
            if (remaining < 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }

    // 释放许可
    protected final boolean tryReleaseShared(int releases) {
        for (;;) {
            int current = getState();
            int next = current + releases;
            if (compareAndSetState(current, next))
                return true;
        }
    }
}
```

### 7. Condition条件变量

#### 7.1 ConditionObject实现

```java
// AQS内部的ConditionObject实现
public class ConditionObject implements Condition {
    private transient Node firstWaiter;  // 条件队列头
    private transient Node lastWaiter;   // 条件队列尾

    // await方法实现
    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();

        Node node = addConditionWaiter();     // 1. 加入条件队列
        int savedState = fullyRelease(node);  // 2. 完全释放锁
        int interruptMode = 0;

        while (!isOnSyncQueue(node)) {        // 3. 检查是否在同步队列中
            LockSupport.park(this);           // 4. 阻塞等待
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }

        // 5. 重新获取锁
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;

        if (node.nextWaiter != null)
            unlinkCancelledWaiters();

        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }

    // signal方法实现
    public final void signal() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);  // 将第一个等待节点转移到同步队列
    }
}
```

### 8. AQS的优势与特点

#### 8.1 核心优势

```java
// 1. 模板方法模式，简化同步器开发
public abstract class CustomSynchronizer extends AbstractQueuedSynchronizer {
    // 只需实现核心方法
    protected boolean tryAcquire(int arg) { /* 子类实现 */ }
    protected boolean tryRelease(int arg) { /* 子类实现 */ }
}

// 2. 高效的FIFO队列
// - 使用CAS操作，避免重量级锁
// - 双向链表，支持快速插入和删除
// - 虚拟头节点，简化边界处理

// 3. 灵活的中断处理
public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);  // 支持中断响应
}

// 4. 支持超时机制
public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(time));
}
```

#### 8.2 性能特点

```java
public class AQSPerformanceFeatures {
    // 1. 无锁算法
    private boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }

    // 2. 适应性自旋
    // 在SMP系统上，短时间自旋比直接阻塞效率更高

    // 3. LockSupport支持
    // 比Object.wait/notify更高效
    LockSupport.park(this);    // 阻塞当前线程
    LockSupport.unpark(thread); // 唤醒指定线程
}
```

### 9. 面试重点

1. **AQS的核心原理和设计思想**
2. **state状态的含义和CAS操作**
3. **独占锁和共享锁的实现差异**
4. **等待队列的数据结构和节点状态**
5. **ReentrantLock、Semaphore等基于AQS的实现**
6. **Condition条件变量的实现原理**
7. **公平锁和非公平锁在AQS中的体现**
8. **如何基于AQS实现自定义同步器**

### 10. 常见面试问题

**Q1: AQS中的state字段有什么作用？**
A: state是同步状态，用CAS保证原子性修改。在不同同步器中含义不同：
- ReentrantLock中表示重入次数
- Semaphore中表示可用许可数
- CountDownLatch中表示倒计时数量

**Q2: 为什么AQS队列是FIFO的？**
A: FIFO保证公平性，避免线程饥饿。先等待的线程先获得锁，符合直觉和公平原则。

**Q3: AQS如何实现可重入锁？**
A: 通过state字段记录重入次数，同时记录当前持有锁的线程。每次重入时state递增，释放时递减，直到state为0才真正释放锁。
