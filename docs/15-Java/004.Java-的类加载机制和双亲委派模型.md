---
title: Java 的类加载机制和双亲委派模型
tags:
  - Java
status: robot
class: Java
slug: java-class-loading-parent-delegation-model
ref:
---

## 核心要点

- **类加载过程**：加载 → 验证 → 准备 → 解析 → 初始化五个阶段
- **双亲委派模型**：子加载器首先委托父加载器加载，保证类的全局唯一性
- **系统类加载器**：Bootstrap → Extension → Application 三层结构
- **自定义类加载器**：通过继承ClassLoader可以实现特殊的加载需求
- **类加载时机**：首次主动使用时触发，包括实例化、访问静态变量等

## 详细解答

### 1. 类加载的生命周期

类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括7个阶段：

```
加载(Loading) → 验证(Verification) → 准备(Preparation) → 解析(Resolution) → 初始化(Initialization) → 使用(Using) → 卸载(Unloading)
```

**其中前5个阶段统称为类加载过程。**

### 2. 类加载过程详解

#### 2.1 加载（Loading）

加载阶段JVM需要完成以下3件事：

```java
public class ClassLoadingDemo {
    // 1. 通过类的全限定名获取二进制字节流
    byte[] classBytes = getClassBytes("com.example.MyClass");

    // 2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
    RuntimeDataStructure runtimeData = parseClassBytes(classBytes);

    // 3. 在内存中生成代表这个类的Class对象
    Class<?> clazz = createClassObject(runtimeData);
}
```

**获取字节流的方式：**
- 从ZIP包中读取（JAR、WAR等）
- 从网络中获取（Applet）
- 运行时计算生成（动态代理）
- 从数据库中读取
- 从文件系统读取（最常见）

#### 2.2 验证（Verification）

确保Class文件的字节流包含的信息符合虚拟机要求，不会危害虚拟机安全。

```java
public class ClassVerification {
    public void verify(byte[] classBytes) {
        // 1. 文件格式验证
        verifyFileFormat(classBytes);
        // 检查魔数、版本号、常量池等

        // 2. 元数据验证
        verifyMetadata(classBytes);
        // 检查类是否有父类、是否实现了抽象方法等

        // 3. 字节码验证
        verifyBytecode(classBytes);
        // 确保程序语义合法、符合逻辑

        // 4. 符号引用验证
        verifySymbolicReferences(classBytes);
        // 确保解析阶段能正常执行
    }
}
```

#### 2.3 准备（Preparation）

为类的静态变量分配内存并设置默认初始值。

```java
public class PreparationDemo {
    // 准备阶段：value = 0（默认值）
    // 初始化阶段：value = 100（显式值）
    public static int value = 100;

    // 准备阶段：finalValue = 100（常量直接赋值）
    public static final int finalValue = 100;

    // 准备阶段：obj = null（引用类型默认值）
    public static Object obj = new Object();
}
```

**默认值对照表：**
```java
boolean → false
byte/short/int → 0
long → 0L
float → 0.0f
double → 0.0d
char → '\u0000'
reference → null
```

#### 2.4 解析（Resolution）

将常量池中的符号引用替换为直接引用。

```java
public class ResolutionDemo {
    // 符号引用："java/lang/Object"
    // 解析后变为直接引用：指向Object类的内存地址
    Object obj = new Object();

    // 方法符号引用："println:(Ljava/lang/String;)V"
    // 解析后变为直接引用：指向println方法的内存地址
    public void test() {
        System.out.println("Hello");
    }
}
```

#### 2.5 初始化（Initialization）

执行类构造器`<clinit>()`方法的过程。

```java
public class InitializationDemo {
    static {
        System.out.println("静态代码块执行");
    }

    // <clinit>()方法由编译器自动收集：
    // 1. 所有静态变量的赋值动作
    // 2. 所有静态代码块
    public static int value = 100;

    // <clinit>()方法不需要显式调用父类构造器
    // 虚拟机保证父类<clinit>()方法先执行
}
```

### 3. 双亲委派模型

#### 3.1 类加载器层次结构

```
Bootstrap ClassLoader（启动类加载器）
    ↑
Extension ClassLoader（扩展类加载器）
    ↑
Application ClassLoader（应用程序类加载器）
    ↑
Custom ClassLoader（自定义类加载器）
```

#### 3.2 各类加载器职责

```java
public class ClassLoaderHierarchy {
    public void demonstrateClassLoaders() {
        // 1. Bootstrap ClassLoader（C++实现，Java中显示为null）
        // 加载<JAVA_HOME>/lib目录下的核心类库
        ClassLoader bootstrap = String.class.getClassLoader();
        System.out.println("String的类加载器: " + bootstrap); // null

        // 2. Extension ClassLoader
        // 加载<JAVA_HOME>/lib/ext目录下的扩展类库
        ClassLoader extension = sun.security.provider.Sun.class.getClassLoader();
        System.out.println("扩展类的加载器: " + extension);

        // 3. Application ClassLoader
        // 加载用户类路径(CLASSPATH)上的类
        ClassLoader application = ClassLoaderHierarchy.class.getClassLoader();
        System.out.println("应用类的加载器: " + application);

        // 验证父子关系
        System.out.println("Application的父加载器: " + application.getParent());
        System.out.println("Extension的父加载器: " + application.getParent().getParent());
    }
}
```

#### 3.3 双亲委派工作流程

```java
public abstract class ClassLoader {
    protected Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException {

        synchronized (getClassLoadingLock(name)) {
            // 1. 检查类是否已经被加载
            Class<?> c = findLoadedClass(name);

            if (c == null) {
                try {
                    // 2. 委托父加载器加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        // 父加载器为null，委托Bootstrap ClassLoader
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父加载器无法加载时，才由自己加载
                }

                if (c == null) {
                    // 3. 父加载器无法加载，自己尝试加载
                    c = findClass(name);
                }
            }

            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
}
```

#### 3.4 双亲委派的优势

```java
public class ParentDelegationAdvantages {
    /**
     * 优势1：避免类的重复加载
     * 如果父加载器已经加载了某个类，子加载器就不会再加载
     */
    public void avoidDuplication() {
        // java.lang.Object只会被Bootstrap ClassLoader加载一次
        Object obj1 = new Object();
        Object obj2 = new Object();
        // obj1和obj2的Class对象是同一个
    }

    /**
     * 优势2：保证Java核心API不被篡改
     * 用户无法替换系统的核心类
     */
    public void securityProtection() {
        // 即使用户定义了java.lang.String类
        // 也会被Bootstrap ClassLoader拦截，加载系统的String类
    }
}
```

### 4. 自定义类加载器

#### 4.1 基本实现

```java
public class CustomClassLoader extends ClassLoader {
    private String classPath;

    public CustomClassLoader(String classPath) {
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // 1. 获取类文件的字节数组
            byte[] classData = getClassData(name);

            // 2. 将字节数组转换为Class对象
            return defineClass(name, classData, 0, classData.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("类加载失败: " + name, e);
        }
    }

    private byte[] getClassData(String className) throws IOException {
        // 将类名转换为文件路径
        String path = classPath + File.separatorChar +
                     className.replace('.', File.separatorChar) + ".class";

        try (InputStream is = new FileInputStream(path);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            byte[] buffer = new byte[4096];
            int bytesNumRead;
            while ((bytesNumRead = is.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        }
    }
}
```

#### 4.2 网络类加载器

```java
public class NetworkClassLoader extends ClassLoader {
    private String baseUrl;

    public NetworkClassLoader(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            String url = baseUrl + "/" + name.replace('.', '/') + ".class";
            byte[] classData = downloadClass(url);
            return defineClass(name, classData, 0, classData.length);
        } catch (Exception e) {
            throw new ClassNotFoundException("无法从网络加载类: " + name, e);
        }
    }

    private byte[] downloadClass(String url) throws IOException {
        try (InputStream is = new URL(url).openStream();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = is.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            return baos.toByteArray();
        }
    }
}
```

#### 4.3 加密类加载器

```java
public class EncryptedClassLoader extends ClassLoader {
    private String key;

    public EncryptedClassLoader(String key) {
        this.key = key;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] encryptedData = loadEncryptedClassData(name);
            byte[] decryptedData = decrypt(encryptedData, key);
            return defineClass(name, decryptedData, 0, decryptedData.length);
        } catch (Exception e) {
            throw new ClassNotFoundException("解密类失败: " + name, e);
        }
    }

    private byte[] decrypt(byte[] encryptedData, String key) {
        // 简单的XOR解密示例
        byte[] keyBytes = key.getBytes();
        byte[] decrypted = new byte[encryptedData.length];

        for (int i = 0; i < encryptedData.length; i++) {
            decrypted[i] = (byte) (encryptedData[i] ^ keyBytes[i % keyBytes.length]);
        }
        return decrypted;
    }
}
```

### 5. 打破双亲委派模型

#### 5.1 SPI机制

Java SPI（Service Provider Interface）打破了双亲委派模型：

```java
public class SPIExample {
    public void demonstrateSPI() {
        // JDBC驱动加载示例
        // DriverManager由Bootstrap ClassLoader加载
        // 但需要加载用户提供的数据库驱动实现类

        // 使用线程上下文类加载器
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();

        // 通过ServiceLoader加载服务提供者
        ServiceLoader<Driver> drivers = ServiceLoader.load(Driver.class, contextClassLoader);

        for (Driver driver : drivers) {
            System.out.println("找到驱动: " + driver.getClass().getName());
        }
    }
}
```

#### 5.2 OSGi模型

OSGi实现了复杂的类加载架构：

```java
public class OSGiClassLoader extends ClassLoader {
    private Bundle bundle;
    private List<ClassLoader> importedPackageLoaders;

    @Override
    protected Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException {

        // 1. 检查是否为java.*包（委托给父加载器）
        if (name.startsWith("java.")) {
            return getParent().loadClass(name);
        }

        // 2. 检查Import-Package
        for (ClassLoader loader : importedPackageLoaders) {
            try {
                return loader.loadClass(name);
            } catch (ClassNotFoundException e) {
                // 继续尝试下一个
            }
        }

        // 3. 检查Bundle内部类
        return findClass(name);
    }
}
```

### 6. 类加载时机

#### 6.1 主动引用（触发初始化）

```java
public class ActiveReference {
    public static void main(String[] args) {
        // 1. 遇到new、getstatic、putstatic、invokestatic指令
        MyClass obj = new MyClass();        // new
        int value = MyClass.staticVar;      // getstatic
        MyClass.staticVar = 10;             // putstatic
        MyClass.staticMethod();             // invokestatic

        // 2. 使用反射调用类
        Class.forName("com.example.MyClass");

        // 3. 初始化子类时，父类先初始化
        ChildClass child = new ChildClass();

        // 4. 虚拟机启动时的主类
        // main方法所在的类

        // 5. JDK 7的动态语言支持
        // MethodHandle解析结果为指定类的方法句柄
    }
}
```

#### 6.2 被动引用（不触发初始化）

```java
public class PassiveReference {
    public static void main(String[] args) {
        // 1. 通过子类引用父类静态字段
        System.out.println(ChildClass.parentStaticVar); // 只初始化父类

        // 2. 通过数组定义引用类
        MyClass[] array = new MyClass[10]; // 不初始化MyClass

        // 3. 引用常量
        System.out.println(MyClass.CONSTANT); // 常量在编译期已确定
    }
}

class ParentClass {
    public static String parentStaticVar = "父类静态变量";
    static {
        System.out.println("父类初始化");
    }
}

class ChildClass extends ParentClass {
    static {
        System.out.println("子类初始化");
    }
}

class MyClass {
    public static final String CONSTANT = "常量";
    static {
        System.out.println("MyClass初始化");
    }
}
```

### 7. 实际应用场景

#### 7.1 热部署实现

```java
public class HotDeploymentManager {
    private Map<String, CustomClassLoader> classLoaders = new ConcurrentHashMap<>();

    public Object createInstance(String className, String classPath) throws Exception {
        // 为每个版本创建新的类加载器
        String key = className + "_" + System.currentTimeMillis();
        CustomClassLoader loader = new CustomClassLoader(classPath);
        classLoaders.put(key, loader);

        Class<?> clazz = loader.loadClass(className);
        return clazz.getDeclaredConstructor().newInstance();
    }

    public void unloadClass(String key) {
        CustomClassLoader loader = classLoaders.remove(key);
        if (loader != null) {
            // 清理引用，等待GC回收
            loader = null;
        }
    }
}
```

#### 7.2 插件系统

```java
public class PluginManager {
    public void loadPlugin(String jarPath) throws Exception {
        // 为每个插件创建独立的类加载器
        URLClassLoader pluginLoader = new URLClassLoader(
            new URL[]{new File(jarPath).toURI().toURL()},
            this.getClass().getClassLoader()
        );

        // 加载插件主类
        Class<?> pluginClass = pluginLoader.loadClass("com.plugin.Main");
        Plugin plugin = (Plugin) pluginClass.getDeclaredConstructor().newInstance();

        // 启动插件
        plugin.start();
    }
}
```

### 总结

Java类加载机制通过双亲委派模型保证了类的唯一性和安全性：

- **类加载过程**：严格按照加载、验证、准备、解析、初始化五个阶段进行
- **双亲委派**：确保核心类库不被篡改，避免类的重复加载
- **自定义加载器**：可以实现特殊需求，如热部署、插件系统等
- **加载时机**：只有在首次主动使用时才触发类的初始化

理解类加载机制对于深入掌握Java虚拟机、实现框架级功能具有重要意义。
