---
title: Java 的垃圾回收器（Serial、Parallel、CMS、G1、ZGC）
tags:
  - Java
  - 垃圾回收
status: robot
class: Java
slug: java-garbage-collectors-serial-parallel-cms-g1-zgc
ref:
---

## 核心要点

- **Serial**：单线程回收器，STW时间长，适用于小型单核应用
- **Parallel**：多线程并行回收器，高吞吐量，适用于后台计算任务
- **CMS**：并发标记清除回收器，低延迟但有内存碎片，已被废弃
- **G1**：分区域低延迟回收器，平衡吞吐量和延迟，适用于大内存应用
- **ZGC**：超低延迟回收器，STW时间稳定在10ms以下，适用于对延迟敏感的应用

## 详细解答

### 1. Serial 垃圾回收器

最古老的垃圾回收器，采用单线程进行垃圾回收。

**工作原理：**
```
应用线程执行 → 暂停所有应用线程(STW) → 单线程GC → 恢复应用线程执行
```

**实现特点：**
```java
// Serial GC的工作模式
public class SerialGC {
    public void collectGarbage() {
        stopAllApplicationThreads(); // Stop The World

        // 新生代：复制算法
        copyingGC(youngGeneration);

        // 老年代：标记-清除算法
        markSweepGC(oldGeneration);

        resumeApplicationThreads(); // 恢复应用线程
    }
}
```

**适用场景：**
- 客户端模式的JVM
- 单核CPU环境
- 内存较小的应用（几十MB到几百MB）
- 对延迟要求不高的应用

**JVM参数配置：**
```bash
# 新生代使用Serial，老年代使用Serial Old
-XX:+UseSerialGC

# 设置新生代大小
-Xmn512m

# 打印GC日志
-XX:+PrintGC
```

### 2. Parallel 垃圾回收器

多线程并行垃圾回收器，JDK 8的默认回收器。

**工作原理：**
```
应用线程执行 → 暂停所有应用线程(STW) → 多线程并行GC → 恢复应用线程执行
```

**实现特点：**
```java
public class ParallelGC {
    private int gcThreads = Runtime.getRuntime().availableProcessors();

    public void collectGarbage() {
        stopAllApplicationThreads();

        // 多线程并行回收
        ExecutorService gcExecutor = Executors.newFixedThreadPool(gcThreads);

        // 新生代：并行复制算法
        parallelCopyingGC(youngGeneration, gcExecutor);

        // 老年代：并行标记-整理算法
        parallelMarkCompactGC(oldGeneration, gcExecutor);

        resumeApplicationThreads();
    }
}
```

**分类：**
- **Parallel Scavenge**：新生代回收器，关注吞吐量
- **Parallel Old**：老年代回收器，使用标记-整理算法

**自适应调节：**
```java
// Parallel GC的自适应策略
public class AdaptiveSizePolicy {
    public void adjustHeapSize() {
        if (gcTime / totalTime > maxGCTimeRatio) {
            increaseHeapSize(); // 增加堆大小
        }

        if (pauseTime > maxPauseGoal) {
            decreaseGenerationSize(); // 减少分代大小
        }
    }
}
```

**JVM参数配置：**
```bash
# 启用Parallel GC
-XX:+UseParallelGC
-XX:+UseParallelOldGC

# 设置GC线程数
-XX:ParallelGCThreads=4

# 设置最大GC停顿时间目标（毫秒）
-XX:MaxGCPauseMillis=200

# 设置吞吐量目标（应用时间/总时间）
-XX:GCTimeRatio=19  # 95%的时间用于应用，5%用于GC
```

### 3. CMS 垃圾回收器（已废弃）

并发标记清除回收器，以获取最短回收停顿时间为目标。

**工作流程：**
```
1. 初始标记（STW）        → 标记GC Roots直接关联的对象
2. 并发标记              → 与应用线程并发执行，标记所有可达对象
3. 重新标记（STW）        → 修正并发标记期间变动的对象
4. 并发清除              → 与应用线程并发执行，清除垃圾对象
```

**实现原理：**
```java
public class CMSCollector {
    public void concurrentMarkSweep() {
        // 1. 初始标记 - STW
        initialMark(); // 很短的停顿

        // 2. 并发标记 - 与应用线程并发
        concurrentMark();

        // 3. 预清理（可选）
        preclean();

        // 4. 重新标记 - STW
        remark(); // 相对较短的停顿

        // 5. 并发清除 - 与应用线程并发
        concurrentSweep();

        // 6. 重置
        reset();
    }
}
```

**主要问题：**
```java
// 1. 内存碎片问题
// CMS使用标记清除算法，产生内存碎片
if (fragmentationRatio > threshold) {
    // 触发Full GC进行内存整理
    serialOldGC(); // 使用Serial Old回收器
}

// 2. 浮动垃圾问题
// 并发清除期间产生的新垃圾无法在本次GC中清除
// 需要预留空间给并发运行的应用线程

// 3. CPU资源竞争
// 并发阶段会占用CPU资源，影响应用性能
```

**JVM参数配置：**
```bash
# 启用CMS（已在JDK 14中移除）
-XX:+UseConcMarkSweepGC

# 设置触发CMS的老年代使用率阈值
-XX:CMSInitiatingOccupancyFraction=75

# 启用并发收集
-XX:+CMSConcurrentMTEnabled

# 设置CMS线程数
-XX:ConcGCThreads=2
```

### 4. G1 垃圾回收器

面向服务端应用的垃圾回收器，JDK 9的默认回收器。

**核心概念：**
```
内存布局：
堆内存被分为若干个大小相等的Region（1MB-32MB）

Region类型：
├── Eden Region      → 新分配对象
├── Survivor Region  → 存活对象
├── Old Region       → 老年代对象
└── Humongous Region → 大对象（超过Region大小50%）
```

**工作流程：**
```java
public class G1Collector {
    public void collectGarbage() {
        // 年轻代收集（Evacuation Pause）
        youngGenCollection();

        // 并发标记周期
        if (needConcurrentCycle()) {
            initialMark();      // 与young GC一起执行
            rootRegionScan();   // 扫描Survivor区的引用
            concurrentMark();   // 并发标记
            remark();          // 最终标记
            cleanup();         // 清理
        }

        // 混合收集（Mixed GC）
        if (needMixedGC()) {
            mixedCollection(); // 收集年轻代+部分老年代
        }
    }
}
```

**记忆集（Remembered Set）：**
```java
// 每个Region都有一个RSet记录指向该Region的引用
public class RememberedSet {
    // 记录从其他Region指向本Region的引用
    private Set<CardTable> crossRegionReferences;

    public void recordReference(Object from, Object to) {
        if (inDifferentRegion(from, to)) {
            crossRegionReferences.add(getCard(from));
        }
    }
}
```

**优势特点：**
- 可预测的停顿时间
- 没有内存碎片
- 适用于大堆内存（6GB+）
- 并发与并行结合

**JVM参数配置：**
```bash
# 启用G1
-XX:+UseG1GC

# 设置最大停顿时间目标
-XX:MaxGCPauseMillis=100

# 设置Region大小
-XX:G1HeapRegionSize=16m

# 设置并发线程数
-XX:ConcGCThreads=2

# 设置混合GC的触发阈值
-XX:G1MixedGCLiveThresholdPercent=85
```

### 5. ZGC 垃圾回收器

超低延迟垃圾回收器，JDK 11引入的实验性功能。

**核心技术：**
```java
// 1. 着色指针（Colored Pointers）
// 在64位指针中嵌入标记信息
public class ColoredPointer {
    // 64位指针布局：
    // [63-48] 未使用
    // [47-44] 颜色信息（标记、重定位等）
    // [43-0]  实际地址

    private static final long MARKED_MASK = 1L << 44;
    private static final long REMAPPED_MASK = 1L << 45;

    public boolean isMarked(long pointer) {
        return (pointer & MARKED_MASK) != 0;
    }
}

// 2. 内存多重映射
// 同一块物理内存映射到多个虚拟地址
public class MultiMapping {
    private long markedView;    // 标记视图
    private long relocatedView; // 重定位视图
    private long remappedView;  // 重映射视图
}
```

**并发回收过程：**
```java
public class ZGCollector {
    public void collectGarbage() {
        // 1. 并发标记
        concurrentMark(); // 标记可达对象

        // 2. 并发重定位集选择
        selectRelocationSet(); // 选择要清理的区域

        // 3. 并发重定位
        concurrentRelocate(); // 移动对象，更新引用

        // 所有阶段都与应用线程并发执行
        // STW时间仅为根扫描，通常<10ms
    }
}
```

**内存管理：**
```java
// ZPage：ZGC的内存管理单元
public class ZPage {
    private static final int SMALL = 2 * 1024 * 1024;     // 2MB
    private static final int MEDIUM = 32 * 1024 * 1024;   // 32MB
    private static final int LARGE = Integer.MAX_VALUE;    // 大对象

    public ZPage allocatePage(int size) {
        if (size <= SMALL) return new SmallZPage();
        if (size <= MEDIUM) return new MediumZPage();
        return new LargeZPage();
    }
}
```

**JVM参数配置：**
```bash
# 启用ZGC（JDK 11+）
-XX:+UnlockExperimentalVMOptions
-XX:+UseZGC

# 设置最大堆大小
-Xmx32g

# 启用分代ZGC（JDK 17+）
-XX:+UseZGC
-XX:+UnlockExperimentalVMOptions
-XX:+UseZGCGenerational
```

### 6. 垃圾回收器选择指南

**根据应用特点选择：**
```java
public GarbageCollector selectGC(ApplicationProfile profile) {
    if (profile.heapSize < 100 * MB) {
        return SerialGC; // 小堆，单核环境
    }

    if (profile.latencyRequirement == ULTRA_LOW) {
        return ZGC; // 超低延迟要求
    }

    if (profile.latencyRequirement == LOW && profile.heapSize > 6 * GB) {
        return G1GC; // 大堆，低延迟要求
    }

    if (profile.throughputPriority == HIGH) {
        return ParallelGC; // 高吞吐量要求
    }

    return G1GC; // 默认选择
}
```

### 7. 性能对比

| 回收器 | STW时间 | 吞吐量 | 内存开销 | 适用场景 |
|--------|---------|---------|----------|----------|
| Serial | 长 | 低 | 最小 | 小型应用 |
| Parallel | 中 | 高 | 小 | 批处理应用 |
| CMS | 短 | 中 | 中 | 低延迟应用（已废弃） |
| G1 | 可控 | 中高 | 中 | 大内存应用 |
| ZGC | 极短 | 中 | 大 | 超低延迟应用 |

### 8. 实际应用示例

**高吞吐量后台处理：**
```bash
# 使用Parallel GC
java -XX:+UseParallelGC \
     -XX:ParallelGCThreads=8 \
     -XX:MaxGCPauseMillis=100 \
     -Xms4g -Xmx4g \
     BatchProcessingApp
```

**Web应用服务：**
```bash
# 使用G1 GC
java -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=50 \
     -XX:G1HeapRegionSize=16m \
     -Xms8g -Xmx8g \
     WebApplication
```

**实时交易系统：**
```bash
# 使用ZGC
java -XX:+UseZGC \
     -XX:+UnlockExperimentalVMOptions \
     -Xms16g -Xmx16g \
     TradingSystem
```

### 总结

选择垃圾回收器需要综合考虑：
- **应用特点**：延迟敏感 vs 吞吐量优先
- **内存大小**：小堆 vs 大堆
- **硬件环境**：单核 vs 多核
- **业务场景**：批处理 vs 在线服务

现代应用推荐使用G1或ZGC，它们在大多数场景下都能提供良好的性能表现。
