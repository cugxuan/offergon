---
title: Java 的 happens-before 规则
tags:
  - Java
status: robot
class: Java
slug: java-happens-before-rules
ref:
---

## 要点提炼

- **核心定义**：happens-before是JMM中确定内存可见性的核心规则
- **基本规则**：8条基本规则：程序顺序、监视器锁、volatile、final、线程启动/终止等
- **传递性**：A happens-before B，B happens-before C，则A happens-before C
- **实际作用**：建立正确的同步关系，避免数据竞争和内存可见性问题

## 详细解答

### 1. happens-before概念

#### 1.1 定义与意义

```java
/*
happens-before关系的定义：
如果一个操作A happens-before 操作B，那么操作A的执行结果对操作B可见，
且操作A的执行顺序在操作B之前。

happens-before关系的作用：
1. 定义内存可见性的规则
2. 禁止某些重排序
3. 建立线程间的同步关系
*/

public class HappensBeforeExample {
    private int data = 0;
    private volatile boolean flag = false;

    // 线程1执行
    public void writer() {
        data = 42;          // 操作1
        flag = true;        // 操作2（volatile写）
    }

    // 线程2执行
    public void reader() {
        if (flag) {         // 操作3（volatile读）
            int value = data; // 操作4，必定读取到42
        }
    }

    /*
    happens-before关系链：
    1. 操作1 happens-before 操作2（程序顺序规则）
    2. 操作2 happens-before 操作3（volatile规则）
    3. 操作3 happens-before 操作4（程序顺序规则）

    通过传递性：操作1 happens-before 操作4
    因此操作4能够看到操作1的结果
    */
}
```

#### 1.2 与内存可见性的关系

```java
public class MemoryVisibilityExample {
    private int x = 0;
    private int y = 0;

    // 没有happens-before关系的情况
    public void noHappensBeforeExample() {
        // 线程1
        new Thread(() -> {
            x = 1;  // 写操作1
            y = 2;  // 写操作2
        }).start();

        // 线程2
        new Thread(() -> {
            int a = y;  // 读操作1
            int b = x;  // 读操作2
            // 可能的结果：a=2, b=0（由于重排序和缓存不一致）
            System.out.println("a=" + a + ", b=" + b);
        }).start();
    }

    // 建立happens-before关系
    private volatile boolean ready = false;

    public void withHappensBeforeExample() {
        // 线程1
        new Thread(() -> {
            x = 1;          // 操作1
            y = 2;          // 操作2
            ready = true;   // 操作3（volatile写）
        }).start();

        // 线程2
        new Thread(() -> {
            if (ready) {    // 操作4（volatile读）
                int a = y;  // 操作5，一定能看到y=2
                int b = x;  // 操作6，一定能看到x=1
                System.out.println("a=" + a + ", b=" + b);
            }
        }).start();
    }
}
```

### 2. 八条happens-before规则

#### 2.1 程序顺序规则（Program Order Rule）

```java
public class ProgramOrderRule {
    private int a = 0;
    private int b = 0;

    public void demonstrateRule() {
        a = 1;    // 操作1
        b = 2;    // 操作2
        int c = a + b;  // 操作3

        /*
        程序顺序规则：
        在单个线程中，按照程序代码顺序：
        - 操作1 happens-before 操作2
        - 操作2 happens-before 操作3
        - 操作1 happens-before 操作3（传递性）

        注意：这不意味着禁止重排序，而是保证重排序不会影响单线程的语义
        */
    }

    // 重排序的例子
    public void reorderingExample() {
        int x = 1;      // 可能被重排序
        int y = 2;      // 可能被重排序
        int z = x + y;  // 不能重排序到x、y赋值之前

        // 编译器可能重排序为：
        // int y = 2;
        // int x = 1;
        // int z = x + y;
    }
}
```

#### 2.2 监视器锁规则（Monitor Lock Rule）

```java
public class MonitorLockRule {
    private int sharedData = 0;
    private final Object lock = new Object();

    // 线程1
    public void thread1() {
        synchronized (lock) {
            sharedData = 42;  // 操作1（在锁内）
        }  // 解锁操作2
    }

    // 线程2
    public void thread2() {
        synchronized (lock) {  // 加锁操作3
            int value = sharedData;  // 操作4，一定能看到42
            System.out.println("value = " + value);
        }
    }

    /*
    监视器锁规则：
    同一个锁的解锁操作 happens-before 该锁的加锁操作

    happens-before关系：
    操作2（解锁）happens-before 操作3（加锁）

    通过程序顺序规则和传递性：
    操作1 happens-before 操作4
    */

    // 使用不同锁的情况
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void differentLocksExample() {
        // 线程1
        new Thread(() -> {
            synchronized (lock1) {
                sharedData = 100;
            }
        }).start();

        // 线程2
        new Thread(() -> {
            synchronized (lock2) {  // 不同的锁！
                int value = sharedData;  // 可能看不到最新值
            }
        }).start();
    }
}
```

#### 2.3 volatile变量规则（Volatile Variable Rule）

```java
public class VolatileRule {
    private int data = 0;
    private volatile boolean flag = false;

    // 线程1
    public void writer() {
        data = 42;          // 操作1
        flag = true;        // 操作2（volatile写）
    }

    // 线程2
    public void reader() {
        if (flag) {         // 操作3（volatile读）
            int value = data;  // 操作4，必定读到42
        }
    }

    /*
    volatile规则：
    对volatile变量的写操作 happens-before 后续对该变量的读操作

    happens-before关系：
    操作2（volatile写）happens-before 操作3（volatile读）

    通过程序顺序规则和传递性：
    操作1 happens-before 操作4
    */

    // 多个volatile变量
    private volatile int v1 = 0;
    private volatile int v2 = 0;
    private int normalVar = 0;

    public void multipleVolatileExample() {
        // 线程1
        new Thread(() -> {
            normalVar = 100;   // 操作1
            v1 = 1;           // 操作2（volatile写）
            v2 = 2;           // 操作3（volatile写）
        }).start();

        // 线程2
        new Thread(() -> {
            int a = v2;       // 操作4（volatile读）
            int b = v1;       // 操作5（volatile读）
            int c = normalVar; // 操作6

            // 操作2 happens-before 操作4
            // 但操作3与操作5之间没有直接的happens-before关系
            // 不过通过程序顺序规则：操作1 happens-before 操作3
            // 如果a=2，那么c=100（因为操作3 happens-before 操作4）
        }).start();
    }
}
```

#### 2.4 线程启动规则（Thread Start Rule）

```java
public class ThreadStartRule {
    private int data = 0;

    public void demonstrateRule() {
        data = 42;        // 操作1

        Thread thread = new Thread(() -> {
            int value = data;  // 操作3，必定读到42
            System.out.println("value = " + value);
        });

        thread.start();   // 操作2（线程启动）
    }

    /*
    线程启动规则：
    Thread.start()方法的调用 happens-before 该线程中的任何操作

    happens-before关系：
    操作1 happens-before 操作2（程序顺序规则）
    操作2 happens-before 操作3（线程启动规则）
    操作1 happens-before 操作3（传递性）
    */

    // 多个线程启动
    public void multipleThreadsExample() {
        data = 100;  // 操作1

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1: " + data);  // 能看到100
        });

        Thread t2 = new Thread(() -> {
            System.out.println("Thread 2: " + data);  // 能看到100
        });

        t1.start();  // 操作2
        t2.start();  // 操作3

        // 每个start()都与对应线程的操作建立happens-before关系
    }
}
```

#### 2.5 线程终止规则（Thread Termination Rule）

```java
public class ThreadTerminationRule {
    private int result = 0;

    public void demonstrateRule() throws InterruptedException {
        Thread thread = new Thread(() -> {
            // 一些计算
            for (int i = 0; i < 1000; i++) {
                result += i;  // 操作1
            }
            // 线程即将结束，操作2
        });

        thread.start();
        thread.join();    // 操作3（等待线程终止）

        System.out.println("result = " + result);  // 操作4，能看到最终结果
    }

    /*
    线程终止规则：
    线程中的任何操作 happens-before 其他线程检测到该线程已经终止

    检测终止的方式：
    1. Thread.join()方法返回
    2. Thread.isAlive()返回false

    happens-before关系：
    操作1 happens-before 操作3（线程终止规则）
    操作3 happens-before 操作4（程序顺序规则）
    操作1 happens-before 操作4（传递性）
    */

    // 使用isAlive()检测
    public void isAliveExample() throws InterruptedException {
        Thread thread = new Thread(() -> {
            result = 999;  // 操作1
        });

        thread.start();

        // 忙等待（不推荐，仅作演示）
        while (thread.isAlive()) {
            Thread.sleep(1);
        }

        System.out.println("result = " + result);  // 能看到999
    }
}
```

#### 2.6 线程中断规则（Thread Interruption Rule）

```java
public class ThreadInterruptionRule {
    private int data = 0;

    public void demonstrateRule() throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                data = 42;  // 操作1
                Thread.sleep(1000);  // 可能被中断
            } catch (InterruptedException e) {
                // 线程被中断
                data = 100;  // 操作2
            }
        });

        thread.start();
        Thread.sleep(100);  // 确保线程开始执行
        thread.interrupt();  // 操作3（中断线程）

        thread.join();
        System.out.println("data = " + data);  // 能看到最新值
    }

    /*
    线程中断规则：
    对线程interrupt()方法的调用 happens-before 被中断线程检测到中断事件

    检测中断的方式：
    1. InterruptedException异常抛出
    2. Thread.interrupted()返回true
    3. Thread.isInterrupted()返回true
    */
}
```

#### 2.7 对象终结规则（Finalizer Rule）

```java
public class FinalizerRule {
    private int data = 0;

    // 构造函数
    public FinalizerRule() {
        data = 42;  // 操作1
    }

    // finalize方法
    @Override
    protected void finalize() throws Throwable {
        System.out.println("data = " + data);  // 操作2，能看到42
        super.finalize();
    }

    /*
    对象终结规则：
    对象的构造函数结束 happens-before 该对象的finalize()方法开始

    注意：
    1. finalize()方法已被弃用
    2. 不要依赖finalize()进行重要的清理工作
    3. 使用try-with-resources或显式的close()方法
    */

    public static void demonstrateRule() {
        FinalizerRule obj = new FinalizerRule();
        obj = null;  // 使对象可被回收
        System.gc(); // 建议垃圾回收（不保证立即执行）
    }
}
```

#### 2.8 传递性规则（Transitivity Rule）

```java
public class TransitivityRule {
    private int a = 0;
    private int b = 0;
    private volatile boolean flag1 = false;
    private volatile boolean flag2 = false;

    public void demonstrateTransitivity() {
        // 线程1
        new Thread(() -> {
            a = 1;           // 操作1
            flag1 = true;    // 操作2（volatile写）
        }).start();

        // 线程2
        new Thread(() -> {
            if (flag1) {     // 操作3（volatile读）
                b = 2;       // 操作4
                flag2 = true; // 操作5（volatile写）
            }
        }).start();

        // 线程3
        new Thread(() -> {
            if (flag2) {     // 操作6（volatile读）
                int valueA = a;  // 操作7，必定读到1
                int valueB = b;  // 操作8，必定读到2
                System.out.println("a=" + valueA + ", b=" + valueB);
            }
        }).start();

        /*
        传递性规则：
        如果A happens-before B，且B happens-before C，
        那么A happens-before C

        happens-before关系链：
        1. 操作1 happens-before 操作2（程序顺序）
        2. 操作2 happens-before 操作3（volatile规则）
        3. 操作3 happens-before 操作4（程序顺序）
        4. 操作4 happens-before 操作5（程序顺序）
        5. 操作5 happens-before 操作6（volatile规则）
        6. 操作6 happens-before 操作7（程序顺序）

        通过传递性：
        操作1 happens-before 操作7
        操作4 happens-before 操作8
        */
    }
}
```

### 3. happens-before的实际应用

#### 3.1 生产者-消费者模式

```java
public class ProducerConsumerExample {
    private String data = null;
    private volatile boolean ready = false;

    // 生产者
    public void producer() {
        String producedData = produceData();  // 操作1
        data = producedData;                  // 操作2
        ready = true;                         // 操作3（volatile写）
    }

    // 消费者
    public void consumer() {
        if (ready) {                          // 操作4（volatile读）
            String consumedData = data;       // 操作5，必定非null
            processData(consumedData);        // 操作6
        }
    }

    /*
    happens-before保证：
    操作2 happens-before 操作5
    因此消费者读取到的data不会是null
    */

    private String produceData() {
        return "produced data";
    }

    private void processData(String data) {
        System.out.println("Processing: " + data);
    }
}
```

#### 3.2 双重检查锁定单例

```java
public class SingletonExample {
    private volatile static SingletonExample instance;
    private int value = 0;

    private SingletonExample() {
        value = 42;  // 操作1（构造函数中的赋值）
    }

    public static SingletonExample getInstance() {
        if (instance == null) {                    // 操作2（第一次检查）
            synchronized (SingletonExample.class) {
                if (instance == null) {            // 操作3（第二次检查）
                    instance = new SingletonExample(); // 操作4（volatile写）
                }
            }
        }
        return instance;  // 操作5（读取）
    }

    public int getValue() {
        return value;  // 操作6
    }

    /*
    happens-before关系：
    1. 操作1 happens-before 操作4（对象构造完成后才赋值给instance）
    2. 操作4 happens-before 操作5（volatile规则）
    3. 操作1 happens-before 操作6（传递性）

    因此调用getValue()时能够看到正确初始化的value值
    */
}
```

#### 3.3 安全发布对象

```java
public class SafePublicationExample {
    private final List<String> list;
    private volatile boolean initialized = false;

    public SafePublicationExample() {
        list = new ArrayList<>();
        list.add("item1");    // 操作1
        list.add("item2");    // 操作2
        initialized = true;   // 操作3（volatile写）
    }

    public List<String> getList() {
        if (initialized) {    // 操作4（volatile读）
            return list;      // 操作5，返回完全初始化的list
        }
        return Collections.emptyList();
    }

    /*
    happens-before关系：
    操作1、操作2 happens-before 操作3（程序顺序）
    操作3 happens-before 操作4（volatile规则）
    操作1、操作2 happens-before 操作5（传递性）

    确保返回的list是完全初始化的
    */

    // 使用final字段的安全发布
    public static class FinalFieldExample {
        private final int value;
        private final List<String> list;

        public FinalFieldExample() {
            value = 42;                    // 操作1
            list = new ArrayList<>();
            list.add("data");             // 操作2
            // 构造函数结束，操作3
        }

        /*
        final字段规则：
        构造函数内对final字段的写入 happens-before
        构造函数结束后对该对象的引用

        因此其他线程看到这个对象时，final字段已经正确初始化
        */
    }
}
```

### 4. 常见错误与陷阱

#### 4.1 缺少同步的错误

```java
public class UnsynchronizedExample {
    private boolean ready = false;  // 不是volatile
    private int data = 0;

    // 错误示例：没有建立happens-before关系
    public void incorrectExample() {
        // 线程1
        new Thread(() -> {
            data = 42;      // 操作1
            ready = true;   // 操作2
        }).start();

        // 线程2
        new Thread(() -> {
            if (ready) {    // 操作3，可能永远看不到true
                System.out.println(data);  // 操作4，可能看不到42
            }
        }).start();

        /*
        问题：
        1. 操作2和操作3之间没有happens-before关系
        2. 线程2可能永远看不到ready=true
        3. 即使看到ready=true，也可能看不到data=42
        */
    }

    // 正确示例1：使用volatile
    private volatile boolean volatileReady = false;

    public void correctExample1() {
        // 线程1
        new Thread(() -> {
            data = 42;              // 操作1
            volatileReady = true;   // 操作2（volatile写）
        }).start();

        // 线程2
        new Thread(() -> {
            if (volatileReady) {    // 操作3（volatile读）
                System.out.println(data);  // 操作4，必定看到42
            }
        }).start();
    }

    // 正确示例2：使用synchronized
    private final Object lock = new Object();

    public void correctExample2() {
        // 线程1
        new Thread(() -> {
            synchronized (lock) {
                data = 42;      // 操作1
                ready = true;   // 操作2
            }  // 操作3（解锁）
        }).start();

        // 线程2
        new Thread(() -> {
            synchronized (lock) {  // 操作4（加锁）
                if (ready) {
                    System.out.println(data);  // 操作5，必定看到42
                }
            }
        }).start();
    }
}
```

#### 4.2 误解happens-before的含义

```java
public class MisunderstandingExample {
    private int x = 0;
    private int y = 0;
    private volatile boolean flag = false;

    // 误解：认为volatile能保证所有操作的顺序
    public void misunderstanding() {
        // 线程1
        new Thread(() -> {
            x = 1;          // 操作1
            flag = true;    // 操作2（volatile写）
            y = 2;          // 操作3
        }).start();

        // 线程2
        new Thread(() -> {
            if (flag) {     // 操作4（volatile读）
                int a = x;  // 操作5，必定看到x=1
                int b = y;  // 操作6，可能看不到y=2！
            }
        }).start();

        /*
        正确理解：
        1. 操作1 happens-before 操作5（通过volatile规则和传递性）
        2. 但操作3和操作6之间没有happens-before关系
        3. 操作3可能在操作4之后执行，导致操作6看不到y=2
        */
    }

    // 正确的做法：确保所有写操作都在volatile写之前
    public void correctApproach() {
        // 线程1
        new Thread(() -> {
            x = 1;          // 操作1
            y = 2;          // 操作2
            flag = true;    // 操作3（volatile写）
        }).start();

        // 线程2
        new Thread(() -> {
            if (flag) {     // 操作4（volatile读）
                int a = x;  // 操作5，必定看到x=1
                int b = y;  // 操作6，必定看到y=2
            }
        }).start();
    }
}
```

### 5. 性能考虑

#### 5.1 happens-before的开销

```java
public class PerformanceConsiderations {
    private int normalField = 0;
    private volatile int volatileField = 0;
    private final Object lock = new Object();

    // 最快：普通字段访问（但不保证可见性）
    public void normalAccess() {
        normalField = 42;
        int value = normalField;
    }

    // 中等：volatile字段访问
    public void volatileAccess() {
        volatileField = 42;  // 内存屏障开销
        int value = volatileField;
    }

    // 最慢：synchronized访问
    public void synchronizedAccess() {
        synchronized (lock) {
            normalField = 42;
            int value = normalField;
        }
    }

    /*
    性能排序（从快到慢）：
    1. 普通字段访问
    2. volatile字段访问
    3. synchronized访问
    4. Lock接口访问

    选择原则：
    - 只需要可见性：使用volatile
    - 需要原子性：使用synchronized或Lock
    - 性能敏感且能保证安全：使用普通字段
    */
}
```

### 6. 最佳实践

#### 6.1 如何正确使用happens-before

```java
public class BestPractices {

    // 1. 状态标志使用volatile
    private volatile boolean shutdown = false;

    public void useVolatileForFlags() {
        // 控制线程
        new Thread(() -> {
            shutdown = true;  // volatile写，立即可见
        }).start();

        // 工作线程
        while (!shutdown) {   // volatile读，能及时看到变化
            doWork();
        }
    }

    // 2. 对象发布使用volatile
    private volatile Configuration config;

    public void useVolatileForPublication() {
        // 更新线程
        new Thread(() -> {
            Configuration newConfig = loadConfiguration();
            config = newConfig;  // 安全发布
        }).start();

        // 使用线程
        Configuration currentConfig = config;
        if (currentConfig != null) {
            currentConfig.use();  // 安全使用
        }
    }

    // 3. 复杂同步使用synchronized
    private final List<String> items = new ArrayList<>();

    public synchronized void addItem(String item) {
        items.add(item);
    }

    public synchronized List<String> getItems() {
        return new ArrayList<>(items);
    }

    // 4. 生产者-消费者使用BlockingQueue
    private final BlockingQueue<String> queue = new LinkedBlockingQueue<>();

    public void producer() throws InterruptedException {
        String item = produceItem();
        queue.put(item);  // 内置同步机制
    }

    public void consumer() throws InterruptedException {
        String item = queue.take();  // 内置同步机制
        processItem(item);
    }

    // 辅助方法
    private void doWork() { /* ... */ }
    private Configuration loadConfiguration() { return new Configuration(); }
    private String produceItem() { return "item"; }
    private void processItem(String item) { /* ... */ }

    static class Configuration {
        public void use() { /* ... */ }
    }
}
```

### 7. 面试重点

1. **happens-before的定义和作用**
2. **8条基本的happens-before规则**
3. **传递性规则的应用**
4. **volatile变量的happens-before语义**
5. **synchronized的happens-before语义**
6. **线程启动和终止的happens-before关系**
7. **如何通过happens-before避免数据竞争**
8. **happens-before与重排序的关系**

### 8. 常见面试问题

**Q1: happens-before和时间顺序是一回事吗？**
A: 不是。happens-before是逻辑上的先后关系，不代表时间上的先后。它主要用于确保内存可见性，而不是执行时间顺序。

**Q2: volatile变量的happens-before语义是什么？**
A: 对volatile变量的写操作happens-before后续对该变量的读操作。这确保了写操作的结果对读操作可见。

**Q3: 如何利用happens-before规则避免数据竞争？**
A: 通过建立正确的happens-before关系，确保对共享变量的写操作在读操作之前可见。可以使用volatile、synchronized、或其他同步机制来建立这种关系。

**Q4: happens-before的传递性如何应用？**
A: 如果A happens-before B，B happens-before C，则A happens-before C。这允许我们通过中间变量（如volatile标志）来建立不同操作之间的可见性关系。
