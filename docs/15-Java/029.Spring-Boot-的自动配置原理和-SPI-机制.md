---
title: Spring Boot 的自动配置原理和 SPI 机制
tags:
  - Java
status: robot
class: Java
slug: spring-boot-auto-configuration-spi-mechanism
ref:
---

## 核心要点提炼

**Spring Boot自动配置的核心机制：**
- `@EnableAutoConfiguration` 注解触发自动配置
- 通过 SPI 机制加载 META-INF/spring.factories 中的配置类
- 条件注解控制配置类的生效条件
- 配置属性绑定实现外部化配置

## 详细回答

### 1. Spring Boot 自动配置原理

#### 1.1 自动配置的触发机制

Spring Boot 自动配置的入口是 `@SpringBootApplication` 注解，它包含了 `@EnableAutoConfiguration` 注解：

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// @SpringBootApplication 包含的关键注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration  // 关键注解
@ComponentScan
public @interface SpringBootApplication {
    // ...
}
```

#### 1.2 @EnableAutoConfiguration 的工作原理

`@EnableAutoConfiguration` 通过 `@Import` 注解导入 `AutoConfigurationImportSelector`：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)  // 核心导入
public @interface EnableAutoConfiguration {
    // ...
}
```

`AutoConfigurationImportSelector` 的核心方法：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector {

    @Override
    public String[] selectImports(AnnotationMetadata annotationMetadata) {
        if (!isEnabled(annotationMetadata)) {
            return NO_IMPORTS;
        }
        // 1. 获取自动配置元数据
        AutoConfigurationMetadata autoConfigurationMetadata =
            AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);

        // 2. 获取自动配置类的候选列表
        AutoConfigurationEntry autoConfigurationEntry =
            getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);

        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
    }

    protected AutoConfigurationEntry getAutoConfigurationEntry(
            AutoConfigurationMetadata autoConfigurationMetadata,
            AnnotationMetadata annotationMetadata) {

        if (!isEnabled(annotationMetadata)) {
            return EMPTY_ENTRY;
        }

        AnnotationAttributes attributes = getAttributes(annotationMetadata);

        // 3. 通过 SPI 加载候选配置类
        List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);

        // 4. 去重
        configurations = removeDuplicates(configurations);

        // 5. 处理排除
        Set<String> exclusions = getExclusions(annotationMetadata, attributes);
        checkExcludedClasses(configurations, exclusions);
        configurations.removeAll(exclusions);

        // 6. 过滤（条件匹配）
        configurations = filter(configurations, autoConfigurationMetadata);

        // 7. 触发事件
        fireAutoConfigurationImportEvents(configurations, exclusions);

        return new AutoConfigurationEntry(configurations, exclusions);
    }
}
```

### 2. SPI 机制详解

#### 2.1 Java SPI 基础

SPI（Service Provider Interface）是 Java 提供的一种服务发现机制：

```java
// 1. 定义服务接口
public interface DatabaseDriver {
    void connect(String url);
}

// 2. 实现服务提供者
public class MySQLDriver implements DatabaseDriver {
    @Override
    public void connect(String url) {
        System.out.println("Connecting to MySQL: " + url);
    }
}

// 3. 在 META-INF/services/com.example.DatabaseDriver 文件中声明实现类
// com.example.MySQLDriver

// 4. 使用 ServiceLoader 加载服务
ServiceLoader<DatabaseDriver> drivers = ServiceLoader.load(DatabaseDriver.class);
for (DatabaseDriver driver : drivers) {
    driver.connect("jdbc:mysql://localhost:3306/test");
}
```

#### 2.2 Spring Boot 中的 SPI 应用

Spring Boot 使用类似 SPI 的机制来加载自动配置类：

```java
// SpringFactoriesLoader 类
public final class SpringFactoriesLoader {

    public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";

    public static <T> List<T> loadFactories(Class<T> factoryClass,
                                          @Nullable ClassLoader classLoader) {
        ClassLoader classLoaderToUse = classLoader;
        if (classLoaderToUse == null) {
            classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
        }

        // 1. 加载工厂类名称
        List<String> factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);

        // 2. 实例化工厂类
        List<T> result = new ArrayList<>(factoryNames.size());
        for (String factoryName : factoryNames) {
            result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));
        }

        // 3. 排序
        AnnotationAwareOrderComparator.sort(result);
        return result;
    }

    public static List<String> loadFactoryNames(Class<?> factoryClass,
                                              @Nullable ClassLoader classLoader) {
        String factoryClassName = factoryClass.getName();

        // 从 META-INF/spring.factories 文件中加载配置
        return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
    }
}
```

#### 2.3 spring.factories 文件示例

```properties
# META-INF/spring.factories 文件内容示例
# 自动配置类
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration

# 应用监听器
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener

# 初始化器
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer
```

### 3. 条件注解机制

#### 3.1 常用条件注解

```java
// 示例自动配置类
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)  // 类路径下存在 RedisOperations 类
@EnableConfigurationProperties(RedisProperties.class)  // 启用配置属性
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean(name = "redisTemplate")  // 不存在名为 redisTemplate 的 Bean
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)  // 存在唯一的 RedisConnectionFactory
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Bean
    @ConditionalOnMissingBean  // 不存在该类型的 Bean
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
}
```

#### 3.2 条件注解的实现原理

```java
// 条件注解的处理器
public class OnClassCondition extends FilteringSpringBootCondition {

    @Override
    protected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,
                                                  AutoConfigurationMetadata autoConfigurationMetadata) {

        ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length];
        for (int i = 0; i < outcomes.length; i++) {
            String autoConfigurationClass = autoConfigurationClasses[i];

            if (autoConfigurationClass != null) {
                // 检查配置的条件是否满足
                Set<String> onClasses = autoConfigurationMetadata
                    .getSet(autoConfigurationClass, "ConditionalOnClass");
                outcomes[i] = getOutcome(onClasses, ClassNameFilter.PRESENT);
            }
        }
        return outcomes;
    }

    private ConditionOutcome getOutcome(Set<String> requiredClassNames,
                                      ClassNameFilter classNameFilter) {

        List<String> missing = filter(requiredClassNames, classNameFilter, getClass().getClassLoader());

        if (!missing.isEmpty()) {
            return ConditionOutcome.noMatch(
                ConditionMessage.forCondition(ConditionalOnClass.class)
                    .didNotFind("required class", "required classes")
                    .items(Style.QUOTE, missing));
        }

        return ConditionOutcome.match(
            ConditionMessage.forCondition(ConditionalOnClass.class)
                .found("required class", "required classes")
                .items(Style.QUOTE, requiredClassNames));
    }
}
```

### 4. 配置属性绑定

#### 4.1 @ConfigurationProperties 注解

```java
// 配置属性类
@ConfigurationProperties(prefix = "spring.redis")
public class RedisProperties {

    private String host = "localhost";
    private int port = 6379;
    private String password;
    private int timeout;
    private Jedis jedis = new Jedis();
    private Lettuce lettuce = new Lettuce();

    // getter 和 setter 方法
    public String getHost() { return this.host; }
    public void setHost(String host) { this.host = host; }

    public static class Jedis {
        private Pool pool = new Pool();

        public static class Pool {
            private int maxActive = 10;
            private int maxIdle = 10;
            private int minIdle = 0;

            // getter 和 setter
        }
    }
}
```

#### 4.2 配置绑定的实现

```java
// ConfigurationPropertiesBindingPostProcessor
@Component
public class ConfigurationPropertiesBindingPostProcessor
        implements BeanPostProcessor, ApplicationContextAware {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {

        ConfigurationProperties annotation = AnnotationUtils
            .findAnnotation(bean.getClass(), ConfigurationProperties.class);

        if (annotation != null) {
            // 绑定配置属性
            bind(bean, annotation);
        }
        return bean;
    }

    private void bind(Object bean, ConfigurationProperties annotation) {
        Binder binder = Binder.get(this.environment);

        // 获取属性前缀
        String prefix = annotation.prefix();

        // 绑定属性
        binder.bind(prefix, Bindable.ofInstance(bean));
    }
}
```

### 5. 自动配置的执行时序

```java
// Spring Boot 启动时的配置加载顺序
public class SpringApplication {

    public ConfigurableApplicationContext run(String... args) {

        // 1. 创建应用上下文
        ConfigurableApplicationContext context = createApplicationContext();

        // 2. 准备上下文
        prepareContext(context, environment, listeners, applicationArguments, printedBanner);

        // 3. 刷新上下文（这里会触发自动配置）
        refreshContext(context);

        // 4. 后续处理
        afterRefresh(context, applicationArguments);

        return context;
    }

    private void prepareContext(ConfigurableApplicationContext context, ...) {

        // 加载配置源
        Set<Object> sources = getAllSources();

        // 注册配置类（包含 @EnableAutoConfiguration）
        load(context, sources.toArray(new Object[0]));
    }
}
```

### 6. 自定义自动配置

#### 6.1 创建自动配置类

```java
// 自定义自动配置类
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(MyService.class)
@ConditionalOnProperty(prefix = "myservice", name = "enabled", havingValue = "true", matchIfMissing = true)
@EnableConfigurationProperties(MyServiceProperties.class)
public class MyServiceAutoConfiguration {

    @Autowired
    private MyServiceProperties properties;

    @Bean
    @ConditionalOnMissingBean
    public MyService myService() {
        MyService service = new MyService();
        service.setHost(properties.getHost());
        service.setPort(properties.getPort());
        return service;
    }
}

// 配置属性类
@ConfigurationProperties(prefix = "myservice")
public class MyServiceProperties {
    private String host = "localhost";
    private int port = 8080;
    private boolean enabled = true;

    // getter 和 setter
}
```

#### 6.2 注册自动配置

```properties
# 在 META-INF/spring.factories 中注册
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.MyServiceAutoConfiguration
```

### 7. 实际应用场景

#### 7.1 数据源自动配置

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@ConditionalOnMissingBean(type = "javax.sql.DataSource")
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class,
          DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {

    @Configuration(proxyBeanMethods = false)
    @Conditional(EmbeddedDatabaseCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import(EmbeddedDataSourceConfiguration.class)
    protected static class EmbeddedDatabaseConfiguration {
    }

    @Configuration(proxyBeanMethods = false)
    @Conditional(PooledDataSourceCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import({ DataSourceConfiguration.Hikari.class,
              DataSourceConfiguration.Tomcat.class,
              DataSourceConfiguration.Dbcp2.class,
              DataSourceConfiguration.OracleUcp.class,
              DataSourceConfiguration.Generic.class })
    protected static class PooledDataSourceConfiguration {
    }
}
```

#### 7.2 Web MVC 自动配置

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
                     TaskExecutionAutoConfiguration.class,
                     ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    @ConditionalOnProperty(prefix = "spring.mvc.hiddenmethod.filter", name = "enabled")
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
        return new OrderedHiddenHttpMethodFilter();
    }

    @Bean
    @ConditionalOnMissingBean(HttpPutFormContentFilter.class)
    @ConditionalOnProperty(prefix = "spring.mvc.formcontent.filter", name = "enabled", matchIfMissing = true)
    public OrderedHttpPutFormContentFilter httpPutFormContentFilter() {
        return new OrderedHttpPutFormContentFilter();
    }
}
```

## 总结

Spring Boot 的自动配置通过以下机制实现了"约定优于配置"的理念：

1. **SPI 机制**：通过 `META-INF/spring.factories` 文件发现并加载自动配置类
2. **条件注解**：根据类路径、Bean 存在性、属性配置等条件决定是否启用配置
3. **配置属性绑定**：将外部配置文件的属性绑定到配置类
4. **优先级和排序**：通过 `@AutoConfigureOrder` 等注解控制配置的加载顺序

这种设计使得开发者只需要添加相应的依赖，Spring Boot 就能自动配置所需的 Bean，大大简化了应用的配置工作。
