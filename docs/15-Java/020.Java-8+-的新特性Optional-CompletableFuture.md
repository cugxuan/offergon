---
title: Java 8+ 的新特性(Optional、CompletableFuture)
tags:
  - Java
status: robot
class: Java
slug: java-8-optional-completablefuture-features
ref:
---

## 核心要点

**Optional**:容器类型,用于优雅处理可能为 null 的值,避免 NPE。通过 `ofNullable()`、`map()`、`orElse()` 等方法实现链式调用,但**不应过度使用**(如作为方法参数或字段)。

**CompletableFuture**:Java 8 引入的异步编程工具,支持**链式组合**(thenApply/thenCompose)、**异常处理**(exceptionally/handle)、**并行聚合**(allOf/anyOf)。核心优势是将回调地狱转为声明式的流式 API。

**适用场景**:Optional 用于返回值处理;CompletableFuture 用于 IO 密集型异步任务、微服务编排、并行计算。两者结合函数式编程,显著提升代码可读性和健壮性。

---

## 详细回答

### 一、Optional:优雅的空值处理

#### 1. Optional 的设计初衷

**问题背景**:空指针异常(NullPointerException)是 Java 中最常见的运行时错误。

传统处理方式:
```java
// 传统的防御性编程
public String getUserCity(Long userId) {
    User user = userDao.findById(userId);
    if (user != null) {
        Address address = user.getAddress();
        if (address != null) {
            City city = address.getCity();
            if (city != null) {
                return city.getName();
            }
        }
    }
    return "Unknown";
}
```

**Optional 的解决方案**:
```java
// 使用 Optional 的链式调用
public String getUserCity(Long userId) {
    return userDao.findById(userId)          // Optional<User>
        .map(User::getAddress)                // Optional<Address>
        .map(Address::getCity)                // Optional<City>
        .map(City::getName)                   // Optional<String>
        .orElse("Unknown");                   // String
}
```

**核心价值**:
- 明确表达"值可能不存在"的语义
- 强制调用者处理空值情况
- 提供流式 API,减少嵌套判断

#### 2. Optional 的创建方式

```java
// 1. Optional.of():值不能为 null
Optional<String> opt1 = Optional.of("Hello");
Optional<String> opt2 = Optional.of(null);  // NullPointerException!

// 2. Optional.ofNullable():值可以为 null
Optional<String> opt3 = Optional.ofNullable("Hello");
Optional<String> opt4 = Optional.ofNullable(null);  // Optional.empty

// 3. Optional.empty():空容器
Optional<String> opt5 = Optional.empty();

// 判断是否有值
System.out.println(opt3.isPresent());  // true
System.out.println(opt4.isEmpty());    // true (Java 11+)
```

#### 3. Optional 的核心 API

**3.1 获取值**

```java
Optional<String> opt = Optional.of("Hello");

// 1. get():有值返回,无值抛异常(不推荐)
String value = opt.get();  // "Hello"
Optional.empty().get();    // NoSuchElementException

// 2. orElse():有值返回,无值返回默认值
String value = opt.orElse("Default");
String value2 = Optional.empty().orElse("Default");  // "Default"

// 3. orElseGet():有值返回,无值执行 Supplier
String value = opt.orElseGet(() -> {
    // 复杂的默认值计算逻辑
    return "Computed Default";
});

// 4. orElseThrow():有值返回,无值抛自定义异常
String value = opt.orElseThrow(() -> new IllegalArgumentException("值不存在"));
```

**orElse vs orElseGet 的性能差异**:
```java
// orElse:无论有无值,都会执行参数表达式
Optional<String> opt = Optional.of("Hello");
String value = opt.orElse(expensiveOperation());  // expensiveOperation() 会执行!

// orElseGet:只有无值时才执行 Supplier(推荐)
String value = opt.orElseGet(() -> expensiveOperation());  // 不会执行
```

**3.2 条件处理**

```java
Optional<String> opt = Optional.of("Hello");

// 1. ifPresent():有值时执行 Consumer
opt.ifPresent(value -> System.out.println("Value: " + value));

// 2. ifPresentOrElse():有值执行第一个,无值执行第二个(Java 9+)
opt.ifPresentOrElse(
    value -> System.out.println("Value: " + value),
    () -> System.out.println("No value")
);

// 3. filter():过滤值
Optional<String> filtered = opt.filter(s -> s.length() > 3);
System.out.println(filtered.orElse("Too short"));  // "Hello"

Optional<String> filtered2 = opt.filter(s -> s.length() > 10);
System.out.println(filtered2.orElse("Too short"));  // "Too short"
```

**3.3 转换操作**

```java
Optional<String> opt = Optional.of("123");

// 1. map():转换值(一对一)
Optional<Integer> length = opt.map(String::length);  // Optional[3]
Optional<Integer> number = opt.map(Integer::parseInt);  // Optional[123]

// 2. flatMap():转换并扁平化(避免 Optional<Optional<T>>)
public Optional<Address> getAddress(User user) {
    return Optional.ofNullable(user.getAddress());
}

Optional<User> userOpt = Optional.of(user);

// 错误:返回 Optional<Optional<Address>>
Optional<Optional<Address>> wrongResult = userOpt.map(this::getAddress);

// 正确:返回 Optional<Address>
Optional<Address> correctResult = userOpt.flatMap(this::getAddress);

// 实际使用
String cityName = userOpt
    .flatMap(this::getAddress)
    .map(Address::getCity)
    .map(City::getName)
    .orElse("Unknown");
```

**3.4 Java 9+ 新增特性**

```java
// 1. or():提供备选 Optional
Optional<String> primary = Optional.empty();
Optional<String> fallback = Optional.of("Fallback");

Optional<String> result = primary.or(() -> fallback);  // Optional["Fallback"]

// 2. stream():将 Optional 转为 Stream(方便集成 Stream API)
List<String> names = users.stream()
    .map(user -> Optional.ofNullable(user.getName()))
    .flatMap(Optional::stream)  // 过滤掉空值
    .collect(Collectors.toList());
```

#### 4. Optional 的正确使用姿势

**✅ 推荐做法**:

```java
// 1. 作为方法返回值
public Optional<User> findUserById(Long id) {
    User user = userDao.findById(id);
    return Optional.ofNullable(user);
}

// 2. 链式处理复杂逻辑
public String processUser(Long userId) {
    return findUserById(userId)
        .filter(user -> user.isActive())
        .map(User::getEmail)
        .map(String::toUpperCase)
        .orElse("NO_EMAIL");
}

// 3. 与 Stream 结合
List<String> emails = userIds.stream()
    .map(this::findUserById)
    .flatMap(Optional::stream)
    .map(User::getEmail)
    .collect(Collectors.toList());
```

**❌ 反模式**:

```java
// 1. 不要作为方法参数(增加复杂度)
// 错误
public void processUser(Optional<User> userOpt) {
    userOpt.ifPresent(user -> {...});
}
// 正确:用方法重载
public void processUser(User user) {...}

// 2. 不要作为字段(序列化问题)
// 错误
public class User {
    private Optional<String> middleName;  // 不推荐
}
// 正确:字段可为 null,getter 返回 Optional
public class User {
    private String middleName;

    public Optional<String> getMiddleName() {
        return Optional.ofNullable(middleName);
    }
}

// 3. 不要用在集合元素中
// 错误
List<Optional<User>> users;
// 正确:直接用 null 或空集合

// 4. 避免嵌套 Optional
// 错误
Optional<Optional<String>> nested;
// 正确:使用 flatMap 扁平化

// 5. 不要仅仅为了避免判空而用 Optional
// 错误(过度使用)
Optional.ofNullable(user).ifPresent(u -> u.setName("Alice"));
// 正确(直接判断)
if (user != null) {
    user.setName("Alice");
}
```

#### 5. Optional 的性能考量

```java
// 基准测试
User user = new User("Alice");

// 传统判空:快
if (user != null) {
    String name = user.getName();
}

// Optional:慢(需要创建对象)
Optional.ofNullable(user).map(User::getName);
```

**性能建议**:
- 性能关键路径(如循环内)避免频繁创建 Optional
- 外部 API 和复杂业务逻辑推荐使用 Optional
- 内部工具方法可以用传统判空

---

### 二、CompletableFuture:强大的异步编程工具

#### 1. 异步编程的演进

**传统多线程**:
```java
// 手动管理线程
ExecutorService executor = Executors.newFixedThreadPool(10);

Future<String> future = executor.submit(() -> {
    Thread.sleep(1000);
    return "Result";
});

// 阻塞等待结果
try {
    String result = future.get();  // 阻塞!
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}
```

**Future 的缺陷**:
- ❌ 无法组合多个异步任务
- ❌ 无法链式处理结果
- ❌ 无法优雅处理异常
- ❌ 只能阻塞获取结果(get)

**CompletableFuture 的优势**:
```java
// 声明式的异步编程
CompletableFuture.supplyAsync(() -> {
    // 异步执行
    return fetchUserFromDb(userId);
})
.thenApply(user -> {
    // 转换结果
    return user.getEmail();
})
.thenAccept(email -> {
    // 消费结果
    sendEmail(email);
})
.exceptionally(ex -> {
    // 异常处理
    log.error("Error: ", ex);
    return null;
});
```

#### 2. CompletableFuture 的创建方式

```java
// 1. supplyAsync:有返回值的异步任务
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
    return "Hello";
});

// 2. runAsync:无返回值的异步任务
CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
    System.out.println("Running...");
});

// 3. completedFuture:已完成的 Future(用于测试或缓存)
CompletableFuture<String> future3 = CompletableFuture.completedFuture("Immediate");

// 4. 手动完成
CompletableFuture<String> future4 = new CompletableFuture<>();
future4.complete("Manual result");  // 手动设置结果

// 5. 指定线程池(推荐)
ExecutorService executor = Executors.newFixedThreadPool(10);
CompletableFuture<String> future5 = CompletableFuture.supplyAsync(
    () -> "Hello",
    executor  // 自定义线程池
);
```

#### 3. 链式转换与组合

**3.1 单个 Future 的转换**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "123";
});

// 1. thenApply:转换结果(同步)
CompletableFuture<Integer> numberFuture = future.thenApply(Integer::parseInt);

// 2. thenApplyAsync:转换结果(异步,使用默认线程池)
CompletableFuture<Integer> asyncFuture = future.thenApplyAsync(Integer::parseInt);

// 3. thenCompose:扁平化(避免嵌套 Future)
CompletableFuture<User> userFuture = CompletableFuture.supplyAsync(() -> userId)
    .thenCompose(id -> fetchUserAsync(id));  // fetchUserAsync 返回 CompletableFuture<User>

// 错误:返回 CompletableFuture<CompletableFuture<User>>
CompletableFuture<CompletableFuture<User>> wrongFuture =
    CompletableFuture.supplyAsync(() -> userId)
        .thenApply(id -> fetchUserAsync(id));

// 4. thenAccept:消费结果(无返回值)
future.thenAccept(value -> System.out.println("Result: " + value));

// 5. thenRun:执行逻辑(不关心结果)
future.thenRun(() -> System.out.println("Done"));
```

**3.2 组合多个 Future**

```java
// 场景:获取用户信息和订单信息,两者独立
CompletableFuture<User> userFuture = CompletableFuture.supplyAsync(() -> fetchUser(userId));
CompletableFuture<List<Order>> orderFuture = CompletableFuture.supplyAsync(() -> fetchOrders(userId));

// 1. thenCombine:组合两个 Future 的结果
CompletableFuture<UserWithOrders> combinedFuture = userFuture.thenCombine(
    orderFuture,
    (user, orders) -> new UserWithOrders(user, orders)
);

// 2. thenAcceptBoth:消费两个结果
userFuture.thenAcceptBoth(
    orderFuture,
    (user, orders) -> System.out.println(user + " has " + orders.size() + " orders")
);

// 3. runAfterBoth:两个都完成后执行
userFuture.runAfterBoth(
    orderFuture,
    () -> System.out.println("Both completed")
);

// 4. applyToEither:取最先完成的结果
CompletableFuture<String> fastFuture = userFuture.applyToEither(
    orderFuture,
    result -> "First result: " + result
);

// 5. acceptEither:消费最先完成的结果
userFuture.acceptEither(
    orderFuture,
    result -> System.out.println("First: " + result)
);
```

**3.3 批量并行处理**

```java
// 场景:并行调用多个微服务
List<CompletableFuture<String>> futures = Arrays.asList(
    CompletableFuture.supplyAsync(() -> callService1()),
    CompletableFuture.supplyAsync(() -> callService2()),
    CompletableFuture.supplyAsync(() -> callService3())
);

// 1. allOf:等待所有完成(无返回值聚合)
CompletableFuture<Void> allFuture = CompletableFuture.allOf(
    futures.toArray(new CompletableFuture[0])
);

// 手动聚合结果
allFuture.thenApply(v -> {
    return futures.stream()
        .map(CompletableFuture::join)  // 获取结果
        .collect(Collectors.toList());
});

// 2. anyOf:取最先完成的
CompletableFuture<Object> anyFuture = CompletableFuture.anyOf(
    futures.toArray(new CompletableFuture[0])
);

anyFuture.thenAccept(result -> {
    System.out.println("First result: " + result);
});
```

#### 4. 异常处理

**4.1 基础异常处理**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    if (Math.random() > 0.5) {
        throw new RuntimeException("Error!");
    }
    return "Success";
});

// 1. exceptionally:捕获异常,返回默认值
CompletableFuture<String> handled = future.exceptionally(ex -> {
    log.error("Exception: ", ex);
    return "Default";
});

// 2. handle:同时处理结果和异常
CompletableFuture<String> handled2 = future.handle((result, ex) -> {
    if (ex != null) {
        log.error("Exception: ", ex);
        return "Error handled";
    }
    return result.toUpperCase();
});

// 3. whenComplete:副作用处理(不改变结果)
future.whenComplete((result, ex) -> {
    if (ex != null) {
        log.error("Exception: ", ex);
    } else {
        log.info("Result: " + result);
    }
});
```

**4.2 链式异常传播**

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return fetchData();
})
.thenApply(data -> {
    return processData(data);  // 可能抛异常
})
.thenApply(processed -> {
    return saveData(processed);  // 可能抛异常
})
.exceptionally(ex -> {
    // 捕获整个链路的异常
    log.error("Pipeline error: ", ex);
    return "Failed";
});
```

#### 5. 实战场景

**场景 1:微服务编排**

```java
// 需求:获取用户信息、订单列表、推荐商品,三者并行
public UserDashboard getUserDashboard(Long userId) {
    CompletableFuture<User> userFuture = CompletableFuture.supplyAsync(
        () -> userService.getUser(userId)
    );

    CompletableFuture<List<Order>> orderFuture = CompletableFuture.supplyAsync(
        () -> orderService.getOrders(userId)
    );

    CompletableFuture<List<Product>> recommendFuture = CompletableFuture.supplyAsync(
        () -> recommendService.getRecommendations(userId)
    );

    // 等待所有完成并聚合结果
    return CompletableFuture.allOf(userFuture, orderFuture, recommendFuture)
        .thenApply(v -> {
            User user = userFuture.join();
            List<Order> orders = orderFuture.join();
            List<Product> recommendations = recommendFuture.join();

            return new UserDashboard(user, orders, recommendations);
        })
        .join();  // 阻塞等待最终结果
}
```

**场景 2:分页并行查询**

```java
// 需求:并行查询 10 页数据
public List<User> fetchAllUsers() {
    List<CompletableFuture<List<User>>> futures = new ArrayList<>();

    for (int page = 1; page <= 10; page++) {
        int currentPage = page;
        CompletableFuture<List<User>> future = CompletableFuture.supplyAsync(
            () -> userService.getUsersByPage(currentPage)
        );
        futures.add(future);
    }

    // 聚合所有结果
    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> {
            return futures.stream()
                .map(CompletableFuture::join)
                .flatMap(List::stream)
                .collect(Collectors.toList());
        })
        .join();
}
```

**场景 3:超时控制**

```java
// 需求:调用第三方 API,超时 3 秒
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return callExternalApi();  // 可能很慢
});

try {
    // 超时控制
    String result = future.get(3, TimeUnit.SECONDS);
} catch (TimeoutException e) {
    future.cancel(true);  // 取消任务
    return "Timeout";
}

// Java 9+ 更优雅的超时处理
CompletableFuture<String> result = future
    .orTimeout(3, TimeUnit.SECONDS)  // 超时抛异常
    .exceptionally(ex -> "Timeout");

// 超时时提供默认值
CompletableFuture<String> result = future
    .completeOnTimeout("Default", 3, TimeUnit.SECONDS);
```

**场景 4:重试机制**

```java
public <T> CompletableFuture<T> retryAsync(Supplier<T> supplier, int maxRetries) {
    CompletableFuture<T> future = CompletableFuture.supplyAsync(supplier);

    for (int i = 0; i < maxRetries; i++) {
        future = future.exceptionally(ex -> {
            log.warn("Retry due to: " + ex.getMessage());
            return null;
        }).thenCompose(result -> {
            if (result == null) {
                return CompletableFuture.supplyAsync(supplier);
            }
            return CompletableFuture.completedFuture(result);
        });
    }

    return future;
}

// 使用
CompletableFuture<String> result = retryAsync(() -> callUnstableApi(), 3);
```

#### 6. CompletableFuture 的陷阱

**陷阱 1:线程池耗尽**

```java
// 危险:使用默认 ForkJoinPool(公共线程池)
CompletableFuture.supplyAsync(() -> {
    // 如果大量任务阻塞,会耗尽线程池
    Thread.sleep(10000);
    return "Result";
});

// 正确:使用自定义线程池
ExecutorService executor = Executors.newFixedThreadPool(50);
CompletableFuture.supplyAsync(() -> {
    Thread.sleep(10000);
    return "Result";
}, executor);
```

**陷阱 2:异常吞掉**

```java
// 错误:异常被静默吞掉
CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("Error");
}).thenApply(result -> {
    return result.toUpperCase();  // 永远不会执行
});

// 正确:添加异常处理
CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("Error");
})
.exceptionally(ex -> {
    log.error("Exception: ", ex);  // 必须记录日志
    return "Default";
});
```

**陷阱 3:阻塞主线程**

```java
// 错误:在主线程 join 会阻塞
public String getResult() {
    return CompletableFuture.supplyAsync(() -> {
        Thread.sleep(5000);
        return "Result";
    }).join();  // 阻塞 5 秒!
}

// 正确:返回 CompletableFuture,让调用者决定
public CompletableFuture<String> getResultAsync() {
    return CompletableFuture.supplyAsync(() -> {
        Thread.sleep(5000);
        return "Result";
    });
}
```

---

### 三、Optional 与 CompletableFuture 的结合

```java
// 场景:异步查询用户,可能不存在
public CompletableFuture<Optional<User>> findUserAsync(Long userId) {
    return CompletableFuture.supplyAsync(() -> {
        User user = userDao.findById(userId);
        return Optional.ofNullable(user);
    });
}

// 使用
findUserAsync(userId)
    .thenAccept(userOpt -> {
        userOpt.ifPresentOrElse(
            user -> System.out.println("Found: " + user.getName()),
            () -> System.out.println("User not found")
        );
    });

// 链式处理
CompletableFuture<String> emailFuture = findUserAsync(userId)
    .thenApply(userOpt -> userOpt
        .map(User::getEmail)
        .orElse("no-email@example.com")
    );
```

---

### 四、最佳实践总结

#### 1. Optional 使用指南

**✅ 推荐**:
- 方法返回值明确可能为空时使用
- 与 Stream API 配合处理集合
- 复杂的链式转换逻辑

**❌ 避免**:
- 不要作为方法参数、字段、集合元素
- 不要仅仅为了避免 if 判断而使用
- 性能敏感路径慎用

#### 2. CompletableFuture 使用指南

**✅ 推荐**:
- IO 密集型任务(网络请求、数据库查询)
- 微服务间并行调用
- 需要异步编排的复杂流程

**❌ 避免**:
- CPU 密集型任务(应使用 parallelStream)
- 简单的顺序执行(增加复杂度)
- 不指定线程池(使用默认公共池)

#### 3. 线程池配置建议

```java
// IO 密集型:线程数 = CPU 核心数 * 2
ExecutorService ioPool = new ThreadPoolExecutor(
    20, 50,
    60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(1000),
    new ThreadPoolExecutor.CallerRunsPolicy()
);

// CPU 密集型:线程数 = CPU 核心数 + 1
int coreCount = Runtime.getRuntime().availableProcessors();
ExecutorService cpuPool = Executors.newFixedThreadPool(coreCount + 1);
```

---

### 五、总结

**Optional 的核心价值**:
1. 明确表达"值可能不存在"的语义
2. 提供流式 API,减少嵌套判断
3. 强制调用者处理空值,减少 NPE

**CompletableFuture 的核心价值**:
1. 声明式的异步编程,告别回调地狱
2. 强大的组合能力(串行、并行、异常处理)
3. 与函数式编程无缝集成

**使用建议**:
- Optional 用于返回值,不要滥用
- CompletableFuture 用于 IO 密集型异步任务
- 两者结合函数式编程,显著提升代码质量

这两个特性标志着 Java 向现代编程范式的转变,熟练掌握它们是编写高质量、高性能 Java 代码的关键。在面试中,能够结合实际场景分析其优劣并给出最佳实践,是高级工程师的必备能力。
