---
title: Spring 的循环依赖解决机制（三级缓存）
tags:
  - Java
  - 缓存策略
status: robot
class: Java
slug: spring-circular-dependency-resolution-three-level-cache
ref:
---

## 核心要点
- **三级缓存机制**：一级缓存存成品Bean，二级缓存存半成品Bean，三级缓存存Bean工厂
- **循环依赖问题**：A依赖B，B又依赖A，形成环形依赖链
- **提前暴露机制**：Spring通过提前暴露未完成初始化的Bean来解决循环依赖
- **AOP代理处理**：三级缓存确保循环依赖场景下AOP代理对象的一致性

## 详细解答

### 1. 循环依赖问题概述

**循环依赖**是指两个或多个Bean之间相互依赖，形成一个闭环。Spring框架通过巧妙的三级缓存机制来解决这个复杂问题。

```java
// 典型的循环依赖场景
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;  // A依赖B

    public void doSomething() {
        serviceB.process();
    }
}

@Component
public class ServiceB {
    @Autowired
    private ServiceA serviceA;  // B依赖A，形成循环依赖

    public void process() {
        serviceA.doSomething();
    }
}
```

### 2. Spring三级缓存架构

Spring通过三级缓存来管理Bean的创建和依赖注入过程：

```java
// Spring容器中的三级缓存实现（简化版）
public class DefaultSingletonBeanRegistry {

    // 一级缓存：成品Bean缓存，存储完全初始化的Bean
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

    // 二级缓存：早期Bean缓存，存储未完成初始化但已实例化的Bean
    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);

    // 三级缓存：Bean工厂缓存，存储能够创建Bean的工厂方法
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

    // 标记正在创建中的Bean名称
    private final Set<String> singletonsCurrentlyInCreation =
        Collections.newSetFromMap(new ConcurrentHashMap<>(16));
}
```

#### 2.1 各级缓存详解

| 缓存级别 | 名称 | 存储内容 | 作用 |
|---------|------|----------|------|
| **一级缓存** | `singletonObjects` | 完全初始化的Bean | 存储成品Bean，供正常使用 |
| **二级缓存** | `earlySingletonObjects` | 早期暴露的Bean | 存储半成品Bean，解决循环依赖 |
| **三级缓存** | `singletonFactories` | Bean创建工厂 | 支持AOP代理，确保对象一致性 |

### 3. 循环依赖解决流程

#### 3.1 完整解决流程图

```java
public class CircularDependencyResolver {

    /**
     * 获取Bean的完整流程（支持循环依赖）
     */
    public Object getSingleton(String beanName) {
        // 1. 先从一级缓存获取成品Bean
        Object singletonObject = this.singletonObjects.get(beanName);

        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                // 2. 从二级缓存获取早期Bean
                singletonObject = this.earlySingletonObjects.get(beanName);

                if (singletonObject == null) {
                    // 3. 从三级缓存获取Bean工厂
                    ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        // 4. 通过工厂创建Bean（可能是代理对象）
                        singletonObject = singletonFactory.getObject();
                        // 5. 将创建的Bean放入二级缓存
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        // 6. 从三级缓存移除工厂
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return singletonObject;
    }
}
```

#### 3.2 Bean创建的详细步骤

```java
public class BeanCreationProcess {

    public Object createBean(String beanName, Class<?> beanClass) {
        // 步骤1：标记Bean正在创建中
        beforeSingletonCreation(beanName);

        try {
            // 步骤2：实例化Bean（调用构造器）
            Object bean = createBeanInstance(beanName, beanClass);

            // 步骤3：提前暴露Bean工厂到三级缓存（关键步骤）
            if (isSingletonCurrentlyInCreation(beanName)) {
                addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, bean));
            }

            // 步骤4：填充Bean属性（依赖注入）
            populateBean(beanName, bean);

            // 步骤5：初始化Bean（调用初始化方法）
            bean = initializeBean(beanName, bean);

            return bean;
        } finally {
            // 步骤6：创建完成，移除创建标记
            afterSingletonCreation(beanName);
        }
    }

    /**
     * 提前暴露Bean引用（支持AOP）
     */
    protected Object getEarlyBeanReference(String beanName, Object bean) {
        Object exposedObject = bean;

        // 如果有AOP配置，创建代理对象
        for (BeanPostProcessor processor : getBeanPostProcessors()) {
            if (processor instanceof SmartInstantiationAwareBeanPostProcessor) {
                SmartInstantiationAwareBeanPostProcessor smartProcessor =
                    (SmartInstantiationAwareBeanPostProcessor) processor;
                exposedObject = smartProcessor.getEarlyBeanReference(exposedObject, beanName);
            }
        }

        return exposedObject;
    }
}
```

### 4. 实际案例演示

#### 4.1 循环依赖创建过程详解

```java
// 详细演示ServiceA和ServiceB的创建过程
public class CircularDependencyDemo {

    public static void demonstrateCircularDependency() {
        /*
         * 假设Spring容器启动，需要创建ServiceA
         */

        // === 创建ServiceA开始 ===

        // 1. 检查一级缓存 - ServiceA不存在
        // 2. 标记ServiceA正在创建中
        // 3. 实例化ServiceA（调用构造器，但未注入依赖）
        ServiceA serviceA = new ServiceA(); // 未完成的对象

        // 4. 【关键】将ServiceA的工厂放入三级缓存
        singletonFactories.put("serviceA", () -> {
            // 这里会检查是否需要AOP代理
            return getEarlyBeanReference("serviceA", serviceA);
        });

        // 5. 开始填充ServiceA的属性（注入ServiceB）
        // 6. 发现需要ServiceB，开始创建ServiceB

        // === 创建ServiceB开始 ===

        // 7. 检查一级缓存 - ServiceB不存在
        // 8. 标记ServiceB正在创建中
        // 9. 实例化ServiceB
        ServiceB serviceB = new ServiceB(); // 未完成的对象

        // 10. 将ServiceB的工厂放入三级缓存
        singletonFactories.put("serviceB", () -> {
            return getEarlyBeanReference("serviceB", serviceB);
        });

        // 11. 开始填充ServiceB的属性（注入ServiceA）
        // 12. 发现需要ServiceA，但ServiceA正在创建中！

        // === 解决循环依赖 ===

        // 13. 从三级缓存获取ServiceA的工厂
        ObjectFactory<ServiceA> factoryA = singletonFactories.get("serviceA");

        // 14. 通过工厂获取ServiceA（可能是代理对象）
        ServiceA earlyServiceA = factoryA.getObject();

        // 15. 将早期ServiceA放入二级缓存
        earlySingletonObjects.put("serviceA", earlyServiceA);
        singletonFactories.remove("serviceA");

        // 16. 将earlyServiceA注入到ServiceB中
        serviceB.setServiceA(earlyServiceA);

        // 17. ServiceB创建完成，放入一级缓存
        singletonObjects.put("serviceB", serviceB);

        // 18. 回到ServiceA的创建，注入ServiceB
        serviceA.setServiceB(serviceB);

        // 19. ServiceA创建完成，放入一级缓存
        singletonObjects.put("serviceA", serviceA);

        // 20. 清理二级缓存
        earlySingletonObjects.remove("serviceA");
    }
}
```

#### 4.2 带AOP的循环依赖处理

```java
@Component
public class UserService {
    @Autowired
    private OrderService orderService;

    @Transactional  // 需要AOP代理
    public void createUser(String username) {
        // 用户创建逻辑
        orderService.createDefaultOrder(username);
    }
}

@Component
public class OrderService {
    @Autowired
    private UserService userService;

    @Cacheable("orders")  // 需要AOP代理
    public void createDefaultOrder(String username) {
        // 订单创建逻辑
        userService.validateUser(username);
    }
}

/**
 * AOP场景下的早期引用处理
 */
public class AopEarlyReferenceHandler {

    public Object getEarlyBeanReference(Object bean, String beanName) {
        Object exposedObject = bean;

        // 检查是否需要创建AOP代理
        if (shouldCreateProxy(bean, beanName)) {
            // 创建代理对象
            exposedObject = createAopProxy(bean);

            // 记录代理映射关系，确保后续获取的是同一个代理对象
            earlyProxyReferences.put(beanName, exposedObject);
        }

        return exposedObject;
    }

    private boolean shouldCreateProxy(Object bean, String beanName) {
        // 检查是否有@Transactional, @Cacheable等注解
        // 或者是否匹配AOP切点表达式
        return hasTransactionalAnnotation(bean) ||
               hasCacheableAnnotation(bean) ||
               matchesAopPointcut(bean, beanName);
    }
}
```

### 5. 三级缓存的必要性

#### 5.1 为什么需要三级缓存？

```java
public class WhyThreeLevelCache {

    /**
     * 如果只有二级缓存会怎样？
     */
    public void demonstrateTwoLevelCacheProblem() {
        /*
         * 问题：AOP代理对象不一致
         *
         * 场景：ServiceA需要AOP代理，ServiceB依赖ServiceA
         *
         * 只有二级缓存的流程：
         * 1. 创建ServiceA实例
         * 2. 直接将ServiceA放入二级缓存（原始对象）
         * 3. ServiceB获取到原始ServiceA对象
         * 4. ServiceA完成初始化，创建代理对象
         * 5. 结果：ServiceB持有原始对象，容器持有代理对象 - 不一致！
         */
    }

    /**
     * 三级缓存如何解决这个问题？
     */
    public void demonstrateThreeLevelCacheSolution() {
        /*
         * 三级缓存的优势：
         *
         * 1. 延迟代理对象创建
         * 2. 保证代理对象一致性
         * 3. 支持复杂的AOP场景
         *
         * 流程：
         * 1. 创建ServiceA实例
         * 2. 将ServiceA工厂放入三级缓存（不是对象本身）
         * 3. ServiceB需要ServiceA时，通过工厂获取（可能是代理）
         * 4. 代理对象放入二级缓存
         * 5. 确保所有引用都是同一个代理对象
         */
    }
}
```

#### 5.2 三级缓存核心代码实现

```java
public class ThreeLevelCacheImplementation {

    // 三级缓存容器
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>();
    private final Map<String, Object> earlySingletonObjects = new HashMap<>();
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>();

    /**
     * 核心获取方法
     */
    public Object getSingleton(String beanName, boolean allowEarlyReference) {
        // 一级缓存查找
        Object singletonObject = this.singletonObjects.get(beanName);

        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                // 二级缓存查找
                singletonObject = this.earlySingletonObjects.get(beanName);

                if (singletonObject == null && allowEarlyReference) {
                    // 三级缓存查找
                    ObjectFactory<?> singletonFactory =
                        this.singletonFactories.get(beanName);

                    if (singletonFactory != null) {
                        // 通过工厂创建对象（关键：可能创建代理）
                        singletonObject = singletonFactory.getObject();

                        // 升级到二级缓存
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }

        return singletonObject;
    }

    /**
     * 添加到三级缓存
     */
    public void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
        synchronized (this.singletonObjects) {
            if (!this.singletonObjects.containsKey(beanName)) {
                this.singletonFactories.put(beanName, singletonFactory);
                this.earlySingletonObjects.remove(beanName);
            }
        }
    }
}
```

### 6. 循环依赖的限制和注意事项

#### 6.1 无法解决的循环依赖场景

```java
// 1. 构造器循环依赖（无法解决）
@Component
public class ConstructorCircularA {
    private final ConstructorCircularB b;

    // 构造器注入的循环依赖Spring无法解决
    public ConstructorCircularA(ConstructorCircularB b) {
        this.b = b;
    }
}

@Component
public class ConstructorCircularB {
    private final ConstructorCircularA a;

    public ConstructorCircularB(ConstructorCircularA a) {
        this.a = a;
    }
}

// 2. prototype作用域的循环依赖（无法解决）
@Component
@Scope("prototype")
public class PrototypeCircularA {
    @Autowired
    private PrototypeCircularB b;  // prototype Bean每次都创建新实例
}

@Component
@Scope("prototype")
public class PrototypeCircularB {
    @Autowired
    private PrototypeCircularA a;
}
```

#### 6.2 最佳实践建议

```java
// 1. 使用@Lazy注解延迟初始化
@Component
public class LazyCircularA {
    @Autowired
    @Lazy  // 延迟注入，打破循环依赖
    private LazyCircularB b;
}

@Component
public class LazyCircularB {
    @Autowired
    private LazyCircularA a;
}

// 2. 使用ApplicationContextAware获取Bean
@Component
public class ContextAwareService implements ApplicationContextAware {
    private ApplicationContext applicationContext;

    public void doSomething() {
        // 运行时获取Bean，避免循环依赖
        OtherService otherService = applicationContext.getBean(OtherService.class);
        otherService.process();
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
}

// 3. 重构代码，消除循环依赖
@Component
public class RefactoredServiceA {
    @Autowired
    private CommonService commonService;  // 提取公共依赖
}

@Component
public class RefactoredServiceB {
    @Autowired
    private CommonService commonService;  // 提取公共依赖
}

@Component
public class CommonService {
    // 公共业务逻辑
}
```

### 7. 源码分析与调试技巧

#### 7.1 关键源码位置

```java
/**
 * 关键类和方法（Spring Framework源码）
 */
public class SpringSourceCodeAnalysis {

    // 核心类：
    // org.springframework.beans.factory.support.DefaultSingletonBeanRegistry
    // org.springframework.beans.factory.support.AbstractBeanFactory
    // org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory

    /**
     * 关键方法调用链：
     *
     * 1. AbstractBeanFactory.doGetBean()
     * 2. DefaultSingletonBeanRegistry.getSingleton()
     * 3. AbstractAutowireCapableBeanFactory.createBean()
     * 4. AbstractAutowireCapableBeanFactory.doCreateBean()
     * 5. AbstractAutowireCapableBeanFactory.addSingletonFactory()
     */
}
```

#### 7.2 调试和监控

```java
@Configuration
@EnableAspectJAutoProxy
public class CircularDependencyMonitor {

    @Component
    public static class CircularDependencyLogger {

        @EventListener
        public void handleContextRefresh(ContextRefreshedEvent event) {
            ApplicationContext context = event.getApplicationContext();

            // 检查是否有循环依赖被解决
            if (context instanceof ConfigurableApplicationContext) {
                ConfigurableApplicationContext configurableContext =
                    (ConfigurableApplicationContext) context;

                DefaultSingletonBeanRegistry registry =
                    (DefaultSingletonBeanRegistry) configurableContext.getBeanFactory();

                // 通过反射获取缓存信息（调试用）
                logCacheStatus(registry);
            }
        }

        private void logCacheStatus(DefaultSingletonBeanRegistry registry) {
            try {
                Field singletonObjectsField =
                    DefaultSingletonBeanRegistry.class.getDeclaredField("singletonObjects");
                singletonObjectsField.setAccessible(true);

                Map<String, Object> singletonObjects =
                    (Map<String, Object>) singletonObjectsField.get(registry);

                System.out.println("一级缓存Bean数量: " + singletonObjects.size());

                // 类似地可以检查二级和三级缓存

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

Spring的三级缓存机制是一个精妙的设计，它不仅解决了循环依赖问题，还保证了AOP代理对象的一致性。理解这个机制对于深入掌握Spring IoC容器的工作原理具有重要意义。在实际开发中，虽然Spring能够处理大部分循环依赖场景，但我们仍应该通过良好的架构设计来避免不必要的循环依赖。
