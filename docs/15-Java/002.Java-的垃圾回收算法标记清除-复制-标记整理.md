---
title: Java 的垃圾回收算法（标记清除、复制、标记整理）
tags:
  - Java
status: robot
class: Java
slug: java-garbage-collection-algorithms
ref:
---

## 核心要点

- **标记清除（Mark-Sweep）**：分标记和清除两个阶段，会产生内存碎片
- **复制算法（Copying）**：将内存分为两块，复制存活对象到另一块，空间利用率低但效率高
- **标记整理（Mark-Compact）**：标记后移动对象整理内存，解决碎片问题但性能开销大
- **分代收集**：新生代使用复制算法，老年代使用标记清除或标记整理

## 详细解答

### 1. 标记清除算法（Mark-Sweep）

这是最基础的垃圾回收算法，分为两个阶段执行。

**执行过程：**
```
第一阶段：标记（Mark）
├── 从GC Roots开始遍历对象图
├── 标记所有可达的对象
└── 未被标记的对象即为垃圾对象

第二阶段：清除（Sweep）
├── 遍历整个内存空间
├── 回收所有未被标记的对象
└── 释放对象占用的内存空间
```

**算法实现示意：**
```java
// 伪代码示例
public void markSweepGC() {
    // 标记阶段
    markReachableObjects();

    // 清除阶段
    sweepUnmarkedObjects();
}

private void markReachableObjects() {
    Queue<Object> queue = new LinkedList<>();
    // 从GC Roots开始
    queue.addAll(gcRoots);

    while (!queue.isEmpty()) {
        Object obj = queue.poll();
        if (!isMarked(obj)) {
            mark(obj);
            // 将引用的对象加入队列
            queue.addAll(getReferences(obj));
        }
    }
}
```

**优缺点分析：**

*优点：*
- 实现简单，概念清晰
- 不需要额外的内存空间
- 对于存活对象较多的场景效率较高

*缺点：*
- 产生内存碎片，影响大对象分配
- 需要暂停程序执行（Stop The World）
- 清除阶段需要遍历整个内存空间

**内存碎片问题：**
```
回收前：[对象A][对象B][对象C][对象D][对象E]
回收后：[对象A][空闲][对象C][空闲][对象E]
        ↑      ↑      ↑     ↑     ↑
        存活   回收   存活  回收  存活
```

### 2. 复制算法（Copying）

将内存分为两个相等的区域，每次只使用其中一个区域。

**执行过程：**
```
初始状态：
From空间：[对象A][对象B][对象C][对象D]
To空间：  [空闲区域]

GC执行：
1. 从GC Roots开始标记存活对象（A、C）
2. 将存活对象复制到To空间
3. 清空From空间
4. 交换From和To空间的角色

GC后：
From空间：[空闲区域]
To空间：  [对象A][对象C][空闲区域]
```

**算法实现示意：**
```java
public void copyingGC() {
    // 复制存活对象到To空间
    copyLiveObjects(fromSpace, toSpace);

    // 清空From空间
    clear(fromSpace);

    // 交换From和To空间
    swap(fromSpace, toSpace);
}

private void copyLiveObjects(Space from, Space to) {
    Queue<Object> queue = new LinkedList<>();
    queue.addAll(gcRoots);

    while (!queue.isEmpty()) {
        Object obj = queue.poll();
        if (isInSpace(obj, from) && !isCopied(obj)) {
            Object newObj = copyToSpace(obj, to);
            updateReferences(obj, newObj);
            queue.addAll(getReferences(newObj));
        }
    }
}
```

**优缺点分析：**

*优点：*
- 没有内存碎片，分配对象时只需移动指针
- 回收效率高，只需遍历存活对象
- 实现简单

*缺点：*
- 内存利用率低，只能使用50%的内存
- 当存活对象较多时，复制开销大
- 需要额外的空间来保证复制操作

**适用场景：**
- 新生代垃圾回收（对象存活率低）
- 临时对象较多的应用

### 3. 标记整理算法（Mark-Compact）

结合了标记清除和复制算法的优点，解决了内存碎片问题。

**执行过程：**
```
第一阶段：标记存活对象
[对象A][对象B][对象C][对象D][对象E]
 ✓存活   ✗死亡   ✓存活   ✗死亡   ✓存活

第二阶段：整理内存
移动前：[对象A][空闲][对象C][空闲][对象E]
移动后：[对象A][对象C][对象E][空闲区域]
```

**算法实现示意：**
```java
public void markCompactGC() {
    // 标记阶段
    markLiveObjects();

    // 计算新地址
    computeNewAddresses();

    // 更新引用
    updateReferences();

    // 移动对象
    compactMemory();
}

private void computeNewAddresses() {
    int newAddress = memoryStart;
    for (Object obj : allObjects) {
        if (isMarked(obj)) {
            setNewAddress(obj, newAddress);
            newAddress += getObjectSize(obj);
        }
    }
}
```

**优缺点分析：**

*优点：*
- 没有内存碎片
- 内存利用率高
- 不需要额外的内存空间

*缺点：*
- 移动对象的成本较高
- 需要更新所有引用
- 算法复杂度较高

### 4. 分代收集策略

现代JVM采用分代收集，针对不同代使用不同算法。

**分代假说：**
- 大部分对象都是朝生夕死
- 熬过越多次垃圾收集的对象就越难以消亡

**具体实现：**
```java
// 新生代GC（Minor GC）
public void minorGC() {
    // Eden区 + Survivor From区 → Survivor To区
    copyingGC(eden, survivorFrom, survivorTo);

    // 年龄增长，超过阈值的对象晋升到老年代
    promoteOldObjects();
}

// 老年代GC（Major GC）
public void majorGC() {
    if (fragmentationRatio > threshold) {
        markCompactGC(); // 碎片多时使用标记整理
    } else {
        markSweepGC();   // 否则使用标记清除
    }
}
```

**Hotspot虚拟机的实现：**
```
新生代（Young Generation）：
├── Eden区：8个单位
├── Survivor0：1个单位  } 使用复制算法
└── Survivor1：1个单位  }

老年代（Old Generation）：
└── 使用标记清除或标记整理算法
```

### 5. 算法选择策略

**根据对象存活率选择：**
```java
public GCAlgorithm selectAlgorithm(double survivalRate) {
    if (survivalRate < 0.5) {
        return COPYING;      // 存活率低，复制算法效率高
    } else if (fragmentationSevere()) {
        return MARK_COMPACT; // 碎片严重，需要整理
    } else {
        return MARK_SWEEP;   // 一般情况，标记清除
    }
}
```

### 6. 性能对比

| 算法 | 时间复杂度 | 空间复杂度 | 内存碎片 | 适用场景 |
|------|------------|------------|----------|----------|
| 标记清除 | O(存活对象数 + 总对象数) | O(1) | 有 | 老年代 |
| 复制算法 | O(存活对象数) | O(内存大小/2) | 无 | 新生代 |
| 标记整理 | O(总对象数) | O(1) | 无 | 老年代 |

### 7. 实际应用场景

**新生代场景：**
```java
// 大量临时对象
public void processRequests() {
    for (Request request : requests) {
        // 创建大量临时对象处理请求
        Response response = new Response();
        Data data = parseRequest(request);
        Result result = processData(data);
        response.setResult(result);
        // 这些对象在方法结束后就可以回收
    }
}
```

**老年代场景：**
```java
// 长期存活的对象
public class CacheManager {
    private static final Map<String, Object> cache = new HashMap<>();

    // 缓存对象长期存活，适合标记清除算法
    public void cacheData(String key, Object data) {
        cache.put(key, data);
    }
}
```

### 总结

三种基本垃圾回收算法各有特点：
- **标记清除**：简单但有碎片，适合存活对象多的老年代
- **复制算法**：高效无碎片但空间利用率低，适合存活对象少的新生代
- **标记整理**：解决碎片但开销大，适合碎片严重的老年代

现代JVM通过分代收集策略，在不同区域使用最适合的算法，实现了垃圾回收的最优化。
