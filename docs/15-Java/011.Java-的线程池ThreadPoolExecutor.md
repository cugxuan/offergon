---
title: Java 的线程池（ThreadPoolExecutor）
tags:
  - Java
status: robot
class: Java
slug: threadpoolexecutor-in-java
ref:
---

## 要点提炼

- **核心参数**：核心线程数、最大线程数、队列、拒绝策略、存活时间
- **执行流程**：核心线程→队列→临时线程→拒绝策略
- **预设线程池**：四种类型及其适用场景
- **参数配置**：合理设置避免OOM和资源浪费

## 详细解答

### 1. ThreadPoolExecutor核心参数

```java
public ThreadPoolExecutor(
    int corePoolSize,              // 核心线程数
    int maximumPoolSize,           // 最大线程数
    long keepAliveTime,            // 空闲线程存活时间
    TimeUnit unit,                 // 时间单位
    BlockingQueue<Runnable> workQueue,  // 任务队列
    ThreadFactory threadFactory,   // 线程工厂
    RejectedExecutionHandler handler     // 拒绝策略
)
```

**各参数详解：**

- **corePoolSize（核心线程数）**：线程池常驻的线程数量，即使空闲也不会被回收
- **maximumPoolSize（最大线程数）**：线程池能创建的最大线程数量
- **keepAliveTime（存活时间）**：非核心线程空闲后的存活时间
- **workQueue（工作队列）**：存储待执行任务的阻塞队列
- **threadFactory（线程工厂）**：创建新线程的工厂，可自定义线程名称、优先级等
- **handler（拒绝策略）**：当队列满且线程数达到上限时的处理策略

### 2. 任务执行流程

线程池处理任务的核心流程：

```
1. 提交任务
2. 当前线程数 < corePoolSize？
   ├── 是：创建核心线程执行任务
   └── 否：进入步骤3
3. 工作队列未满？
   ├── 是：任务加入队列等待
   └── 否：进入步骤4
4. 当前线程数 < maximumPoolSize？
   ├── 是：创建临时线程执行任务
   └── 否：执行拒绝策略
```

**关键点：**
- 优先使用核心线程
- 核心线程忙时任务进队列
- 队列满时创建临时线程
- 达到最大线程数时执行拒绝策略

### 3. 常用工作队列类型

```java
// 1. 无界队列（容量为Integer.MAX_VALUE）
BlockingQueue<Runnable> queue1 = new LinkedBlockingQueue<>();

// 2. 有界队列
BlockingQueue<Runnable> queue2 = new ArrayBlockingQueue<>(100);

// 3. 同步队列（无容量，直接交换）
BlockingQueue<Runnable> queue3 = new SynchronousQueue<>();

// 4. 优先级队列
BlockingQueue<Runnable> queue4 = new PriorityBlockingQueue<>();
```

### 4. 拒绝策略

Java提供四种预设拒绝策略：

```java
// 1. AbortPolicy（默认）：抛出RejectedExecutionException
ThreadPoolExecutor.AbortPolicy abortPolicy = new ThreadPoolExecutor.AbortPolicy();

// 2. CallerRunsPolicy：由调用线程执行任务
ThreadPoolExecutor.CallerRunsPolicy callerRunsPolicy = new ThreadPoolExecutor.CallerRunsPolicy();

// 3. DiscardPolicy：静默丢弃任务
ThreadPoolExecutor.DiscardPolicy discardPolicy = new ThreadPoolExecutor.DiscardPolicy();

// 4. DiscardOldestPolicy：丢弃队列中最老的任务
ThreadPoolExecutor.DiscardOldestPolicy discardOldestPolicy = new ThreadPoolExecutor.DiscardOldestPolicy();
```

### 5. 四种预设线程池

```java
// 1. FixedThreadPool：固定大小线程池
ExecutorService fixedPool = Executors.newFixedThreadPool(10);
// 特点：核心线程数=最大线程数，使用无界队列
// 适用：负载较重且任务执行时间长的场景

// 2. CachedThreadPool：缓存线程池
ExecutorService cachedPool = Executors.newCachedThreadPool();
// 特点：核心线程数=0，最大线程数=Integer.MAX_VALUE，使用SynchronousQueue
// 适用：执行大量短期异步任务

// 3. SingleThreadExecutor：单线程池
ExecutorService singlePool = Executors.newSingleThreadExecutor();
// 特点：只有一个核心线程，使用无界队列
// 适用：需要保证任务执行顺序的场景

// 4. ScheduledThreadPool：定时任务线程池
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(5);
// 特点：支持定时和周期性任务执行
// 适用：需要定时执行任务的场景
```

### 6. 线程池状态

线程池有5种状态：

```java
// RUNNING：接受新任务并处理队列中的任务
// SHUTDOWN：不接受新任务，但处理队列中的任务
// STOP：不接受新任务，不处理队列中的任务，中断正在执行的任务
// TIDYING：所有任务已终止，workerCount为0
// TERMINATED：terminated()方法执行完成
```

### 7. 最佳实践

**参数配置建议：**

```java
// CPU密集型任务
int corePoolSize = Runtime.getRuntime().availableProcessors();
int maximumPoolSize = corePoolSize + 1;

// IO密集型任务
int corePoolSize = Runtime.getRuntime().availableProcessors() * 2;
int maximumPoolSize = corePoolSize * 2;

// 混合型任务（根据具体场景调整）
int corePoolSize = Runtime.getRuntime().availableProcessors();
int maximumPoolSize = corePoolSize * 2;
```

**使用规范：**

```java
// 1. 使用ThreadPoolExecutor构造函数，避免使用Executors
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                                    // 核心线程数
    10,                                   // 最大线程数
    60L, TimeUnit.SECONDS,               // 空闲线程存活时间
    new ArrayBlockingQueue<>(100),       // 有界队列
    new ThreadFactory() {                // 自定义线程工厂
        private AtomicInteger threadNumber = new AtomicInteger(1);
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r, "custom-pool-" + threadNumber.getAndIncrement());
            thread.setDaemon(false);
            return thread;
        }
    },
    new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
);

// 2. 监控线程池状态
System.out.println("活跃线程数：" + executor.getActiveCount());
System.out.println("队列大小：" + executor.getQueue().size());
System.out.println("已完成任务数：" + executor.getCompletedTaskCount());

// 3. 优雅关闭
executor.shutdown();
try {
    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        executor.shutdownNow();
    }
} catch (InterruptedException e) {
    executor.shutdownNow();
    Thread.currentThread().interrupt();
}
```

### 8. 常见问题与陷阱

**问题1：使用无界队列导致OOM**
```java
// 错误：使用无界队列
new LinkedBlockingQueue<>() // 容量为Integer.MAX_VALUE

// 正确：使用有界队列
new ArrayBlockingQueue<>(1000)
```

**问题2：不合理的线程数配置**
```java
// 错误：固定使用CPU核心数
int threadCount = Runtime.getRuntime().availableProcessors();

// 正确：根据任务类型调整
// CPU密集型：CPU核心数 + 1
// IO密集型：CPU核心数 * 2
// 混合型：根据IO等待时间比例调整
```

**问题3：忘记处理拒绝的任务**
```java
// 错误：使用默认的AbortPolicy但不处理异常
executor.execute(task); // 可能抛出RejectedExecutionException

// 正确：选择合适的拒绝策略或捕获异常
try {
    executor.execute(task);
} catch (RejectedExecutionException e) {
    // 处理被拒绝的任务
}
```

### 9. 面试重点

1. **核心参数的作用和配置原则**
2. **任务执行流程，特别是什么时候创建新线程**
3. **不同队列类型的特点和适用场景**
4. **四种拒绝策略的区别**
5. **为什么不推荐使用Executors工厂方法**
6. **如何根据任务类型配置线程数**
7. **线程池的监控和优雅关闭**
