---
title: Vue 的测试工具和最佳实践
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue-testing-tools-best-practices
ref:
---

## 核心要点

**Vue 测试分为单元测试（Vitest + Vue Test Utils）、组件测试（Cypress Component）和 E2E 测试（Playwright/Cypress）三个层次。最佳实践包括：测试用户行为而非实现细节、使用 data-testid 定位元素、模拟外部依赖、保持测试独立性和可读性。**

---

## 详细回答

### 一、Vue 测试体系概览

Vue 应用的测试可以分为三个层次：

```
测试金字塔（从底到顶）
        ╱  E2E 测试  ╲          少量、慢、全面
       ╱--------------╲
      ╱ 组件集成测试   ╲        适量、中速、真实
     ╱------------------╲
    ╱    单元测试        ╲      大量、快、隔离
   ╱----------------------╲
```

1. **单元测试（Unit Tests）**：测试独立的函数、组合式函数（Composables）
2. **组件测试（Component Tests）**：测试单个 Vue 组件的行为
3. **E2E 测试（End-to-End Tests）**：测试完整的用户流程

---

### 二、核心测试工具

#### 1. Vitest（推荐的测试运行器）

**为什么选择 Vitest？**
- 🚀 基于 Vite，启动速度极快
- 🔧 原生支持 ESM、TypeScript
- ⚡ 热更新支持（HMR）
- 🎯 与 Jest API 兼容
- 📊 内置代码覆盖率（c8/istanbul）

**安装配置：**
```bash
npm install -D vitest @vue/test-utils jsdom
```

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,           // 全局 API（describe、test、expect）
    environment: 'jsdom',    // 模拟浏览器环境
    setupFiles: './tests/setup.js', // 全局设置
    coverage: {
      reporter: ['text', 'html'], // 覆盖率报告
      exclude: ['node_modules/', 'tests/']
    }
  }
})
```

#### 2. Vue Test Utils（官方测试库）

**核心 API：**
- `mount()`：挂载组件，渲染子组件
- `shallowMount()`：浅挂载，不渲染子组件（已废弃，推荐用插槽存根）
- `wrapper.find()`：查找元素
- `wrapper.trigger()`：触发事件
- `wrapper.vm`：访问组件实例

**基础示例：**
```javascript
import { mount } from '@vue/test-utils'
import Counter from '@/components/Counter.vue'
import { describe, it, expect } from 'vitest'

describe('Counter.vue', () => {
  it('increments count when button is clicked', async () => {
    const wrapper = mount(Counter)

    // 查找按钮并触发点击
    const button = wrapper.find('[data-testid="increment"]')
    await button.trigger('click')

    // 断言文本更新
    expect(wrapper.text()).toContain('Count: 1')
  })
})
```

#### 3. Cypress（组件 + E2E 测试）

**组件测试示例：**
```javascript
// cypress/component/Counter.cy.js
import Counter from '@/components/Counter.vue'

describe('Counter Component', () => {
  it('mounts and increments', () => {
    cy.mount(Counter)
    cy.get('[data-testid="count"]').should('contain', '0')
    cy.get('[data-testid="increment"]').click()
    cy.get('[data-testid="count"]').should('contain', '1')
  })
})
```

**E2E 测试示例：**
```javascript
// cypress/e2e/login.cy.js
describe('Login Flow', () => {
  it('allows user to log in', () => {
    cy.visit('/login')
    cy.get('input[name="email"]').type('user@example.com')
    cy.get('input[name="password"]').type('password123')
    cy.get('button[type="submit"]').click()
    cy.url().should('include', '/dashboard')
    cy.contains('Welcome back!').should('be.visible')
  })
})
```

#### 4. Playwright（现代 E2E 方案）

**优势：**
- 支持多浏览器（Chrome、Firefox、Safari、Edge）
- 更快的执行速度
- 更好的调试体验

```javascript
// tests/e2e/login.spec.js
import { test, expect } from '@playwright/test'

test('user can log in', async ({ page }) => {
  await page.goto('http://localhost:3000/login')
  await page.fill('input[name="email"]', 'user@example.com')
  await page.fill('input[name="password"]', 'password123')
  await page.click('button[type="submit"]')
  await expect(page).toHaveURL(/.*dashboard/)
  await expect(page.locator('text=Welcome back!')).toBeVisible()
})
```

---

### 三、单元测试最佳实践

#### 1. 测试组合式函数（Composables）

```javascript
// composables/useCounter.js
import { ref } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue)

  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => count.value = initialValue

  return { count, increment, decrement, reset }
}
```

**测试代码：**
```javascript
// tests/useCounter.spec.js
import { useCounter } from '@/composables/useCounter'
import { describe, it, expect } from 'vitest'

describe('useCounter', () => {
  it('initializes with default value', () => {
    const { count } = useCounter()
    expect(count.value).toBe(0)
  })

  it('initializes with custom value', () => {
    const { count } = useCounter(10)
    expect(count.value).toBe(10)
  })

  it('increments count', () => {
    const { count, increment } = useCounter()
    increment()
    expect(count.value).toBe(1)
  })

  it('resets to initial value', () => {
    const { count, increment, reset } = useCounter(5)
    increment()
    increment()
    expect(count.value).toBe(7)
    reset()
    expect(count.value).toBe(5)
  })
})
```

#### 2. 测试纯函数/工具函数

```javascript
// utils/formatter.js
export function formatCurrency(amount) {
  return `$${amount.toFixed(2)}`
}

export function truncateText(text, maxLength) {
  if (text.length <= maxLength) return text
  return text.slice(0, maxLength) + '...'
}
```

**测试代码：**
```javascript
// tests/formatter.spec.js
import { formatCurrency, truncateText } from '@/utils/formatter'
import { describe, it, expect } from 'vitest'

describe('formatCurrency', () => {
  it('formats number as currency', () => {
    expect(formatCurrency(100)).toBe('$100.00')
    expect(formatCurrency(99.5)).toBe('$99.50')
  })
})

describe('truncateText', () => {
  it('returns text as is if under max length', () => {
    expect(truncateText('Hello', 10)).toBe('Hello')
  })

  it('truncates text with ellipsis', () => {
    expect(truncateText('Hello World', 5)).toBe('Hello...')
  })
})
```

---

### 四、组件测试最佳实践

#### 1. 测试用户交互

```vue
<!-- components/TodoList.vue -->
<template>
  <div>
    <input v-model="newTodo" @keyup.enter="addTodo" placeholder="Add todo" />
    <ul>
      <li v-for="todo in todos" :key="todo.id" :data-testid="`todo-${todo.id}`">
        {{ todo.text }}
        <button @click="removeTodo(todo.id)">Delete</button>
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const todos = ref([])
const newTodo = ref('')
let nextId = 1

const addTodo = () => {
  if (newTodo.value.trim()) {
    todos.value.push({ id: nextId++, text: newTodo.value })
    newTodo.value = ''
  }
}

const removeTodo = (id) => {
  todos.value = todos.value.filter(t => t.id !== id)
}
</script>
```

**测试代码：**
```javascript
// tests/components/TodoList.spec.js
import { mount } from '@vue/test-utils'
import TodoList from '@/components/TodoList.vue'
import { describe, it, expect } from 'vitest'

describe('TodoList.vue', () => {
  it('adds a new todo on enter key', async () => {
    const wrapper = mount(TodoList)
    const input = wrapper.find('input')

    // 输入文本并按 Enter
    await input.setValue('Buy milk')
    await input.trigger('keyup.enter')

    // 验证 todo 被添加
    expect(wrapper.text()).toContain('Buy milk')
    expect(wrapper.findAll('li')).toHaveLength(1)

    // 验证输入框被清空
    expect(input.element.value).toBe('')
  })

  it('removes a todo when delete button is clicked', async () => {
    const wrapper = mount(TodoList, {
      data() {
        return {
          todos: [{ id: 1, text: 'Test Todo' }]
        }
      }
    })

    expect(wrapper.text()).toContain('Test Todo')

    await wrapper.find('button').trigger('click')

    expect(wrapper.text()).not.toContain('Test Todo')
    expect(wrapper.findAll('li')).toHaveLength(0)
  })

  it('does not add empty todos', async () => {
    const wrapper = mount(TodoList)
    const input = wrapper.find('input')

    await input.setValue('   ') // 只有空格
    await input.trigger('keyup.enter')

    expect(wrapper.findAll('li')).toHaveLength(0)
  })
})
```

#### 2. 测试 Props 和 Events

```vue
<!-- components/UserCard.vue -->
<template>
  <div class="user-card">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <button @click="$emit('edit', user.id)">Edit</button>
    <button @click="$emit('delete', user.id)">Delete</button>
  </div>
</template>

<script setup>
defineProps({
  user: {
    type: Object,
    required: true
  }
})

defineEmits(['edit', 'delete'])
</script>
```

**测试代码：**
```javascript
// tests/components/UserCard.spec.js
import { mount } from '@vue/test-utils'
import UserCard from '@/components/UserCard.vue'
import { describe, it, expect } from 'vitest'

describe('UserCard.vue', () => {
  const user = { id: 1, name: 'John Doe', email: 'john@example.com' }

  it('displays user information', () => {
    const wrapper = mount(UserCard, {
      props: { user }
    })

    expect(wrapper.text()).toContain('John Doe')
    expect(wrapper.text()).toContain('john@example.com')
  })

  it('emits edit event with user id', async () => {
    const wrapper = mount(UserCard, {
      props: { user }
    })

    await wrapper.find('button[data-testid="edit"]').trigger('click')

    expect(wrapper.emitted()).toHaveProperty('edit')
    expect(wrapper.emitted('edit')[0]).toEqual([1])
  })

  it('emits delete event with user id', async () => {
    const wrapper = mount(UserCard, {
      props: { user }
    })

    await wrapper.find('button[data-testid="delete"]').trigger('click')

    expect(wrapper.emitted('delete')[0]).toEqual([1])
  })
})
```

#### 3. 测试异步操作

```vue
<!-- components/UserProfile.vue -->
<template>
  <div>
    <div v-if="loading">Loading...</div>
    <div v-else-if="error">Error: {{ error }}</div>
    <div v-else>
      <h2>{{ user.name }}</h2>
      <p>{{ user.bio }}</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { fetchUser } from '@/api/users'

const props = defineProps({
  userId: Number
})

const user = ref(null)
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    user.value = await fetchUser(props.userId)
  } catch (e) {
    error.value = e.message
  } finally {
    loading.value = false
  }
})
</script>
```

**测试代码：**
```javascript
// tests/components/UserProfile.spec.js
import { mount, flushPromises } from '@vue/test-utils'
import UserProfile from '@/components/UserProfile.vue'
import { fetchUser } from '@/api/users'
import { describe, it, expect, vi, beforeEach } from 'vitest'

// Mock API 函数
vi.mock('@/api/users', () => ({
  fetchUser: vi.fn()
}))

describe('UserProfile.vue', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('displays loading state initially', () => {
    fetchUser.mockReturnValue(new Promise(() => {})) // 永不 resolve

    const wrapper = mount(UserProfile, {
      props: { userId: 1 }
    })

    expect(wrapper.text()).toContain('Loading...')
  })

  it('displays user data after successful fetch', async () => {
    fetchUser.mockResolvedValue({
      name: 'John Doe',
      bio: 'Software Engineer'
    })

    const wrapper = mount(UserProfile, {
      props: { userId: 1 }
    })

    await flushPromises() // 等待所有 Promise 完成

    expect(wrapper.text()).toContain('John Doe')
    expect(wrapper.text()).toContain('Software Engineer')
    expect(wrapper.text()).not.toContain('Loading...')
  })

  it('displays error message on fetch failure', async () => {
    fetchUser.mockRejectedValue(new Error('Network error'))

    const wrapper = mount(UserProfile, {
      props: { userId: 1 }
    })

    await flushPromises()

    expect(wrapper.text()).toContain('Error: Network error')
  })
})
```

#### 4. 测试插槽（Slots）

```vue
<!-- components/Card.vue -->
<template>
  <div class="card">
    <header v-if="$slots.header">
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer v-if="$slots.footer">
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

**测试代码：**
```javascript
// tests/components/Card.spec.js
import { mount } from '@vue/test-utils'
import Card from '@/components/Card.vue'
import { describe, it, expect } from 'vitest'

describe('Card.vue', () => {
  it('renders default slot content', () => {
    const wrapper = mount(Card, {
      slots: {
        default: '<p>Main content</p>'
      }
    })

    expect(wrapper.html()).toContain('<p>Main content</p>')
  })

  it('renders named slots', () => {
    const wrapper = mount(Card, {
      slots: {
        header: '<h1>Title</h1>',
        default: '<p>Body</p>',
        footer: '<small>Footer</small>'
      }
    })

    expect(wrapper.html()).toContain('<h1>Title</h1>')
    expect(wrapper.html()).toContain('<p>Body</p>')
    expect(wrapper.html()).toContain('<small>Footer</small>')
  })

  it('hides header when no slot provided', () => {
    const wrapper = mount(Card, {
      slots: {
        default: '<p>Content</p>'
      }
    })

    expect(wrapper.find('header').exists()).toBe(false)
  })
})
```

#### 5. 测试 Vuex/Pinia 状态管理

**Pinia 示例：**
```javascript
// stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  actions: {
    increment() {
      this.count++
    }
  }
})
```

**测试代码：**
```javascript
// tests/stores/counter.spec.js
import { setActivePinia, createPinia } from 'pinia'
import { useCounterStore } from '@/stores/counter'
import { describe, it, expect, beforeEach } from 'vitest'

describe('Counter Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('initializes with count 0', () => {
    const store = useCounterStore()
    expect(store.count).toBe(0)
  })

  it('increments count', () => {
    const store = useCounterStore()
    store.increment()
    expect(store.count).toBe(1)
  })
})
```

**在组件中测试 Store：**
```javascript
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import CounterComponent from '@/components/CounterComponent.vue'

describe('CounterComponent with Pinia', () => {
  it('uses counter store', () => {
    const wrapper = mount(CounterComponent, {
      global: {
        plugins: [createPinia()]
      }
    })

    expect(wrapper.text()).toContain('Count: 0')

    wrapper.find('button').trigger('click')

    expect(wrapper.text()).toContain('Count: 1')
  })
})
```

---

### 五、测试最佳实践

#### 1. 使用 data-testid 定位元素

```vue
<!-- ✅ 好：使用 data-testid -->
<button data-testid="submit-button">Submit</button>

<!-- ❌ 差：依赖 class 或文本 -->
<button class="btn btn-primary">Submit</button>
```

**原因：**
- class 可能因样式变化而改变
- 文本可能因国际化而变化
- `data-testid` 明确表示测试用途

#### 2. 测试行为，而非实现细节

```javascript
// ❌ 差：测试内部状态
it('sets loading to true', () => {
  wrapper.vm.loading = true
  expect(wrapper.vm.loading).toBe(true)
})

// ✅ 好：测试用户可见的行为
it('shows loading indicator', async () => {
  wrapper.vm.fetchData()
  await wrapper.vm.$nextTick()
  expect(wrapper.find('[data-testid="loading"]').exists()).toBe(true)
})
```

#### 3. 保持测试独立性

```javascript
// ❌ 差：测试之间有依赖
let wrapper
beforeAll(() => {
  wrapper = mount(Component)
})

it('test 1', () => {
  wrapper.vm.count++ // 修改了状态
})

it('test 2', () => {
  expect(wrapper.vm.count).toBe(0) // ❌ 依赖上一个测试
})

// ✅ 好：每个测试独立
beforeEach(() => {
  wrapper = mount(Component)
})

it('test 1', () => {
  wrapper.vm.count++
  expect(wrapper.vm.count).toBe(1)
})

it('test 2', () => {
  expect(wrapper.vm.count).toBe(0) // ✅ 独立验证
})
```

#### 4. 使用工厂函数创建测试数据

```javascript
// tests/factories/user.js
export function createUser(overrides = {}) {
  return {
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    role: 'user',
    ...overrides
  }
}

// 使用
import { createUser } from './factories/user'

it('displays admin badge for admin users', () => {
  const adminUser = createUser({ role: 'admin' })
  const wrapper = mount(UserCard, {
    props: { user: adminUser }
  })
  expect(wrapper.find('.admin-badge').exists()).toBe(true)
})
```

#### 5. Mock 外部依赖

```javascript
// ❌ 差：依赖真实 API
import axios from 'axios'

it('fetches data', async () => {
  const data = await axios.get('/api/users') // 真实请求
  // ...
})

// ✅ 好：Mock API
vi.mock('axios')

it('fetches data', async () => {
  axios.get.mockResolvedValue({ data: [{ id: 1, name: 'John' }] })
  const data = await fetchUsers()
  expect(data).toHaveLength(1)
})
```

#### 6. 测试边界情况

```javascript
describe('formatPrice', () => {
  it('handles normal prices', () => {
    expect(formatPrice(10.5)).toBe('$10.50')
  })

  it('handles zero', () => {
    expect(formatPrice(0)).toBe('$0.00')
  })

  it('handles negative numbers', () => {
    expect(formatPrice(-5)).toBe('-$5.00')
  })

  it('handles very large numbers', () => {
    expect(formatPrice(9999999.99)).toBe('$9,999,999.99')
  })

  it('throws error for non-numbers', () => {
    expect(() => formatPrice('abc')).toThrow()
  })
})
```

---

### 六、代码覆盖率

**配置覆盖率报告：**
```javascript
// vite.config.js
export default defineConfig({
  test: {
    coverage: {
      provider: 'v8', // 或 'istanbul'
      reporter: ['text', 'html', 'lcov'],
      include: ['src/**/*.{js,vue}'],
      exclude: [
        'src/main.js',
        'src/**/*.spec.js',
        'src/**/__tests__/*'
      ],
      statements: 80,
      branches: 80,
      functions: 80,
      lines: 80
    }
  }
})
```

**运行覆盖率测试：**
```bash
npm run test -- --coverage
```

**解读覆盖率指标：**
- **Statements（语句覆盖）**：执行了多少语句
- **Branches（分支覆盖）**：if/else 的所有分支是否都测试到
- **Functions（函数覆盖）**：调用了多少函数
- **Lines（行覆盖）**：执行了多少行代码

**目标：**
- 核心业务逻辑：90%+
- 工具函数：100%
- UI 组件：70-80%
- 整体项目：80%+

---

### 七、CI/CD 集成

**GitHub Actions 示例：**
```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run test:unit
      - run: npm run test:e2e
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
```

---

### 总结

Vue 测试的最佳实践：

1. **工具选择**：Vitest（单元） + Vue Test Utils（组件） + Playwright（E2E）
2. **测试原则**：测试行为而非实现、保持独立性、使用语义化定位器
3. **覆盖范围**：核心业务逻辑 > 工具函数 > UI 组件
4. **性能优化**：Mock 外部依赖、并行运行测试、使用快照测试（慎用）
5. **团队协作**：强制覆盖率门槛、代码审查包含测试、CI/CD 自动化

好的测试不仅能捕获 bug，更能作为活文档，帮助团队理解代码意图，提升重构信心。
