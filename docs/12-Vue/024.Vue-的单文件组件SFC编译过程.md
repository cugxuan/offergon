---
title: Vue 的单文件组件（SFC）编译过程
tags:
  - 前端Vue
status: robot
class: 前端Vue
slug: vue-sfc-compilation-process
ref:
---

## 核心要点

**Vue 单文件组件（SFC）的编译分为三大阶段：解析（Parse）将 .vue 文件拆分为 template、script、style 三个描述对象；转换（Transform）将模板编译为渲染函数、处理 script setup 语法糖；生成（Generate）输出最终的 JavaScript 和 CSS 代码。整个过程由 @vue/compiler-sfc 完成。**

---

## 详细回答

### 一、什么是单文件组件（SFC）？

Vue 单文件组件（Single-File Component）是以 `.vue` 为扩展名的文件，包含三个部分：

```vue
<template>
  <div class="hello">{{ message }}</div>
</template>

<script>
export default {
  data() {
    return { message: 'Hello Vue!' }
  }
}
</script>

<style scoped>
.hello {
  color: red;
}
</style>
```

这种格式无法直接在浏览器中运行，需要经过**编译**转换为浏览器可执行的 JavaScript 代码。

---

### 二、SFC 编译的整体流程

Vue SFC 的编译过程主要由 `@vue/compiler-sfc` 包完成，分为以下三个主要阶段：

```
.vue 文件
   ↓
1. 解析（Parse）
   ↓
SFC 描述对象（descriptor）
   ↓
2. 转换（Transform）
   - 编译 template
   - 处理 script
   - 处理 style
   ↓
3. 生成（Generate）
   ↓
最终代码（.js + .css）
```

---

### 三、第一阶段：解析（Parse）

#### 1. 目标
将 `.vue` 文件内容解析为结构化的**描述对象**（SFCDescriptor），包含 template、script、style 等各个区块的信息。

#### 2. 核心 API

```javascript
import { parse } from '@vue/compiler-sfc'

const source = `
<template>
  <div>{{ message }}</div>
</template>

<script setup>
import { ref } from 'vue'
const message = ref('Hello')
</script>

<style scoped>
div { color: red; }
</style>
`

const { descriptor, errors } = parse(source, {
  filename: 'App.vue',
  sourceMap: true
})
```

#### 3. 描述对象结构

```typescript
interface SFCDescriptor {
  filename: string            // 文件名
  source: string             // 源代码
  template: SFCTemplateBlock | null  // <template> 区块
  script: SFCScriptBlock | null      // <script> 区块
  scriptSetup: SFCScriptBlock | null // <script setup> 区块
  styles: SFCStyleBlock[]            // <style> 区块（可多个）
  customBlocks: SFCBlock[]           // 自定义区块（如 <docs>）
}

// template 区块
interface SFCTemplateBlock {
  type: 'template'
  content: string            // 模板内容
  loc: SourceLocation        // 位置信息
  attrs: Record<string, string | true> // 属性（如 lang="pug"）
}

// script 区块
interface SFCScriptBlock {
  type: 'script'
  content: string            // 脚本内容
  loc: SourceLocation
  attrs: Record<string, string | true> // 属性（如 setup、lang="ts"）
  setup?: boolean            // 是否是 setup 脚本
}

// style 区块
interface SFCStyleBlock {
  type: 'style'
  content: string            // 样式内容
  loc: SourceLocation
  attrs: Record<string, string | true> // 属性（如 scoped、lang="scss"）
  scoped?: boolean           // 是否是 scoped 样式
  module?: string | boolean  // 是否是 CSS Modules
}
```

#### 4. 解析示例输出

```javascript
{
  descriptor: {
    filename: 'App.vue',
    template: {
      type: 'template',
      content: '\n  <div>{{ message }}</div>\n',
      loc: { start: {...}, end: {...} },
      attrs: {}
    },
    scriptSetup: {
      type: 'script',
      content: "\nimport { ref } from 'vue'\nconst message = ref('Hello')\n",
      loc: { start: {...}, end: {...} },
      attrs: { setup: true },
      setup: true
    },
    styles: [
      {
        type: 'style',
        content: '\ndiv { color: red; }\n',
        loc: { start: {...}, end: {...} },
        attrs: { scoped: true },
        scoped: true
      }
    ],
    customBlocks: []
  },
  errors: []
}
```

---

### 四、第二阶段：转换（Transform）

这个阶段将各个区块转换为可执行代码，是最复杂的部分。

#### 1. 编译 Template

**目标：** 将模板字符串编译为渲染函数（render function）。

```javascript
import { compileTemplate } from '@vue/compiler-sfc'

const { code, errors } = compileTemplate({
  source: descriptor.template.content,
  filename: descriptor.filename,
  id: 'data-v-1234', // 用于 scoped CSS
  scoped: descriptor.styles.some(s => s.scoped),
  compilerOptions: {
    mode: 'module' // 或 'function'
  }
})
```

**编译结果示例：**

```javascript
// 输入模板
<div class="container">
  <h1>{{ title }}</h1>
  <p v-if="show">内容</p>
</div>

// 输出渲染函数
import { toDisplayString as _toDisplayString, openBlock as _openBlock,
         createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { class: "container" }, [
    _createElementVNode("h1", null, _toDisplayString(_ctx.title), 1 /* TEXT */),
    (_ctx.show)
      ? (_openBlock(), _createElementBlock("p", { key: 0 }, "内容"))
      : _createCommentVNode("v-if", true)
  ]))
}
```

**关键优化：**
- **静态提升**：静态节点提取到渲染函数外
- **PatchFlag**：标记动态内容类型
- **缓存事件处理器**：避免重复创建函数

#### 2. 编译 Script

**2.1 普通 script 处理**

普通的 `<script>` 区块直接输出，但需要处理：
- 默认导出对象的合并
- 导入语句的提取
- TypeScript 转译（如果使用 `lang="ts"`）

**2.2 script setup 语法糖处理**

这是 Vue 3 最复杂的编译部分，由 `compileScript` 函数完成。

```javascript
import { compileScript } from '@vue/compiler-sfc'

const compiledScript = compileScript(descriptor, {
  id: 'data-v-1234',
  inlineTemplate: true // 是否内联模板到 setup 中
})
```

**script setup 的转换规则：**

```vue
<!-- 源代码 -->
<script setup>
import { ref, computed } from 'vue'
import MyComponent from './MyComponent.vue'

const count = ref(0)
const double = computed(() => count.value * 2)

defineProps({
  title: String
})

defineEmits(['update'])

defineExpose({
  count
})
</script>
```

**编译后：**

```javascript
import { ref, computed, defineComponent } from 'vue'
import MyComponent from './MyComponent.vue'

export default defineComponent({
  props: {
    title: String
  },
  emits: ['update'],
  setup(__props, { expose, emit }) {
    const count = ref(0)
    const double = computed(() => count.value * 2)

    expose({
      count
    })

    // 自动返回顶层绑定（给模板使用）
    return {
      count,
      double,
      MyComponent
    }
  }
})
```

**处理要点：**
- 顶层变量、函数、import 自动暴露给模板
- `defineProps`、`defineEmits` 宏编译为组件选项
- `defineExpose` 编译为 expose() 调用
- 自动生成 return 语句

#### 3. 编译 Style

**目标：** 处理 CSS 预处理器（Sass、Less）、Scoped CSS、CSS Modules。

```javascript
import { compileStyle } from '@vue/compiler-sfc'

const { code, errors } = compileStyle({
  source: descriptor.styles[0].content,
  filename: descriptor.filename,
  id: 'data-v-1234',
  scoped: descriptor.styles[0].scoped,
  preprocessLang: 'scss' // 预处理器
})
```

**3.1 Scoped CSS 处理**

原理：为选择器添加唯一的属性选择器。

```css
/* 源代码 */
<style scoped>
.container {
  color: red;
}
.container .title {
  font-size: 20px;
}
</style>

/* 编译后 */
.container[data-v-1234] {
  color: red;
}
.container .title[data-v-1234] {
  font-size: 20px;
}
```

同时，模板中的元素会被添加对应的属性：
```html
<!-- 编译后的模板 -->
<div class="container" data-v-1234>
  <h1 class="title" data-v-1234>标题</h1>
</div>
```

**深度选择器：**
```css
/* 源代码 */
.container :deep(.child) {
  color: blue;
}

/* 编译后 */
.container[data-v-1234] .child {
  color: blue;
}
```

**3.2 CSS Modules 处理**

```vue
<style module>
.red {
  color: red;
}
</style>

<script setup>
// 自动注入 $style 对象
import { useCssModule } from 'vue'
const $style = useCssModule()
</script>

<template>
  <div :class="$style.red">文本</div>
</template>
```

编译后生成唯一的类名：
```css
._red_1a2b3 {
  color: red;
}
```

---

### 五、第三阶段：生成（Generate）

将编译后的各个部分组合成最终的可执行代码。

#### 完整输出示例

**输入：**
```vue
<template>
  <div class="hello">{{ message }}</div>
</template>

<script setup>
import { ref } from 'vue'
const message = ref('Hello Vue!')
</script>

<style scoped>
.hello {
  color: red;
}
</style>
```

**输出（JavaScript 部分）：**
```javascript
import { ref, defineComponent } from 'vue'
import { createElementVNode, toDisplayString, openBlock, createElementBlock } from 'vue'

const _sfc_main = defineComponent({
  setup(__props) {
    const message = ref('Hello Vue!')

    return { message }
  }
})

function _sfc_render(_ctx, _cache) {
  return (openBlock(), createElementBlock("div", {
    class: "hello",
    "data-v-7ba5bd90": ""
  }, toDisplayString(_ctx.message), 1))
}

_sfc_main.render = _sfc_render
_sfc_main.__scopeId = "data-v-7ba5bd90"

export default _sfc_main
```

**输出（CSS 部分）：**
```css
.hello[data-v-7ba5bd90] {
  color: red;
}
```

---

### 六、构建工具的集成

在实际开发中，SFC 编译由构建工具（Vite、Webpack）自动完成。

#### 1. Vite 中的处理

Vite 使用 `@vitejs/plugin-vue` 插件：

```javascript
// vite.config.js
import vue from '@vitejs/plugin-vue'

export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // 自定义编译选项
        }
      },
      script: {
        defineModel: true, // 启用 defineModel
        propsDestructure: true // 启用 props 解构
      }
    })
  ]
}
```

**处理流程：**
1. Vite 拦截 `.vue` 文件请求
2. 插件调用 `@vue/compiler-sfc` 编译
3. 返回编译后的 JavaScript 模块
4. 浏览器直接执行（HMR 支持热更新）

#### 2. Webpack 中的处理

使用 `vue-loader`：

```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ]
}
```

**处理流程：**
1. `vue-loader` 解析 `.vue` 文件
2. 将 template、script、style 分别转换为 Webpack 模块
3. 通过不同的 loader 处理（babel-loader、sass-loader 等）
4. 最终打包为 bundle

---

### 七、特殊功能的编译

#### 1. 自定义块（Custom Blocks）

```vue
<docs>
这是组件文档
</docs>

<i18n>
{
  "en": { "hello": "Hello" },
  "zh": { "hello": "你好" }
}
</i18n>
```

通过插件自定义处理：
```javascript
// vite.config.js
import vue from '@vitejs/plugin-vue'

export default {
  plugins: [
    vue({
      customElement: true
    }),
    {
      name: 'custom-block-plugin',
      transform(code, id) {
        if (id.endsWith('.vue?type=docs')) {
          // 处理 <docs> 块
        }
      }
    }
  ]
}
```

#### 2. TypeScript 支持

```vue
<script setup lang="ts">
import { ref, Ref } from 'vue'

const count: Ref<number> = ref(0)

interface Props {
  title: string
}

defineProps<Props>()
</script>
```

编译器会：
1. 提取类型信息（用于类型检查）
2. 移除类型标注（生成 JavaScript）
3. 生成类型声明文件（`.d.ts`）

---

### 八、编译优化技术

#### 1. 静态提升（Hoisting）

```javascript
// 优化前
function render() {
  return h('div', [
    h('p', 'static'), // 每次都创建
    h('p', dynamicText)
  ])
}

// 优化后
const _hoisted_1 = h('p', 'static') // 提升到外部
function render() {
  return h('div', [
    _hoisted_1,
    h('p', dynamicText)
  ])
}
```

#### 2. 预字符串化

```javascript
// 20+ 个连续静态节点直接生成 HTML 字符串
const _hoisted_1 = createStaticVNode(
  "<p>静态1</p><p>静态2</p>...<p>静态20</p>",
  20
)
```

#### 3. 缓存事件处理器

```javascript
// 优化前
<button @click="handleClick">点击</button>
// 每次渲染都创建新函数

// 优化后
<button @click="_cache[0] || (_cache[0] = handleClick)">点击</button>
// 缓存函数引用
```

---

### 九、调试编译结果

#### 方法 1：使用 Vue SFC Playground
访问 [https://play.vuejs.org/](https://play.vuejs.org/)，输入 SFC 代码，查看编译输出。

#### 方法 2：本地测试脚本

```javascript
import { parse, compileScript, compileTemplate } from '@vue/compiler-sfc'
import fs from 'fs'

const source = fs.readFileSync('App.vue', 'utf-8')
const { descriptor } = parse(source, { filename: 'App.vue' })

// 编译 script
const compiledScript = compileScript(descriptor, { id: 'test' })
console.log('Script:', compiledScript.content)

// 编译 template
const compiledTemplate = compileTemplate({
  source: descriptor.template.content,
  filename: 'App.vue',
  id: 'test'
})
console.log('Template:', compiledTemplate.code)
```

#### 方法 3：查看 Vite 构建输出

```bash
# 开发模式下查看浏览器 Network 面板
# 可以看到 .vue 文件被编译为 .js 的结果

# 或者使用 vite-plugin-inspect
npm i -D vite-plugin-inspect
```

```javascript
// vite.config.js
import inspect from 'vite-plugin-inspect'

export default {
  plugins: [vue(), inspect()] // 访问 /__inspect/ 查看编译结果
}
```

---

### 十、性能优化建议

1. **合理拆分组件**
   - 小组件编译更快
   - 利于代码分割和按需加载

2. **使用 `<script setup>`**
   - 编译产物更精简
   - 自动优化（Tree Shaking 友好）

3. **避免过度使用动态特性**
   ```vue
   <!-- ❌ 过度动态 -->
   <component :is="dynamicComponent" v-bind="dynamicProps" />

   <!-- ✅ 尽可能静态 -->
   <MyComponent :title="title" :count="count" />
   ```

4. **利用编译时宏**
   ```vue
   <script setup>
   // ✅ 编译时常量
   const CONFIG = { /* ... */ }

   // ✅ 类型安全的 props
   defineProps<{ title: string }>()
   </script>
   ```

---

### 总结

Vue SFC 的编译是一个复杂但高效的过程：

1. **解析阶段**：将 `.vue` 文件拆分为结构化数据
2. **转换阶段**：
   - Template → 渲染函数（优化 diff）
   - Script Setup → 标准组件选项
   - Style → Scoped CSS / CSS Modules
3. **生成阶段**：输出可执行的 JavaScript 和 CSS

整个过程由 `@vue/compiler-sfc` 驱动，配合构建工具（Vite/Webpack）实现开发环境的热更新和生产环境的优化打包。理解这个流程有助于我们：
- 更好地利用 Vue 3 的编译优化特性
- 排查编译相关的错误
- 编写自定义的 SFC 插件
