---
title: Vue 2 和 Vue 3 的响应式原理区别（Object.defineProperty vs Proxy）
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue2-vue3-reactivity-diff-proxy-vs-defineproperty
ref:
---

## 核心要点

- **Vue 2**：基于 `Object.defineProperty`，通过递归遍历劫持对象属性的 getter/setter
- **Vue 3**：基于 `Proxy`，直接代理整个对象，性能更好、功能更强
- **关键区别**：Vue 2 无法监听属性新增/删除和数组索引变化，Vue 3 全面支持
- **性能对比**：Proxy 按需代理，defineProperty 需要递归遍历全部属性

---

## 详细回答

### 一、Vue 2 的响应式原理（Object.defineProperty）

#### 1.1 实现机制

Vue 2 使用 `Object.defineProperty` 来拦截对象属性的访问和修改：

```javascript
function defineReactive(obj, key, val) {
  const dep = new Dep(); // 依赖收集器

  // 递归处理嵌套对象
  observe(val);

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      // 依赖收集：当前正在执行的 Watcher 订阅此属性
      if (Dep.target) {
        dep.depend();
      }
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      val = newVal;
      // 新值也需要观测
      observe(newVal);
      // 通知所有订阅者更新
      dep.notify();
    }
  });
}

function observe(value) {
  if (typeof value !== 'object' || value === null) return;

  // 遍历对象的每个属性
  Object.keys(value).forEach(key => {
    defineReactive(value, key, value[key]);
  });
}
```

#### 1.2 核心流程

1. **初始化阶段**：递归遍历 data 对象的所有属性，为每个属性添加 getter/setter
2. **依赖收集**：组件渲染时触发 getter，收集当前 Watcher（视图依赖）
3. **派发更新**：数据修改时触发 setter，通知所有依赖的 Watcher 重新渲染

#### 1.3 存在的局限性

```javascript
// ❌ 无法检测属性的新增和删除
const vm = new Vue({
  data: {
    user: { name: 'Alice' }
  }
});

vm.user.age = 18; // 不会触发更新
delete vm.user.name; // 不会触发更新

// ✅ 需要使用 Vue.set / Vue.delete
Vue.set(vm.user, 'age', 18);
Vue.delete(vm.user, 'name');

// ❌ 无法监听数组索引和 length 的变化
vm.items[0] = 'new'; // 不会触发更新
vm.items.length = 0; // 不会触发更新

// ✅ 需要使用变异方法
vm.items.splice(0, 1, 'new');
```

**为什么有这些限制？**
- `Object.defineProperty` 只能劫持**已存在**的属性
- 初始化时未声明的属性无法被劫持
- 出于性能考虑，Vue 2 没有劫持数组索引（数组可能很长）

---

### 二、Vue 3 的响应式原理（Proxy）

#### 2.1 实现机制

Vue 3 使用 ES6 的 `Proxy` 代理整个对象：

```javascript
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);

      // 依赖收集
      track(target, key);

      // 嵌套对象的懒代理（性能优化）
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }

      return result;
    },

    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);

      // 只在值真正改变时触发更新
      if (oldValue !== value) {
        trigger(target, key);
      }

      return result;
    },

    deleteProperty(target, key) {
      const hadKey = Object.hasOwnProperty.call(target, key);
      const result = Reflect.deleteProperty(target, key);

      // 删除属性时触发更新
      if (hadKey && result) {
        trigger(target, key);
      }

      return result;
    },

    has(target, key) {
      const result = Reflect.has(target, key);
      track(target, key);
      return result;
    },

    ownKeys(target) {
      track(target, 'iterate');
      return Reflect.ownKeys(target);
    }
  });
}
```

#### 2.2 关键优势

```javascript
const state = reactive({
  user: { name: 'Alice' }
});

// ✅ 支持属性的动态新增
state.user.age = 18; // 自动触发更新

// ✅ 支持属性删除
delete state.user.name; // 自动触发更新

// ✅ 支持数组索引修改
const arr = reactive([1, 2, 3]);
arr[0] = 99; // 自动触发更新
arr.length = 0; // 自动触发更新

// ✅ 支持 Map、Set、WeakMap、WeakSet
const map = reactive(new Map());
map.set('key', 'value'); // 自动触发更新
```

#### 2.3 性能优化

**懒代理（Lazy Reactive）**：
```javascript
// Vue 2：初始化时递归处理所有嵌套对象
const data = {
  level1: {
    level2: {
      level3: { /* 深层嵌套 */ }
    }
  }
};
// 初始化时会立即递归处理 level1、level2、level3

// Vue 3：访问时才代理嵌套对象
const state = reactive(data);
// 只有在访问 state.level1.level2 时才会代理 level2
```

---

### 三、核心区别对比表

| 特性 | Vue 2 (Object.defineProperty) | Vue 3 (Proxy) |
|------|------------------------------|---------------|
| **监听方式** | 遍历对象属性，逐个劫持 getter/setter | 代理整个对象，拦截 13 种操作 |
| **新增属性** | ❌ 不支持（需要 `Vue.set`） | ✅ 原生支持 |
| **删除属性** | ❌ 不支持（需要 `Vue.delete`） | ✅ 原生支持 |
| **数组索引** | ❌ 不支持（需要变异方法） | ✅ 原生支持 |
| **数组 length** | ❌ 不支持 | ✅ 原生支持 |
| **Map/Set** | ❌ 不支持 | ✅ 原生支持 |
| **嵌套对象** | 初始化时递归处理（性能差） | 访问时才代理（懒代理，性能好） |
| **性能** | 初始化慢，对象越深越慢 | 初始化快，按需代理 |
| **浏览器兼容性** | IE9+ | IE11+（不支持 IE） |

---

### 四、实际应用场景对比

#### 场景 1：动态表单字段

```javascript
// Vue 2：繁琐的响应式处理
methods: {
  addField() {
    // ❌ 直接赋值不会触发更新
    // this.formData.newField = ''

    // ✅ 必须使用 Vue.set
    this.$set(this.formData, 'newField', '');
  }
}

// Vue 3：自然的 JavaScript 写法
const formData = reactive({});
function addField() {
  formData.newField = ''; // ✅ 直接赋值即可
}
```

#### 场景 2：数组操作

```javascript
// Vue 2：限制较多
this.list[0] = newItem; // ❌ 不会更新
this.list.length = 0;   // ❌ 不会更新

this.$set(this.list, 0, newItem); // ✅ 需要 $set
this.list.splice(0);              // ✅ 使用变异方法

// Vue 3：符合直觉
list.value[0] = newItem; // ✅ 直接修改
list.value.length = 0;   // ✅ 直接清空
```

#### 场景 3：深层嵌套对象

```javascript
// Vue 2：初始化时全量递归，性能差
data() {
  return {
    deepObject: {
      level1: { level2: { level3: { /* 1000 个属性 */ } } }
    }
  };
}
// 即使不访问 level3，初始化时也会递归处理

// Vue 3：按需代理，性能好
const state = reactive({
  deepObject: {
    level1: { level2: { level3: { /* 1000 个属性 */ } } }
  }
});
// 只有访问到 level3 时才会代理它
```

---

### 五、面试回答建议

**简洁版（1-2 分钟）**：
> Vue 2 使用 `Object.defineProperty` 递归劫持对象的每个属性，通过 getter 收集依赖，通过 setter 触发更新。但它无法监听属性的新增删除和数组索引变化，需要使用 `$set` 等 API。
>
> Vue 3 改用 `Proxy` 代理整个对象，可以拦截包括属性新增、删除、数组索引在内的 13 种操作。同时采用懒代理策略，只在访问嵌套对象时才进行代理，性能更优。这让我们可以用更自然的 JavaScript 语法操作响应式数据。

**深入版（3-5 分钟）**：
在简洁版基础上，可以补充：
1. **依赖收集机制**：Dep、Watcher 的关系
2. **具体代码示例**：展示 Vue 2 和 Vue 3 处理动态属性的差异
3. **性能数据**：Vue 3 初始化速度提升、内存占用降低的具体数值
4. **兼容性考虑**：Proxy 不支持 IE11 以下，这是 Vue 3 的权衡

---

### 六、扩展知识点

#### 6.1 为什么 Vue 3 不完全抛弃 Object.defineProperty？

Vue 3 的 `ref` API 内部仍使用 `Object.defineProperty`：

```javascript
class RefImpl {
  constructor(value) {
    this._value = convert(value);
  }

  get value() {
    track(this, 'value');
    return this._value;
  }

  set value(newVal) {
    this._value = convert(newVal);
    trigger(this, 'value');
  }
}
```

原因：`ref` 包装的是单个值，不需要 Proxy 的复杂拦截能力。

#### 6.2 Proxy 的性能开销

虽然 Proxy 更强大，但也有开销：
- **代理创建成本**：每次访问嵌套对象都需要创建新代理
- **拦截调用成本**：每次操作都要经过 handler 函数

Vue 3 通过以下方式优化：
- **缓存代理对象**：同一对象只创建一次代理
- **跳过只读对象**：使用 `shallowReactive` 减少不必要的深层代理
- **编译时优化**：静态节点跳过响应式处理
