---
title: Vue 的组件通信方式（props、emit、provide/inject）
tags:
  - 前端Vue
status: robot
class: 前端Vue
slug: vue-component-communication-methods
ref:
---

## 核心要点

- **props/emit**：父子组件通信的标准方式（单向数据流）
- **provide/inject**：跨层级依赖注入，避免 props 逐层传递
- **其他方式**：$refs、EventBus（不推荐）、Vuex/Pinia（全局状态）
- **最佳实践**：优先使用 props/emit，跨层级用 provide/inject，复杂状态用状态管理库

---

## 详细解答

### 一、Props：父传子（单向数据流）

#### 1. 基础用法

```javascript
// 父组件
<template>
  <ChildComponent
    :title="pageTitle"
    :count="counter"
    :user-info="userData"
  />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const pageTitle = ref('Dashboard')
const counter = ref(10)
const userData = ref({ name: 'Alice', age: 25 })
</script>

// 子组件
<template>
  <div>
    <h1>{{ title }}</h1>
    <p>Count: {{ count }}</p>
    <p>User: {{ userInfo.name }}</p>
  </div>
</template>

<script setup>
import { defineProps } from 'vue'

// Vue 3 Composition API 写法
const props = defineProps({
  title: {
    type: String,
    required: true,
    default: 'Default Title'
  },
  count: {
    type: Number,
    default: 0
  },
  userInfo: {
    type: Object,
    required: true,
    validator: (value) => {
      // 自定义校验
      return value.name && value.age > 0
    }
  }
})

// 访问 props
console.log(props.title)
</script>
```

#### 2. Props 类型定义（TypeScript）

```typescript
<script setup lang="ts">
interface UserInfo {
  name: string
  age: number
  email?: string
}

interface Props {
  title: string
  count?: number
  userInfo: UserInfo
}

// 方式 1：使用 withDefaults
const props = withDefaults(defineProps<Props>(), {
  count: 0
})

// 方式 2：使用运行时声明
const props = defineProps({
  title: {
    type: String,
    required: true
  },
  count: {
    type: Number,
    default: 0
  },
  userInfo: {
    type: Object as PropType<UserInfo>,
    required: true
  }
})
</script>
```

#### 3. Props 的重要规则

```javascript
// ❌ 错误：子组件不能直接修改 props
<script setup>
const props = defineProps(['count'])

// ❌ 这样会报警告
props.count = 100

// ✅ 正确做法 1：使用本地 ref
const localCount = ref(props.count)
localCount.value = 100

// ✅ 正确做法 2：使用 computed
const doubleCount = computed(() => props.count * 2)

// ✅ 正确做法 3：通知父组件修改
const emit = defineEmits(['update:count'])
emit('update:count', 100)
</script>
```

#### 4. Props 的单向数据流

```javascript
// 父组件
<template>
  <ChildComponent
    :initial-value="parentValue"
    @update="handleUpdate"
  />
</template>

<script setup>
const parentValue = ref(100)

const handleUpdate = (newValue) => {
  parentValue.value = newValue // 父组件控制数据
}
</script>

// 子组件
<template>
  <div>
    <p>Current: {{ localValue }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script setup>
const props = defineProps(['initialValue'])
const emit = defineEmits(['update'])

// 子组件维护本地副本
const localValue = ref(props.initialValue)

const increment = () => {
  localValue.value++
  emit('update', localValue.value) // 通知父组件
}
</script>
```

### 二、Emit：子传父（事件触发）

#### 1. 基础用法

```javascript
// 子组件
<template>
  <div>
    <button @click="sendMessage">发送消息</button>
    <input v-model="text" @input="handleInput" />
  </div>
</template>

<script setup>
import { ref } from 'vue'

// 声明要触发的事件
const emit = defineEmits(['submit', 'input-change'])

const text = ref('')

const sendMessage = () => {
  // 触发事件，传递数据
  emit('submit', {
    message: 'Hello from child',
    timestamp: Date.now()
  })
}

const handleInput = () => {
  emit('input-change', text.value)
}
</script>

// 父组件
<template>
  <ChildComponent
    @submit="handleSubmit"
    @input-change="handleInputChange"
  />
</template>

<script setup>
const handleSubmit = (payload) => {
  console.log('Received:', payload.message)
  console.log('At:', payload.timestamp)
}

const handleInputChange = (value) => {
  console.log('Input changed to:', value)
}
</script>
```

#### 2. 事件校验（TypeScript）

```typescript
<script setup lang="ts">
// 方式 1：运行时校验
const emit = defineEmits({
  submit: (payload: { message: string; timestamp: number }) => {
    // 返回 true 表示校验通过
    if (!payload.message) {
      console.warn('Message is required')
      return false
    }
    return true
  },
  'input-change': (value: string) => value.length > 0
})

// 方式 2：类型声明
interface Emits {
  (e: 'submit', payload: { message: string; timestamp: number }): void
  (e: 'input-change', value: string): void
  (e: 'close'): void
}

const emit = defineEmits<Emits>()

// 使用
emit('submit', { message: 'test', timestamp: Date.now() })
</script>
```

#### 3. v-model 的双向绑定实现

```javascript
// 本质上是 props + emit 的语法糖

// 父组件
<template>
  <!-- 简写 -->
  <CustomInput v-model="text" />

  <!-- 等价于 -->
  <CustomInput
    :modelValue="text"
    @update:modelValue="text = $event"
  />

  <!-- 多个 v-model -->
  <UserForm
    v-model:name="userName"
    v-model:age="userAge"
  />
</template>

// 子组件实现
<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>

<script setup>
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
</script>

// 多个 v-model 实现
<template>
  <div>
    <input
      :value="name"
      @input="$emit('update:name', $event.target.value)"
    />
    <input
      type="number"
      :value="age"
      @input="$emit('update:age', Number($event.target.value))"
    />
  </div>
</template>

<script setup>
defineProps(['name', 'age'])
defineEmits(['update:name', 'update:age'])
</script>
```

### 三、Provide/Inject：跨层级依赖注入

#### 1. 基础用法

```javascript
// 祖先组件（提供数据）
<template>
  <div>
    <h1>App Root</h1>
    <ParentComponent />
  </div>
</template>

<script setup>
import { ref, provide } from 'vue'

const theme = ref('dark')
const userInfo = ref({
  name: 'Alice',
  role: 'admin'
})

// 提供数据
provide('theme', theme)
provide('userInfo', userInfo)
provide('updateTheme', (newTheme) => {
  theme.value = newTheme
})
</script>

// 中间组件（可以不做任何处理）
<template>
  <div>
    <ChildComponent />
  </div>
</template>

// 后代组件（注入数据）
<template>
  <div :class="theme">
    <p>User: {{ userInfo.name }}</p>
    <button @click="updateTheme('light')">切换主题</button>
  </div>
</template>

<script setup>
import { inject } from 'vue'

// 注入数据
const theme = inject('theme')
const userInfo = inject('userInfo')
const updateTheme = inject('updateTheme')

// 提供默认值
const config = inject('config', { timeout: 5000 })

// 使用工厂函数提供默认值（避免重复创建）
const settings = inject('settings', () => ({ debug: false }))
</script>
```

#### 2. 响应式注入

```javascript
// 祖先组件
<script setup>
import { ref, provide, readonly } from 'vue'

const count = ref(0)

// 方式 1：提供可修改的响应式数据
provide('count', count)
provide('increment', () => count.value++)

// 方式 2：提供只读数据（推荐）
provide('readonlyCount', readonly(count))
provide('setCount', (newValue) => {
  count.value = newValue
})
</script>

// 后代组件
<script setup>
import { inject } from 'vue'

const count = inject('count')
const increment = inject('increment')

// ❌ 如果是只读的，这样会报错
const readonlyCount = inject('readonlyCount')
// readonlyCount.value = 100 // 错误！

// ✅ 使用提供的方法修改
const setCount = inject('setCount')
setCount(100)
</script>
```

#### 3. TypeScript 支持

```typescript
// 定义注入的 key 和类型
import { InjectionKey, Ref } from 'vue'

interface User {
  name: string
  role: string
}

// 创建类型化的 key
export const userKey: InjectionKey<Ref<User>> = Symbol('user')
export const themeKey: InjectionKey<Ref<string>> = Symbol('theme')

// 祖先组件
<script setup lang="ts">
import { ref, provide } from 'vue'
import { userKey, themeKey } from './keys'

const user = ref<User>({ name: 'Alice', role: 'admin' })
const theme = ref('dark')

provide(userKey, user)
provide(themeKey, theme)
</script>

// 后代组件
<script setup lang="ts">
import { inject } from 'vue'
import { userKey, themeKey } from './keys'

// 自动获得类型推导
const user = inject(userKey) // Ref<User> | undefined
const theme = inject(themeKey) // Ref<string> | undefined

// 提供默认值
const config = inject(userKey, ref({ name: 'Guest', role: 'user' }))
</script>
```

#### 4. Provide/Inject 的应用场景

```javascript
// 场景 1：主题切换
// App.vue
<script setup>
import { ref, provide } from 'vue'

const theme = ref('light')
provide('theme', theme)
provide('toggleTheme', () => {
  theme.value = theme.value === 'light' ? 'dark' : 'light'
})
</script>

// DeepNestedComponent.vue
<script setup>
import { inject } from 'vue'

const theme = inject('theme')
const toggleTheme = inject('toggleTheme')
</script>

// 场景 2：国际化
// App.vue
<script setup>
import { ref, provide, computed } from 'vue'

const locale = ref('zh-CN')
const messages = {
  'zh-CN': { hello: '你好' },
  'en-US': { hello: 'Hello' }
}

provide('locale', locale)
provide('t', (key) => {
  return messages[locale.value]?.[key] || key
})
</script>

// AnyComponent.vue
<script setup>
const t = inject('t')
</script>
<template>
  <div>{{ t('hello') }}</div>
</template>

// 场景 3：表单状态管理
// FormContainer.vue
<script setup>
import { reactive, provide } from 'vue'

const formState = reactive({
  values: {},
  errors: {},
  touched: {}
})

provide('formState', formState)
provide('registerField', (name) => {
  formState.values[name] = ''
})
provide('updateField', (name, value) => {
  formState.values[name] = value
})
</script>

// FormField.vue
<script setup>
const formState = inject('formState')
const updateField = inject('updateField')
</script>
```

### 四、其他组件通信方式

#### 1. $refs（父访问子）

```javascript
// 父组件
<template>
  <ChildComponent ref="childRef" />
  <button @click="callChildMethod">调用子组件方法</button>
</template>

<script setup>
import { ref } from 'vue'

const childRef = ref(null)

const callChildMethod = () => {
  // 直接调用子组件的方法
  childRef.value?.doSomething()

  // 访问子组件的数据
  console.log(childRef.value?.someData)
}
</script>

// 子组件
<script setup>
import { ref } from 'vue'

const someData = ref('child data')

const doSomething = () => {
  console.log('Child method called')
}

// 必须显式暴露给父组件
defineExpose({
  someData,
  doSomething
})
</script>
```

#### 2. $parent 和 $root（不推荐）

```javascript
// 子组件访问父组件（不推荐，耦合性强）
<script setup>
import { getCurrentInstance } from 'vue'

const instance = getCurrentInstance()

// Vue 3 中需要通过 instance 访问
const parentData = instance?.parent?.data
const rootData = instance?.root?.data
</script>
```

#### 3. EventBus（Vue 2 中常用，Vue 3 不推荐）

```javascript
// Vue 2 中的用法（Vue 3 移除了 $on, $off）
// eventBus.js (Vue 2)
import Vue from 'vue'
export const EventBus = new Vue()

// 组件 A
EventBus.$emit('custom-event', data)

// 组件 B
EventBus.$on('custom-event', (data) => {
  console.log(data)
})

// Vue 3 替代方案：使用第三方库 mitt
import mitt from 'mitt'

const emitter = mitt()

// 组件 A
emitter.emit('custom-event', data)

// 组件 B
emitter.on('custom-event', (data) => {
  console.log(data)
})

// 记得清理
onUnmounted(() => {
  emitter.off('custom-event')
})
```

#### 4. Vuex/Pinia（全局状态管理）

```javascript
// Pinia Store
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    name: 'Alice',
    age: 25
  }),
  actions: {
    updateName(newName) {
      this.name = newName
    }
  }
})

// 任意组件中使用
<script setup>
import { useUserStore } from '@/stores/user'

const userStore = useUserStore()

// 读取数据
console.log(userStore.name)

// 修改数据
userStore.updateName('Bob')
</script>
```

### 五、组件通信方式对比

| 方式 | 适用场景 | 优点 | 缺点 | 推荐度 |
|------|----------|------|------|--------|
| **props/emit** | 父子组件 | 清晰、可预测、易维护 | 多层传递麻烦 | ⭐⭐⭐⭐⭐ |
| **provide/inject** | 跨层级组件 | 避免 props 逐层传递 | 不够显式，难追踪 | ⭐⭐⭐⭐ |
| **$refs** | 父访问子 | 简单直接 | 耦合性强，违背单向数据流 | ⭐⭐⭐ |
| **EventBus** | 任意组件 | 灵活 | 难维护、易内存泄漏 | ⭐（不推荐） |
| **Vuex/Pinia** | 全局状态 | 强大、可预测、支持 DevTools | 小项目过度设计 | ⭐⭐⭐⭐⭐ |

### 六、最佳实践

#### 1. 选择合适的通信方式

```javascript
// ✅ 场景 1：简单父子通信
// 用 props + emit
<Parent>
  <Child :data="parentData" @update="handleUpdate" />
</Parent>

// ✅ 场景 2：跨 2-3 层传递
// 用 provide/inject
<Grandparent> (provide)
  <Parent>
    <Child> (inject)
    </Child>
  </Parent>
</Grandparent>

// ✅ 场景 3：全局状态（用户信息、主题等）
// 用 Pinia
const userStore = useUserStore()

// ✅ 场景 4：兄弟组件通信
// 方案 1：通过父组件中转
<Parent>
  <Child1 @event="handleEvent" />
  <Child2 :data="sharedData" />
</Parent>

// 方案 2：使用 Pinia
const sharedStore = useSharedStore()
```

#### 2. Props 验证

```javascript
// ✅ 始终进行 props 验证
defineProps({
  id: {
    type: Number,
    required: true
  },
  status: {
    type: String,
    validator: (value) => ['pending', 'active', 'completed'].includes(value)
  },
  config: {
    type: Object,
    default: () => ({}) // 对象/数组必须用工厂函数
  }
})
```

#### 3. 事件命名规范

```javascript
// ✅ 使用 kebab-case
emit('input-change', value)
emit('form-submit', data)

// ❌ 避免使用 camelCase（在模板中不友好）
emit('inputChange', value)
```

#### 4. 避免过度 provide/inject

```javascript
// ❌ 不要用 provide/inject 传递所有数据
provide('everything', {
  userData,
  appConfig,
  methods,
  // ... 太多了
})

// ✅ 只提供必要的数据
provide('theme', theme)
provide('locale', locale)
```

#### 5. 使用 TypeScript 增强类型安全

```typescript
// ✅ 定义清晰的接口
interface UserData {
  id: number
  name: string
  role: 'admin' | 'user'
}

const props = defineProps<{
  user: UserData
  isActive: boolean
}>()

const emit = defineEmits<{
  (e: 'update', user: UserData): void
  (e: 'delete', id: number): void
}>()
```

### 七、常见面试问题

#### Q1: props 为什么是单向数据流？

**答：为了保证数据流向清晰可预测。** 如果子组件可以直接修改 props，当多个子组件同时修改同一个 prop 时，会导致数据混乱，难以追踪数据变化的来源。

#### Q2: provide/inject 和 Vuex 的区别？

| 特性 | provide/inject | Vuex/Pinia |
|------|----------------|------------|
| 响应式 | 需要手动处理 | 原生支持 |
| DevTools | 不支持 | 支持 |
| 时间旅行 | 不支持 | 支持 |
| 适用场景 | 组件树内共享 | 全局状态管理 |

#### Q3: 什么时候使用 emit，什么时候使用 provide/inject？

- **emit**：父子组件直接通信，关系明确
- **provide/inject**：跨多层级通信，避免 props drilling

#### Q4: v-model 的原理是什么？

```javascript
// v-model 是语法糖
<CustomInput v-model="text" />

// 等价于
<CustomInput
  :modelValue="text"
  @update:modelValue="text = $event"
/>
```

### 八、总结

1. **首选 props/emit**：清晰、可维护
2. **跨层级用 provide/inject**：避免 props drilling
3. **全局状态用 Pinia**：强大、可调试
4. **避免 EventBus**：难维护、易出错
5. **谨慎使用 $refs**：违背单向数据流
6. **始终进行类型校验**：提高代码质量
