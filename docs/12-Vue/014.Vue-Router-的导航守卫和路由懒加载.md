---
title: Vue Router 的导航守卫和路由懒加载
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue-router-navigation-guards-lazy-loading
ref:
---

## 核心要点

**导航守卫是 Vue Router 提供的路由拦截机制，分为全局守卫、路由独享守卫、组件内守卫三个层级，用于权限控制、数据预加载、路由验证等。执行顺序：全局前置 → 路由独享 → 组件内beforeRouteEnter → 全局解析 → 全局后置。路由懒加载通过动态 import() 实现按需加载，结合 webpack 魔法注释可优化代码分割、预加载策略。**

---

## 详细回答

### 一、导航守卫（Navigation Guards）

#### 1. 导航守卫的作用

导航守卫是 Vue Router 提供的**路由跳转拦截机制**，主要用于：

- **权限验证**：检查用户是否有访问权限
- **登录校验**：未登录用户跳转到登录页
- **数据预加载**：进入路由前加载数据
- **页面访问日志**：记录用户访问轨迹
- **离开确认**：表单未保存时提示用户
- **动态路由**：根据权限动态添加路由
- **页面标题设置**：根据路由 meta 设置标题

#### 2. 守卫的三个参数

所有导航守卫都接收三个参数：

```typescript
function guard(to, from, next) {
  // to: 即将进入的目标路由对象
  // from: 当前导航正要离开的路由对象
  // next: 控制导航行为的函数
}
```

**参数详解：**

| 参数 | 类型 | 说明 |
|------|------|------|
| **to** | Route | 目标路由对象，包含 path、params、query、meta 等 |
| **from** | Route | 当前路由对象 |
| **next** | Function | **必须调用**，否则导航会被阻塞 |

**next() 的调用方式：**

```javascript
// 1. 放行，进入目标路由
next()

// 2. 中断当前导航，停留在 from 路由
next(false)

// 3. 跳转到指定路由（字符串路径）
next('/login')

// 4. 跳转到指定路由（路由对象）
next({ path: '/login', query: { redirect: to.fullPath } })

// 5. 传入 Error 实例，导航会被终止且错误传递给 router.onError()
next(new Error('Permission denied'))
```

**注意事项：**
- **必须调用 next() 一次且仅一次**
- 不要在异步回调中多次调用 next()
- 使用 `return next()` 确保不会执行后续代码

### 二、导航守卫的分类

#### 1. 全局守卫（Global Guards）

##### （1）全局前置守卫 beforeEach

在**所有路由跳转前**执行，最常用的守卫。

```javascript
// router/index.js
import { createRouter } from 'vue-router'
import { useUserStore } from '@/stores/user'

const router = createRouter({
  // ...
})

// 全局前置守卫
router.beforeEach((to, from, next) => {
  console.log('全局前置守卫：beforeEach')

  // 1. 设置页面标题
  document.title = to.meta.title || '默认标题'

  // 2. 权限验证
  const userStore = useUserStore()
  const requiresAuth = to.meta.requiresAuth

  if (requiresAuth && !userStore.isLoggedIn) {
    // 需要登录但未登录，跳转到登录页
    next({
      path: '/login',
      query: { redirect: to.fullPath }  // 保存目标路由，登录后跳转
    })
  } else if (to.path === '/login' && userStore.isLoggedIn) {
    // 已登录用户访问登录页，跳转到首页
    next('/')
  } else {
    // 放行
    next()
  }
})

export default router
```

**实战示例：完整的权限验证**

```javascript
router.beforeEach(async (to, from, next) => {
  const userStore = useUserStore()
  const token = localStorage.getItem('token')

  // 1. 白名单路由（无需登录）
  const whiteList = ['/login', '/register', '/404']
  if (whiteList.includes(to.path)) {
    return next()
  }

  // 2. 检查 token
  if (!token) {
    return next({
      path: '/login',
      query: { redirect: to.fullPath }
    })
  }

  // 3. 检查用户信息是否已加载
  if (!userStore.userInfo) {
    try {
      // 获取用户信息和权限
      await userStore.fetchUserInfo()

      // 动态添加权限路由
      const accessRoutes = await generateRoutes(userStore.roles)
      accessRoutes.forEach(route => router.addRoute(route))

      // 重新导航到目标路由（确保动态路由已添加）
      return next({ ...to, replace: true })
    } catch (error) {
      // 获取用户信息失败，清除 token 并跳转登录页
      userStore.logout()
      return next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    }
  }

  // 4. 检查角色权限
  if (to.meta.roles && !to.meta.roles.includes(userStore.role)) {
    return next({ path: '/403' })  // 无权限
  }

  next()
})
```

##### （2）全局解析守卫 beforeResolve

在导航被确认之前，**所有组件内守卫和异步路由组件被解析后**执行。

```javascript
router.beforeResolve(async (to, from, next) => {
  console.log('全局解析守卫：beforeResolve')

  // 适合做数据预加载
  if (to.meta.requiresData) {
    try {
      // 预加载数据
      await fetchPageData(to.params.id)
      next()
    } catch (error) {
      next(false)  // 取消导航
    }
  } else {
    next()
  }
})
```

##### （3）全局后置钩子 afterEach

在导航完成**之后**执行，**没有 next 参数**，不会影响导航。

```javascript
router.afterEach((to, from, failure) => {
  console.log('全局后置钩子：afterEach')

  // 1. 关闭加载动画
  hideLoading()

  // 2. 发送页面访问统计
  sendPageView(to.path)

  // 3. 滚动到页面顶部
  window.scrollTo(0, 0)

  // 4. 检查导航失败
  if (failure) {
    console.error('Navigation failed:', failure)
  }
})
```

**failure 参数**（Vue Router 4+）：
- 导航失败时包含错误信息
- 可以判断失败原因（重复导航、取消导航等）

#### 2. 路由独享守卫（Per-Route Guards）

在路由配置中直接定义，只对当前路由生效。

```javascript
const routes = [
  {
    path: '/admin',
    component: () => import('@/views/Admin.vue'),
    meta: {
      requiresAuth: true,
      roles: ['admin']
    },
    // 路由独享守卫
    beforeEnter: (to, from, next) => {
      console.log('路由独享守卫：beforeEnter')

      const userStore = useUserStore()

      // 检查是否是管理员
      if (userStore.role !== 'admin') {
        alert('只有管理员可以访问此页面')
        next(false)  // 取消导航
      } else {
        next()
      }
    }
  }
]
```

**支持数组形式**（Vue Router 4.x）：

```javascript
function checkAuth(to, from, next) {
  // 权限检查
}

function logAccess(to, from, next) {
  console.log('访问日志')
  next()
}

const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: [checkAuth, logAccess]  // 按顺序执行
  }
]
```

#### 3. 组件内守卫（In-Component Guards）

在路由组件内部定义，只对当前组件生效。

##### （1）beforeRouteEnter

进入路由**之前**调用，此时**组件实例还未创建**，无法访问 `this`。

```vue
<script>
export default {
  beforeRouteEnter(to, from, next) {
    console.log('组件内守卫：beforeRouteEnter')
    // ❌ 此时 this 不可用

    // 通过 next 回调访问组件实例
    next(vm => {
      // ✅ vm 是组件实例
      vm.message = '从导航守卫设置的值'
    })
  }
}
</script>
```

**Vue 3 Composition API 写法：**

```vue
<script setup>
import { onBeforeRouteEnter } from 'vue-router'

// ⚠️ 注意：setup 中无法使用 beforeRouteEnter
// 因为 setup 在组件实例创建前执行，与 beforeRouteEnter 时机冲突

// 替代方案：使用全局守卫或 onMounted
</script>
```

##### （2）beforeRouteUpdate

当前路由复用组件时调用（如 `/user/1` → `/user/2`）。

```vue
<script setup>
import { onBeforeRouteUpdate } from 'vue-router'

onBeforeRouteUpdate((to, from) => {
  console.log('组件内守卫：beforeRouteUpdate')

  // 路由参数变化时重新加载数据
  if (to.params.id !== from.params.id) {
    fetchData(to.params.id)
  }

  // ⚠️ Composition API 中不需要调用 next()
  // 直接 return false 可以取消导航
  // return false
})
</script>
```

**Options API 写法：**

```vue
<script>
export default {
  async beforeRouteUpdate(to, from, next) {
    // 加载新数据
    await this.fetchData(to.params.id)
    next()
  }
}
</script>
```

##### （3）beforeRouteLeave

离开当前路由**之前**调用，可用于离开确认。

```vue
<script setup>
import { onBeforeRouteLeave } from 'vue-router'
import { ref } from 'vue'

const hasUnsavedChanges = ref(false)

onBeforeRouteLeave((to, from) => {
  console.log('组件内守卫：beforeRouteLeave')

  if (hasUnsavedChanges.value) {
    const answer = window.confirm('有未保存的更改，确定要离开吗？')
    if (!answer) {
      return false  // 取消导航
    }
  }

  // 清理工作：取消请求、清除定时器等
  cleanupResources()
})

function cleanupResources() {
  // 取消未完成的 API 请求
  abortController.abort()
}
</script>
```

### 三、完整的导航解析流程

当触发一次路由导航时，守卫的执行顺序如下：

```
1. 触发导航
   ↓
2. 在失活的组件里调用 beforeRouteLeave
   ↓
3. 调用全局的 beforeEach 守卫
   ↓
4. 在重用的组件里调用 beforeRouteUpdate（如果组件被复用）
   ↓
5. 调用路由配置里的 beforeEnter
   ↓
6. 解析异步路由组件
   ↓
7. 在被激活的组件里调用 beforeRouteEnter
   ↓
8. 调用全局的 beforeResolve 守卫
   ↓
9. 导航被确认
   ↓
10. 调用全局的 afterEach 钩子
   ↓
11. 触发 DOM 更新
   ↓
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数
```

**示例验证：**

```javascript
// 全局守卫
router.beforeEach((to, from, next) => {
  console.log('1. 全局 beforeEach')
  next()
})

router.beforeResolve((to, from, next) => {
  console.log('5. 全局 beforeResolve')
  next()
})

router.afterEach(() => {
  console.log('6. 全局 afterEach')
})

// 路由配置
const routes = [
  {
    path: '/user/:id',
    component: User,
    beforeEnter: (to, from, next) => {
      console.log('2. 路由独享 beforeEnter')
      next()
    }
  }
]

// 组件内
export default {
  beforeRouteEnter(to, from, next) {
    console.log('3. 组件内 beforeRouteEnter')
    next(() => {
      console.log('7. beforeRouteEnter 的 next 回调')
    })
  },

  beforeRouteUpdate(to, from, next) {
    console.log('4. 组件内 beforeRouteUpdate')
    next()
  },

  beforeRouteLeave(to, from, next) {
    console.log('0. 组件内 beforeRouteLeave')
    next()
  }
}
```

### 四、路由懒加载（Lazy Loading）

#### 1. 什么是路由懒加载

路由懒加载是指**按需加载路由组件**，而不是在应用启动时一次性加载所有组件。

**核心优势：**
- **减少首屏加载时间**：首次只加载必要的代码
- **优化打包体积**：将代码分割成多个小块（chunk）
- **提升用户体验**：页面加载更快
- **按需加载**：只有访问某个路由时才下载对应代码

#### 2. 实现方式

##### 基础语法：动态 import()

```javascript
// ❌ 同步导入（会打包到主 bundle）
import Home from '@/views/Home.vue'

// ✅ 异步导入（懒加载）
const Home = () => import('@/views/Home.vue')
```

##### 路由配置示例

```javascript
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      name: 'Home',
      // 懒加载
      component: () => import('@/views/Home.vue')
    },
    {
      path: '/about',
      name: 'About',
      component: () => import('@/views/About.vue')
    },
    {
      path: '/admin',
      name: 'Admin',
      // 添加 webpack 魔法注释
      component: () => import(
        /* webpackChunkName: "admin" */
        '@/views/Admin.vue'
      ),
      meta: { requiresAuth: true }
    }
  ]
})

export default router
```

#### 3. Webpack 魔法注释（Magic Comments）

魔法注释可以控制代码分割的行为：

##### （1）webpackChunkName - 指定 chunk 名称

```javascript
component: () => import(
  /* webpackChunkName: "admin" */
  '@/views/Admin.vue'
)

// 打包后生成：admin.js（而不是随机数字）
```

##### （2）webpackPrefetch - 预加载（推荐）

浏览器**空闲时**预先下载，用户访问时直接使用缓存。

```javascript
component: () => import(
  /* webpackChunkName: "dashboard" */
  /* webpackPrefetch: true */
  '@/views/Dashboard.vue'
)

// 生成：<link rel="prefetch" href="dashboard.js">
```

**优势：**
- 用户体验好：点击后立即显示（已缓存）
- 不影响首屏：在浏览器空闲时下载
- 适合：高优先级但非首屏的页面

##### （3）webpackPreload - 并行加载

与父 chunk **并行加载**，优先级高。

```javascript
component: () => import(
  /* webpackChunkName: "critical" */
  /* webpackPreload: true */
  '@/views/Critical.vue'
)

// 生成：<link rel="preload" href="critical.js">
```

**注意：**
- 会立即下载，占用带宽
- 仅用于**关键资源**
- 过度使用会影响首屏性能

##### （4）webpackMode - 动态导入模式

```javascript
// 懒加载（默认）
component: () => import(
  /* webpackMode: "lazy" */
  '@/views/User.vue'
)

// 懒加载（一次性）- 首次加载后缓存
component: () => import(
  /* webpackMode: "lazy-once" */
  `@/views/${componentName}.vue`
)

// 急切加载 - 立即解析和执行
component: () => import(
  /* webpackMode: "eager" */
  '@/views/Home.vue'
)
```

#### 4. 路由分组（Chunk Grouping）

将相关路由打包到同一个 chunk，减少请求数量。

```javascript
const routes = [
  {
    path: '/admin/users',
    component: () => import(
      /* webpackChunkName: "admin-group" */
      '@/views/admin/Users.vue'
    )
  },
  {
    path: '/admin/roles',
    component: () => import(
      /* webpackChunkName: "admin-group" */  // 相同 chunk 名称
      '@/views/admin/Roles.vue'
    )
  },
  {
    path: '/admin/permissions',
    component: () => import(
      /* webpackChunkName: "admin-group" */
      '@/views/admin/Permissions.vue'
    )
  }
]

// 这三个组件会被打包到同一个 admin-group.js 文件
```

**适用场景：**
- 功能模块相关的页面（如管理后台的多个子页面）
- 访问频率相近的页面

#### 5. 实战示例：按角色懒加载

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    // 公共页面（首屏加载）
    {
      path: '/login',
      component: () => import('@/views/Login.vue')
    },

    // 普通用户页面（懒加载 + 预加载）
    {
      path: '/dashboard',
      component: () => import(
        /* webpackChunkName: "user" */
        /* webpackPrefetch: true */
        '@/views/Dashboard.vue'
      ),
      meta: { roles: ['user', 'admin'] }
    },

    // 管理员页面（懒加载，按需加载）
    {
      path: '/admin',
      component: () => import(
        /* webpackChunkName: "admin" */
        '@/views/Admin.vue'
      ),
      meta: { roles: ['admin'] },
      children: [
        {
          path: 'users',
          component: () => import(
            /* webpackChunkName: "admin" */
            '@/views/admin/UserManagement.vue'
          )
        },
        {
          path: 'settings',
          component: () => import(
            /* webpackChunkName: "admin" */
            '@/views/admin/Settings.vue'
          )
        }
      ]
    }
  ]
})

export default router
```

#### 6. 性能优化技巧

##### （1）合理使用 prefetch

```javascript
// ✅ 高优先级页面使用 prefetch
component: () => import(
  /* webpackPrefetch: true */
  '@/views/Dashboard.vue'
)

// ❌ 不要对所有路由都 prefetch（浪费带宽）
```

##### （2）监控 chunk 大小

```javascript
// vue.config.js
module.exports = {
  configureWebpack: {
    performance: {
      maxAssetSize: 250000,  // 单个文件最大 250KB
      maxEntrypointSize: 250000,
      hints: 'warning'  // 超出时警告
    }
  }
}
```

##### （3）代码分割分析

```bash
# 分析打包结果
npm run build -- --report

# 或使用 webpack-bundle-analyzer
npm install --save-dev webpack-bundle-analyzer
```

### 五、实战场景与最佳实践

#### 场景1：权限路由 + 懒加载

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/stores/user'

// 静态路由（无需权限）
const constantRoutes = [
  {
    path: '/login',
    component: () => import('@/views/Login.vue')
  },
  {
    path: '/404',
    component: () => import('@/views/404.vue')
  }
]

// 动态路由（需要根据权限加载）
export const asyncRoutes = [
  {
    path: '/admin',
    component: () => import(
      /* webpackChunkName: "admin" */
      '@/layouts/AdminLayout.vue'
    ),
    meta: { roles: ['admin'] },
    children: [
      {
        path: 'dashboard',
        component: () => import('@/views/admin/Dashboard.vue'),
        meta: { roles: ['admin'] }
      }
    ]
  },
  {
    path: '/user',
    component: () => import(
      /* webpackChunkName: "user" */
      '@/layouts/UserLayout.vue'
    ),
    meta: { roles: ['user', 'admin'] },
    children: [
      {
        path: 'profile',
        component: () => import('@/views/user/Profile.vue')
      }
    ]
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes: constantRoutes
})

// 根据角色过滤路由
function filterAsyncRoutes(routes, roles) {
  return routes.filter(route => {
    if (route.meta?.roles) {
      return roles.some(role => route.meta.roles.includes(role))
    }
    return true
  }).map(route => {
    if (route.children) {
      route.children = filterAsyncRoutes(route.children, roles)
    }
    return route
  })
}

// 全局守卫
router.beforeEach(async (to, from, next) => {
  const userStore = useUserStore()

  if (to.path === '/login') {
    return next()
  }

  if (!userStore.token) {
    return next('/login')
  }

  // 动态添加路由
  if (!userStore.routesAdded) {
    const accessRoutes = filterAsyncRoutes(asyncRoutes, userStore.roles)
    accessRoutes.forEach(route => router.addRoute(route))
    userStore.routesAdded = true

    return next({ ...to, replace: true })
  }

  next()
})

export default router
```

#### 场景2：路由切换进度条

```javascript
// router/index.js
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'

router.beforeEach((to, from, next) => {
  NProgress.start()  // 开始进度条
  next()
})

router.afterEach(() => {
  NProgress.done()  // 完成进度条
})
```

#### 场景3：页面访问埋点

```javascript
router.afterEach((to, from) => {
  // 发送页面访问统计
  window.gtag('config', 'GA_MEASUREMENT_ID', {
    page_path: to.path,
    page_title: to.meta.title
  })
})
```

### 六、常见问题与解决方案

#### 1. 无限循环导航

**问题**：守卫中不正确的 next() 调用导致死循环

```javascript
// ❌ 错误示例
router.beforeEach((to, from, next) => {
  if (to.path !== '/login') {
    next('/login')  // 会一直跳转到 /login
  }
  next()  // 又会继续执行，造成无限循环
})

// ✅ 正确示例
router.beforeEach((to, from, next) => {
  if (to.path === '/login') {
    return next()  // return 防止继续执行
  }

  if (!isAuthenticated()) {
    return next('/login')
  }

  next()
})
```

#### 2. 动态路由 404

**问题**：动态添加路由后访问404

**解决**：使用 `next({ ...to, replace: true })` 重新导航

```javascript
router.beforeEach(async (to, from, next) => {
  // 添加动态路由后
  router.addRoute(newRoute)

  // ⚠️ 必须重新导航，让 router 匹配新添加的路由
  return next({ ...to, replace: true })
})
```

#### 3. 组件重用时守卫不触发

**问题**：路由参数变化但组件未更新

**解决**：使用 `beforeRouteUpdate` 或 watch `$route`

```vue
<script setup>
import { watch } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()

watch(
  () => route.params.id,
  (newId) => {
    fetchData(newId)
  },
  { immediate: true }
)
</script>
```

### 七、面试总结

**核心要点：**

1. **导航守卫分类**：
   - 全局守卫：beforeEach、beforeResolve、afterEach
   - 路由独享守卫：beforeEnter
   - 组件内守卫：beforeRouteEnter/Update/Leave

2. **执行顺序**：
   - beforeRouteLeave → beforeEach → beforeEnter → beforeRouteEnter → beforeResolve → afterEach

3. **next() 调用**：
   - 必须调用且仅调用一次
   - next() 放行、next(false) 取消、next('/path') 跳转
   - 使用 `return next()` 避免继续执行

4. **路由懒加载**：
   - 使用 `() => import()` 实现按需加载
   - webpack 魔法注释：chunkName、prefetch、preload
   - 路由分组：相关路由使用相同 chunkName

5. **实战应用**：
   - 权限验证 + 动态路由
   - 数据预加载 + 加载动画
   - 离开确认 + 资源清理
   - 埋点统计 + SEO 优化

**高级话题**：
- 动态路由权限管理（RBAC）
- 路由守卫与 Pinia 的集成
- Vite 的动态 import 优化
- 路由元信息的最佳实践
