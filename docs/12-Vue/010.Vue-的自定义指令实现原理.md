---
title: Vue 的自定义指令实现原理
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue-custom-directive-implementation
ref:
---

## 核心要点

- **自定义指令**：扩展 Vue 的模板语法，直接操作 DOM 元素
- **生命周期钩子**：created、beforeMount、mounted、beforeUpdate、updated、beforeUnmount、unmounted
- **应用场景**：DOM 操作（聚焦、拖拽、懒加载）、权限控制、埋点统计
- **最佳实践**：优先考虑组件化，只在必要时使用自定义指令

---

## 详细解答

### 一、自定义指令基础

#### 1. 什么是自定义指令？

自定义指令是 Vue 提供的一种直接操作 DOM 的机制，用于封装可复用的 DOM 操作逻辑。Vue 内置了 `v-model`、`v-show`、`v-if` 等指令，我们也可以创建自己的指令。

#### 2. 注册自定义指令

**全局注册：**

```javascript
// main.js 或 app.js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

// 注册全局自定义指令
app.directive('focus', {
  mounted(el) {
    el.focus()
  }
})

app.mount('#app')
```

**局部注册：**

```javascript
<script setup>
// Vue 3 Composition API 局部注册
const vFocus = {
  mounted(el) {
    el.focus()
  }
}
</script>

<template>
  <!-- 使用指令（注意 v 前缀） -->
  <input v-focus />
</template>

// 选项式 API 局部注册
export default {
  directives: {
    focus: {
      mounted(el) {
        el.focus()
      }
    }
  }
}
```

#### 3. 指令的使用方式

```html
<!-- 无参数 -->
<div v-my-directive></div>

<!-- 带值 -->
<div v-my-directive="value"></div>

<!-- 带参数 -->
<div v-my-directive:arg="value"></div>

<!-- 带修饰符 -->
<div v-my-directive.modifier="value"></div>

<!-- 复合使用 -->
<div v-my-directive:arg.modifier="value"></div>
```

### 二、指令的生命周期钩子

Vue 3 的自定义指令提供了 7 个生命周期钩子：

```javascript
app.directive('demo', {
  // 1. 在绑定元素的 attribute 或事件监听器被应用之前调用
  created(el, binding, vnode, prevVnode) {
    console.log('created')
  },

  // 2. 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode, prevVnode) {
    console.log('beforeMount')
  },

  // 3. 在绑定元素的父组件及其所有子组件都挂载完成后调用
  mounted(el, binding, vnode, prevVnode) {
    console.log('mounted')
    // 最常用的钩子，可以安全地操作 DOM
  },

  // 4. 在绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {
    console.log('beforeUpdate')
  },

  // 5. 在绑定元素的父组件及其所有子组件都更新后调用
  updated(el, binding, vnode, prevVnode) {
    console.log('updated')
  },

  // 6. 在绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode, prevVnode) {
    console.log('beforeUnmount')
  },

  // 7. 在绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode, prevVnode) {
    console.log('unmounted')
    // 适合清理工作（事件监听、定时器等）
  }
})
```

#### 钩子参数详解

```javascript
app.directive('demo', {
  mounted(el, binding, vnode, prevVnode) {
    // el: 指令绑定到的 DOM 元素
    console.log('el:', el)

    // binding: 包含指令信息的对象
    console.log('binding.value:', binding.value)       // 指令的值
    console.log('binding.oldValue:', binding.oldValue) // 之前的值（仅在更新钩子中可用）
    console.log('binding.arg:', binding.arg)           // 指令的参数
    console.log('binding.modifiers:', binding.modifiers) // 修饰符对象
    console.log('binding.instance:', binding.instance) // 组件实例
    console.log('binding.dir:', binding.dir)           // 指令定义对象

    // vnode: 绑定元素的虚拟 DOM 节点
    console.log('vnode:', vnode)

    // prevVnode: 之前的虚拟节点（仅在更新钩子中可用）
    console.log('prevVnode:', prevVnode)
  }
})
```

**使用示例：**

```html
<div v-demo:foo.bar="123"></div>
```

**对应的 binding 对象：**

```javascript
{
  value: 123,              // 传递的值
  arg: 'foo',              // 参数
  modifiers: { bar: true }, // 修饰符
  instance: {...},         // 组件实例
  dir: {...}               // 指令定义
}
```

### 三、常见自定义指令实现

#### 1. v-focus：自动聚焦

```javascript
// 简单版本
app.directive('focus', {
  mounted(el) {
    el.focus()
  }
})

// 完整版本：支持条件聚焦
app.directive('focus', {
  mounted(el, binding) {
    // v-focus="true" 时才聚焦
    if (binding.value) {
      el.focus()
    }
  },
  updated(el, binding) {
    // 值变化时重新判断
    if (binding.value && !binding.oldValue) {
      el.focus()
    }
  }
})

// 使用
<template>
  <input v-focus />
  <input v-focus="shouldFocus" />
</template>
```

#### 2. v-clickoutside：点击外部

```javascript
app.directive('clickoutside', {
  mounted(el, binding) {
    // 定义点击处理函数
    el._clickOutside = (event) => {
      // 检查点击是否在元素外部
      if (!(el === event.target || el.contains(event.target))) {
        // 调用绑定的方法
        binding.value(event)
      }
    }

    // 添加事件监听（使用捕获阶段）
    document.addEventListener('click', el._clickOutside, true)
  },

  beforeUnmount(el) {
    // 清理事件监听
    document.removeEventListener('click', el._clickOutside, true)
    delete el._clickOutside
  }
})

// 使用
<template>
  <div v-clickoutside="handleClickOutside">
    <p>点击我外面试试</p>
  </div>
</template>

<script setup>
const handleClickOutside = () => {
  console.log('Clicked outside!')
}
</script>
```

#### 3. v-lazy：图片懒加载

```javascript
app.directive('lazy', {
  mounted(el, binding) {
    // 创建 IntersectionObserver
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // 元素进入视口，加载图片
            const img = entry.target
            const src = binding.value

            img.src = src
            img.classList.add('loaded')

            // 停止观察
            observer.unobserve(img)
          }
        })
      },
      {
        // 提前 100px 开始加载
        rootMargin: '100px'
      }
    )

    // 开始观察
    observer.observe(el)

    // 保存 observer 以便清理
    el._lazy_observer = observer
  },

  updated(el, binding) {
    // 如果图片 src 改变，重新观察
    if (binding.value !== binding.oldValue) {
      el._lazy_observer.unobserve(el)
      el.src = '' // 清空当前图片
      el._lazy_observer.observe(el)
    }
  },

  beforeUnmount(el) {
    // 清理观察器
    if (el._lazy_observer) {
      el._lazy_observer.disconnect()
      delete el._lazy_observer
    }
  }
})

// 使用
<template>
  <img
    v-lazy="imageUrl"
    alt="Lazy loaded image"
    class="lazy-img"
  />
</template>

<style>
.lazy-img {
  background: #f0f0f0;
  min-height: 200px;
}
.lazy-img.loaded {
  background: transparent;
}
</style>
```

#### 4. v-permission：权限控制

```javascript
app.directive('permission', {
  mounted(el, binding) {
    const { value } = binding

    // 获取用户权限（实际项目中从 store 或 context 获取）
    const userPermissions = ['read', 'write'] // 模拟用户权限

    // 检查权限
    const hasPermission = userPermissions.includes(value)

    if (!hasPermission) {
      // 无权限：移除元素
      el.parentNode?.removeChild(el)

      // 或者：禁用元素
      // el.disabled = true
      // el.style.opacity = '0.5'
      // el.style.cursor = 'not-allowed'
    }
  }
})

// 高级版本：支持多种权限模式
app.directive('permission', {
  mounted(el, binding) {
    const { value, arg, modifiers } = binding
    const userPermissions = ['read', 'write'] // 从 store 获取

    let hasPermission = false

    if (Array.isArray(value)) {
      // v-permission="['read', 'write']"
      if (modifiers.all) {
        // v-permission.all - 需要全部权限
        hasPermission = value.every(p => userPermissions.includes(p))
      } else {
        // 默认：只需一个权限
        hasPermission = value.some(p => userPermissions.includes(p))
      }
    } else {
      // v-permission="'read'"
      hasPermission = userPermissions.includes(value)
    }

    if (!hasPermission) {
      if (arg === 'disable') {
        // v-permission:disable - 禁用而不是移除
        el.disabled = true
        el.style.opacity = '0.5'
        el.style.cursor = 'not-allowed'
        el.title = '您没有权限执行此操作'
      } else {
        // 默认：移除元素
        el.parentNode?.removeChild(el)
      }
    }
  }
})

// 使用
<template>
  <!-- 需要 delete 权限，无权限则移除 -->
  <button v-permission="'delete'">删除</button>

  <!-- 需要 admin 权限，无权限则禁用 -->
  <button v-permission:disable="'admin'">管理</button>

  <!-- 需要 read 或 write 权限之一 -->
  <div v-permission="['read', 'write']">内容</div>

  <!-- 需要同时具有 read 和 write 权限 -->
  <div v-permission.all="['read', 'write']">敏感内容</div>
</template>
```

#### 5. v-copy：复制到剪贴板

```javascript
app.directive('copy', {
  mounted(el, binding) {
    // 定义复制函数
    el._copy_handler = async () => {
      const text = binding.value

      try {
        // 使用现代 API
        await navigator.clipboard.writeText(text)
        console.log('复制成功:', text)

        // 提示用户
        if (binding.arg === 'toast') {
          showToast('复制成功')
        }
      } catch (err) {
        // 降级方案
        const textarea = document.createElement('textarea')
        textarea.value = text
        textarea.style.position = 'fixed'
        textarea.style.opacity = '0'
        document.body.appendChild(textarea)
        textarea.select()
        document.execCommand('copy')
        document.body.removeChild(textarea)

        console.log('复制成功（降级）:', text)
      }
    }

    // 绑定点击事件
    el.addEventListener('click', el._copy_handler)
  },

  updated(el, binding) {
    // 值更新时无需特殊处理，点击时会获取最新的 binding.value
  },

  beforeUnmount(el) {
    // 清理事件监听
    el.removeEventListener('click', el._copy_handler)
    delete el._copy_handler
  }
})

// 使用
<template>
  <button v-copy="textToCopy">复制文本</button>
  <button v-copy:toast="codeSnippet">复制代码（带提示）</button>
</template>

<script setup>
const textToCopy = ref('Hello Vue!')
const codeSnippet = ref('const x = 10;')
</script>
```

#### 6. v-debounce：防抖

```javascript
app.directive('debounce', {
  mounted(el, binding) {
    const { value, arg } = binding
    const delay = arg ? parseInt(arg) : 300 // 默认 300ms

    let timer = null

    el._debounce_handler = (event) => {
      if (timer) {
        clearTimeout(timer)
      }

      timer = setTimeout(() => {
        value(event)
      }, delay)
    }

    // 获取事件类型（默认 click）
    const eventType = binding.modifiers.input ? 'input' : 'click'

    el.addEventListener(eventType, el._debounce_handler)
  },

  beforeUnmount(el, binding) {
    const eventType = binding.modifiers.input ? 'input' : 'click'
    el.removeEventListener(eventType, el._debounce_handler)
    delete el._debounce_handler
  }
})

// 使用
<template>
  <!-- 点击防抖（默认 300ms） -->
  <button v-debounce="handleClick">点击</button>

  <!-- 自定义延迟时间（500ms） -->
  <button v-debounce:500="handleSearch">搜索</button>

  <!-- input 事件防抖 -->
  <input v-debounce.input:500="handleInput" />
</template>
```

#### 7. v-draggable：拖拽

```javascript
app.directive('draggable', {
  mounted(el, binding) {
    let isDragging = false
    let startX = 0
    let startY = 0
    let initialX = 0
    let initialY = 0

    // 设置元素样式
    el.style.position = 'absolute'
    el.style.cursor = 'move'

    const onMouseDown = (e) => {
      isDragging = true

      // 记录起始位置
      startX = e.clientX
      startY = e.clientY

      // 获取元素当前位置
      const rect = el.getBoundingClientRect()
      initialX = rect.left
      initialY = rect.top

      // 添加拖拽类
      el.classList.add('dragging')

      // 触发开始回调
      if (binding.value?.onStart) {
        binding.value.onStart(e)
      }
    }

    const onMouseMove = (e) => {
      if (!isDragging) return

      // 计算移动距离
      const deltaX = e.clientX - startX
      const deltaY = e.clientY - startY

      // 更新元素位置
      el.style.left = `${initialX + deltaX}px`
      el.style.top = `${initialY + deltaY}px`

      // 触发移动回调
      if (binding.value?.onMove) {
        binding.value.onMove(e, { x: initialX + deltaX, y: initialY + deltaY })
      }
    }

    const onMouseUp = (e) => {
      if (!isDragging) return

      isDragging = false
      el.classList.remove('dragging')

      // 触发结束回调
      if (binding.value?.onEnd) {
        const rect = el.getBoundingClientRect()
        binding.value.onEnd(e, { x: rect.left, y: rect.top })
      }
    }

    // 绑定事件
    el.addEventListener('mousedown', onMouseDown)
    document.addEventListener('mousemove', onMouseMove)
    document.addEventListener('mouseup', onMouseUp)

    // 保存事件处理函数以便清理
    el._draggable_handlers = { onMouseDown, onMouseMove, onMouseUp }
  },

  beforeUnmount(el) {
    const { onMouseDown, onMouseMove, onMouseUp } = el._draggable_handlers || {}

    el.removeEventListener('mousedown', onMouseDown)
    document.removeEventListener('mousemove', onMouseMove)
    document.removeEventListener('mouseup', onMouseUp)

    delete el._draggable_handlers
  }
})

// 使用
<template>
  <div
    v-draggable="{
      onStart: handleDragStart,
      onMove: handleDragMove,
      onEnd: handleDragEnd
    }"
    class="draggable-box"
  >
    拖拽我
  </div>
</template>

<script setup>
const handleDragStart = (e) => {
  console.log('开始拖拽')
}

const handleDragMove = (e, position) => {
  console.log('拖拽中:', position)
}

const handleDragEnd = (e, position) => {
  console.log('拖拽结束:', position)
}
</script>

<style>
.draggable-box {
  width: 100px;
  height: 100px;
  background: #42b983;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  user-select: none;
}

.draggable-box.dragging {
  opacity: 0.8;
  z-index: 1000;
}
</style>
```

### 四、指令的实现原理

#### 1. 指令的注册和存储

```javascript
// Vue 内部简化版实现
class App {
  constructor() {
    this._directives = new Map()
  }

  directive(name, definition) {
    if (!definition) {
      // 获取指令
      return this._directives.get(name)
    }

    // 注册指令
    if (typeof definition === 'function') {
      // 简写形式：只提供一个函数，作为 mounted 和 updated 钩子
      definition = {
        mounted: definition,
        updated: definition
      }
    }

    this._directives.set(name, definition)
    return this
  }
}
```

#### 2. 指令的解析和绑定

```javascript
// 模板编译时解析指令
function parseDirective(node) {
  const directives = []

  // 遍历元素的属性
  for (const attr of node.attributes) {
    if (attr.name.startsWith('v-')) {
      // 解析指令名、参数、修饰符
      const match = attr.name.match(/^v-([^:\.]+)(?::(.+?))?(?:\.(.+))?$/)

      if (match) {
        const directive = {
          name: match[1],           // 指令名
          arg: match[2] || null,    // 参数
          modifiers: {},            // 修饰符
          value: attr.value         // 值
        }

        // 解析修饰符
        if (match[3]) {
          match[3].split('.').forEach(mod => {
            directive.modifiers[mod] = true
          })
        }

        directives.push(directive)
      }
    }
  }

  return directives
}
```

#### 3. 指令生命周期的调用

```javascript
// 简化版：指令钩子的调用
function invokeDirectiveHook(vnode, name, prevVnode) {
  const { directives } = vnode

  directives.forEach(directive => {
    const hook = directive.def[name] // 获取对应的钩子函数

    if (hook) {
      hook(
        vnode.el,           // 元素
        directive.binding,  // binding 对象
        vnode,              // 当前 vnode
        prevVnode           // 之前的 vnode
      )
    }
  })
}

// 在组件生命周期中调用
function mountComponent(vnode) {
  // ... 创建元素

  // 调用指令的 created 钩子
  invokeDirectiveHook(vnode, 'created')

  // 调用指令的 beforeMount 钩子
  invokeDirectiveHook(vnode, 'beforeMount')

  // 插入 DOM
  document.body.appendChild(vnode.el)

  // 调用指令的 mounted 钩子
  invokeDirectiveHook(vnode, 'mounted')
}
```

### 五、指令 vs 组件

| 特性 | 自定义指令 | 组件 |
|------|-----------|------|
| **用途** | DOM 操作 | 业务逻辑和 UI |
| **复杂度** | 简单 | 可以很复杂 |
| **状态管理** | 不方便 | 内置支持 |
| **可组合性** | 有限 | 强大 |
| **适用场景** | 底层 DOM 操作 | 功能模块 |

**何时使用指令？**
- ✅ 纯 DOM 操作（聚焦、滚动、拖拽）
- ✅ 全局行为（权限、埋点、防抖）
- ✅ 不需要复杂状态的简单功能

**何时使用组件？**
- ✅ 需要复杂的 UI 和交互
- ✅ 需要管理状态
- ✅ 需要生命周期管理
- ✅ 需要与其他组件通信

### 六、最佳实践

#### 1. 避免过度使用

```javascript
// ❌ 不好：用指令实现复杂功能
app.directive('modal', { /* 复杂的弹窗逻辑 */ })

// ✅ 更好：用组件
<Modal v-model="showModal">...</Modal>
```

#### 2. 清理副作用

```javascript
// ✅ 始终清理事件监听器、定时器等
app.directive('example', {
  mounted(el) {
    el._handler = () => { /* ... */ }
    el.addEventListener('click', el._handler)
  },
  beforeUnmount(el) {
    el.removeEventListener('click', el._handler)
    delete el._handler
  }
})
```

#### 3. 处理动态值

```javascript
// ✅ 正确处理值的变化
app.directive('color', {
  mounted(el, binding) {
    el.style.color = binding.value
  },
  updated(el, binding) {
    // 值变化时更新
    if (binding.value !== binding.oldValue) {
      el.style.color = binding.value
    }
  }
})
```

#### 4. 提供配置选项

```javascript
// ✅ 使用对象形式提供配置
app.directive('tooltip', {
  mounted(el, binding) {
    const { value, arg, modifiers } = binding

    const config = {
      text: typeof value === 'string' ? value : value.text,
      position: arg || 'top',
      delay: modifiers.slow ? 500 : 200,
      theme: value.theme || 'dark'
    }

    // 使用配置创建 tooltip
  }
})

// 使用
<div v-tooltip:right.slow="{ text: 'Hint', theme: 'light' }">
  悬停显示提示
</div>
```

### 七、常见面试问题

#### Q1: 自定义指令的生命周期有哪些？

**答：** Vue 3 提供了 7 个钩子：
- created、beforeMount、mounted（创建和挂载）
- beforeUpdate、updated（更新）
- beforeUnmount、unmounted（卸载）

最常用的是 `mounted`（初始化 DOM 操作）和 `unmounted`（清理副作用）。

#### Q2: 指令和组件有什么区别？

**答：**
- **指令**：用于底层 DOM 操作，轻量级，无状态管理
- **组件**：用于功能模块，完整的生命周期，支持状态管理和复杂交互

简单的 DOM 操作用指令，复杂功能用组件。

#### Q3: 如何在自定义指令中访问组件实例？

```javascript
app.directive('example', {
  mounted(el, binding, vnode) {
    // 通过 binding.instance 访问组件实例
    const componentInstance = binding.instance
    console.log(componentInstance.someMethod())
  }
})
```

#### Q4: 自定义指令的函数简写形式是什么？

```javascript
// 完整写法
app.directive('color', {
  mounted(el, binding) {
    el.style.color = binding.value
  },
  updated(el, binding) {
    el.style.color = binding.value
  }
})

// 简写形式（mounted 和 updated 使用同一个函数）
app.directive('color', (el, binding) => {
  el.style.color = binding.value
})
```

### 八、总结

1. **自定义指令**用于封装 DOM 操作逻辑
2. **7 个生命周期钩子**，最常用 mounted 和 unmounted
3. **应用场景**：聚焦、权限、懒加载、拖拽、防抖等
4. **优先使用组件**，只在必要时使用指令
5. **记得清理副作用**，避免内存泄漏
6. **合理使用参数和修饰符**，提高指令灵活性
