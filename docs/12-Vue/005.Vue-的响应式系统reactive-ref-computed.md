---
title: Vue 的响应式系统（reactive、ref、computed）
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue-reactive-system-ref-computed
ref:
---

## 核心要点

- **reactive**：用于包装对象/数组，基于 Proxy 实现深层响应式
- **ref**：用于包装基本类型值，通过 `.value` 访问，对象值会自动调用 reactive
- **computed**：计算属性，基于依赖自动缓存，惰性求值，只在依赖变化时重新计算
- **核心原理**：依赖收集（track）+ 触发更新（trigger）+ 副作用调度（scheduler）

---

## 详细回答

### 一、响应式系统的核心概念

#### 1.1 什么是响应式？

```javascript
// 非响应式：手动更新视图
let count = 0;
function increment() {
  count++;
  document.getElementById('count').textContent = count; // 手动更新
}

// Vue 响应式：自动更新视图
const state = reactive({ count: 0 });
function increment() {
  state.count++; // 自动触发视图更新
}
```

**核心思想**：
- 数据变化时，自动执行相关的副作用函数（渲染、watch 回调等）
- 通过**依赖收集**建立数据与副作用的关系
- 通过**派发更新**在数据变化时通知所有依赖

#### 1.2 响应式系统架构

```
📊 响应式数据（reactive/ref）
    ↓
【依赖收集 - track】
    ↓
💾 依赖映射表（targetMap）
    ↓
【数据变化 - trigger】
    ↓
🔄 副作用队列（effectQueue）
    ↓
【执行副作用 - effect】
    ↓
🎨 更新视图 / 执行回调
```

---

### 二、reactive：对象的响应式包装

#### 2.1 基本用法

```javascript
import { reactive } from 'vue';

// 创建响应式对象
const state = reactive({
  count: 0,
  user: {
    name: 'Alice',
    age: 18
  },
  items: [1, 2, 3]
});

// 访问和修改属性
console.log(state.count); // 0
state.count++;            // 触发更新

// 深层响应式
state.user.name = 'Bob';  // 触发更新
state.items.push(4);      // 触发更新
```

#### 2.2 实现原理

```javascript
// Vue 3 响应式核心实现（简化版）
const targetMap = new WeakMap(); // 存储所有响应式对象的依赖

function reactive(target) {
  // 如果已经是代理对象，直接返回
  if (target.__v_isReactive) {
    return target;
  }

  return new Proxy(target, {
    get(target, key, receiver) {
      // 特殊标记
      if (key === '__v_isReactive') {
        return true;
      }

      const result = Reflect.get(target, key, receiver);

      // 依赖收集
      track(target, key);

      // 如果值是对象，递归包装为响应式（懒代理）
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }

      return result;
    },

    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);

      // 只有值真正改变时才触发更新
      if (oldValue !== value) {
        trigger(target, key);
      }

      return result;
    },

    deleteProperty(target, key) {
      const hadKey = Object.hasOwnProperty.call(target, key);
      const result = Reflect.deleteProperty(target, key);

      // 删除成功时触发更新
      if (hadKey && result) {
        trigger(target, key);
      }

      return result;
    }
  });
}
```

#### 2.3 依赖收集机制

```javascript
// 当前正在执行的副作用函数
let activeEffect;

// 存储依赖关系：WeakMap<target, Map<key, Set<effect>>>
const targetMap = new WeakMap();

function track(target, key) {
  if (!activeEffect) return;

  // 获取 target 对应的 depsMap
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }

  // 获取 key 对应的 dep（依赖集合）
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }

  // 将当前副作用函数添加到依赖集合
  dep.add(activeEffect);
}

// 示例：依赖关系结构
// targetMap = WeakMap {
//   { count: 0 } => Map {
//     'count' => Set [effect1, effect2]
//   }
// }
```

#### 2.4 触发更新机制

```javascript
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;

  const dep = depsMap.get(key);
  if (!dep) return;

  // 执行所有依赖的副作用函数
  dep.forEach(effect => {
    if (effect.scheduler) {
      // 如果有调度器，使用调度器执行（如异步更新队列）
      effect.scheduler();
    } else {
      // 直接执行副作用函数
      effect();
    }
  });
}
```

#### 2.5 完整示例

```javascript
// 创建副作用函数
function effect(fn) {
  const effectFn = () => {
    activeEffect = effectFn;
    fn();
    activeEffect = null;
  };
  effectFn();
  return effectFn;
}

// 使用
const state = reactive({ count: 0 });

effect(() => {
  console.log('Count changed:', state.count); // 依赖收集
});
// 输出：Count changed: 0

state.count++; // 触发更新
// 输出：Count changed: 1
```

---

### 三、ref：基本类型的响应式包装

#### 3.1 基本用法

```javascript
import { ref } from 'vue';

// 创建响应式引用
const count = ref(0);
const message = ref('Hello');

// 通过 .value 访问和修改
console.log(count.value);  // 0
count.value++;             // 触发更新

// 对象值会自动调用 reactive
const user = ref({ name: 'Alice' });
user.value.name = 'Bob';   // 触发更新（深层响应式）
```

#### 3.2 实现原理

```javascript
class RefImpl {
  constructor(value) {
    this._rawValue = value;
    this._value = convert(value);
    this.__v_isRef = true;
  }

  get value() {
    // 依赖收集
    track(this, 'value');
    return this._value;
  }

  set value(newValue) {
    if (newValue !== this._rawValue) {
      this._rawValue = newValue;
      this._value = convert(newValue);
      // 触发更新
      trigger(this, 'value');
    }
  }
}

function convert(value) {
  // 对象类型使用 reactive，基本类型直接返回
  return typeof value === 'object' && value !== null
    ? reactive(value)
    : value;
}

function ref(value) {
  return new RefImpl(value);
}
```

#### 3.3 为什么需要 ref？

```javascript
// ❌ reactive 不能包装基本类型
const count = reactive(0); // 无效，会返回 0

// ✅ ref 可以包装基本类型
const count = ref(0);
count.value++; // 有效

// ❌ reactive 包装的基本类型丢失响应式
let state = reactive({ count: 0 });
let { count } = state;  // 解构后 count 变成普通数字
count++;                // 不会触发更新

// ✅ ref 保持响应式
const count = ref(0);
const anotherCount = count; // 仍然是响应式
anotherCount.value++;       // 触发更新
```

#### 3.4 模板中的自动解包

```vue
<template>
  <!-- ref 在模板中自动解包，不需要 .value -->
  <div>{{ count }}</div>
  <button @click="count++">Increment</button>
</template>

<script setup>
import { ref } from 'vue';

const count = ref(0);

// 在 JS 中仍需要 .value
function increment() {
  count.value++;
}
</script>
```

**解包规则**：
```javascript
// 1. 顶层 ref 自动解包
const count = ref(0);
// 模板：{{ count }} ✅

// 2. 嵌套在 reactive 对象中自动解包
const state = reactive({
  count: ref(0)
});
console.log(state.count); // 0 (自动解包)
state.count++; // 有效

// 3. 数组/Map 中不会自动解包
const list = reactive([ref(0)]);
console.log(list[0].value); // 需要 .value ❌
```

---

### 四、computed：计算属性

#### 4.1 基本用法

```javascript
import { ref, computed } from 'vue';

const count = ref(0);

// 只读计算属性
const doubled = computed(() => {
  console.log('Computing...');
  return count.value * 2;
});

console.log(doubled.value); // Computing... 0
console.log(doubled.value); // 0 (使用缓存，不重新计算)

count.value++;
console.log(doubled.value); // Computing... 2 (依赖变化，重新计算)

// 可写计算属性
const fullName = computed({
  get() {
    return `${firstName.value} ${lastName.value}`;
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ');
  }
});
```

#### 4.2 实现原理

```javascript
class ComputedRefImpl {
  constructor(getter, setter) {
    this._getter = getter;
    this._setter = setter;
    this._dirty = true;   // 脏标记：是否需要重新计算
    this._value = undefined;

    // 创建副作用函数
    this.effect = effect(getter, {
      lazy: true,  // 懒执行，不立即计算
      scheduler: () => {
        // 依赖变化时，标记为脏，不立即计算
        if (!this._dirty) {
          this._dirty = true;
          // 触发依赖此计算属性的副作用
          trigger(this, 'value');
        }
      }
    });
  }

  get value() {
    // 依赖收集
    track(this, 'value');

    // 如果是脏的，重新计算
    if (this._dirty) {
      this._value = this.effect();
      this._dirty = false;
    }

    return this._value;
  }

  set value(newValue) {
    this._setter(newValue);
  }
}

function computed(getterOrOptions) {
  let getter, setter;

  if (typeof getterOrOptions === 'function') {
    getter = getterOrOptions;
    setter = () => {
      console.warn('Computed property is readonly');
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  return new ComputedRefImpl(getter, setter);
}
```

#### 4.3 缓存机制

```javascript
const count = ref(0);

// ❌ 函数：每次访问都重新计算
function doubled() {
  console.log('Computing...');
  return count.value * 2;
}

console.log(doubled()); // Computing... 0
console.log(doubled()); // Computing... 0 (重复计算)

// ✅ computed：有缓存，只在依赖变化时计算
const doubledComputed = computed(() => {
  console.log('Computing...');
  return count.value * 2;
});

console.log(doubledComputed.value); // Computing... 0
console.log(doubledComputed.value); // 0 (使用缓存)
count.value++;
console.log(doubledComputed.value); // Computing... 2 (依赖变化，重新计算)
```

#### 4.4 惰性求值

```javascript
const count = ref(0);

// computed 是惰性的，不访问就不计算
const expensive = computed(() => {
  console.log('Expensive computation...');
  let sum = 0;
  for (let i = 0; i < 1000000; i++) {
    sum += count.value;
  }
  return sum;
});

// 此时还没有计算
count.value = 10;

// 第一次访问时才计算
console.log(expensive.value); // Expensive computation... 10000000
```

---

### 五、三者对比与选择

#### 5.1 功能对比表

| 特性 | reactive | ref | computed |
|------|----------|-----|----------|
| **适用类型** | 对象、数组 | 任意类型 | 基于其他响应式数据计算 |
| **访问方式** | 直接访问 | `.value` 访问 | `.value` 访问 |
| **深层响应式** | ✅ 默认深层 | ✅ 对象值自动 reactive | ✅ 根据依赖 |
| **模板解包** | ✅ 自动 | ✅ 顶层自动 | ✅ 自动 |
| **解构后响应式** | ❌ 丢失 | ✅ 保持 | ✅ 保持 |
| **性能开销** | 中（Proxy） | 低（getter/setter） | 低（有缓存） |
| **适用场景** | 复杂对象 | 单个值、函数参数 | 派生状态 |

#### 5.2 使用场景

```javascript
// 1️⃣ reactive：管理复杂对象
const state = reactive({
  user: {
    name: 'Alice',
    age: 18
  },
  settings: {
    theme: 'dark',
    lang: 'zh'
  }
});

// 2️⃣ ref：单个基本类型值
const count = ref(0);
const isLoading = ref(false);
const message = ref('Hello');

// 3️⃣ ref：需要在函数间传递
function useCounter() {
  const count = ref(0);
  const increment = () => count.value++;
  return { count, increment }; // 解构后仍保持响应式
}

// 4️⃣ computed：派生数据
const firstName = ref('John');
const lastName = ref('Doe');
const fullName = computed(() => `${firstName.value} ${lastName.value}`);

const items = ref([1, 2, 3, 4, 5]);
const evenItems = computed(() => items.value.filter(x => x % 2 === 0));
```

#### 5.3 最佳实践

```javascript
// ❌ 不好的实践
const state = reactive({
  count: ref(0)  // 嵌套 ref 容易混淆
});

// ✅ 好的实践
const state = reactive({
  count: 0  // reactive 内直接用普通值
});

// 或
const count = ref(0);  // 顶层用 ref


// ❌ 避免解构 reactive
const state = reactive({ count: 0 });
const { count } = state;  // 丢失响应式
count++;  // 无效

// ✅ 使用 toRefs 解构
import { toRefs } from 'vue';
const state = reactive({ count: 0 });
const { count } = toRefs(state);  // 保持响应式
count.value++;  // 有效


// ❌ 避免在 computed 中执行副作用
const fullName = computed(() => {
  console.log('Side effect!');  // 不推荐
  return `${firstName.value} ${lastName.value}`;
});

// ✅ 使用 watch 执行副作用
watch([firstName, lastName], () => {
  console.log('Name changed!');
});
```

---

### 六、高级 API

#### 6.1 shallowReactive：浅层响应式

```javascript
import { shallowReactive } from 'vue';

const state = shallowReactive({
  count: 0,
  nested: {
    value: 1
  }
});

state.count++;         // ✅ 触发更新
state.nested.value++;  // ❌ 不触发更新（只有第一层是响应式的）
state.nested = { value: 2 }; // ✅ 触发更新（替换整个对象）
```

**适用场景**：
- 大型不可变数据结构（如图表配置）
- 性能优化（减少深层代理的开销）

#### 6.2 toRefs / toRef

```javascript
import { reactive, toRefs, toRef } from 'vue';

const state = reactive({
  count: 0,
  message: 'Hello'
});

// toRefs：转换所有属性为 ref
const stateRefs = toRefs(state);
console.log(stateRefs.count.value); // 0
stateRefs.count.value++; // 触发更新

// toRef：转换单个属性为 ref
const count = toRef(state, 'count');
count.value++; // 触发更新
```

#### 6.3 isRef / isReactive / isProxy

```javascript
import { ref, reactive, isRef, isReactive, isProxy } from 'vue';

const count = ref(0);
const state = reactive({ count: 0 });

console.log(isRef(count));       // true
console.log(isReactive(state));  // true
console.log(isProxy(count));     // false (ref 不是 Proxy)
console.log(isProxy(state));     // true
```

#### 6.4 markRaw / readonly

```javascript
import { reactive, markRaw, readonly } from 'vue';

// markRaw：标记对象永远不被转为响应式
const raw = markRaw({ count: 0 });
const state = reactive({ raw });
state.raw.count++; // 不触发更新

// readonly：创建只读代理
const original = reactive({ count: 0 });
const copy = readonly(original);
copy.count++; // 警告：只读属性
original.count++; // ✅ 原对象仍可修改
```

---

### 七、性能优化技巧

#### 7.1 使用 shallowRef 避免深层响应式

```javascript
import { shallowRef } from 'vue';

// ❌ 深层响应式（性能差）
const largeData = ref({
  level1: { level2: { level3: { /* 深层嵌套 */ } } }
});

// ✅ 浅层响应式（性能好）
const largeData = shallowRef({
  level1: { level2: { level3: { /* 深层嵌套 */ } } }
});
// 只有整体替换才触发更新
largeData.value = newData;
```

#### 7.2 使用 computed 缓存复杂计算

```javascript
// ❌ 每次访问都计算
const filteredItems = items.value.filter(item => item.active);

// ✅ 有缓存，依赖不变时不重新计算
const filteredItems = computed(() =>
  items.value.filter(item => item.active)
);
```

#### 7.3 合理使用 markRaw

```javascript
// 第三方库实例不需要响应式
import Chart from 'chart.js';

const state = reactive({
  chart: markRaw(new Chart(...))  // 避免代理 Chart 实例
});
```

---

### 八、面试回答建议

**简洁版（1-2 分钟）**：
> Vue 3 的响应式系统基于 Proxy 实现，提供了三个核心 API：
>
> - **reactive**：用于包装对象和数组，提供深层响应式
> - **ref**：用于包装基本类型值，通过 `.value` 访问，对象值会自动调用 reactive
> - **computed**：计算属性，基于依赖自动缓存，只在依赖变化时重新计算
>
> 核心原理是依赖收集和派发更新：访问响应式数据时收集依赖（track），修改数据时触发更新（trigger），执行所有相关的副作用函数。

**深入版（3-5 分钟）**：
在简洁版基础上，补充：
1. **依赖收集机制**：WeakMap 存储依赖关系，Set 存储副作用函数
2. **computed 缓存原理**：脏标记（dirty flag）+ 惰性求值
3. **三者选择**：reactive 用于对象，ref 用于基本类型和需要传递的场景，computed 用于派生状态
4. **性能优化**：shallowReactive、shallowRef、markRaw 的使用场景
5. **常见陷阱**：reactive 解构丢失响应式、ref 在数组中不自动解包

---

### 九、扩展知识点

#### 9.1 effect 调度器（Scheduler）

```javascript
const state = reactive({ count: 0 });

effect(
  () => {
    console.log('Count:', state.count);
  },
  {
    scheduler(job) {
      // 自定义调度：异步更新队列
      queueJob(job);
    }
  }
);

state.count++; // 不立即执行，加入队列
state.count++; // 合并更新
state.count++; // 合并更新

// 下一个 tick 执行一次
// 输出：Count: 3
```

#### 9.2 stop：停止副作用

```javascript
import { effect, stop } from 'vue';

const state = reactive({ count: 0 });

const runner = effect(() => {
  console.log('Count:', state.count);
});
// 输出：Count: 0

state.count++; // 输出：Count: 1

stop(runner); // 停止副作用

state.count++; // 不再输出
```

#### 9.3 watch 的底层实现

```javascript
import { watch, reactive } from 'vue';

const state = reactive({ count: 0 });

// watch 本质上是 effect + scheduler
watch(
  () => state.count,  // getter 函数
  (newValue, oldValue) => {
    console.log(`${oldValue} → ${newValue}`);
  }
);

// 等价于
effect(
  () => {
    const value = state.count; // 触发依赖收集
    return value;
  },
  {
    scheduler(job) {
      // 在 scheduler 中执行回调
      const newValue = job();
      callback(newValue, oldValue);
      oldValue = newValue;
    }
  }
);
```
