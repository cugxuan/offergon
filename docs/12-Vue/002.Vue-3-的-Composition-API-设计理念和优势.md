---
title: Vue 3 的 Composition API 设计理念和优势
tags:
  - 前端Vue
status: robot
class: 前端Vue
slug: vue3-composition-api-design-and-advantages
ref:
---

## 核心要点

- **设计理念**：基于函数的逻辑组合，解决 Options API 在大型组件中的代码碎片化和逻辑复用问题
- **核心优势**：更好的逻辑复用、类型推断、代码组织和 Tree-shaking
- **关键对比**：Options API 按选项分散逻辑，Composition API 按功能聚合逻辑
- **适用场景**：大型复杂组件、需要复用逻辑的场景、TypeScript 项目

---

## 详细回答

### 一、Options API 的痛点

#### 1.1 代码碎片化问题

在 Vue 2 的 Options API 中，同一个功能的代码被强制分散到不同选项中：

```javascript
export default {
  data() {
    return {
      // 用户相关
      user: null,
      userLoading: false,
      userError: null,

      // 文章相关
      posts: [],
      postsLoading: false,
      postsError: null,

      // 评论相关
      comments: [],
      commentsLoading: false,
      commentsError: null
    };
  },

  computed: {
    // 用户相关计算属性
    userName() {
      return this.user?.name || '匿名';
    },

    // 文章相关计算属性
    publishedPosts() {
      return this.posts.filter(p => p.published);
    },

    // 评论相关计算属性
    latestComments() {
      return this.comments.slice(0, 5);
    }
  },

  methods: {
    // 用户相关方法
    async fetchUser() { /* ... */ },
    updateUser() { /* ... */ },

    // 文章相关方法
    async fetchPosts() { /* ... */ },
    deletePost() { /* ... */ },

    // 评论相关方法
    async fetchComments() { /* ... */ },
    replyComment() { /* ... */ }
  },

  mounted() {
    // 初始化时需要调用三个功能的方法
    this.fetchUser();
    this.fetchPosts();
    this.fetchComments();
  }
};
```

**问题**：
1. **可维护性差**：同一个功能（如"用户管理"）的代码分散在 data、computed、methods、mounted 等多个选项中
2. **导航困难**：修改一个功能需要在文件中上下跳转
3. **难以理解**：新人接手时很难快速理解代码的业务逻辑

#### 1.2 逻辑复用困难

Vue 2 的逻辑复用方案都有明显缺陷：

```javascript
// 方案 1：Mixins（命名冲突、来源不清晰）
export default {
  mixins: [userMixin, postMixin],
  data() {
    return {
      count: 0 // 可能被 mixin 覆盖，不知道最终值是什么
    };
  }
};

// 方案 2：高阶组件（包装地狱、props 来源不明）
export default {
  extends: BaseComponent,
  // 不知道哪些 props 是从父组件来的，哪些是注入的
};

// 方案 3：Renderless 组件（增加嵌套层级、性能开销）
<DataProvider v-slot="{ data, loading }">
  <UserProvider v-slot="{ user }">
    <PostProvider v-slot="{ posts }">
      <!-- 嵌套地狱 -->
    </PostProvider>
  </UserProvider>
</DataProvider>
```

#### 1.3 TypeScript 支持不足

```javascript
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      // TypeScript 难以推断 this.count 的类型
      this.count++;
    }
  }
};
```

---

### 二、Composition API 的设计理念

#### 2.1 核心思想：逻辑组合

Composition API 将组件按**功能**而非**选项类型**组织代码：

```javascript
import { ref, computed, onMounted } from 'vue';

export default {
  setup() {
    // 📦 用户相关逻辑集中在一起
    const user = ref(null);
    const userLoading = ref(false);
    const userName = computed(() => user.value?.name || '匿名');
    const fetchUser = async () => {
      userLoading.value = true;
      user.value = await api.getUser();
      userLoading.value = false;
    };

    // 📦 文章相关逻辑集中在一起
    const posts = ref([]);
    const postsLoading = ref(false);
    const publishedPosts = computed(() => posts.value.filter(p => p.published));
    const fetchPosts = async () => {
      postsLoading.value = true;
      posts.value = await api.getPosts();
      postsLoading.value = false;
    };

    // 📦 评论相关逻辑集中在一起
    const comments = ref([]);
    const latestComments = computed(() => comments.value.slice(0, 5));
    const fetchComments = async () => {
      comments.value = await api.getComments();
    };

    // 统一初始化
    onMounted(() => {
      fetchUser();
      fetchPosts();
      fetchComments();
    });

    return {
      user, userName, fetchUser,
      posts, publishedPosts, fetchPosts,
      comments, latestComments, fetchComments
    };
  }
};
```

**优势明显**：
- ✅ 相关逻辑聚合在一起，一目了然
- ✅ 修改某个功能时不需要跳转文件位置
- ✅ 可以轻松抽离为独立的组合式函数

#### 2.2 组合式函数（Composables）

将功能抽离为可复用的函数：

```javascript
// composables/useUser.js
export function useUser() {
  const user = ref(null);
  const loading = ref(false);
  const error = ref(null);

  const userName = computed(() => user.value?.name || '匿名');

  const fetchUser = async () => {
    loading.value = true;
    error.value = null;
    try {
      user.value = await api.getUser();
    } catch (e) {
      error.value = e;
    } finally {
      loading.value = false;
    }
  };

  return {
    user,
    userName,
    loading,
    error,
    fetchUser
  };
}

// 组件中使用
import { useUser } from '@/composables/useUser';

export default {
  setup() {
    const { user, userName, fetchUser } = useUser();
    const { posts, fetchPosts } = usePosts();
    const { comments, fetchComments } = useComments();

    onMounted(() => {
      fetchUser();
      fetchPosts();
      fetchComments();
    });

    return {
      userName,
      posts,
      comments
    };
  }
};
```

**与 Mixins 对比**：
| 特性 | Mixins | Composables |
|------|--------|-------------|
| **命名冲突** | ❌ 容易冲突，且难以发现 | ✅ 解构时可重命名 |
| **来源清晰** | ❌ 不知道属性从哪来 | ✅ 明确的 import |
| **类型推断** | ❌ TypeScript 支持差 | ✅ 完美支持 |
| **按需引入** | ❌ 全量引入 | ✅ 按需解构 |

---

### 三、Composition API 的核心优势

#### 3.1 更好的逻辑复用

**实战案例：鼠标位置追踪**

```javascript
// composables/useMouse.js
import { ref, onMounted, onUnmounted } from 'vue';

export function useMouse() {
  const x = ref(0);
  const y = ref(0);

  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }

  onMounted(() => {
    window.addEventListener('mousemove', update);
  });

  onUnmounted(() => {
    window.removeEventListener('mousemove', update);
  });

  return { x, y };
}

// 在任意组件中使用
import { useMouse } from '@/composables/useMouse';

export default {
  setup() {
    const { x, y } = useMouse();
    return { x, y };
  }
};
```

**复杂案例：组合多个 Composables**

```javascript
import { useFetch } from '@/composables/useFetch';
import { useLocalStorage } from '@/composables/useLocalStorage';
import { useDebounce } from '@/composables/useDebounce';

export default {
  setup() {
    // 组合多个功能
    const { data, loading } = useFetch('/api/users');
    const { value: theme, set: setTheme } = useLocalStorage('theme', 'light');
    const debouncedSearch = useDebounce(searchQuery, 500);

    // 逻辑清晰、易于理解
    return {
      users: data,
      loading,
      theme,
      setTheme,
      debouncedSearch
    };
  }
};
```

#### 3.2 更好的类型推断

```typescript
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0); // TypeScript 自动推断为 Ref<number>
    const doubled = computed(() => count.value * 2); // 自动推断为 ComputedRef<number>

    function increment() {
      count.value++; // 类型安全，编译器会检查
    }

    return {
      count,
      doubled,
      increment
    };
  }
};
```

对比 Options API：
```javascript
// Options API 中 TypeScript 需要额外配置
export default {
  data() {
    return {
      count: 0 as number // 需要手动标注
    };
  },
  methods: {
    increment() {
      // this.count 的类型推断依赖复杂的类型系统
      this.count++;
    }
  }
};
```

#### 3.3 更好的代码组织

**按功能拆分代码**：

```javascript
// ❌ Options API：按选项拆分（不直观）
export default {
  data() { /* 搜索、筛选、分页的数据混在一起 */ },
  computed: { /* 搜索、筛选、分页的计算属性混在一起 */ },
  methods: { /* 搜索、筛选、分页的方法混在一起 */ }
};

// ✅ Composition API：按功能拆分（清晰明了）
export default {
  setup() {
    // 🔍 搜索功能
    const { searchQuery, searchResults, search } = useSearch();

    // 🎯 筛选功能
    const { filters, applyFilters } = useFilters();

    // 📄 分页功能
    const { currentPage, totalPages, goToPage } = usePagination();

    // 或者内联实现
    const searchLogic = () => { /* 搜索逻辑 */ };
    const filterLogic = () => { /* 筛选逻辑 */ };
    const paginationLogic = () => { /* 分页逻辑 */ };

    return { /* ... */ };
  }
};
```

#### 3.4 更好的 Tree-shaking

```javascript
// Options API：整个 Vue 对象都会被打包
import Vue from 'vue';

// Composition API：按需引入
import { ref, computed } from 'vue'; // 只打包用到的 API
```

Vue 3 的包体积比 Vue 2 小 41%（13.5kb vs 23kb），部分归功于 Composition API 的按需引入。

---

### 四、实际应用场景对比

#### 场景 1：大型表单组件

```javascript
// ❌ Options API：代码分散，难以维护（300+ 行）
export default {
  data() {
    return {
      // 表单字段（50+ 行）
      personalInfo: {},
      workInfo: {},
      contactInfo: {},
      // 验证状态（30+ 行）
      errors: {},
      // 表单状态（20+ 行）
      loading: false,
      submitted: false
    };
  },
  computed: {
    // 各种计算属性（80+ 行）
  },
  methods: {
    // 各种方法（100+ 行）
  }
};

// ✅ Composition API：按功能模块拆分
export default {
  setup() {
    const { personalInfo, validatePersonalInfo } = usePersonalInfo();
    const { workInfo, validateWorkInfo } = useWorkInfo();
    const { contactInfo, validateContactInfo } = useContactInfo();
    const { submit, loading, submitted } = useFormSubmit();

    return {
      personalInfo,
      workInfo,
      contactInfo,
      submit,
      loading
    };
  }
};
```

#### 场景 2：复杂的数据获取逻辑

```javascript
// composables/useFetch.js
export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);
  const loading = ref(false);

  const execute = async () => {
    loading.value = true;
    error.value = null;
    try {
      const response = await fetch(url.value);
      data.value = await response.json();
    } catch (e) {
      error.value = e;
    } finally {
      loading.value = false;
    }
  };

  // 自动执行
  watchEffect(execute);

  return { data, error, loading, retry: execute };
}

// 组件中使用
const { data: users } = useFetch(ref('/api/users'));
const { data: posts } = useFetch(ref('/api/posts'));
```

#### 场景 3：生命周期钩子的灵活使用

```javascript
export default {
  setup() {
    // 可以在任意位置、任意次数调用生命周期钩子
    const { start, stop } = useTimer();

    onMounted(() => {
      start();
      console.log('Timer started');
    });

    onMounted(() => {
      // 可以多次注册同一个钩子
      console.log('Component mounted');
    });

    onUnmounted(() => {
      stop();
    });

    // 甚至可以在 Composable 内部注册钩子
    function useAutoSave() {
      onMounted(() => {
        setInterval(save, 5000);
      });
    }

    useAutoSave();
  }
};
```

---

### 五、Composition API vs Options API

#### 5.1 何时使用 Composition API？

✅ **推荐使用场景**：
- 大型复杂组件（200+ 行）
- 需要复用逻辑的场景
- TypeScript 项目
- 需要更好的代码组织和可维护性

✅ **推荐使用 Options API**：
- 简单组件（< 100 行）
- 团队不熟悉 Composition API
- 不需要复杂的逻辑复用

#### 5.2 两者可以混用

```javascript
export default {
  // Options API
  props: ['userId'],

  // Composition API
  setup(props) {
    const user = ref(null);

    watchEffect(() => {
      // 可以访问 props
      fetchUser(props.userId);
    });

    return { user };
  },

  // Options API
  computed: {
    userName() {
      return this.user?.name;
    }
  }
};
```

---

### 六、面试回答建议

**简洁版（1-2 分钟）**：
> Composition API 是 Vue 3 引入的新特性，它基于函数组合的思想来组织组件逻辑。核心优势是解决了 Options API 的两大痛点：
>
> 1. **代码碎片化**：Options API 按选项类型（data、methods、computed）分散代码，导致同一功能的代码散落各处。Composition API 允许按功能聚合逻辑，提高可维护性。
>
> 2. **逻辑复用困难**：Mixins 有命名冲突和来源不清的问题。Composition API 通过组合式函数（Composables）实现更优雅的逻辑复用，支持任意组合、重命名，且 TypeScript 类型推断完美。

**深入版（3-5 分钟）**：
在简洁版基础上，补充：
1. **具体代码示例**：展示同一组件用两种 API 的实现对比
2. **Composables 实战**：`useMouse`、`useFetch` 等通用逻辑的封装
3. **适用场景**：大型组件用 Composition API，小组件可用 Options API
4. **性能优势**：Tree-shaking、更小的打包体积
5. **迁移策略**：两者可以混用，渐进式迁移

---

### 七、扩展知识点

#### 7.1 Script Setup 语法糖

Vue 3.2+ 提供了更简洁的写法：

```vue
<script setup>
import { ref, computed } from 'vue';

// 无需 setup 函数，顶层变量自动暴露给模板
const count = ref(0);
const doubled = computed(() => count.value * 2);

function increment() {
  count.value++;
}
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Doubled: {{ doubled }}</p>
    <button @click="increment">+1</button>
  </div>
</template>
```

#### 7.2 常见 Composables 库

- **VueUse**：100+ 实用组合式函数（https://vueuse.org/）
  ```javascript
  import { useMouse, useLocalStorage, useDebounce } from '@vueuse/core';
  ```

- **自定义 Composables 设计原则**：
  1. 以 `use` 开头命名
  2. 接受 `ref` 参数，返回 `ref` 值
  3. 清理副作用（在 `onUnmounted` 中）
  4. 避免副作用（纯函数优先）

#### 7.3 性能对比

| 指标 | Options API | Composition API |
|------|-------------|-----------------|
| **初始化性能** | 略快（对象遍历） | 略慢（函数调用） |
| **内存占用** | 每个实例都有完整的 options 对象 | 可共享逻辑，内存占用更小 |
| **Tree-shaking** | 不支持 | 支持，打包体积更小 |
| **大型组件性能** | 随代码量增长性能下降明显 | 影响较小 |
