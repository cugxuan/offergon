---
title: Vue 的 keep-alive 缓存组件原理
tags:
  - 前端Vue
  - 缓存策略
status: robot
class: 前端Vue
slug: vue-keep-alive-component-caching-principle
ref:
---

## 核心要点

**keep-alive 是 Vue 内置的抽象组件，通过 LRU 缓存策略缓存组件实例，避免重复渲染和销毁，保留组件状态和 DOM。核心机制包括：组件实例缓存、VNode 标记、生命周期钩子（activated/deactivated）、以及 include/exclude/max 的灵活控制。**

---

## 详细回答

### 一、keep-alive 的本质与作用

`keep-alive` 是 Vue 提供的一个**抽象组件**（abstract component），它本身不会渲染成 DOM 元素，也不会出现在父组件链中。它的主要作用是：

1. **缓存组件实例**：当组件被切换时，不销毁组件实例，而是将其缓存起来
2. **保留组件状态**：缓存的组件保留其数据状态、DOM 状态和用户交互状态
3. **性能优化**：避免重复的组件创建、渲染和销毁，减少性能开销
4. **提升用户体验**：快速恢复组件状态，如表单填写、滚动位置等

### 二、核心实现原理

#### 1. 缓存策略：LRU 算法

keep-alive 内部使用 **LRU（Least Recently Used，最近最少使用）** 算法来管理缓存：

```javascript
// Vue 3 源码简化示例
const cache = new Map()  // 缓存组件实例
const keys = new Set()   // 缓存的 key 集合

// 缓存组件时
if (cache.has(key)) {
  // 已存在，更新为最新访问（移到末尾）
  keys.delete(key)
  keys.add(key)
} else {
  // 新增缓存
  keys.add(key)
  cache.set(key, vnode)

  // 超出 max 限制，删除最久未使用的（第一个）
  if (max && keys.size > parseInt(max)) {
    const oldestKey = keys.values().next().value
    keys.delete(oldestKey)
    cache.delete(oldestKey)
  }
}
```

#### 2. 组件缓存流程

**首次渲染时：**
```
创建组件实例 → 渲染组件 → 将实例和 VNode 缓存到 cache 中 → 标记 VNode 为 keepAlive
```

**切换离开时：**
```
触发 deactivated 钩子 → 不销毁实例 → 将 DOM 移除但保留实例
```

**再次渲染时：**
```
检查 cache 是否存在 → 存在则取出缓存实例 → 触发 activated 钩子 → 复用实例直接渲染
```

#### 3. VNode 标记机制

keep-alive 会在缓存的 VNode 上添加特殊标记：

```javascript
// Vue 内部处理
vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE

// 渲染器识别标记后会：
// 1. 不调用 unmount（销毁）逻辑
// 2. 调用 deactivate 而非 unmount
// 3. 保留组件实例在内存中
```

### 三、生命周期钩子

keep-alive 引入了两个特殊的生命周期钩子：

| 钩子 | 触发时机 | 用途 |
|------|---------|------|
| **activated** | 组件被激活时（从缓存中恢复） | 重新获取数据、恢复定时器、重新订阅事件等 |
| **deactivated** | 组件被停用时（进入缓存） | 清理定时器、取消订阅、暂停请求等 |

```vue
<script setup>
import { onActivated, onDeactivated } from 'vue'

let timer = null

onActivated(() => {
  console.log('组件被激活，从缓存中恢复')
  // 重新启动定时器
  timer = setInterval(() => {
    console.log('刷新数据')
  }, 1000)
})

onDeactivated(() => {
  console.log('组件被缓存')
  // 清理定时器，避免内存泄漏
  if (timer) {
    clearInterval(timer)
    timer = null
  }
})
</script>
```

### 四、配置选项详解

#### 1. include / exclude

精确控制哪些组件需要缓存：

```vue
<!-- 匹配组件的 name 选项 -->
<keep-alive include="ComponentA,ComponentB">
  <component :is="currentComponent" />
</keep-alive>

<!-- 使用正则表达式 -->
<keep-alive :include="/^Component/">
  <router-view />
</keep-alive>

<!-- 使用数组 -->
<keep-alive :include="['ComponentA', 'ComponentB']">
  <router-view />
</keep-alive>

<!-- 排除指定组件 -->
<keep-alive exclude="ComponentC">
  <router-view />
</keep-alive>
```

**注意事项：**
- 匹配的是组件的 `name` 选项，不是组件的注册名
- 组件必须显式定义 `name` 选项才能被匹配

```vue
<!-- 组件需要定义 name -->
<script setup>
defineOptions({
  name: 'UserList'  // Vue 3.3+ 语法
})
</script>

<!-- 或者 Vue 3.3 以下版本 -->
<script>
export default {
  name: 'UserList'
}
</script>
```

#### 2. max

限制最大缓存数量：

```vue
<keep-alive :max="10">
  <router-view />
</keep-alive>
```

当缓存数量达到 `max` 时，会删除最久未访问的组件实例。

### 五、实际应用场景

#### 1. 路由缓存（最常见）

```vue
<!-- App.vue -->
<template>
  <router-view v-slot="{ Component }">
    <keep-alive :include="cachedViews">
      <component :is="Component" :key="$route.fullPath" />
    </keep-alive>
  </router-view>
</template>

<script setup>
import { computed } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()

// 根据路由 meta 动态控制缓存
const cachedViews = computed(() => {
  return route.meta.keepAlive ? [route.name] : []
})
</script>
```

路由配置：

```javascript
const routes = [
  {
    path: '/list',
    name: 'UserList',
    component: () => import('./UserList.vue'),
    meta: { keepAlive: true }  // 需要缓存
  },
  {
    path: '/detail/:id',
    name: 'UserDetail',
    component: () => import('./UserDetail.vue'),
    meta: { keepAlive: false }  // 不缓存
  }
]
```

#### 2. Tab 切换场景

```vue
<template>
  <div class="tabs">
    <button @click="activeTab = 'tab1'">Tab 1</button>
    <button @click="activeTab = 'tab2'">Tab 2</button>
    <button @click="activeTab = 'tab3'">Tab 3</button>
  </div>

  <keep-alive>
    <component :is="activeTab" />
  </keep-alive>
</template>

<script setup>
import { ref } from 'vue'
import Tab1 from './Tab1.vue'
import Tab2 from './Tab2.vue'
import Tab3 from './Tab3.vue'

const activeTab = ref('tab1')
</script>
```

#### 3. 动态缓存控制

结合 Pinia/Vuex 全局管理缓存列表：

```javascript
// store/cache.js
import { defineStore } from 'pinia'

export const useCacheStore = defineStore('cache', {
  state: () => ({
    cachedViews: []
  }),
  actions: {
    addCachedView(view) {
      if (!this.cachedViews.includes(view)) {
        this.cachedViews.push(view)
      }
    },
    removeCachedView(view) {
      const index = this.cachedViews.indexOf(view)
      if (index > -1) {
        this.cachedViews.splice(index, 1)
      }
    },
    clearAllCache() {
      this.cachedViews = []
    }
  }
})
```

```vue
<!-- App.vue -->
<template>
  <router-view v-slot="{ Component }">
    <keep-alive :include="cacheStore.cachedViews">
      <component :is="Component" />
    </keep-alive>
  </router-view>
</template>

<script setup>
import { useCacheStore } from '@/stores/cache'
const cacheStore = useCacheStore()
</script>
```

### 六、常见问题与解决方案

#### 1. 缓存失效问题

**问题**：切换后组件没有被缓存

**原因与解决**：
- 组件未定义 `name` 选项 → 添加 `name` 选项
- `include` 匹配失败 → 检查 name 是否正确
- 使用了 `v-if` 而非 `v-show` → keep-alive 内部用 `component :is` 或 `router-view`

#### 2. 缓存数据不更新

**问题**：缓存的组件数据过时

**解决方案**：

```vue
<script setup>
import { onActivated } from 'vue'

onActivated(() => {
  // 每次激活时重新获取数据
  fetchData()
})

async function fetchData() {
  // 获取最新数据
}
</script>
```

#### 3. 内存泄漏风险

**问题**：大量缓存导致内存占用过高

**解决方案**：
```vue
<!-- 设置 max 限制 -->
<keep-alive :max="10">
  <router-view />
</keep-alive>
```

```javascript
// 或在适当时机清除缓存
import { useCacheStore } from '@/stores/cache'

function logout() {
  useCacheStore().clearAllCache()
}
```

#### 4. 列表页滚动位置保存

```vue
<script setup>
import { ref, onActivated, onDeactivated } from 'vue'

const scrollTop = ref(0)
const listEl = ref(null)

onActivated(() => {
  // 恢复滚动位置
  if (listEl.value) {
    listEl.value.scrollTop = scrollTop.value
  }
})

onDeactivated(() => {
  // 保存滚动位置
  if (listEl.value) {
    scrollTop.value = listEl.value.scrollTop
  }
})
</script>

<template>
  <div ref="listEl" class="list-container">
    <!-- 列表内容 -->
  </div>
</template>
```

### 七、Vue 2 vs Vue 3 的差异

| 特性 | Vue 2 | Vue 3 |
|------|-------|-------|
| 缓存数据结构 | Object | Map |
| LRU 实现 | 数组 | Set |
| 生命周期钩子 | activated/deactivated | 相同，但需 import |
| 性能 | 较低 | 更高效 |

### 八、面试总结

面试时应重点强调：

1. **原理**：抽象组件 + LRU 缓存策略 + VNode 标记
2. **核心机制**：不销毁实例，仅移除 DOM，保留状态
3. **生命周期**：activated/deactivated 的使用场景
4. **性能优化**：避免重复渲染、保留状态、max 限制
5. **实际应用**：路由缓存、Tab 切换、动态控制
6. **注意事项**：组件 name 定义、内存管理、数据更新

**高级回答可补充**：
- LRU 算法的实现细节（Map + Set 的优势）
- 渲染器对 COMPONENT_KEPT_ALIVE 标记的处理逻辑
- 与 Vue Router 结合的最佳实践
- 大型应用的缓存管理策略（Pinia/Vuex 全局控制）
