---
title: Vue 的 nextTick 实现原理
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue-nexttick-implementation-principle
ref:
---

## 核心要点

**nextTick 是 Vue 的异步更新队列机制，确保在 DOM 更新完成后执行回调。核心原理：利用微任务（Promise）或宏任务（setTimeout）实现异步延迟执行，保证获取最新的 DOM 状态。**

---

## 详细回答

### 一、为什么需要 nextTick？

在 Vue 中，当我们修改响应式数据后，DOM 并不会立即更新。Vue 采用**异步更新队列**的策略，将同一事件循环中的所有数据变更缓冲起来，然后在下一个"tick"（事件循环）统一更新 DOM。这样做的好处是：

1. **性能优化**：避免频繁的 DOM 操作，多次数据修改只触发一次 DOM 更新
2. **去重优化**：相同 watcher 在一个 tick 内只会被推入队列一次

但这也带来了一个问题：**如果我们需要在数据变更后立即操作更新后的 DOM，直接操作会失败**，因为此时 DOM 还未更新。

```javascript
// 错误示例
this.message = 'updated'
console.log(this.$el.textContent) // 仍然是旧值，因为 DOM 还未更新

// 正确示例
this.message = 'updated'
this.$nextTick(() => {
  console.log(this.$el.textContent) // 'updated'，DOM 已更新
})
```

### 二、nextTick 的实现原理

Vue 的 nextTick 实现基于 JavaScript 的**事件循环机制**（Event Loop），核心思想是将回调推入微任务或宏任务队列，等待当前执行栈清空后执行。

#### 1. 事件循环基础

JavaScript 的事件循环包括：
- **执行栈**：同步代码执行
- **微任务队列**（Microtask Queue）：Promise.then、MutationObserver
- **宏任务队列**（Macrotask Queue）：setTimeout、setImmediate、MessageChannel

执行顺序：**同步代码 → 微任务 → 宏任务 → 下一轮循环**

#### 2. Vue 2.x 的实现策略

Vue 2 中的 nextTick 按照优先级依次尝试以下方案（降级策略）：

```javascript
// 源码简化版
let timerFunc

// 1. 优先使用 Promise（微任务）
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    // iOS 的 UIWebView 中，Promise.then 可能不会执行
    // 需要一个空的 timer 强制刷新微任务队列
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
}
// 2. 尝试 MutationObserver（微任务）
else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter) // 触发 MutationObserver
  }
  isUsingMicroTask = true
}
// 3. 尝试 setImmediate（宏任务，仅 IE 和 Node.js 支持）
else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
}
// 4. 降级到 setTimeout（宏任务）
else {
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```

#### 3. 核心流程

```javascript
const callbacks = [] // 回调队列
let pending = false   // 防止重复触发

function nextTick(cb, ctx) {
  let _resolve
  // 将回调包装后推入队列
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx) // 支持 Promise 化
    }
  })

  // 如果没有在 pending，启动异步任务
  if (!pending) {
    pending = true
    timerFunc() // 将 flushCallbacks 推入微任务/宏任务队列
  }

  // 支持 Promise 用法
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}

function flushCallbacks() {
  pending = false
  const copies = callbacks.slice(0) // 拷贝队列
  callbacks.length = 0
  // 依次执行所有回调
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}
```

### 三、Vue 3 的优化

Vue 3 中的 nextTick 实现更加简洁，直接使用 **Promise.resolve()** 作为微任务调度器，不再做降级处理：

```javascript
// Vue 3 源码
const resolvedPromise = Promise.resolve()
let currentFlushPromise = null

export function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(fn) : p
}
```

原因：
1. 现代浏览器都支持 Promise
2. 微任务的执行时机更早，性能更好
3. 代码更简洁，维护成本更低

### 四、使用场景

1. **在数据变更后操作 DOM**
```javascript
this.list.push(newItem)
this.$nextTick(() => {
  // 此时 DOM 已更新，可以获取新增元素的高度等信息
  this.$refs.newItem.scrollIntoView()
})
```

2. **在 created 钩子中操作 DOM**
```javascript
created() {
  this.$nextTick(() => {
    // 虽然 created 时 DOM 未挂载，但 nextTick 会等到 mounted 后执行
    this.$refs.input.focus()
  })
}
```

3. **确保使用更新后的 DOM 计算样式**
```javascript
this.show = true
this.$nextTick(() => {
  const height = this.$refs.content.offsetHeight
  // 使用计算出的高度做动画
})
```

### 五、常见误区

1. **nextTick 不等于 mounted**
   - nextTick 只保证 DOM 更新完成，不保证组件已挂载
   - 在 created 中使用 nextTick 仍然访问不到 $refs

2. **多次调用 nextTick 的执行顺序**
```javascript
this.$nextTick(() => console.log(1))
this.$nextTick(() => console.log(2))
// 输出顺序：1, 2（按照推入队列的顺序执行）
```

3. **微任务与宏任务的差异**
```javascript
// Vue 2 中如果降级到 setTimeout
this.msg = 'new'
this.$nextTick(() => console.log('nextTick'))
setTimeout(() => console.log('setTimeout'), 0)
// 如果 nextTick 使用 Promise：nextTick → setTimeout
// 如果 nextTick 降级到 setTimeout：执行顺序不确定
```

### 六、最佳实践

1. **优先使用 async/await 语法**
```javascript
async updateData() {
  this.list = newList
  await this.$nextTick()
  this.$refs.list.scrollTop = 0
}
```

2. **避免过度依赖 nextTick**
   - 如果只是获取响应式数据，直接访问即可，无需等待 DOM 更新
   - 考虑是否可以用 watch 的 flush: 'post' 选项（Vue 3）替代

3. **注意内存泄漏**
```javascript
// 组件销毁前清理 nextTick 回调
beforeUnmount() {
  // Vue 会自动处理，但在某些复杂场景下需要手动清理异步引用
}
```

### 总结

nextTick 是 Vue 异步更新策略的核心，通过事件循环机制实现延迟执行。Vue 2 使用降级策略兼容性好，Vue 3 统一使用 Promise 更简洁高效。理解 nextTick 的原理有助于我们更好地处理 DOM 更新时序问题，避免常见的异步陷阱。
