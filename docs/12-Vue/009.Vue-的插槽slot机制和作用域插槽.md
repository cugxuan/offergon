---
title: Vue 的插槽（slot）机制和作用域插槽
tags:
  - 前端Vue
status: robot
class: 前端Vue
slug: vue-slot-and-scoped-slot-mechanism
ref:
---

## 核心要点

- **默认插槽**：父组件向子组件传递模板内容，实现内容分发
- **具名插槽**：多个插槽，通过 name 属性区分不同位置
- **作用域插槽**：子组件向父组件暴露数据，父组件决定如何渲染
- **应用场景**：组件库、布局组件、列表渲染、弹窗等高度可复用的组件

---

## 详细解答

### 一、默认插槽（基础插槽）

#### 1. 基本用法

```javascript
// 子组件 - Card.vue
<template>
  <div class="card">
    <div class="card-header">
      <h3>Card Title</h3>
    </div>
    <div class="card-body">
      <!-- 插槽出口：父组件传递的内容会渲染在这里 -->
      <slot></slot>
    </div>
  </div>
</template>

// 父组件
<template>
  <Card>
    <!-- 插槽内容：会被传递到子组件的 <slot> 位置 -->
    <p>这是卡片的内容</p>
    <button>点击按钮</button>
  </Card>
</template>

// 最终渲染结果
<div class="card">
  <div class="card-header">
    <h3>Card Title</h3>
  </div>
  <div class="card-body">
    <p>这是卡片的内容</p>
    <button>点击按钮</button>
  </div>
</div>
```

#### 2. 插槽的后备内容（默认内容）

```javascript
// 子组件
<template>
  <button class="btn">
    <slot>
      <!-- 后备内容：当父组件没有提供插槽内容时显示 -->
      默认按钮文字
    </slot>
  </button>
</template>

// 父组件 - 使用情况 1：不提供内容
<MyButton />
// 渲染：<button class="btn">默认按钮文字</button>

// 父组件 - 使用情况 2：提供自定义内容
<MyButton>提交</MyButton>
// 渲染：<button class="btn">提交</button>
```

#### 3. 插槽的作用域

```javascript
// 父组件
<template>
  <Card>
    <!-- 插槽内容可以访问父组件的数据 -->
    <p>{{ parentMessage }}</p>

    <!-- ❌ 但无法访问子组件的数据 -->
    <!-- <p>{{ childMessage }}</p>  这样会报错 -->
  </Card>
</template>

<script setup>
const parentMessage = ref('来自父组件的消息')
</script>

// 子组件 - Card.vue
<template>
  <div class="card">
    <slot></slot>
  </div>
</template>

<script setup>
const childMessage = ref('来自子组件的消息') // 插槽内容访问不到
</script>
```

**重要原则：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。**

### 二、具名插槽（Named Slots）

#### 1. 基础用法

```javascript
// 子组件 - Layout.vue
<template>
  <div class="container">
    <header>
      <!-- 具名插槽：header -->
      <slot name="header"></slot>
    </header>

    <main>
      <!-- 默认插槽（未命名） -->
      <slot></slot>
    </main>

    <footer>
      <!-- 具名插槽：footer -->
      <slot name="footer"></slot>
    </footer>
  </div>
</template>

// 父组件 - Vue 3 语法（推荐）
<template>
  <Layout>
    <!-- 使用 v-slot 指令，简写为 # -->
    <template #header>
      <h1>页面标题</h1>
      <p>副标题</p>
    </template>

    <!-- 默认插槽可以不用 template 包裹 -->
    <p>这是主要内容区域</p>
    <p>第二段内容</p>

    <!-- 或者显式使用 default -->
    <template #default>
      <p>显式的默认插槽内容</p>
    </template>

    <template #footer>
      <p>© 2024 My Company</p>
    </template>
  </Layout>
</template>

// 最终渲染结果
<div class="container">
  <header>
    <h1>页面标题</h1>
    <p>副标题</p>
  </header>
  <main>
    <p>这是主要内容区域</p>
    <p>第二段内容</p>
  </main>
  <footer>
    <p>© 2024 My Company</p>
  </footer>
</div>
```

#### 2. 动态插槽名

```javascript
<template>
  <BaseLayout>
    <!-- 动态插槽名 -->
    <template #[dynamicSlotName]>
      <p>动态插槽内容</p>
    </template>
  </BaseLayout>
</template>

<script setup>
import { ref } from 'vue'

const dynamicSlotName = ref('header')

// 可以动态改变插槽位置
setTimeout(() => {
  dynamicSlotName.value = 'footer'
}, 2000)
</script>
```

### 三、作用域插槽（Scoped Slots）⭐

作用域插槽是插槽机制中最强大的功能，允许子组件向父组件传递数据。

#### 1. 基础用法

```javascript
// 子组件 - TodoList.vue
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      <!-- 子组件向插槽传递数据 -->
      <slot
        :item="item"
        :index="index"
        :is-completed="item.completed"
      >
        <!-- 后备内容 -->
        {{ item.text }}
      </slot>
    </li>
  </ul>
</template>

<script setup>
import { ref } from 'vue'

const items = ref([
  { id: 1, text: '学习 Vue', completed: true },
  { id: 2, text: '学习 React', completed: false },
  { id: 3, text: '学习 Angular', completed: false }
])
</script>

// 父组件 - 使用作用域插槽
<template>
  <TodoList>
    <!-- v-slot 接收子组件传递的数据 -->
    <template #default="slotProps">
      <div class="todo-item">
        <span :class="{ completed: slotProps.isCompleted }">
          {{ slotProps.item.text }}
        </span>
        <span class="index">#{{ slotProps.index }}</span>
      </div>
    </template>
  </TodoList>
</template>

<style>
.completed {
  text-decoration: line-through;
  color: gray;
}
</style>
```

#### 2. 解构插槽 Props

```javascript
// 父组件 - 解构写法（推荐）
<template>
  <TodoList>
    <!-- 直接解构，代码更简洁 -->
    <template #default="{ item, index, isCompleted }">
      <div class="todo-item">
        <span :class="{ completed: isCompleted }">
          {{ item.text }}
        </span>
        <span class="index">#{{ index }}</span>
      </div>
    </template>
  </TodoList>
</template>

// 也可以重命名
<template>
  <TodoList>
    <template #default="{ item: todo, isCompleted: done }">
      <span :class="{ done }">{{ todo.text }}</span>
    </template>
  </TodoList>
</template>

// 提供默认值
<template>
  <TodoList>
    <template #default="{ item, index = 0 }">
      <span>{{ index }}: {{ item.text }}</span>
    </template>
  </TodoList>
</template>
```

#### 3. 具名作用域插槽

```javascript
// 子组件 - DataTable.vue
<template>
  <table>
    <thead>
      <tr>
        <!-- 具名作用域插槽：header -->
        <slot name="header" :columns="columns">
          <th v-for="col in columns" :key="col">{{ col }}</th>
        </slot>
      </tr>
    </thead>
    <tbody>
      <tr v-for="(row, rowIndex) in data" :key="rowIndex">
        <!-- 具名作用域插槽：row -->
        <slot
          name="row"
          :row="row"
          :index="rowIndex"
          :edit="editRow"
        >
          <td v-for="(value, key) in row" :key="key">
            {{ value }}
          </td>
        </slot>
      </tr>
    </tbody>
  </table>
</template>

<script setup>
import { ref } from 'vue'

const columns = ref(['ID', 'Name', 'Age'])
const data = ref([
  { id: 1, name: 'Alice', age: 25 },
  { id: 2, name: 'Bob', age: 30 }
])

const editRow = (index) => {
  console.log('Edit row:', index)
}
</script>

// 父组件
<template>
  <DataTable>
    <!-- 自定义表头 -->
    <template #header="{ columns }">
      <th v-for="col in columns" :key="col">
        <strong>{{ col.toUpperCase() }}</strong>
      </th>
      <th>操作</th>
    </template>

    <!-- 自定义行渲染 -->
    <template #row="{ row, index, edit }">
      <td>{{ row.id }}</td>
      <td>
        <a href="#">{{ row.name }}</a>
      </td>
      <td>{{ row.age }} 岁</td>
      <td>
        <button @click="edit(index)">编辑</button>
      </td>
    </template>
  </DataTable>
</template>
```

### 四、实际应用场景

#### 场景 1：可复用的列表组件

```javascript
// 子组件 - UserList.vue
<template>
  <div class="user-list">
    <div
      v-for="user in users"
      :key="user.id"
      class="user-item"
    >
      <slot
        :user="user"
        :is-online="user.status === 'online'"
        :avatar-url="user.avatar"
      >
        <!-- 默认渲染 -->
        <div class="default-user">
          <img :src="user.avatar" alt="" />
          <span>{{ user.name }}</span>
        </div>
      </slot>
    </div>
  </div>
</template>

// 父组件 - 场景 1：简单显示（使用默认插槽）
<UserList :users="users" />

// 父组件 - 场景 2：自定义渲染
<UserList :users="users">
  <template #default="{ user, isOnline }">
    <div class="custom-user">
      <img :src="user.avatar" class="avatar-lg" />
      <div class="info">
        <h3>{{ user.name }}</h3>
        <span :class="{ online: isOnline }">
          {{ isOnline ? '在线' : '离线' }}
        </span>
      </div>
    </div>
  </template>
</UserList>
```

#### 场景 2：弹窗组件

```javascript
// 子组件 - Modal.vue
<template>
  <Teleport to="body">
    <div v-if="modelValue" class="modal-overlay" @click="close">
      <div class="modal" @click.stop>
        <!-- 标题插槽 -->
        <div class="modal-header">
          <slot name="header">
            <h2>{{ title }}</h2>
          </slot>
          <button @click="close" class="close-btn">×</button>
        </div>

        <!-- 内容插槽 -->
        <div class="modal-body">
          <slot></slot>
        </div>

        <!-- 底部操作区插槽 -->
        <div class="modal-footer">
          <slot name="footer" :confirm="confirm" :cancel="close">
            <button @click="close">取消</button>
            <button @click="confirm" class="primary">确认</button>
          </slot>
        </div>
      </div>
    </div>
  </Teleport>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue'

const props = defineProps({
  modelValue: Boolean,
  title: String
})

const emit = defineEmits(['update:modelValue', 'confirm'])

const close = () => {
  emit('update:modelValue', false)
}

const confirm = () => {
  emit('confirm')
  close()
}
</script>

// 父组件使用
<template>
  <Modal v-model="showModal" title="删除确认">
    <!-- 自定义内容 -->
    <p>确定要删除这个项目吗？此操作不可恢复。</p>

    <!-- 自定义底部按钮 -->
    <template #footer="{ confirm, cancel }">
      <button @click="cancel">再想想</button>
      <button @click="confirm" class="danger">确认删除</button>
    </template>
  </Modal>
</template>
```

#### 场景 3：表格组件

```javascript
// 子组件 - Table.vue
<template>
  <table class="data-table">
    <thead>
      <tr>
        <th
          v-for="column in columns"
          :key="column.key"
          @click="sort(column.key)"
        >
          <slot
            :name="`header-${column.key}`"
            :column="column"
            :sort-by="sortBy"
            :sort-order="sortOrder"
          >
            {{ column.label }}
            <span v-if="sortBy === column.key">
              {{ sortOrder === 'asc' ? '↑' : '↓' }}
            </span>
          </slot>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr v-for="(row, index) in sortedData" :key="row.id">
        <td v-for="column in columns" :key="column.key">
          <slot
            :name="`cell-${column.key}`"
            :row="row"
            :column="column"
            :value="row[column.key]"
            :index="index"
          >
            {{ row[column.key] }}
          </slot>
        </td>
      </tr>
    </tbody>
  </table>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  columns: Array,
  data: Array
})

const sortBy = ref('')
const sortOrder = ref('asc')

const sort = (key) => {
  if (sortBy.value === key) {
    sortOrder.value = sortOrder.value === 'asc' ? 'desc' : 'asc'
  } else {
    sortBy.value = key
    sortOrder.value = 'asc'
  }
}

const sortedData = computed(() => {
  if (!sortBy.value) return props.data

  return [...props.data].sort((a, b) => {
    const aVal = a[sortBy.value]
    const bVal = b[sortBy.value]

    if (sortOrder.value === 'asc') {
      return aVal > bVal ? 1 : -1
    } else {
      return aVal < bVal ? 1 : -1
    }
  })
})
</script>

// 父组件使用
<template>
  <Table :columns="columns" :data="users">
    <!-- 自定义姓名列 -->
    <template #cell-name="{ row, value }">
      <a :href="`/user/${row.id}`">{{ value }}</a>
    </template>

    <!-- 自定义状态列 -->
    <template #cell-status="{ value }">
      <span
        :class="{
          'badge-success': value === 'active',
          'badge-warning': value === 'pending',
          'badge-danger': value === 'inactive'
        }"
      >
        {{ value }}
      </span>
    </template>

    <!-- 自定义操作列表头 -->
    <template #header-actions>
      操作
    </template>

    <!-- 自定义操作列 -->
    <template #cell-actions="{ row, index }">
      <button @click="editUser(row)">编辑</button>
      <button @click="deleteUser(index)">删除</button>
    </template>
  </Table>
</template>
```

#### 场景 4：无渲染组件（Renderless Component）

```javascript
// 子组件 - FetchData.vue
<template>
  <!-- 无渲染组件：不渲染任何自己的标签，只提供逻辑 -->
  <slot
    :data="data"
    :loading="loading"
    :error="error"
    :refetch="fetchData"
  ></slot>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const props = defineProps({
  url: String
})

const data = ref(null)
const loading = ref(false)
const error = ref(null)

const fetchData = async () => {
  loading.value = true
  error.value = null

  try {
    const response = await fetch(props.url)
    data.value = await response.json()
  } catch (e) {
    error.value = e.message
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  fetchData()
})
</script>

// 父组件使用
<template>
  <FetchData url="/api/users">
    <template #default="{ data, loading, error, refetch }">
      <div v-if="loading">加载中...</div>
      <div v-else-if="error">
        错误：{{ error }}
        <button @click="refetch">重试</button>
      </div>
      <div v-else>
        <ul>
          <li v-for="user in data" :key="user.id">
            {{ user.name }}
          </li>
        </ul>
      </div>
    </template>
  </FetchData>
</template>
```

### 五、插槽的高级技巧

#### 1. 条件插槽

```javascript
// 子组件
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header"></slot>
    </div>

    <div class="card-body">
      <slot></slot>
    </div>

    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>

<script setup>
import { useSlots } from 'vue'

const slots = useSlots()

// 检查是否提供了某个插槽
console.log('Has header?', !!slots.header)
</script>
```

#### 2. 插槽透传

```javascript
// 中间组件包装另一个组件，透传插槽
<template>
  <BaseTable v-bind="$attrs">
    <!-- 透传所有插槽 -->
    <template v-for="(_, name) in $slots" #[name]="slotProps">
      <slot :name="name" v-bind="slotProps" />
    </template>
  </BaseTable>
</template>
```

### 六、Vue 2 vs Vue 3 插槽语法

| 特性 | Vue 2 | Vue 3 |
|------|-------|-------|
| 默认插槽 | `<slot></slot>` | `<slot></slot>` |
| 具名插槽（子） | `<slot name="header">` | `<slot name="header">` |
| 具名插槽（父） | `<div slot="header">` | `<template #header>` |
| 作用域插槽（父）| `<template slot-scope="props">` | `<template #default="props">` |
| 简写 | `slot="name"` | `#name` |

```javascript
// Vue 2 写法（已废弃）
<template>
  <MyComponent>
    <div slot="header">标题</div>
    <template slot-scope="{ item }">
      {{ item.text }}
    </template>
  </MyComponent>
</template>

// Vue 3 写法（推荐）
<template>
  <MyComponent>
    <template #header>
      <div>标题</div>
    </template>
    <template #default="{ item }">
      {{ item.text }}
    </template>
  </MyComponent>
</template>
```

### 七、常见面试问题

#### Q1: 插槽的作用域是怎样的？

**答：** 父级模板里的所有内容都在父级作用域中编译；子模板里的所有内容都在子作用域中编译。插槽内容默认只能访问父组件的数据，除非使用作用域插槽接收子组件传递的数据。

#### Q2: 什么是作用域插槽？

**答：** 作用域插槽允许子组件向父组件的插槽内容传递数据。子组件通过在 `<slot>` 上绑定属性来传递数据，父组件通过 `v-slot="slotProps"` 接收这些数据。

#### Q3: 插槽和 props 的区别？

| 特性 | Props | Slots |
|------|-------|-------|
| 传递内容 | 数据 | 模板/组件 |
| 灵活性 | 低（固定数据格式） | 高（任意 HTML 结构） |
| 适用场景 | 配置型组件 | 内容分发型组件 |

#### Q4: 如何判断插槽是否被使用？

```javascript
<script setup>
import { useSlots } from 'vue'

const slots = useSlots()

// 判断是否提供了插槽
const hasHeader = !!slots.header
const hasDefault = !!slots.default

// 在模板中使用
</script>

<template>
  <div v-if="hasHeader">
    <slot name="header"></slot>
  </div>
</template>
```

### 八、最佳实践

1. **优先使用具名插槽**，明确插槽用途
2. **作用域插槽传递必要数据**，让父组件有足够的控制权
3. **提供后备内容**，增强组件的易用性
4. **使用解构语法**，简化代码
5. **无渲染组件**适合封装复杂逻辑
6. **检查插槽是否存在**，避免渲染空容器

### 九、总结

1. **默认插槽**：最简单的内容分发
2. **具名插槽**：多个插槽位置
3. **作用域插槽**：子传父数据，父控制渲染
4. **应用场景**：布局组件、列表组件、表格、弹窗、无渲染组件
5. **Vue 3 语法更简洁**：使用 `#` 作为 `v-slot` 的简写
