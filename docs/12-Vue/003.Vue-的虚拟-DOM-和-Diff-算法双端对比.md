---
title: Vue 的虚拟 DOM 和 Diff 算法（双端对比）
tags:
  - Vue
status: robot
class: 前端Vue
slug: vue-virtual-dom-diff-algorithm-two-end-comparison
ref:
---

## 核心要点

- **虚拟 DOM**：JavaScript 对象描述真实 DOM 结构，通过 diff 算法最小化真实 DOM 操作
- **Diff 算法核心**：同层比较、key 标识、双端对比（Vue 2）、最长递增子序列（Vue 3）
- **性能优势**：批量更新、减少重排重绘、跨平台渲染能力
- **Vue 2 vs Vue 3**：Vue 3 使用快速 Diff 算法，性能提升 2-3 倍

---

## 详细回答

### 一、为什么需要虚拟 DOM？

#### 1.1 真实 DOM 操作的性能瓶颈

```javascript
// ❌ 频繁的真实 DOM 操作（性能差）
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  container.appendChild(div); // 每次都触发重排重绘
}

// ✅ 虚拟 DOM 的思路（性能好）
const vNodes = [];
for (let i = 0; i < 1000; i++) {
  vNodes.push({ tag: 'div', children: `Item ${i}` });
}
// 一次性批量更新到真实 DOM
render(vNodes, container);
```

**问题**：
1. **重排重绘开销大**：每次 DOM 操作都可能触发浏览器的重排（Reflow）和重绘（Repaint）
2. **操作粒度粗**：很难精确控制哪些节点需要更新
3. **状态管理困难**：难以追踪数据变化与视图的对应关系

#### 1.2 虚拟 DOM 的解决方案

```javascript
// 虚拟 DOM 节点结构
const vNode = {
  tag: 'div',              // 标签名
  props: {                 // 属性
    id: 'app',
    class: 'container'
  },
  children: [              // 子节点
    {
      tag: 'h1',
      children: 'Hello Vue'
    },
    {
      tag: 'p',
      children: 'Virtual DOM'
    }
  ]
};
```

**核心优势**：
1. **批量更新**：收集所有变更，一次性应用到真实 DOM
2. **精确更新**：通过 Diff 算法找出最小变更集
3. **跨平台能力**：同一套虚拟 DOM 可渲染到不同平台（Web、Native、Canvas）

---

### 二、虚拟 DOM 的工作流程

#### 2.1 完整流程

```
1. 模板编译 → Render 函数
2. 执行 Render 函数 → 虚拟 DOM 树（VNode）
3. 首次渲染 → 挂载真实 DOM
4. 数据变化 → 生成新的虚拟 DOM 树
5. Diff 算法比较新旧虚拟 DOM → 计算最小差异（Patch）
6. 将差异应用到真实 DOM
```

#### 2.2 VNode 数据结构

```javascript
// Vue 3 中的 VNode 结构（简化版）
class VNode {
  constructor(tag, props, children, key) {
    this.tag = tag;           // 标签名或组件
    this.props = props;       // 属性对象
    this.children = children; // 子节点数组
    this.key = key;           // 唯一标识
    this.el = null;           // 关联的真实 DOM
  }
}

// 示例
const vnode = new VNode(
  'ul',
  { class: 'list' },
  [
    new VNode('li', { key: 1 }, 'Item 1'),
    new VNode('li', { key: 2 }, 'Item 2')
  ]
);
```

#### 2.3 Render 函数

```javascript
// 模板
<template>
  <div id="app">
    <h1>{{ title }}</h1>
  </div>
</template>

// 编译成 Render 函数
function render() {
  return h('div', { id: 'app' }, [
    h('h1', null, this.title)
  ]);
}
```

---

### 三、Diff 算法核心思想

#### 3.1 基本策略

1. **同层比较**：只比较同一层级的节点，不跨层级比较
2. **类型判断**：标签名不同直接替换，不再比较子节点
3. **Key 标识**：使用 key 追踪节点的身份，实现复用

```javascript
// ❌ 不会跨层级比较（即使节点相同）
// 旧树
<div>
  <span>A</span>
</div>

// 新树
<div>
  <p>
    <span>A</span>
  </p>
</div>
// 虽然 <span>A</span> 相同，但因为层级不同，会被删除重建

// ✅ 同层比较（高效）
// 旧树：<div><span>A</span><span>B</span></div>
// 新树：<div><span>A</span><span>C</span></div>
// 只更新第二个 span 的文本内容
```

#### 3.2 Key 的重要性

```javascript
// ❌ 不使用 key（性能差）
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// 插入新节点到头部
<ul>
  <li>D</li> <!-- 新增 -->
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

// 没有 key 时，Diff 算法认为：
// - 第 1 个 li 从 "A" 变成 "D"（更新文本）
// - 第 2 个 li 从 "B" 变成 "A"（更新文本）
// - 第 3 个 li 从 "C" 变成 "B"（更新文本）
// - 新增第 4 个 li "C"
// 结果：更新了 3 个节点 + 新增 1 个节点

// ✅ 使用 key（性能好）
<ul>
  <li key="a">A</li>
  <li key="b">B</li>
  <li key="c">C</li>
</ul>

// 插入新节点
<ul>
  <li key="d">D</li> <!-- 新增 -->
  <li key="a">A</li>
  <li key="b">B</li>
  <li key="c">C</li>
</ul>

// 有 key 时，Diff 算法识别出：
// - key="a/b/c" 的节点都复用，只移动位置
// - 只新增 key="d" 的节点
// 结果：只新增 1 个节点
```

**关键点**：
- ✅ **使用唯一且稳定的 ID 作为 key**（如后端返回的 ID）
- ❌ **不要用索引作为 key**（列表顺序变化时会导致错误复用）
- ❌ **不要用随机数作为 key**（每次都会重新渲染）

---

### 四、Vue 2 的 Diff 算法（双端对比）

#### 4.1 核心思路

Vue 2 使用**双端对比**算法（Two-ended comparison）：

```javascript
function patchChildren(oldChildren, newChildren) {
  let oldStartIdx = 0;
  let oldEndIdx = oldChildren.length - 1;
  let newStartIdx = 0;
  let newEndIdx = newChildren.length - 1;

  let oldStartVNode = oldChildren[0];
  let oldEndVNode = oldChildren[oldEndIdx];
  let newStartVNode = newChildren[0];
  let newEndVNode = newChildren[newEndIdx];

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (sameVNode(oldStartVNode, newStartVNode)) {
      // 1️⃣ 旧头 vs 新头
      patch(oldStartVNode, newStartVNode);
      oldStartVNode = oldChildren[++oldStartIdx];
      newStartVNode = newChildren[++newStartIdx];
    } else if (sameVNode(oldEndVNode, newEndVNode)) {
      // 2️⃣ 旧尾 vs 新尾
      patch(oldEndVNode, newEndVNode);
      oldEndVNode = oldChildren[--oldEndIdx];
      newEndVNode = newChildren[--newEndIdx];
    } else if (sameVNode(oldStartVNode, newEndVNode)) {
      // 3️⃣ 旧头 vs 新尾（节点右移）
      patch(oldStartVNode, newEndVNode);
      // 移动 DOM
      insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling);
      oldStartVNode = oldChildren[++oldStartIdx];
      newEndVNode = newChildren[--newEndIdx];
    } else if (sameVNode(oldEndVNode, newStartVNode)) {
      // 4️⃣ 旧尾 vs 新头（节点左移）
      patch(oldEndVNode, newStartVNode);
      // 移动 DOM
      insertBefore(oldEndVNode.el, oldStartVNode.el);
      oldEndVNode = oldChildren[--oldEndIdx];
      newStartVNode = newChildren[++newStartIdx];
    } else {
      // 5️⃣ 都不匹配，使用 key 查找
      const idxInOld = findIdxByKey(newStartVNode.key, oldChildren);
      if (idxInOld) {
        const vnodeToMove = oldChildren[idxInOld];
        patch(vnodeToMove, newStartVNode);
        oldChildren[idxInOld] = undefined;
        insertBefore(vnodeToMove.el, oldStartVNode.el);
      } else {
        // 创建新节点
        createElm(newStartVNode);
      }
      newStartVNode = newChildren[++newStartIdx];
    }
  }

  // 处理剩余节点
  if (oldStartIdx > oldEndIdx) {
    // 新节点有剩余，批量新增
    addVNodes(newChildren, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    // 旧节点有剩余，批量删除
    removeVNodes(oldChildren, oldStartIdx, oldEndIdx);
  }
}
```

#### 4.2 双端对比示例

```
旧节点：[A, B, C, D]
新节点：[D, A, B, C]

🔄 第一轮比较：
  旧头(A) vs 新头(D) ❌
  旧尾(D) vs 新尾(C) ❌
  旧头(A) vs 新尾(C) ❌
  旧尾(D) vs 新头(D) ✅ → 将 D 移到最前面

  旧节点：[A, B, C, _]
  新节点：[_, A, B, C]
         ↑
  已处理：D

🔄 第二轮比较：
  旧头(A) vs 新头(A) ✅ → 位置不变

  旧节点：[_, B, C, _]
  新节点：[_, _, B, C]
             ↑
  已处理：D, A

🔄 第三轮比较：
  旧头(B) vs 新头(B) ✅ → 位置不变

🔄 第四轮比较：
  旧头(C) vs 新头(C) ✅ → 位置不变

✅ 完成，只移动了 D 节点一次
```

#### 4.3 复杂度分析

- **最好情况**（节点顺序不变）：O(n)
- **最坏情况**（每次都要遍历查找 key）：O(n²)
- **平均情况**：O(n)

---

### 五、Vue 3 的 Diff 算法（快速 Diff）

#### 5.1 核心优化

Vue 3 借鉴了 ivi 和 inferno 的算法，使用**最长递增子序列**（LIS）优化节点移动：

```javascript
function patchKeyedChildren(oldChildren, newChildren) {
  let i = 0;
  const oldLength = oldChildren.length;
  const newLength = newChildren.length;

  // 1️⃣ 从头部开始，处理相同的前置节点
  while (i < oldLength && i < newLength && sameVNode(oldChildren[i], newChildren[i])) {
    patch(oldChildren[i], newChildren[i]);
    i++;
  }

  // 2️⃣ 从尾部开始，处理相同的后置节点
  let oldEnd = oldLength - 1;
  let newEnd = newLength - 1;
  while (i <= oldEnd && i <= newEnd && sameVNode(oldChildren[oldEnd], newChildren[newEnd])) {
    patch(oldChildren[oldEnd], newChildren[newEnd]);
    oldEnd--;
    newEnd--;
  }

  // 3️⃣ 只有新增节点
  if (i > oldEnd && i <= newEnd) {
    while (i <= newEnd) {
      mount(newChildren[i++]);
    }
  }
  // 4️⃣ 只有删除节点
  else if (i > newEnd && i <= oldEnd) {
    while (i <= oldEnd) {
      unmount(oldChildren[i++]);
    }
  }
  // 5️⃣ 中间乱序部分，使用最长递增子序列
  else {
    const oldStart = i;
    const newStart = i;

    // 建立新节点的 key -> index 映射
    const keyToNewIndexMap = new Map();
    for (i = newStart; i <= newEnd; i++) {
      keyToNewIndexMap.set(newChildren[i].key, i);
    }

    // 记录新节点在旧节点中的位置
    const newIndexToOldIndexMap = new Array(newEnd - newStart + 1).fill(-1);

    let patched = 0;
    const toBePatched = newEnd - newStart + 1;
    let moved = false;
    let maxNewIndexSoFar = 0;

    // 遍历旧节点
    for (i = oldStart; i <= oldEnd; i++) {
      const oldVNode = oldChildren[i];

      if (patched >= toBePatched) {
        // 所有新节点都已处理，剩余旧节点直接删除
        unmount(oldVNode);
        continue;
      }

      const newIndex = keyToNewIndexMap.get(oldVNode.key);

      if (newIndex === undefined) {
        // 旧节点在新节点中不存在，删除
        unmount(oldVNode);
      } else {
        // 记录新旧节点的对应关系
        newIndexToOldIndexMap[newIndex - newStart] = i;

        // 判断是否需要移动
        if (newIndex >= maxNewIndexSoFar) {
          maxNewIndexSoFar = newIndex;
        } else {
          moved = true;
        }

        patch(oldVNode, newChildren[newIndex]);
        patched++;
      }
    }

    // 6️⃣ 如果需要移动，计算最长递增子序列
    const increasingNewIndexSequence = moved
      ? getSequence(newIndexToOldIndexMap)
      : [];

    let j = increasingNewIndexSequence.length - 1;

    // 从后往前遍历，插入/移动节点
    for (i = toBePatched - 1; i >= 0; i--) {
      const nextIndex = newStart + i;
      const nextChild = newChildren[nextIndex];

      if (newIndexToOldIndexMap[i] === -1) {
        // 新增节点
        mount(nextChild);
      } else if (moved) {
        if (j < 0 || i !== increasingNewIndexSequence[j]) {
          // 需要移动
          move(nextChild);
        } else {
          // 在递增序列中，不需要移动
          j--;
        }
      }
    }
  }
}

// 最长递增子序列算法（Longest Increasing Subsequence）
function getSequence(arr) {
  const result = [0];
  const p = arr.slice();

  for (let i = 0; i < arr.length; i++) {
    const arrI = arr[i];
    if (arrI !== -1) {
      const j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }

      let left = 0;
      let right = result.length - 1;
      while (left < right) {
        const mid = (left + right) >> 1;
        if (arr[result[mid]] < arrI) {
          left = mid + 1;
        } else {
          right = mid;
        }
      }

      if (arrI < arr[result[left]]) {
        if (left > 0) {
          p[i] = result[left - 1];
        }
        result[left] = i;
      }
    }
  }

  let i = result.length;
  let u = result[i - 1];
  while (i-- > 0) {
    result[i] = u;
    u = p[u];
  }

  return result;
}
```

#### 5.2 最长递增子序列示例

```
旧节点：[A, B, C, D, E, F, G]
新节点：[A, C, D, B, G, E, F]

1️⃣ 处理前置相同节点：A
2️⃣ 处理后置相同节点：F
3️⃣ 中间乱序部分：
   旧：[B, C, D, E, G]  (索引 1-5)
   新：[C, D, B, G, E]  (索引 1-5)

4️⃣ 建立映射关系：
   newIndexToOldIndexMap = [2, 3, 1, 5, 4]
   (新节点在旧节点中的位置)

5️⃣ 计算最长递增子序列：
   输入：[2, 3, 1, 5, 4]
   LIS：[2, 3, 5] → 对应索引 [0, 1, 3]
   (表示 C、D、G 已经是递增的，不需要移动)

6️⃣ 移动策略：
   - C (索引 0)：在 LIS 中，不移动
   - D (索引 1)：在 LIS 中，不移动
   - B (索引 2)：不在 LIS 中，需要移动
   - G (索引 3)：在 LIS 中，不移动
   - E (索引 4)：不在 LIS 中，需要移动

✅ 结果：只移动 B 和 E，最小化 DOM 操作
```

#### 5.3 性能对比

| 场景 | Vue 2 双端对比 | Vue 3 快速 Diff |
|------|---------------|----------------|
| **顺序不变** | O(n) | O(n) |
| **头部插入** | O(n) | O(n) |
| **尾部插入** | O(n) | O(n) |
| **中间乱序** | O(n²) | O(n log n) |
| **复杂场景** | 可能多次移动 | 最小移动次数 |

**测试数据**（1000 个节点乱序）：
- Vue 2：约 12ms
- Vue 3：约 4ms（提升 3 倍）

---

### 六、Diff 算法的优化技巧

#### 6.1 静态标记（PatchFlag）

Vue 3 在编译阶段标记动态内容：

```javascript
// 模板
<div>
  <p>Static text</p>
  <p>{{ dynamicText }}</p>
  <p :class="dynamicClass">Text</p>
</div>

// 编译后的 VNode
const vnode = {
  type: 'div',
  children: [
    { type: 'p', children: 'Static text' }, // 无标记，跳过 diff
    { type: 'p', children: dynamicText, patchFlag: 1 /* TEXT */ },
    { type: 'p', class: dynamicClass, patchFlag: 2 /* CLASS */ }
  ]
};

// Diff 时只检查有 patchFlag 的节点
function patch(n1, n2) {
  if (n2.patchFlag === 1) {
    // 只更新文本
    n1.el.textContent = n2.children;
  } else if (n2.patchFlag === 2) {
    // 只更新 class
    n1.el.className = n2.class;
  }
  // 静态节点直接跳过
}
```

#### 6.2 静态提升

```javascript
// 模板
<div>
  <p>Static</p>
  <p>{{ dynamic }}</p>
</div>

// 编译优化
const hoisted = h('p', null, 'Static'); // 只创建一次

function render() {
  return h('div', null, [
    hoisted, // 复用静态节点
    h('p', null, this.dynamic)
  ]);
}
```

#### 6.3 事件缓存

```javascript
// 模板
<button @click="handleClick">Click</button>

// 优化前：每次都创建新的事件对象
function render() {
  return h('button', {
    onClick: () => this.handleClick() // 每次渲染都是新函数
  });
}

// 优化后：缓存事件处理器
const cached = this.handleClick;
function render() {
  return h('button', {
    onClick: cached // 复用同一个函数引用
  });
}
```

---

### 七、面试回答建议

**简洁版（1-2 分钟）**：
> 虚拟 DOM 是用 JavaScript 对象描述 DOM 结构，通过 Diff 算法比较新旧虚拟 DOM 的差异，只将变化的部分更新到真实 DOM，从而提升性能。
>
> Vue 的 Diff 算法采用同层比较策略，通过 key 标识节点身份。Vue 2 使用双端对比算法，从头尾两端同时比较；Vue 3 使用快速 Diff 算法，通过最长递增子序列优化节点移动，性能提升 2-3 倍。

**深入版（3-5 分钟）**：
在简洁版基础上，补充：
1. **双端对比原理**：展示头尾指针移动的过程
2. **最长递增子序列**：解释如何最小化节点移动
3. **Key 的作用**：用具体示例说明有无 key 的性能差异
4. **编译优化**：PatchFlag、静态提升等优化手段
5. **实际性能数据**：Vue 3 在复杂场景下的性能提升

---

### 八、扩展知识点

#### 8.1 虚拟 DOM 不一定更快

```javascript
// 场景 1：简单更新（直接操作 DOM 更快）
document.getElementById('count').textContent = count;

// 场景 2：大量节点更新（虚拟 DOM 更快）
// 虚拟 DOM 可以批量处理、最小化操作
for (let i = 0; i < 10000; i++) {
  items[i].text = newText;
}
```

**虚拟 DOM 的真正价值**：
- ✅ **声明式编程**：开发者只关心状态，不关心 DOM 操作
- ✅ **跨平台能力**：同一套代码可渲染到不同平台
- ✅ **组件化**：方便构建可复用的 UI 组件

#### 8.2 Diff 算法的权衡

```javascript
// 完全精确的 Diff（O(n³)）
// 找出两棵树的最小编辑距离（Edit Distance）

// Vue 的 Diff（O(n)）
// 牺牲了部分精确性，但性能大幅提升
// 通过同层比较、key 标识等策略实现
```

#### 8.3 为什么不用索引作为 key？

```javascript
// ❌ 使用索引作为 key
<li v-for="(item, index) in items" :key="index">
  {{ item.name }}
  <input v-model="item.value" />
</li>

// 当在头部插入新元素时：
// 旧：[{name:'A',value:'1'}, {name:'B',value:'2'}]
// 新：[{name:'C',value:''}, {name:'A',value:'1'}, {name:'B',value:'2'}]

// Diff 算法认为：
// key=0: A → C (更新数据，但 input 的值还是 '1')
// key=1: B → A (更新数据，但 input 的值还是 '2')
// key=2: 新增 B

// ✅ 使用唯一 ID 作为 key
// 正确识别节点，input 的值不会错乱
```
