---
title: watch 和 watchEffect 的区别
tags:
  - Vue
status: robot
class: 前端Vue
slug: watch-vs-watcheffect-difference
ref:
---

## 核心要点

- **watch**：显式指定数据源，懒执行，可访问新旧值，精确控制依赖
- **watchEffect**：自动追踪依赖，立即执行，无法获取旧值，代码简洁但依赖隐式
- **使用场景**：watch 适合需要对比新旧值或异步操作；watchEffect 适合副作用逻辑简单的场景

---

## 详细解答

### 一、基本概念

在 Vue 3 的 Composition API 中，`watch` 和 `watchEffect` 都是用来监听响应式数据变化并执行副作用的 API，但它们的设计理念和使用方式有显著区别。

### 二、核心区别

#### 1. 依赖追踪方式

**watch - 显式指定数据源**

```javascript
import { ref, watch } from 'vue'

const count = ref(0)
const message = ref('hello')

// 必须显式指定要监听的数据源
watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`)
})

// 可以监听多个数据源
watch([count, message], ([newCount, newMsg], [oldCount, oldMsg]) => {
  console.log('Multiple sources changed')
})
```

**watchEffect - 自动追踪依赖**

```javascript
import { ref, watchEffect } from 'vue'

const count = ref(0)
const message = ref('hello')

// 自动追踪函数内使用的所有响应式数据
watchEffect(() => {
  // 这里用到了 count，自动成为依赖
  console.log(`Current count: ${count.value}`)
  // 如果这里也用到 message，message 也会成为依赖
})
```

#### 2. 执行时机

**watch - 懒执行（lazy）**

```javascript
const count = ref(0)

// 初始化时不会执行，只有 count 变化时才执行
watch(count, (newValue) => {
  console.log('Count changed:', newValue)
})

// 如果需要立即执行，需要配置 immediate
watch(count, (newValue) => {
  console.log('Count changed:', newValue)
}, { immediate: true })
```

**watchEffect - 立即执行**

```javascript
const count = ref(0)

// 组件初始化时立即执行一次，之后响应式依赖变化时再次执行
watchEffect(() => {
  console.log('Current count:', count.value)
})
// 输出：Current count: 0
```

#### 3. 访问新旧值

**watch - 可以访问新旧值**

```javascript
const count = ref(0)

watch(count, (newValue, oldValue) => {
  console.log(`Changed from ${oldValue} to ${newValue}`)

  // 可以进行对比逻辑
  if (newValue > oldValue) {
    console.log('Count increased')
  }
})

count.value = 10
// 输出：Changed from 0 to 10
// 输出：Count increased
```

**watchEffect - 无法访问旧值**

```javascript
const count = ref(0)

watchEffect(() => {
  // 只能访问当前值，无法获取旧值
  console.log('Current count:', count.value)
})

count.value = 10
// 输出：Current count: 10
```

#### 4. 监听深层对象

**watch - 需要配置 deep 选项**

```javascript
const user = ref({
  name: 'Alice',
  profile: {
    age: 25
  }
})

// 默认只监听 user.value 的引用变化
watch(user, (newValue) => {
  console.log('User changed')
})

user.value.profile.age = 26 // 不会触发

// 需要开启 deep 监听深层属性
watch(user, (newValue) => {
  console.log('User changed deeply')
}, { deep: true })

user.value.profile.age = 27 // 会触发
```

**watchEffect - 自动深度追踪**

```javascript
const user = ref({
  name: 'Alice',
  profile: {
    age: 25
  }
})

watchEffect(() => {
  // 只要在这里访问了，就会被追踪
  console.log('Age:', user.value.profile.age)
})

user.value.profile.age = 26 // 会触发
```

### 三、实际应用场景对比

#### 场景 1：需要对比新旧值（使用 watch）

```javascript
const searchQuery = ref('')

// 实现防抖搜索，需要判断是否真的变化了
watch(searchQuery, (newQuery, oldQuery) => {
  if (newQuery !== oldQuery && newQuery.length > 2) {
    performSearch(newQuery)
  }
})
```

#### 场景 2：简单的副作用同步（使用 watchEffect）

```javascript
const isDark = ref(false)

// 根据主题切换 body 的 class
watchEffect(() => {
  document.body.className = isDark.value ? 'dark' : 'light'
})
```

#### 场景 3：监听多个条件组合（使用 watchEffect 更简洁）

```javascript
const firstName = ref('John')
const lastName = ref('Doe')
const age = ref(30)

// 使用 watchEffect
watchEffect(() => {
  console.log(`${firstName.value} ${lastName.value} is ${age.value} years old`)
})

// 使用 watch 需要显式列出所有依赖
watch([firstName, lastName, age], ([fn, ln, a]) => {
  console.log(`${fn} ${ln} is ${a} years old`)
})
```

#### 场景 4：异步操作和清理（两者都支持）

```javascript
// watch 版本
watch(userId, async (newId, oldId, onCleanup) => {
  let cancelled = false

  onCleanup(() => {
    cancelled = true
  })

  const data = await fetchUserData(newId)
  if (!cancelled) {
    userData.value = data
  }
})

// watchEffect 版本
watchEffect(async (onCleanup) => {
  let cancelled = false

  onCleanup(() => {
    cancelled = true
  })

  const data = await fetchUserData(userId.value)
  if (!cancelled) {
    userData.value = data
  }
})
```

### 四、性能考量

#### watch 的优势

```javascript
const hugeList = ref([...Array(10000)])
const selectedId = ref(1)

// 只监听 selectedId，性能更好
watch(selectedId, (id) => {
  // 只在 id 变化时处理
  processSelection(id)
})
```

#### watchEffect 的陷阱

```javascript
const hugeList = ref([...Array(10000)])
const selectedId = ref(1)

// 可能意外追踪了 hugeList
watchEffect(() => {
  console.log('Selected:', selectedId.value)
  // 如果这里不小心访问了 hugeList，会造成不必要的依赖
  if (hugeList.value.length > 0) { // 意外的依赖！
    // ...
  }
})
```

### 五、总结对比表

| 特性 | watch | watchEffect |
|------|-------|-------------|
| 依赖指定 | 显式指定数据源 | 自动追踪依赖 |
| 执行时机 | 懒执行（除非 immediate） | 立即执行 |
| 新旧值 | 可以访问 | 无法访问 |
| 深度监听 | 需要 `deep: true` | 自动深度追踪 |
| 代码简洁性 | 需要显式声明 | 更简洁 |
| 依赖明确性 | 非常明确 | 可能不够明确 |
| 适用场景 | 需要新旧值对比、精确控制依赖 | 简单的响应式副作用 |

### 六、最佳实践建议

1. **需要新旧值对比时，用 watch**
   ```javascript
   watch(formData, (newData, oldData) => {
     const changes = detectChanges(newData, oldData)
     saveChanges(changes)
   })
   ```

2. **简单的副作用同步，用 watchEffect**
   ```javascript
   watchEffect(() => {
     localStorage.setItem('theme', theme.value)
   })
   ```

3. **性能敏感场景，优先 watch**
   - 明确的依赖可以避免不必要的重新执行

4. **复杂依赖关系，watchEffect 更简洁**
   - 但要注意避免意外的依赖追踪

5. **异步操作建议用 watch**
   - 更容易控制触发时机和防抖节流
